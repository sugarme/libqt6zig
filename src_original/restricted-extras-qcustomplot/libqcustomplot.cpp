#include <QActionEvent>
#include <QBrush>
#include <QByteArray>
#include <QChar>
#include <QChildEvent>
#include <QCloseEvent>
#include <QColor>
#include <QContextMenuEvent>
#include <QDate>
#include <QDateTime>
#include <QDragEnterEvent>
#include <QDragLeaveEvent>
#include <QDragMoveEvent>
#include <QDropEvent>
#include <QEnterEvent>
#include <QEvent>
#include <QFocusEvent>
#include <QFont>
#include <QHash>
#include <QHideEvent>
#include <QInputEvent>
#include <QInputMethodEvent>
#include <QKeyEvent>
#include <QLineF>
#include <QList>
#include <QLocale>
#include <QMap>
#include <QMargins>
#include <QMetaMethod>
#include <QMetaObject>
#include <QMouseEvent>
#include <QMoveEvent>
#include <QObject>
#include <QPaintDevice>
#include <QPaintEngine>
#include <QPaintEvent>
#include <QPainter>
#include <QPainterPath>
#include <QPair>
#include <QPen>
#include <QPixmap>
#include <QPoint>
#include <QPointF>
#include <QRect>
#include <QRectF>
#include <QRegion>
#include <QResizeEvent>
#include <QShowEvent>
#include <QSize>
#include <QString>
#include <QByteArray>
#include <cstring>
#include <QTabletEvent>
#include <QTimeZone>
#include <QTimerEvent>
#include <QVariant>
#include <QVector>
#include <QWheelEvent>
#include <QWidget>
#include <qcustomplot.h>
#include "libqcustomplot.h"
#include "libqcustomplot.hxx"

QMetaObject* QCP_GetEnumMetaObject(int param1) {
    return (QMetaObject*)QCP::qt_getEnumMetaObject(static_cast<QCP::ExportPen>(param1));
}

const char* QCP_GetEnumName(int param1) {
    return (const char*)QCP::qt_getEnumName(static_cast<QCP::ExportPen>(param1));
}

QMetaObject* QCP_GetEnumMetaObject2(int param1) {
    return (QMetaObject*)QCP::qt_getEnumMetaObject(static_cast<QCP::ResolutionUnit>(param1));
}

const char* QCP_GetEnumName2(int param1) {
    return (const char*)QCP::qt_getEnumName(static_cast<QCP::ResolutionUnit>(param1));
}

QMetaObject* QCP_GetEnumMetaObject3(int param1) {
    return (QMetaObject*)QCP::qt_getEnumMetaObject(static_cast<QCP::SignDomain>(param1));
}

const char* QCP_GetEnumName3(int param1) {
    return (const char*)QCP::qt_getEnumName(static_cast<QCP::SignDomain>(param1));
}

QMetaObject* QCP_GetEnumMetaObject4(int param1) {
    return (QMetaObject*)QCP::qt_getEnumMetaObject(static_cast<QCP::MarginSide>(param1));
}

const char* QCP_GetEnumName4(int param1) {
    return (const char*)QCP::qt_getEnumName(static_cast<QCP::MarginSide>(param1));
}

QMetaObject* QCP_GetEnumMetaObject5(int param1) {
    return (QMetaObject*)QCP::qt_getEnumMetaObject(static_cast<QCP::MarginSides>(param1));
}

const char* QCP_GetEnumName5(int param1) {
    return (const char*)QCP::qt_getEnumName(static_cast<QCP::MarginSides>(param1));
}

QMetaObject* QCP_GetEnumMetaObject6(int param1) {
    return (QMetaObject*)QCP::qt_getEnumMetaObject(static_cast<QCP::AntialiasedElement>(param1));
}

const char* QCP_GetEnumName6(int param1) {
    return (const char*)QCP::qt_getEnumName(static_cast<QCP::AntialiasedElement>(param1));
}

QMetaObject* QCP_GetEnumMetaObject7(int param1) {
    return (QMetaObject*)QCP::qt_getEnumMetaObject(static_cast<QCP::AntialiasedElements>(param1));
}

const char* QCP_GetEnumName7(int param1) {
    return (const char*)QCP::qt_getEnumName(static_cast<QCP::AntialiasedElements>(param1));
}

QMetaObject* QCP_GetEnumMetaObject8(int param1) {
    return (QMetaObject*)QCP::qt_getEnumMetaObject(static_cast<QCP::PlottingHint>(param1));
}

const char* QCP_GetEnumName8(int param1) {
    return (const char*)QCP::qt_getEnumName(static_cast<QCP::PlottingHint>(param1));
}

QMetaObject* QCP_GetEnumMetaObject9(int param1) {
    return (QMetaObject*)QCP::qt_getEnumMetaObject(static_cast<QCP::PlottingHints>(param1));
}

const char* QCP_GetEnumName9(int param1) {
    return (const char*)QCP::qt_getEnumName(static_cast<QCP::PlottingHints>(param1));
}

QMetaObject* QCP_GetEnumMetaObject10(int param1) {
    return (QMetaObject*)QCP::qt_getEnumMetaObject(static_cast<QCP::Interaction>(param1));
}

const char* QCP_GetEnumName10(int param1) {
    return (const char*)QCP::qt_getEnumName(static_cast<QCP::Interaction>(param1));
}

QMetaObject* QCP_GetEnumMetaObject11(int param1) {
    return (QMetaObject*)QCP::qt_getEnumMetaObject(static_cast<QCP::Interactions>(param1));
}

const char* QCP_GetEnumName11(int param1) {
    return (const char*)QCP::qt_getEnumName(static_cast<QCP::Interactions>(param1));
}

QMetaObject* QCP_GetEnumMetaObject12(int param1) {
    return (QMetaObject*)QCP::qt_getEnumMetaObject(static_cast<QCP::SelectionRectMode>(param1));
}

const char* QCP_GetEnumName12(int param1) {
    return (const char*)QCP::qt_getEnumName(static_cast<QCP::SelectionRectMode>(param1));
}

QMetaObject* QCP_GetEnumMetaObject13(int param1) {
    return (QMetaObject*)QCP::qt_getEnumMetaObject(static_cast<QCP::SelectionType>(param1));
}

const char* QCP_GetEnumName13(int param1) {
    return (const char*)QCP::qt_getEnumName(static_cast<QCP::SelectionType>(param1));
}

bool QCP_IsInvalidData(double param1) {
    return QCP::isInvalidData(static_cast<double>(param1));
}

bool QCP_IsInvalidData2(double param1, double param2) {
    return QCP::isInvalidData(static_cast<double>(param1), static_cast<double>(param2));
}

void QCP_SetMarginValue(QMargins* param1, int param2, int param3) {
    QCP::setMarginValue(*param1, static_cast<QCP::MarginSide>(param2), static_cast<int>(param3));
}

int QCP_GetMarginValue(const QMargins* param1, int param2) {
    return QCP::getMarginValue(*param1, static_cast<QCP::MarginSide>(param2));
}

QCPVector2D* QCPVector2D_new(const QCPVector2D* other) {
    return new QCPVector2D(*other);
}

QCPVector2D* QCPVector2D_new2(QCPVector2D* other) {
    return new QCPVector2D(std::move(*other));
}

QCPVector2D* QCPVector2D_new3() {
    return new QCPVector2D();
}

QCPVector2D* QCPVector2D_new4(double x, double y) {
    return new QCPVector2D(static_cast<double>(x), static_cast<double>(y));
}

QCPVector2D* QCPVector2D_new5(const QPoint* point) {
    return new QCPVector2D(*point);
}

QCPVector2D* QCPVector2D_new6(const QPointF* point) {
    return new QCPVector2D(*point);
}

QCPVector2D* QCPVector2D_new7(const QCPVector2D* param1) {
    return new QCPVector2D(*param1);
}

void QCPVector2D_CopyAssign(QCPVector2D* self, QCPVector2D* other) {
    *self = *other;
}

void QCPVector2D_MoveAssign(QCPVector2D* self, QCPVector2D* other) {
    *self = std::move(*other);
}

double QCPVector2D_X(const QCPVector2D* self) {
    return self->x();
}

double QCPVector2D_Y(const QCPVector2D* self) {
    return self->y();
}

void QCPVector2D_SetX(QCPVector2D* self, double x) {
    self->setX(static_cast<double>(x));
}

void QCPVector2D_SetY(QCPVector2D* self, double y) {
    self->setY(static_cast<double>(y));
}

double QCPVector2D_Length(const QCPVector2D* self) {
    return self->length();
}

double QCPVector2D_LengthSquared(const QCPVector2D* self) {
    return self->lengthSquared();
}

double QCPVector2D_Angle(const QCPVector2D* self) {
    return self->angle();
}

QPoint* QCPVector2D_ToPoint(const QCPVector2D* self) {
    return new QPoint(self->toPoint());
}

QPointF* QCPVector2D_ToPointF(const QCPVector2D* self) {
    return new QPointF(self->toPointF());
}

bool QCPVector2D_IsNull(const QCPVector2D* self) {
    return self->isNull();
}

void QCPVector2D_Normalize(QCPVector2D* self) {
    self->normalize();
}

QCPVector2D* QCPVector2D_Normalized(const QCPVector2D* self) {
    return new QCPVector2D(self->normalized());
}

QCPVector2D* QCPVector2D_Perpendicular(const QCPVector2D* self) {
    return new QCPVector2D(self->perpendicular());
}

double QCPVector2D_Dot(const QCPVector2D* self, const QCPVector2D* vec) {
    return self->dot(*vec);
}

double QCPVector2D_DistanceSquaredToLine(const QCPVector2D* self, const QCPVector2D* start, const QCPVector2D* end) {
    return self->distanceSquaredToLine(*start, *end);
}

double QCPVector2D_DistanceSquaredToLine2(const QCPVector2D* self, const QLineF* line) {
    return self->distanceSquaredToLine(*line);
}

double QCPVector2D_DistanceToStraightLine(const QCPVector2D* self, const QCPVector2D* base, const QCPVector2D* direction) {
    return self->distanceToStraightLine(*base, *direction);
}

QCPVector2D* QCPVector2D_OperatorMultiplyAssign(QCPVector2D* self, double factor) {
    QCPVector2D& _ret = self->operator*=(static_cast<double>(factor));
    // Cast returned reference into pointer
    return &_ret;
}

QCPVector2D* QCPVector2D_OperatorDivideAssign(QCPVector2D* self, double divisor) {
    QCPVector2D& _ret = self->operator/=(static_cast<double>(divisor));
    // Cast returned reference into pointer
    return &_ret;
}

QCPVector2D* QCPVector2D_OperatorPlusAssign(QCPVector2D* self, const QCPVector2D* vector) {
    QCPVector2D& _ret = self->operator+=(*vector);
    // Cast returned reference into pointer
    return &_ret;
}

QCPVector2D* QCPVector2D_OperatorMinusAssign(QCPVector2D* self, const QCPVector2D* vector) {
    QCPVector2D& _ret = self->operator-=(*vector);
    // Cast returned reference into pointer
    return &_ret;
}

void QCPVector2D_Delete(QCPVector2D* self) {
    delete self;
}

QCPPainter* QCPPainter_new() {
    return new QCPPainter();
}

QCPPainter* QCPPainter_new2(QPaintDevice* device) {
    return new QCPPainter(device);
}

bool QCPPainter_Antialiasing(const QCPPainter* self) {
    return self->antialiasing();
}

int QCPPainter_Modes(const QCPPainter* self) {
    return static_cast<int>(self->modes());
}

void QCPPainter_SetAntialiasing(QCPPainter* self, bool enabled) {
    self->setAntialiasing(enabled);
}

void QCPPainter_SetMode(QCPPainter* self, int mode) {
    self->setMode(static_cast<QCPPainter::PainterMode>(mode));
}

void QCPPainter_SetModes(QCPPainter* self, int modes) {
    self->setModes(static_cast<QCPPainter::PainterModes>(modes));
}

bool QCPPainter_Begin(QCPPainter* self, QPaintDevice* device) {
    return self->begin(device);
}

void QCPPainter_SetPen(QCPPainter* self, const QPen* pen) {
    self->setPen(*pen);
}

void QCPPainter_SetPen2(QCPPainter* self, const QColor* color) {
    self->setPen(*color);
}

void QCPPainter_SetPen3(QCPPainter* self, int penStyle) {
    self->setPen(static_cast<Qt::PenStyle>(penStyle));
}

void QCPPainter_DrawLine(QCPPainter* self, const QLineF* line) {
    self->drawLine(*line);
}

void QCPPainter_DrawLine2(QCPPainter* self, const QPointF* p1, const QPointF* p2) {
    self->drawLine(*p1, *p2);
}

void QCPPainter_Save(QCPPainter* self) {
    self->save();
}

void QCPPainter_Restore(QCPPainter* self) {
    self->restore();
}

void QCPPainter_MakeNonCosmetic(QCPPainter* self) {
    self->makeNonCosmetic();
}

void QCPPainter_SetMode2(QCPPainter* self, int mode, bool enabled) {
    self->setMode(static_cast<QCPPainter::PainterMode>(mode), enabled);
}

void QCPPainter_Delete(QCPPainter* self) {
    delete self;
}

QCPAbstractPaintBuffer* QCPAbstractPaintBuffer_new(const QSize* size, double devicePixelRatio) {
    return new VirtualQCPAbstractPaintBuffer(*size, static_cast<double>(devicePixelRatio));
}

QCPAbstractPaintBuffer* QCPAbstractPaintBuffer_new2(const QCPAbstractPaintBuffer* param1) {
    return new VirtualQCPAbstractPaintBuffer(*param1);
}

QSize* QCPAbstractPaintBuffer_Size(const QCPAbstractPaintBuffer* self) {
    return new QSize(self->size());
}

bool QCPAbstractPaintBuffer_Invalidated(const QCPAbstractPaintBuffer* self) {
    return self->invalidated();
}

double QCPAbstractPaintBuffer_DevicePixelRatio(const QCPAbstractPaintBuffer* self) {
    return self->devicePixelRatio();
}

void QCPAbstractPaintBuffer_SetSize(QCPAbstractPaintBuffer* self, const QSize* size) {
    self->setSize(*size);
}

void QCPAbstractPaintBuffer_SetInvalidated(QCPAbstractPaintBuffer* self) {
    self->setInvalidated();
}

void QCPAbstractPaintBuffer_SetDevicePixelRatio(QCPAbstractPaintBuffer* self, double ratio) {
    self->setDevicePixelRatio(static_cast<double>(ratio));
}

QCPPainter* QCPAbstractPaintBuffer_StartPainting(QCPAbstractPaintBuffer* self) {
    auto* vqcpabstractpaintbuffer = dynamic_cast<VirtualQCPAbstractPaintBuffer*>(self);
    if (vqcpabstractpaintbuffer && vqcpabstractpaintbuffer->isVirtualQCPAbstractPaintBuffer) {
        return vqcpabstractpaintbuffer->startPainting();
    } else {
        return ((VirtualQCPAbstractPaintBuffer*)self)->startPainting();
    }
}

void QCPAbstractPaintBuffer_DonePainting(QCPAbstractPaintBuffer* self) {
    auto* vqcpabstractpaintbuffer = dynamic_cast<VirtualQCPAbstractPaintBuffer*>(self);
    if (vqcpabstractpaintbuffer && vqcpabstractpaintbuffer->isVirtualQCPAbstractPaintBuffer) {
        self->donePainting();
    } else {
        ((VirtualQCPAbstractPaintBuffer*)self)->donePainting();
    }
}

void QCPAbstractPaintBuffer_Draw(const QCPAbstractPaintBuffer* self, QCPPainter* painter) {
    auto* vqcpabstractpaintbuffer = dynamic_cast<const VirtualQCPAbstractPaintBuffer*>(self);
    if (vqcpabstractpaintbuffer && vqcpabstractpaintbuffer->isVirtualQCPAbstractPaintBuffer) {
        vqcpabstractpaintbuffer->draw(painter);
    } else {
        ((VirtualQCPAbstractPaintBuffer*)self)->draw(painter);
    }
}

void QCPAbstractPaintBuffer_Clear(QCPAbstractPaintBuffer* self, const QColor* color) {
    auto* vqcpabstractpaintbuffer = dynamic_cast<VirtualQCPAbstractPaintBuffer*>(self);
    if (vqcpabstractpaintbuffer && vqcpabstractpaintbuffer->isVirtualQCPAbstractPaintBuffer) {
        vqcpabstractpaintbuffer->clear(*color);
    } else {
        ((VirtualQCPAbstractPaintBuffer*)self)->clear(*color);
    }
}

void QCPAbstractPaintBuffer_ReallocateBuffer(QCPAbstractPaintBuffer* self) {
    auto* vqcpabstractpaintbuffer = dynamic_cast<VirtualQCPAbstractPaintBuffer*>(self);
    if (vqcpabstractpaintbuffer && vqcpabstractpaintbuffer->isVirtualQCPAbstractPaintBuffer) {
        vqcpabstractpaintbuffer->reallocateBuffer();
    }
}

void QCPAbstractPaintBuffer_SetInvalidated1(QCPAbstractPaintBuffer* self, bool invalidated) {
    self->setInvalidated(invalidated);
}

// Base class handler implementation
QCPPainter* QCPAbstractPaintBuffer_QBaseStartPainting(QCPAbstractPaintBuffer* self) {
    auto* vqcpabstractpaintbuffer = dynamic_cast<VirtualQCPAbstractPaintBuffer*>(self);
    if (vqcpabstractpaintbuffer && vqcpabstractpaintbuffer->isVirtualQCPAbstractPaintBuffer) {
        vqcpabstractpaintbuffer->setQCPAbstractPaintBuffer_StartPainting_IsBase(true);
        return vqcpabstractpaintbuffer->startPainting();
    } else {
        return ((VirtualQCPAbstractPaintBuffer*)self)->startPainting();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPaintBuffer_OnStartPainting(QCPAbstractPaintBuffer* self, intptr_t slot) {
    auto* vqcpabstractpaintbuffer = dynamic_cast<VirtualQCPAbstractPaintBuffer*>(self);
    if (vqcpabstractpaintbuffer && vqcpabstractpaintbuffer->isVirtualQCPAbstractPaintBuffer) {
        vqcpabstractpaintbuffer->setQCPAbstractPaintBuffer_StartPainting_Callback(reinterpret_cast<VirtualQCPAbstractPaintBuffer::QCPAbstractPaintBuffer_StartPainting_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAbstractPaintBuffer_QBaseDonePainting(QCPAbstractPaintBuffer* self) {
    auto* vqcpabstractpaintbuffer = dynamic_cast<VirtualQCPAbstractPaintBuffer*>(self);
    if (vqcpabstractpaintbuffer && vqcpabstractpaintbuffer->isVirtualQCPAbstractPaintBuffer) {
        vqcpabstractpaintbuffer->setQCPAbstractPaintBuffer_DonePainting_IsBase(true);
        vqcpabstractpaintbuffer->donePainting();
    } else {
        self->QCPAbstractPaintBuffer::donePainting();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPaintBuffer_OnDonePainting(QCPAbstractPaintBuffer* self, intptr_t slot) {
    auto* vqcpabstractpaintbuffer = dynamic_cast<VirtualQCPAbstractPaintBuffer*>(self);
    if (vqcpabstractpaintbuffer && vqcpabstractpaintbuffer->isVirtualQCPAbstractPaintBuffer) {
        vqcpabstractpaintbuffer->setQCPAbstractPaintBuffer_DonePainting_Callback(reinterpret_cast<VirtualQCPAbstractPaintBuffer::QCPAbstractPaintBuffer_DonePainting_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAbstractPaintBuffer_QBaseDraw(const QCPAbstractPaintBuffer* self, QCPPainter* painter) {
    auto* vqcpabstractpaintbuffer = const_cast<VirtualQCPAbstractPaintBuffer*>(dynamic_cast<const VirtualQCPAbstractPaintBuffer*>(self));
    if (vqcpabstractpaintbuffer && vqcpabstractpaintbuffer->isVirtualQCPAbstractPaintBuffer) {
        vqcpabstractpaintbuffer->setQCPAbstractPaintBuffer_Draw_IsBase(true);
        vqcpabstractpaintbuffer->draw(painter);
    } else {
        ((VirtualQCPAbstractPaintBuffer*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPaintBuffer_OnDraw(const QCPAbstractPaintBuffer* self, intptr_t slot) {
    auto* vqcpabstractpaintbuffer = const_cast<VirtualQCPAbstractPaintBuffer*>(dynamic_cast<const VirtualQCPAbstractPaintBuffer*>(self));
    if (vqcpabstractpaintbuffer && vqcpabstractpaintbuffer->isVirtualQCPAbstractPaintBuffer) {
        vqcpabstractpaintbuffer->setQCPAbstractPaintBuffer_Draw_Callback(reinterpret_cast<VirtualQCPAbstractPaintBuffer::QCPAbstractPaintBuffer_Draw_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAbstractPaintBuffer_QBaseClear(QCPAbstractPaintBuffer* self, const QColor* color) {
    auto* vqcpabstractpaintbuffer = dynamic_cast<VirtualQCPAbstractPaintBuffer*>(self);
    if (vqcpabstractpaintbuffer && vqcpabstractpaintbuffer->isVirtualQCPAbstractPaintBuffer) {
        vqcpabstractpaintbuffer->setQCPAbstractPaintBuffer_Clear_IsBase(true);
        vqcpabstractpaintbuffer->clear(*color);
    } else {
        ((VirtualQCPAbstractPaintBuffer*)self)->clear(*color);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPaintBuffer_OnClear(QCPAbstractPaintBuffer* self, intptr_t slot) {
    auto* vqcpabstractpaintbuffer = dynamic_cast<VirtualQCPAbstractPaintBuffer*>(self);
    if (vqcpabstractpaintbuffer && vqcpabstractpaintbuffer->isVirtualQCPAbstractPaintBuffer) {
        vqcpabstractpaintbuffer->setQCPAbstractPaintBuffer_Clear_Callback(reinterpret_cast<VirtualQCPAbstractPaintBuffer::QCPAbstractPaintBuffer_Clear_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAbstractPaintBuffer_QBaseReallocateBuffer(QCPAbstractPaintBuffer* self) {
    auto* vqcpabstractpaintbuffer = dynamic_cast<VirtualQCPAbstractPaintBuffer*>(self);
    if (vqcpabstractpaintbuffer && vqcpabstractpaintbuffer->isVirtualQCPAbstractPaintBuffer) {
        vqcpabstractpaintbuffer->setQCPAbstractPaintBuffer_ReallocateBuffer_IsBase(true);
        vqcpabstractpaintbuffer->reallocateBuffer();
    } else {
        ((VirtualQCPAbstractPaintBuffer*)self)->reallocateBuffer();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPaintBuffer_OnReallocateBuffer(QCPAbstractPaintBuffer* self, intptr_t slot) {
    auto* vqcpabstractpaintbuffer = dynamic_cast<VirtualQCPAbstractPaintBuffer*>(self);
    if (vqcpabstractpaintbuffer && vqcpabstractpaintbuffer->isVirtualQCPAbstractPaintBuffer) {
        vqcpabstractpaintbuffer->setQCPAbstractPaintBuffer_ReallocateBuffer_Callback(reinterpret_cast<VirtualQCPAbstractPaintBuffer::QCPAbstractPaintBuffer_ReallocateBuffer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractPaintBuffer_OperatorAssign(QCPAbstractPaintBuffer* self, const QCPAbstractPaintBuffer* param1) {
    auto* vqcpabstractpaintbuffer = dynamic_cast<VirtualQCPAbstractPaintBuffer*>(self);
    if (vqcpabstractpaintbuffer && vqcpabstractpaintbuffer->isVirtualQCPAbstractPaintBuffer) {
        vqcpabstractpaintbuffer->operator=(*param1);
    } else {
        ((VirtualQCPAbstractPaintBuffer*)self)->operator=(*param1);
    }
}

// Base class handler implementation
void QCPAbstractPaintBuffer_QBaseOperatorAssign(QCPAbstractPaintBuffer* self, const QCPAbstractPaintBuffer* param1) {
    auto* vqcpabstractpaintbuffer = dynamic_cast<VirtualQCPAbstractPaintBuffer*>(self);
    if (vqcpabstractpaintbuffer && vqcpabstractpaintbuffer->isVirtualQCPAbstractPaintBuffer) {
        vqcpabstractpaintbuffer->setQCPAbstractPaintBuffer_OperatorAssign_IsBase(true);
        vqcpabstractpaintbuffer->operator=(*param1);
    } else {
        ((VirtualQCPAbstractPaintBuffer*)self)->operator=(*param1);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPaintBuffer_OnOperatorAssign(QCPAbstractPaintBuffer* self, intptr_t slot) {
    auto* vqcpabstractpaintbuffer = dynamic_cast<VirtualQCPAbstractPaintBuffer*>(self);
    if (vqcpabstractpaintbuffer && vqcpabstractpaintbuffer->isVirtualQCPAbstractPaintBuffer) {
        vqcpabstractpaintbuffer->setQCPAbstractPaintBuffer_OperatorAssign_Callback(reinterpret_cast<VirtualQCPAbstractPaintBuffer::QCPAbstractPaintBuffer_OperatorAssign_Callback>(slot));
    }
}

void QCPAbstractPaintBuffer_Delete(QCPAbstractPaintBuffer* self) {
    delete self;
}

QCPPaintBufferPixmap* QCPPaintBufferPixmap_new(const QSize* size, double devicePixelRatio) {
    return new VirtualQCPPaintBufferPixmap(*size, static_cast<double>(devicePixelRatio));
}

QCPPaintBufferPixmap* QCPPaintBufferPixmap_new2(const QCPPaintBufferPixmap* param1) {
    return new VirtualQCPPaintBufferPixmap(*param1);
}

QCPPainter* QCPPaintBufferPixmap_StartPainting(QCPPaintBufferPixmap* self) {
    auto* vqcppaintbufferpixmap = dynamic_cast<VirtualQCPPaintBufferPixmap*>(self);
    if (vqcppaintbufferpixmap && vqcppaintbufferpixmap->isVirtualQCPPaintBufferPixmap) {
        return self->startPainting();
    } else {
        return ((VirtualQCPPaintBufferPixmap*)self)->startPainting();
    }
}

void QCPPaintBufferPixmap_Draw(const QCPPaintBufferPixmap* self, QCPPainter* painter) {
    auto* vqcppaintbufferpixmap = dynamic_cast<const VirtualQCPPaintBufferPixmap*>(self);
    if (vqcppaintbufferpixmap && vqcppaintbufferpixmap->isVirtualQCPPaintBufferPixmap) {
        self->draw(painter);
    } else {
        ((VirtualQCPPaintBufferPixmap*)self)->draw(painter);
    }
}

void QCPPaintBufferPixmap_Clear(QCPPaintBufferPixmap* self, const QColor* color) {
    auto* vqcppaintbufferpixmap = dynamic_cast<VirtualQCPPaintBufferPixmap*>(self);
    if (vqcppaintbufferpixmap && vqcppaintbufferpixmap->isVirtualQCPPaintBufferPixmap) {
        self->clear(*color);
    } else {
        ((VirtualQCPPaintBufferPixmap*)self)->clear(*color);
    }
}

void QCPPaintBufferPixmap_ReallocateBuffer(QCPPaintBufferPixmap* self) {
    auto* vqcppaintbufferpixmap = dynamic_cast<VirtualQCPPaintBufferPixmap*>(self);
    if (vqcppaintbufferpixmap && vqcppaintbufferpixmap->isVirtualQCPPaintBufferPixmap) {
        vqcppaintbufferpixmap->reallocateBuffer();
    }
}

// Base class handler implementation
QCPPainter* QCPPaintBufferPixmap_QBaseStartPainting(QCPPaintBufferPixmap* self) {
    auto* vqcppaintbufferpixmap = dynamic_cast<VirtualQCPPaintBufferPixmap*>(self);
    if (vqcppaintbufferpixmap && vqcppaintbufferpixmap->isVirtualQCPPaintBufferPixmap) {
        vqcppaintbufferpixmap->setQCPPaintBufferPixmap_StartPainting_IsBase(true);
        return vqcppaintbufferpixmap->startPainting();
    } else {
        return self->QCPPaintBufferPixmap::startPainting();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPaintBufferPixmap_OnStartPainting(QCPPaintBufferPixmap* self, intptr_t slot) {
    auto* vqcppaintbufferpixmap = dynamic_cast<VirtualQCPPaintBufferPixmap*>(self);
    if (vqcppaintbufferpixmap && vqcppaintbufferpixmap->isVirtualQCPPaintBufferPixmap) {
        vqcppaintbufferpixmap->setQCPPaintBufferPixmap_StartPainting_Callback(reinterpret_cast<VirtualQCPPaintBufferPixmap::QCPPaintBufferPixmap_StartPainting_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPaintBufferPixmap_QBaseDraw(const QCPPaintBufferPixmap* self, QCPPainter* painter) {
    auto* vqcppaintbufferpixmap = const_cast<VirtualQCPPaintBufferPixmap*>(dynamic_cast<const VirtualQCPPaintBufferPixmap*>(self));
    if (vqcppaintbufferpixmap && vqcppaintbufferpixmap->isVirtualQCPPaintBufferPixmap) {
        vqcppaintbufferpixmap->setQCPPaintBufferPixmap_Draw_IsBase(true);
        vqcppaintbufferpixmap->draw(painter);
    } else {
        self->QCPPaintBufferPixmap::draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPaintBufferPixmap_OnDraw(const QCPPaintBufferPixmap* self, intptr_t slot) {
    auto* vqcppaintbufferpixmap = const_cast<VirtualQCPPaintBufferPixmap*>(dynamic_cast<const VirtualQCPPaintBufferPixmap*>(self));
    if (vqcppaintbufferpixmap && vqcppaintbufferpixmap->isVirtualQCPPaintBufferPixmap) {
        vqcppaintbufferpixmap->setQCPPaintBufferPixmap_Draw_Callback(reinterpret_cast<VirtualQCPPaintBufferPixmap::QCPPaintBufferPixmap_Draw_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPaintBufferPixmap_QBaseClear(QCPPaintBufferPixmap* self, const QColor* color) {
    auto* vqcppaintbufferpixmap = dynamic_cast<VirtualQCPPaintBufferPixmap*>(self);
    if (vqcppaintbufferpixmap && vqcppaintbufferpixmap->isVirtualQCPPaintBufferPixmap) {
        vqcppaintbufferpixmap->setQCPPaintBufferPixmap_Clear_IsBase(true);
        vqcppaintbufferpixmap->clear(*color);
    } else {
        self->QCPPaintBufferPixmap::clear(*color);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPaintBufferPixmap_OnClear(QCPPaintBufferPixmap* self, intptr_t slot) {
    auto* vqcppaintbufferpixmap = dynamic_cast<VirtualQCPPaintBufferPixmap*>(self);
    if (vqcppaintbufferpixmap && vqcppaintbufferpixmap->isVirtualQCPPaintBufferPixmap) {
        vqcppaintbufferpixmap->setQCPPaintBufferPixmap_Clear_Callback(reinterpret_cast<VirtualQCPPaintBufferPixmap::QCPPaintBufferPixmap_Clear_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPaintBufferPixmap_QBaseReallocateBuffer(QCPPaintBufferPixmap* self) {
    auto* vqcppaintbufferpixmap = dynamic_cast<VirtualQCPPaintBufferPixmap*>(self);
    if (vqcppaintbufferpixmap && vqcppaintbufferpixmap->isVirtualQCPPaintBufferPixmap) {
        vqcppaintbufferpixmap->setQCPPaintBufferPixmap_ReallocateBuffer_IsBase(true);
        vqcppaintbufferpixmap->reallocateBuffer();
    } else {
        ((VirtualQCPPaintBufferPixmap*)self)->reallocateBuffer();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPaintBufferPixmap_OnReallocateBuffer(QCPPaintBufferPixmap* self, intptr_t slot) {
    auto* vqcppaintbufferpixmap = dynamic_cast<VirtualQCPPaintBufferPixmap*>(self);
    if (vqcppaintbufferpixmap && vqcppaintbufferpixmap->isVirtualQCPPaintBufferPixmap) {
        vqcppaintbufferpixmap->setQCPPaintBufferPixmap_ReallocateBuffer_Callback(reinterpret_cast<VirtualQCPPaintBufferPixmap::QCPPaintBufferPixmap_ReallocateBuffer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPaintBufferPixmap_DonePainting(QCPPaintBufferPixmap* self) {
    auto* vqcppaintbufferpixmap = dynamic_cast<VirtualQCPPaintBufferPixmap*>(self);
    if (vqcppaintbufferpixmap && vqcppaintbufferpixmap->isVirtualQCPPaintBufferPixmap) {
        vqcppaintbufferpixmap->donePainting();
    } else {
        self->QCPPaintBufferPixmap::donePainting();
    }
}

// Base class handler implementation
void QCPPaintBufferPixmap_QBaseDonePainting(QCPPaintBufferPixmap* self) {
    auto* vqcppaintbufferpixmap = dynamic_cast<VirtualQCPPaintBufferPixmap*>(self);
    if (vqcppaintbufferpixmap && vqcppaintbufferpixmap->isVirtualQCPPaintBufferPixmap) {
        vqcppaintbufferpixmap->setQCPPaintBufferPixmap_DonePainting_IsBase(true);
        vqcppaintbufferpixmap->donePainting();
    } else {
        self->QCPPaintBufferPixmap::donePainting();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPaintBufferPixmap_OnDonePainting(QCPPaintBufferPixmap* self, intptr_t slot) {
    auto* vqcppaintbufferpixmap = dynamic_cast<VirtualQCPPaintBufferPixmap*>(self);
    if (vqcppaintbufferpixmap && vqcppaintbufferpixmap->isVirtualQCPPaintBufferPixmap) {
        vqcppaintbufferpixmap->setQCPPaintBufferPixmap_DonePainting_Callback(reinterpret_cast<VirtualQCPPaintBufferPixmap::QCPPaintBufferPixmap_DonePainting_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPaintBufferPixmap_OperatorAssign(QCPPaintBufferPixmap* self, const QCPPaintBufferPixmap* param1) {
    auto* vqcppaintbufferpixmap = dynamic_cast<VirtualQCPPaintBufferPixmap*>(self);
    if (vqcppaintbufferpixmap && vqcppaintbufferpixmap->isVirtualQCPPaintBufferPixmap) {
        vqcppaintbufferpixmap->operator=(*param1);
    } else {
        ((VirtualQCPPaintBufferPixmap*)self)->operator=(*param1);
    }
}

// Base class handler implementation
void QCPPaintBufferPixmap_QBaseOperatorAssign(QCPPaintBufferPixmap* self, const QCPPaintBufferPixmap* param1) {
    auto* vqcppaintbufferpixmap = dynamic_cast<VirtualQCPPaintBufferPixmap*>(self);
    if (vqcppaintbufferpixmap && vqcppaintbufferpixmap->isVirtualQCPPaintBufferPixmap) {
        vqcppaintbufferpixmap->setQCPPaintBufferPixmap_OperatorAssign_IsBase(true);
        vqcppaintbufferpixmap->operator=(*param1);
    } else {
        ((VirtualQCPPaintBufferPixmap*)self)->operator=(*param1);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPaintBufferPixmap_OnOperatorAssign(QCPPaintBufferPixmap* self, intptr_t slot) {
    auto* vqcppaintbufferpixmap = dynamic_cast<VirtualQCPPaintBufferPixmap*>(self);
    if (vqcppaintbufferpixmap && vqcppaintbufferpixmap->isVirtualQCPPaintBufferPixmap) {
        vqcppaintbufferpixmap->setQCPPaintBufferPixmap_OperatorAssign_Callback(reinterpret_cast<VirtualQCPPaintBufferPixmap::QCPPaintBufferPixmap_OperatorAssign_Callback>(slot));
    }
}

void QCPPaintBufferPixmap_Delete(QCPPaintBufferPixmap* self) {
    delete self;
}

QCPLayer* QCPLayer_new(QCustomPlot* parentPlot, const libqt_string layerName) {
    QString layerName_QString = QString::fromUtf8(layerName.data, layerName.len);
    return new VirtualQCPLayer(parentPlot, layerName_QString);
}

QMetaObject* QCPLayer_MetaObject(const QCPLayer* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPLayer_Metacast(QCPLayer* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPLayer_Metacall(QCPLayer* self, int param1, int param2, void** param3) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPLayer*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPLayer_Tr(const char* s) {
    QString _ret = QCPLayer::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

QCustomPlot* QCPLayer_ParentPlot(const QCPLayer* self) {
    return self->parentPlot();
}

libqt_string QCPLayer_Name(const QCPLayer* self) {
    QString _ret = self->name();
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

int QCPLayer_Index(const QCPLayer* self) {
    return self->index();
}

libqt_list /* of QCPLayerable* */ QCPLayer_Children(const QCPLayer* self) {
    QList<QCPLayerable*> _ret = self->children();
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPLayerable** _arr = static_cast<QCPLayerable**>(malloc(sizeof(QCPLayerable*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

bool QCPLayer_Visible(const QCPLayer* self) {
    return self->visible();
}

int QCPLayer_Mode(const QCPLayer* self) {
    return static_cast<int>(self->mode());
}

void QCPLayer_SetVisible(QCPLayer* self, bool visible) {
    self->setVisible(visible);
}

void QCPLayer_SetMode(QCPLayer* self, int mode) {
    self->setMode(static_cast<QCPLayer::LayerMode>(mode));
}

void QCPLayer_Replot(QCPLayer* self) {
    self->replot();
}

libqt_string QCPLayer_Tr2(const char* s, const char* c) {
    QString _ret = QCPLayer::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPLayer_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPLayer::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPLayer_QBaseMetacall(QCPLayer* self, int param1, int param2, void** param3) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_Metacall_IsBase(true);
        return vqcplayer->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPLayer::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayer_OnMetacall(QCPLayer* self, intptr_t slot) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_Metacall_Callback(reinterpret_cast<VirtualQCPLayer::QCPLayer_Metacall_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLayer_Event(QCPLayer* self, QEvent* event) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        return vqcplayer->event(event);
    } else {
        return self->QCPLayer::event(event);
    }
}

// Base class handler implementation
bool QCPLayer_QBaseEvent(QCPLayer* self, QEvent* event) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_Event_IsBase(true);
        return vqcplayer->event(event);
    } else {
        return self->QCPLayer::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayer_OnEvent(QCPLayer* self, intptr_t slot) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_Event_Callback(reinterpret_cast<VirtualQCPLayer::QCPLayer_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLayer_EventFilter(QCPLayer* self, QObject* watched, QEvent* event) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        return vqcplayer->eventFilter(watched, event);
    } else {
        return self->QCPLayer::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPLayer_QBaseEventFilter(QCPLayer* self, QObject* watched, QEvent* event) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_EventFilter_IsBase(true);
        return vqcplayer->eventFilter(watched, event);
    } else {
        return self->QCPLayer::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayer_OnEventFilter(QCPLayer* self, intptr_t slot) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_EventFilter_Callback(reinterpret_cast<VirtualQCPLayer::QCPLayer_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayer_TimerEvent(QCPLayer* self, QTimerEvent* event) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->timerEvent(event);
    } else {
        ((VirtualQCPLayer*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPLayer_QBaseTimerEvent(QCPLayer* self, QTimerEvent* event) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_TimerEvent_IsBase(true);
        vqcplayer->timerEvent(event);
    } else {
        ((VirtualQCPLayer*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayer_OnTimerEvent(QCPLayer* self, intptr_t slot) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_TimerEvent_Callback(reinterpret_cast<VirtualQCPLayer::QCPLayer_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayer_ChildEvent(QCPLayer* self, QChildEvent* event) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->childEvent(event);
    } else {
        ((VirtualQCPLayer*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPLayer_QBaseChildEvent(QCPLayer* self, QChildEvent* event) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_ChildEvent_IsBase(true);
        vqcplayer->childEvent(event);
    } else {
        ((VirtualQCPLayer*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayer_OnChildEvent(QCPLayer* self, intptr_t slot) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_ChildEvent_Callback(reinterpret_cast<VirtualQCPLayer::QCPLayer_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayer_CustomEvent(QCPLayer* self, QEvent* event) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->customEvent(event);
    } else {
        ((VirtualQCPLayer*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPLayer_QBaseCustomEvent(QCPLayer* self, QEvent* event) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_CustomEvent_IsBase(true);
        vqcplayer->customEvent(event);
    } else {
        ((VirtualQCPLayer*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayer_OnCustomEvent(QCPLayer* self, intptr_t slot) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_CustomEvent_Callback(reinterpret_cast<VirtualQCPLayer::QCPLayer_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayer_ConnectNotify(QCPLayer* self, const QMetaMethod* signal) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->connectNotify(*signal);
    } else {
        ((VirtualQCPLayer*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPLayer_QBaseConnectNotify(QCPLayer* self, const QMetaMethod* signal) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_ConnectNotify_IsBase(true);
        vqcplayer->connectNotify(*signal);
    } else {
        ((VirtualQCPLayer*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayer_OnConnectNotify(QCPLayer* self, intptr_t slot) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_ConnectNotify_Callback(reinterpret_cast<VirtualQCPLayer::QCPLayer_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayer_DisconnectNotify(QCPLayer* self, const QMetaMethod* signal) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->disconnectNotify(*signal);
    } else {
        ((VirtualQCPLayer*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPLayer_QBaseDisconnectNotify(QCPLayer* self, const QMetaMethod* signal) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_DisconnectNotify_IsBase(true);
        vqcplayer->disconnectNotify(*signal);
    } else {
        ((VirtualQCPLayer*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayer_OnDisconnectNotify(QCPLayer* self, intptr_t slot) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPLayer::QCPLayer_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayer_Draw(QCPLayer* self, QCPPainter* painter) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->draw(painter);
    } else {
        ((VirtualQCPLayer*)self)->draw(painter);
    }
}

// Base class handler implementation
void QCPLayer_QBaseDraw(QCPLayer* self, QCPPainter* painter) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_Draw_IsBase(true);
        vqcplayer->draw(painter);
    } else {
        ((VirtualQCPLayer*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayer_OnDraw(QCPLayer* self, intptr_t slot) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_Draw_Callback(reinterpret_cast<VirtualQCPLayer::QCPLayer_Draw_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayer_DrawToPaintBuffer(QCPLayer* self) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->drawToPaintBuffer();
    } else {
        ((VirtualQCPLayer*)self)->drawToPaintBuffer();
    }
}

// Base class handler implementation
void QCPLayer_QBaseDrawToPaintBuffer(QCPLayer* self) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_DrawToPaintBuffer_IsBase(true);
        vqcplayer->drawToPaintBuffer();
    } else {
        ((VirtualQCPLayer*)self)->drawToPaintBuffer();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayer_OnDrawToPaintBuffer(QCPLayer* self, intptr_t slot) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_DrawToPaintBuffer_Callback(reinterpret_cast<VirtualQCPLayer::QCPLayer_DrawToPaintBuffer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayer_AddChild(QCPLayer* self, QCPLayerable* layerable, bool prepend) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->addChild(layerable, prepend);
    } else {
        ((VirtualQCPLayer*)self)->addChild(layerable, prepend);
    }
}

// Base class handler implementation
void QCPLayer_QBaseAddChild(QCPLayer* self, QCPLayerable* layerable, bool prepend) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_AddChild_IsBase(true);
        vqcplayer->addChild(layerable, prepend);
    } else {
        ((VirtualQCPLayer*)self)->addChild(layerable, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayer_OnAddChild(QCPLayer* self, intptr_t slot) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_AddChild_Callback(reinterpret_cast<VirtualQCPLayer::QCPLayer_AddChild_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayer_RemoveChild(QCPLayer* self, QCPLayerable* layerable) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->removeChild(layerable);
    } else {
        ((VirtualQCPLayer*)self)->removeChild(layerable);
    }
}

// Base class handler implementation
void QCPLayer_QBaseRemoveChild(QCPLayer* self, QCPLayerable* layerable) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_RemoveChild_IsBase(true);
        vqcplayer->removeChild(layerable);
    } else {
        ((VirtualQCPLayer*)self)->removeChild(layerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayer_OnRemoveChild(QCPLayer* self, intptr_t slot) {
    auto* vqcplayer = dynamic_cast<VirtualQCPLayer*>(self);
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_RemoveChild_Callback(reinterpret_cast<VirtualQCPLayer::QCPLayer_RemoveChild_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPLayer_Sender(const QCPLayer* self) {
    auto* vqcplayer = const_cast<VirtualQCPLayer*>(dynamic_cast<const VirtualQCPLayer*>(self));
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        return vqcplayer->sender();
    } else {
        return ((VirtualQCPLayer*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPLayer_QBaseSender(const QCPLayer* self) {
    auto* vqcplayer = const_cast<VirtualQCPLayer*>(dynamic_cast<const VirtualQCPLayer*>(self));
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_Sender_IsBase(true);
        return vqcplayer->sender();
    } else {
        return ((VirtualQCPLayer*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayer_OnSender(const QCPLayer* self, intptr_t slot) {
    auto* vqcplayer = const_cast<VirtualQCPLayer*>(dynamic_cast<const VirtualQCPLayer*>(self));
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_Sender_Callback(reinterpret_cast<VirtualQCPLayer::QCPLayer_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPLayer_SenderSignalIndex(const QCPLayer* self) {
    auto* vqcplayer = const_cast<VirtualQCPLayer*>(dynamic_cast<const VirtualQCPLayer*>(self));
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        return vqcplayer->senderSignalIndex();
    } else {
        return ((VirtualQCPLayer*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPLayer_QBaseSenderSignalIndex(const QCPLayer* self) {
    auto* vqcplayer = const_cast<VirtualQCPLayer*>(dynamic_cast<const VirtualQCPLayer*>(self));
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_SenderSignalIndex_IsBase(true);
        return vqcplayer->senderSignalIndex();
    } else {
        return ((VirtualQCPLayer*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayer_OnSenderSignalIndex(const QCPLayer* self, intptr_t slot) {
    auto* vqcplayer = const_cast<VirtualQCPLayer*>(dynamic_cast<const VirtualQCPLayer*>(self));
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPLayer::QCPLayer_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPLayer_Receivers(const QCPLayer* self, const char* signal) {
    auto* vqcplayer = const_cast<VirtualQCPLayer*>(dynamic_cast<const VirtualQCPLayer*>(self));
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        return vqcplayer->receivers(signal);
    } else {
        return ((VirtualQCPLayer*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPLayer_QBaseReceivers(const QCPLayer* self, const char* signal) {
    auto* vqcplayer = const_cast<VirtualQCPLayer*>(dynamic_cast<const VirtualQCPLayer*>(self));
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_Receivers_IsBase(true);
        return vqcplayer->receivers(signal);
    } else {
        return ((VirtualQCPLayer*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayer_OnReceivers(const QCPLayer* self, intptr_t slot) {
    auto* vqcplayer = const_cast<VirtualQCPLayer*>(dynamic_cast<const VirtualQCPLayer*>(self));
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_Receivers_Callback(reinterpret_cast<VirtualQCPLayer::QCPLayer_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLayer_IsSignalConnected(const QCPLayer* self, const QMetaMethod* signal) {
    auto* vqcplayer = const_cast<VirtualQCPLayer*>(dynamic_cast<const VirtualQCPLayer*>(self));
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        return vqcplayer->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPLayer*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPLayer_QBaseIsSignalConnected(const QCPLayer* self, const QMetaMethod* signal) {
    auto* vqcplayer = const_cast<VirtualQCPLayer*>(dynamic_cast<const VirtualQCPLayer*>(self));
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_IsSignalConnected_IsBase(true);
        return vqcplayer->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPLayer*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayer_OnIsSignalConnected(const QCPLayer* self, intptr_t slot) {
    auto* vqcplayer = const_cast<VirtualQCPLayer*>(dynamic_cast<const VirtualQCPLayer*>(self));
    if (vqcplayer && vqcplayer->isVirtualQCPLayer) {
        vqcplayer->setQCPLayer_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPLayer::QCPLayer_IsSignalConnected_Callback>(slot));
    }
}

void QCPLayer_Delete(QCPLayer* self) {
    delete self;
}

QCPLayerable* QCPLayerable_new(QCustomPlot* plot) {
    return new VirtualQCPLayerable(plot);
}

QCPLayerable* QCPLayerable_new2(QCustomPlot* plot, libqt_string targetLayer) {
    QString targetLayer_QString = QString::fromUtf8(targetLayer.data, targetLayer.len);
    return new VirtualQCPLayerable(plot, targetLayer_QString);
}

QCPLayerable* QCPLayerable_new3(QCustomPlot* plot, libqt_string targetLayer, QCPLayerable* parentLayerable) {
    QString targetLayer_QString = QString::fromUtf8(targetLayer.data, targetLayer.len);
    return new VirtualQCPLayerable(plot, targetLayer_QString, parentLayerable);
}

QMetaObject* QCPLayerable_MetaObject(const QCPLayerable* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPLayerable_Metacast(QCPLayerable* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPLayerable_Metacall(QCPLayerable* self, int param1, int param2, void** param3) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPLayerable*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPLayerable_Tr(const char* s) {
    QString _ret = QCPLayerable::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

bool QCPLayerable_Visible(const QCPLayerable* self) {
    return self->visible();
}

QCustomPlot* QCPLayerable_ParentPlot(const QCPLayerable* self) {
    return self->parentPlot();
}

QCPLayerable* QCPLayerable_ParentLayerable(const QCPLayerable* self) {
    return self->parentLayerable();
}

QCPLayer* QCPLayerable_Layer(const QCPLayerable* self) {
    return self->layer();
}

bool QCPLayerable_Antialiased(const QCPLayerable* self) {
    return self->antialiased();
}

void QCPLayerable_SetVisible(QCPLayerable* self, bool on) {
    self->setVisible(on);
}

bool QCPLayerable_SetLayer(QCPLayerable* self, QCPLayer* layer) {
    return self->setLayer(layer);
}

bool QCPLayerable_SetLayer2(QCPLayerable* self, const libqt_string layerName) {
    QString layerName_QString = QString::fromUtf8(layerName.data, layerName.len);
    return self->setLayer(layerName_QString);
}

void QCPLayerable_SetAntialiased(QCPLayerable* self, bool enabled) {
    self->setAntialiased(enabled);
}

double QCPLayerable_SelectTest(const QCPLayerable* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcplayerable = dynamic_cast<const VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPLayerable*)self)->selectTest(*pos, onlySelectable, details);
    }
}

bool QCPLayerable_RealVisibility(const QCPLayerable* self) {
    return self->realVisibility();
}

void QCPLayerable_LayerChanged(QCPLayerable* self, QCPLayer* newLayer) {
    self->layerChanged(newLayer);
}

void QCPLayerable_Connect_LayerChanged(QCPLayerable* self, intptr_t slot) {
    void (*slotFunc)(QCPLayerable*, QCPLayer*) = reinterpret_cast<void (*)(QCPLayerable*, QCPLayer*)>(slot);
    QCPLayerable::connect(self, &QCPLayerable::layerChanged, [self, slotFunc](QCPLayer* newLayer) {
        QCPLayer* sigval1 = newLayer;
        slotFunc(self, sigval1);
    });
}

void QCPLayerable_ParentPlotInitialized(QCPLayerable* self, QCustomPlot* parentPlot) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->parentPlotInitialized(parentPlot);
    }
}

int QCPLayerable_SelectionCategory(const QCPLayerable* self) {
    auto* vqcplayerable = dynamic_cast<const VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        return static_cast<int>(vqcplayerable->selectionCategory());
    }
    return {};
}

QRect* QCPLayerable_ClipRect(const QCPLayerable* self) {
    auto* vqcplayerable = dynamic_cast<const VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        return new QRect(vqcplayerable->clipRect());
    }
    return {};
}

void QCPLayerable_ApplyDefaultAntialiasingHint(const QCPLayerable* self, QCPPainter* painter) {
    auto* vqcplayerable = dynamic_cast<const VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->applyDefaultAntialiasingHint(painter);
    }
}

void QCPLayerable_Draw(QCPLayerable* self, QCPPainter* painter) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->draw(painter);
    }
}

void QCPLayerable_SelectEvent(QCPLayerable* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

void QCPLayerable_DeselectEvent(QCPLayerable* self, bool* selectionStateChanged) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->deselectEvent(selectionStateChanged);
    }
}

void QCPLayerable_MousePressEvent(QCPLayerable* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->mousePressEvent(event, *details);
    }
}

void QCPLayerable_MouseMoveEvent(QCPLayerable* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->mouseMoveEvent(event, *startPos);
    }
}

void QCPLayerable_MouseReleaseEvent(QCPLayerable* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->mouseReleaseEvent(event, *startPos);
    }
}

void QCPLayerable_MouseDoubleClickEvent(QCPLayerable* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->mouseDoubleClickEvent(event, *details);
    }
}

void QCPLayerable_WheelEvent(QCPLayerable* self, QWheelEvent* event) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->wheelEvent(event);
    }
}

libqt_string QCPLayerable_Tr2(const char* s, const char* c) {
    QString _ret = QCPLayerable::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPLayerable_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPLayerable::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPLayerable_QBaseMetacall(QCPLayerable* self, int param1, int param2, void** param3) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_Metacall_IsBase(true);
        return vqcplayerable->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPLayerable::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnMetacall(QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_Metacall_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
double QCPLayerable_QBaseSelectTest(const QCPLayerable* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcplayerable = const_cast<VirtualQCPLayerable*>(dynamic_cast<const VirtualQCPLayerable*>(self));
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_SelectTest_IsBase(true);
        return vqcplayerable->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPLayerable::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnSelectTest(const QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = const_cast<VirtualQCPLayerable*>(dynamic_cast<const VirtualQCPLayerable*>(self));
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_SelectTest_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLayerable_QBaseParentPlotInitialized(QCPLayerable* self, QCustomPlot* parentPlot) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_ParentPlotInitialized_IsBase(true);
        vqcplayerable->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPLayerable*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnParentPlotInitialized(QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_ParentPlotInitialized_Callback>(slot));
    }
}

// Base class handler implementation
int QCPLayerable_QBaseSelectionCategory(const QCPLayerable* self) {
    auto* vqcplayerable = const_cast<VirtualQCPLayerable*>(dynamic_cast<const VirtualQCPLayerable*>(self));
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcplayerable->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPLayerable*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnSelectionCategory(const QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = const_cast<VirtualQCPLayerable*>(dynamic_cast<const VirtualQCPLayerable*>(self));
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_SelectionCategory_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_SelectionCategory_Callback>(slot));
    }
}

// Base class handler implementation
QRect* QCPLayerable_QBaseClipRect(const QCPLayerable* self) {
    auto* vqcplayerable = const_cast<VirtualQCPLayerable*>(dynamic_cast<const VirtualQCPLayerable*>(self));
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_ClipRect_IsBase(true);
        return new QRect(vqcplayerable->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnClipRect(const QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = const_cast<VirtualQCPLayerable*>(dynamic_cast<const VirtualQCPLayerable*>(self));
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_ClipRect_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_ClipRect_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLayerable_QBaseApplyDefaultAntialiasingHint(const QCPLayerable* self, QCPPainter* painter) {
    auto* vqcplayerable = const_cast<VirtualQCPLayerable*>(dynamic_cast<const VirtualQCPLayerable*>(self));
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcplayerable->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPLayerable*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnApplyDefaultAntialiasingHint(const QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = const_cast<VirtualQCPLayerable*>(dynamic_cast<const VirtualQCPLayerable*>(self));
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLayerable_QBaseDraw(QCPLayerable* self, QCPPainter* painter) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_Draw_IsBase(true);
        vqcplayerable->draw(painter);
    } else {
        ((VirtualQCPLayerable*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnDraw(QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_Draw_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_Draw_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLayerable_QBaseSelectEvent(QCPLayerable* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_SelectEvent_IsBase(true);
        vqcplayerable->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPLayerable*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnSelectEvent(QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_SelectEvent_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_SelectEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLayerable_QBaseDeselectEvent(QCPLayerable* self, bool* selectionStateChanged) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_DeselectEvent_IsBase(true);
        vqcplayerable->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPLayerable*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnDeselectEvent(QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_DeselectEvent_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_DeselectEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLayerable_QBaseMousePressEvent(QCPLayerable* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_MousePressEvent_IsBase(true);
        vqcplayerable->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPLayerable*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnMousePressEvent(QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_MousePressEvent_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_MousePressEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLayerable_QBaseMouseMoveEvent(QCPLayerable* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_MouseMoveEvent_IsBase(true);
        vqcplayerable->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPLayerable*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnMouseMoveEvent(QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_MouseMoveEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLayerable_QBaseMouseReleaseEvent(QCPLayerable* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_MouseReleaseEvent_IsBase(true);
        vqcplayerable->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPLayerable*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnMouseReleaseEvent(QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_MouseReleaseEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLayerable_QBaseMouseDoubleClickEvent(QCPLayerable* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_MouseDoubleClickEvent_IsBase(true);
        vqcplayerable->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPLayerable*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnMouseDoubleClickEvent(QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLayerable_QBaseWheelEvent(QCPLayerable* self, QWheelEvent* event) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_WheelEvent_IsBase(true);
        vqcplayerable->wheelEvent(event);
    } else {
        ((VirtualQCPLayerable*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnWheelEvent(QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_WheelEvent_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLayerable_Event(QCPLayerable* self, QEvent* event) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        return vqcplayerable->event(event);
    } else {
        return self->QCPLayerable::event(event);
    }
}

// Base class handler implementation
bool QCPLayerable_QBaseEvent(QCPLayerable* self, QEvent* event) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_Event_IsBase(true);
        return vqcplayerable->event(event);
    } else {
        return self->QCPLayerable::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnEvent(QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_Event_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLayerable_EventFilter(QCPLayerable* self, QObject* watched, QEvent* event) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        return vqcplayerable->eventFilter(watched, event);
    } else {
        return self->QCPLayerable::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPLayerable_QBaseEventFilter(QCPLayerable* self, QObject* watched, QEvent* event) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_EventFilter_IsBase(true);
        return vqcplayerable->eventFilter(watched, event);
    } else {
        return self->QCPLayerable::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnEventFilter(QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_EventFilter_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayerable_TimerEvent(QCPLayerable* self, QTimerEvent* event) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->timerEvent(event);
    } else {
        ((VirtualQCPLayerable*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPLayerable_QBaseTimerEvent(QCPLayerable* self, QTimerEvent* event) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_TimerEvent_IsBase(true);
        vqcplayerable->timerEvent(event);
    } else {
        ((VirtualQCPLayerable*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnTimerEvent(QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_TimerEvent_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayerable_ChildEvent(QCPLayerable* self, QChildEvent* event) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->childEvent(event);
    } else {
        ((VirtualQCPLayerable*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPLayerable_QBaseChildEvent(QCPLayerable* self, QChildEvent* event) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_ChildEvent_IsBase(true);
        vqcplayerable->childEvent(event);
    } else {
        ((VirtualQCPLayerable*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnChildEvent(QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_ChildEvent_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayerable_CustomEvent(QCPLayerable* self, QEvent* event) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->customEvent(event);
    } else {
        ((VirtualQCPLayerable*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPLayerable_QBaseCustomEvent(QCPLayerable* self, QEvent* event) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_CustomEvent_IsBase(true);
        vqcplayerable->customEvent(event);
    } else {
        ((VirtualQCPLayerable*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnCustomEvent(QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_CustomEvent_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayerable_ConnectNotify(QCPLayerable* self, const QMetaMethod* signal) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->connectNotify(*signal);
    } else {
        ((VirtualQCPLayerable*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPLayerable_QBaseConnectNotify(QCPLayerable* self, const QMetaMethod* signal) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_ConnectNotify_IsBase(true);
        vqcplayerable->connectNotify(*signal);
    } else {
        ((VirtualQCPLayerable*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnConnectNotify(QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_ConnectNotify_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayerable_DisconnectNotify(QCPLayerable* self, const QMetaMethod* signal) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->disconnectNotify(*signal);
    } else {
        ((VirtualQCPLayerable*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPLayerable_QBaseDisconnectNotify(QCPLayerable* self, const QMetaMethod* signal) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_DisconnectNotify_IsBase(true);
        vqcplayerable->disconnectNotify(*signal);
    } else {
        ((VirtualQCPLayerable*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnDisconnectNotify(QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayerable_InitializeParentPlot(QCPLayerable* self, QCustomPlot* parentPlot) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPLayerable*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPLayerable_QBaseInitializeParentPlot(QCPLayerable* self, QCustomPlot* parentPlot) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_InitializeParentPlot_IsBase(true);
        vqcplayerable->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPLayerable*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnInitializeParentPlot(QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayerable_SetParentLayerable(QCPLayerable* self, QCPLayerable* parentLayerable) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPLayerable*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPLayerable_QBaseSetParentLayerable(QCPLayerable* self, QCPLayerable* parentLayerable) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_SetParentLayerable_IsBase(true);
        vqcplayerable->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPLayerable*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnSetParentLayerable(QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLayerable_MoveToLayer(QCPLayerable* self, QCPLayer* layer, bool prepend) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        return vqcplayerable->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPLayerable*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPLayerable_QBaseMoveToLayer(QCPLayerable* self, QCPLayer* layer, bool prepend) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_MoveToLayer_IsBase(true);
        return vqcplayerable->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPLayerable*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnMoveToLayer(QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = dynamic_cast<VirtualQCPLayerable*>(self);
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_MoveToLayer_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayerable_ApplyAntialiasingHint(const QCPLayerable* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcplayerable = const_cast<VirtualQCPLayerable*>(dynamic_cast<const VirtualQCPLayerable*>(self));
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPLayerable*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPLayerable_QBaseApplyAntialiasingHint(const QCPLayerable* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcplayerable = const_cast<VirtualQCPLayerable*>(dynamic_cast<const VirtualQCPLayerable*>(self));
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_ApplyAntialiasingHint_IsBase(true);
        vqcplayerable->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPLayerable*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnApplyAntialiasingHint(const QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = const_cast<VirtualQCPLayerable*>(dynamic_cast<const VirtualQCPLayerable*>(self));
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPLayerable_Sender(const QCPLayerable* self) {
    auto* vqcplayerable = const_cast<VirtualQCPLayerable*>(dynamic_cast<const VirtualQCPLayerable*>(self));
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        return vqcplayerable->sender();
    } else {
        return ((VirtualQCPLayerable*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPLayerable_QBaseSender(const QCPLayerable* self) {
    auto* vqcplayerable = const_cast<VirtualQCPLayerable*>(dynamic_cast<const VirtualQCPLayerable*>(self));
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_Sender_IsBase(true);
        return vqcplayerable->sender();
    } else {
        return ((VirtualQCPLayerable*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnSender(const QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = const_cast<VirtualQCPLayerable*>(dynamic_cast<const VirtualQCPLayerable*>(self));
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_Sender_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPLayerable_SenderSignalIndex(const QCPLayerable* self) {
    auto* vqcplayerable = const_cast<VirtualQCPLayerable*>(dynamic_cast<const VirtualQCPLayerable*>(self));
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        return vqcplayerable->senderSignalIndex();
    } else {
        return ((VirtualQCPLayerable*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPLayerable_QBaseSenderSignalIndex(const QCPLayerable* self) {
    auto* vqcplayerable = const_cast<VirtualQCPLayerable*>(dynamic_cast<const VirtualQCPLayerable*>(self));
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_SenderSignalIndex_IsBase(true);
        return vqcplayerable->senderSignalIndex();
    } else {
        return ((VirtualQCPLayerable*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnSenderSignalIndex(const QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = const_cast<VirtualQCPLayerable*>(dynamic_cast<const VirtualQCPLayerable*>(self));
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPLayerable_Receivers(const QCPLayerable* self, const char* signal) {
    auto* vqcplayerable = const_cast<VirtualQCPLayerable*>(dynamic_cast<const VirtualQCPLayerable*>(self));
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        return vqcplayerable->receivers(signal);
    } else {
        return ((VirtualQCPLayerable*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPLayerable_QBaseReceivers(const QCPLayerable* self, const char* signal) {
    auto* vqcplayerable = const_cast<VirtualQCPLayerable*>(dynamic_cast<const VirtualQCPLayerable*>(self));
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_Receivers_IsBase(true);
        return vqcplayerable->receivers(signal);
    } else {
        return ((VirtualQCPLayerable*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnReceivers(const QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = const_cast<VirtualQCPLayerable*>(dynamic_cast<const VirtualQCPLayerable*>(self));
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_Receivers_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLayerable_IsSignalConnected(const QCPLayerable* self, const QMetaMethod* signal) {
    auto* vqcplayerable = const_cast<VirtualQCPLayerable*>(dynamic_cast<const VirtualQCPLayerable*>(self));
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        return vqcplayerable->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPLayerable*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPLayerable_QBaseIsSignalConnected(const QCPLayerable* self, const QMetaMethod* signal) {
    auto* vqcplayerable = const_cast<VirtualQCPLayerable*>(dynamic_cast<const VirtualQCPLayerable*>(self));
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_IsSignalConnected_IsBase(true);
        return vqcplayerable->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPLayerable*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayerable_OnIsSignalConnected(const QCPLayerable* self, intptr_t slot) {
    auto* vqcplayerable = const_cast<VirtualQCPLayerable*>(dynamic_cast<const VirtualQCPLayerable*>(self));
    if (vqcplayerable && vqcplayerable->isVirtualQCPLayerable) {
        vqcplayerable->setQCPLayerable_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPLayerable::QCPLayerable_IsSignalConnected_Callback>(slot));
    }
}

void QCPLayerable_Delete(QCPLayerable* self) {
    delete self;
}

QCPRange* QCPRange_new(const QCPRange* other) {
    return new QCPRange(*other);
}

QCPRange* QCPRange_new2(QCPRange* other) {
    return new QCPRange(std::move(*other));
}

QCPRange* QCPRange_new3() {
    return new QCPRange();
}

QCPRange* QCPRange_new4(double lower, double upper) {
    return new QCPRange(static_cast<double>(lower), static_cast<double>(upper));
}

QCPRange* QCPRange_new5(const QCPRange* param1) {
    return new QCPRange(*param1);
}

void QCPRange_CopyAssign(QCPRange* self, QCPRange* other) {
    *self = *other;
}

void QCPRange_MoveAssign(QCPRange* self, QCPRange* other) {
    *self = std::move(*other);
}

double QCPRange_Lower(const QCPRange* self) {
    return self->lower;
}

void QCPRange_SetLower(QCPRange* self, double lower) {
    self->lower = static_cast<double>(lower);
}

double QCPRange_Upper(const QCPRange* self) {
    return self->upper;
}

void QCPRange_SetUpper(QCPRange* self, double upper) {
    self->upper = static_cast<double>(upper);
}

bool QCPRange_OperatorEqual(const QCPRange* self, const QCPRange* other) {
    return (*self == *other);
}

bool QCPRange_OperatorNotEqual(const QCPRange* self, const QCPRange* other) {
    return (*self != *other);
}

QCPRange* QCPRange_OperatorPlusAssign(QCPRange* self, const double* value) {
    QCPRange& _ret = self->operator+=(static_cast<const double&>(*value));
    // Cast returned reference into pointer
    return &_ret;
}

QCPRange* QCPRange_OperatorMinusAssign(QCPRange* self, const double* value) {
    QCPRange& _ret = self->operator-=(static_cast<const double&>(*value));
    // Cast returned reference into pointer
    return &_ret;
}

QCPRange* QCPRange_OperatorMultiplyAssign(QCPRange* self, const double* value) {
    QCPRange& _ret = self->operator*=(static_cast<const double&>(*value));
    // Cast returned reference into pointer
    return &_ret;
}

QCPRange* QCPRange_OperatorDivideAssign(QCPRange* self, const double* value) {
    QCPRange& _ret = self->operator/=(static_cast<const double&>(*value));
    // Cast returned reference into pointer
    return &_ret;
}

double QCPRange_Size(const QCPRange* self) {
    return self->size();
}

double QCPRange_Center(const QCPRange* self) {
    return self->center();
}

void QCPRange_Normalize(QCPRange* self) {
    self->normalize();
}

void QCPRange_Expand(QCPRange* self, const QCPRange* otherRange) {
    self->expand(*otherRange);
}

void QCPRange_Expand2(QCPRange* self, double includeCoord) {
    self->expand(static_cast<double>(includeCoord));
}

QCPRange* QCPRange_Expanded(const QCPRange* self, const QCPRange* otherRange) {
    return new QCPRange(self->expanded(*otherRange));
}

QCPRange* QCPRange_Expanded2(const QCPRange* self, double includeCoord) {
    return new QCPRange(self->expanded(static_cast<double>(includeCoord)));
}

QCPRange* QCPRange_Bounded(const QCPRange* self, double lowerBound, double upperBound) {
    return new QCPRange(self->bounded(static_cast<double>(lowerBound), static_cast<double>(upperBound)));
}

QCPRange* QCPRange_SanitizedForLogScale(const QCPRange* self) {
    return new QCPRange(self->sanitizedForLogScale());
}

QCPRange* QCPRange_SanitizedForLinScale(const QCPRange* self) {
    return new QCPRange(self->sanitizedForLinScale());
}

bool QCPRange_Contains(const QCPRange* self, double value) {
    return self->contains(static_cast<double>(value));
}

bool QCPRange_ValidRange(double lower, double upper) {
    return QCPRange::validRange(static_cast<double>(lower), static_cast<double>(upper));
}

bool QCPRange_ValidRange2(const QCPRange* range) {
    return QCPRange::validRange(*range);
}

void QCPRange_Delete(QCPRange* self) {
    delete self;
}

QCPDataRange* QCPDataRange_new(const QCPDataRange* other) {
    return new QCPDataRange(*other);
}

QCPDataRange* QCPDataRange_new2(QCPDataRange* other) {
    return new QCPDataRange(std::move(*other));
}

QCPDataRange* QCPDataRange_new3() {
    return new QCPDataRange();
}

QCPDataRange* QCPDataRange_new4(int begin, int end) {
    return new QCPDataRange(static_cast<int>(begin), static_cast<int>(end));
}

QCPDataRange* QCPDataRange_new5(const QCPDataRange* param1) {
    return new QCPDataRange(*param1);
}

void QCPDataRange_CopyAssign(QCPDataRange* self, QCPDataRange* other) {
    *self = *other;
}

void QCPDataRange_MoveAssign(QCPDataRange* self, QCPDataRange* other) {
    *self = std::move(*other);
}

bool QCPDataRange_OperatorEqual(const QCPDataRange* self, const QCPDataRange* other) {
    return (*self == *other);
}

bool QCPDataRange_OperatorNotEqual(const QCPDataRange* self, const QCPDataRange* other) {
    return (*self != *other);
}

int QCPDataRange_Begin(const QCPDataRange* self) {
    return self->begin();
}

int QCPDataRange_End(const QCPDataRange* self) {
    return self->end();
}

int QCPDataRange_Size(const QCPDataRange* self) {
    return self->size();
}

int QCPDataRange_Length(const QCPDataRange* self) {
    return self->length();
}

void QCPDataRange_SetBegin(QCPDataRange* self, int begin) {
    self->setBegin(static_cast<int>(begin));
}

void QCPDataRange_SetEnd(QCPDataRange* self, int end) {
    self->setEnd(static_cast<int>(end));
}

bool QCPDataRange_IsValid(const QCPDataRange* self) {
    return self->isValid();
}

bool QCPDataRange_IsEmpty(const QCPDataRange* self) {
    return self->isEmpty();
}

QCPDataRange* QCPDataRange_Bounded(const QCPDataRange* self, const QCPDataRange* other) {
    return new QCPDataRange(self->bounded(*other));
}

QCPDataRange* QCPDataRange_Expanded(const QCPDataRange* self, const QCPDataRange* other) {
    return new QCPDataRange(self->expanded(*other));
}

QCPDataRange* QCPDataRange_Intersection(const QCPDataRange* self, const QCPDataRange* other) {
    return new QCPDataRange(self->intersection(*other));
}

QCPDataRange* QCPDataRange_Adjusted(const QCPDataRange* self, int changeBegin, int changeEnd) {
    return new QCPDataRange(self->adjusted(static_cast<int>(changeBegin), static_cast<int>(changeEnd)));
}

bool QCPDataRange_Intersects(const QCPDataRange* self, const QCPDataRange* other) {
    return self->intersects(*other);
}

bool QCPDataRange_Contains(const QCPDataRange* self, const QCPDataRange* other) {
    return self->contains(*other);
}

void QCPDataRange_Delete(QCPDataRange* self) {
    delete self;
}

QCPDataSelection* QCPDataSelection_new() {
    return new QCPDataSelection();
}

QCPDataSelection* QCPDataSelection_new2(const QCPDataRange* range) {
    return new QCPDataSelection(*range);
}

QCPDataSelection* QCPDataSelection_new3(const QCPDataSelection* param1) {
    return new QCPDataSelection(*param1);
}

bool QCPDataSelection_OperatorEqual(const QCPDataSelection* self, const QCPDataSelection* other) {
    return (*self == *other);
}

bool QCPDataSelection_OperatorNotEqual(const QCPDataSelection* self, const QCPDataSelection* other) {
    return (*self != *other);
}

QCPDataSelection* QCPDataSelection_OperatorPlusAssign(QCPDataSelection* self, const QCPDataSelection* other) {
    QCPDataSelection& _ret = self->operator+=(*other);
    // Cast returned reference into pointer
    return &_ret;
}

QCPDataSelection* QCPDataSelection_OperatorPlusAssign2(QCPDataSelection* self, const QCPDataRange* other) {
    QCPDataSelection& _ret = self->operator+=(*other);
    // Cast returned reference into pointer
    return &_ret;
}

QCPDataSelection* QCPDataSelection_OperatorMinusAssign(QCPDataSelection* self, const QCPDataSelection* other) {
    QCPDataSelection& _ret = self->operator-=(*other);
    // Cast returned reference into pointer
    return &_ret;
}

QCPDataSelection* QCPDataSelection_OperatorMinusAssign2(QCPDataSelection* self, const QCPDataRange* other) {
    QCPDataSelection& _ret = self->operator-=(*other);
    // Cast returned reference into pointer
    return &_ret;
}

int QCPDataSelection_DataRangeCount(const QCPDataSelection* self) {
    return self->dataRangeCount();
}

int QCPDataSelection_DataPointCount(const QCPDataSelection* self) {
    return self->dataPointCount();
}

QCPDataRange* QCPDataSelection_DataRange(const QCPDataSelection* self) {
    return new QCPDataRange(self->dataRange());
}

libqt_list /* of QCPDataRange* */ QCPDataSelection_DataRanges(const QCPDataSelection* self) {
    QList<QCPDataRange> _ret = self->dataRanges();
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPDataRange** _arr = static_cast<QCPDataRange**>(malloc(sizeof(QCPDataRange*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = new QCPDataRange(_ret[i]);
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

QCPDataRange* QCPDataSelection_Span(const QCPDataSelection* self) {
    return new QCPDataRange(self->span());
}

void QCPDataSelection_AddDataRange(QCPDataSelection* self, const QCPDataRange* dataRange) {
    self->addDataRange(*dataRange);
}

void QCPDataSelection_Clear(QCPDataSelection* self) {
    self->clear();
}

bool QCPDataSelection_IsEmpty(const QCPDataSelection* self) {
    return self->isEmpty();
}

void QCPDataSelection_Simplify(QCPDataSelection* self) {
    self->simplify();
}

void QCPDataSelection_EnforceType(QCPDataSelection* self, int typeVal) {
    self->enforceType(static_cast<QCP::SelectionType>(typeVal));
}

bool QCPDataSelection_Contains(const QCPDataSelection* self, const QCPDataSelection* other) {
    return self->contains(*other);
}

QCPDataSelection* QCPDataSelection_Intersection(const QCPDataSelection* self, const QCPDataRange* other) {
    return new QCPDataSelection(self->intersection(*other));
}

QCPDataSelection* QCPDataSelection_Intersection2(const QCPDataSelection* self, const QCPDataSelection* other) {
    return new QCPDataSelection(self->intersection(*other));
}

QCPDataSelection* QCPDataSelection_Inverse(const QCPDataSelection* self, const QCPDataRange* outerRange) {
    return new QCPDataSelection(self->inverse(*outerRange));
}

QCPDataRange* QCPDataSelection_DataRange1(const QCPDataSelection* self, int index) {
    return new QCPDataRange(self->dataRange(static_cast<int>(index)));
}

void QCPDataSelection_AddDataRange2(QCPDataSelection* self, const QCPDataRange* dataRange, bool simplify) {
    self->addDataRange(*dataRange, simplify);
}

void QCPDataSelection_Delete(QCPDataSelection* self) {
    delete self;
}

QCPSelectionRect* QCPSelectionRect_new(QCustomPlot* parentPlot) {
    return new VirtualQCPSelectionRect(parentPlot);
}

QMetaObject* QCPSelectionRect_MetaObject(const QCPSelectionRect* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPSelectionRect_Metacast(QCPSelectionRect* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPSelectionRect_Metacall(QCPSelectionRect* self, int param1, int param2, void** param3) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPSelectionRect*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPSelectionRect_Tr(const char* s) {
    QString _ret = QCPSelectionRect::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

QRect* QCPSelectionRect_Rect(const QCPSelectionRect* self) {
    return new QRect(self->rect());
}

QCPRange* QCPSelectionRect_Range(const QCPSelectionRect* self, const QCPAxis* axis) {
    return new QCPRange(self->range(axis));
}

QPen* QCPSelectionRect_Pen(const QCPSelectionRect* self) {
    return new QPen(self->pen());
}

QBrush* QCPSelectionRect_Brush(const QCPSelectionRect* self) {
    return new QBrush(self->brush());
}

bool QCPSelectionRect_IsActive(const QCPSelectionRect* self) {
    return self->isActive();
}

void QCPSelectionRect_SetPen(QCPSelectionRect* self, const QPen* pen) {
    self->setPen(*pen);
}

void QCPSelectionRect_SetBrush(QCPSelectionRect* self, const QBrush* brush) {
    self->setBrush(*brush);
}

void QCPSelectionRect_Cancel(QCPSelectionRect* self) {
    self->cancel();
}

void QCPSelectionRect_Started(QCPSelectionRect* self, QMouseEvent* event) {
    self->started(event);
}

void QCPSelectionRect_Connect_Started(QCPSelectionRect* self, intptr_t slot) {
    void (*slotFunc)(QCPSelectionRect*, QMouseEvent*) = reinterpret_cast<void (*)(QCPSelectionRect*, QMouseEvent*)>(slot);
    QCPSelectionRect::connect(self, &QCPSelectionRect::started, [self, slotFunc](QMouseEvent* event) {
        QMouseEvent* sigval1 = event;
        slotFunc(self, sigval1);
    });
}

void QCPSelectionRect_Changed(QCPSelectionRect* self, const QRect* rect, QMouseEvent* event) {
    self->changed(*rect, event);
}

void QCPSelectionRect_Connect_Changed(QCPSelectionRect* self, intptr_t slot) {
    void (*slotFunc)(QCPSelectionRect*, QRect*, QMouseEvent*) = reinterpret_cast<void (*)(QCPSelectionRect*, QRect*, QMouseEvent*)>(slot);
    QCPSelectionRect::connect(self, &QCPSelectionRect::changed, [self, slotFunc](const QRect& rect, QMouseEvent* event) {
        const QRect& rect_ret = rect;
        // Cast returned reference into pointer
        QRect* sigval1 = const_cast<QRect*>(&rect_ret);
        QMouseEvent* sigval2 = event;
        slotFunc(self, sigval1, sigval2);
    });
}

void QCPSelectionRect_Canceled(QCPSelectionRect* self, const QRect* rect, QInputEvent* event) {
    self->canceled(*rect, event);
}

void QCPSelectionRect_Connect_Canceled(QCPSelectionRect* self, intptr_t slot) {
    void (*slotFunc)(QCPSelectionRect*, QRect*, QInputEvent*) = reinterpret_cast<void (*)(QCPSelectionRect*, QRect*, QInputEvent*)>(slot);
    QCPSelectionRect::connect(self, &QCPSelectionRect::canceled, [self, slotFunc](const QRect& rect, QInputEvent* event) {
        const QRect& rect_ret = rect;
        // Cast returned reference into pointer
        QRect* sigval1 = const_cast<QRect*>(&rect_ret);
        QInputEvent* sigval2 = event;
        slotFunc(self, sigval1, sigval2);
    });
}

void QCPSelectionRect_Accepted(QCPSelectionRect* self, const QRect* rect, QMouseEvent* event) {
    self->accepted(*rect, event);
}

void QCPSelectionRect_Connect_Accepted(QCPSelectionRect* self, intptr_t slot) {
    void (*slotFunc)(QCPSelectionRect*, QRect*, QMouseEvent*) = reinterpret_cast<void (*)(QCPSelectionRect*, QRect*, QMouseEvent*)>(slot);
    QCPSelectionRect::connect(self, &QCPSelectionRect::accepted, [self, slotFunc](const QRect& rect, QMouseEvent* event) {
        const QRect& rect_ret = rect;
        // Cast returned reference into pointer
        QRect* sigval1 = const_cast<QRect*>(&rect_ret);
        QMouseEvent* sigval2 = event;
        slotFunc(self, sigval1, sigval2);
    });
}

void QCPSelectionRect_StartSelection(QCPSelectionRect* self, QMouseEvent* event) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->startSelection(event);
    }
}

void QCPSelectionRect_MoveSelection(QCPSelectionRect* self, QMouseEvent* event) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->moveSelection(event);
    }
}

void QCPSelectionRect_EndSelection(QCPSelectionRect* self, QMouseEvent* event) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->endSelection(event);
    }
}

void QCPSelectionRect_KeyPressEvent(QCPSelectionRect* self, QKeyEvent* event) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->keyPressEvent(event);
    }
}

void QCPSelectionRect_ApplyDefaultAntialiasingHint(const QCPSelectionRect* self, QCPPainter* painter) {
    auto* vqcpselectionrect = dynamic_cast<const VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->applyDefaultAntialiasingHint(painter);
    }
}

void QCPSelectionRect_Draw(QCPSelectionRect* self, QCPPainter* painter) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->draw(painter);
    }
}

libqt_string QCPSelectionRect_Tr2(const char* s, const char* c) {
    QString _ret = QCPSelectionRect::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPSelectionRect_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPSelectionRect::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPSelectionRect_QBaseMetacall(QCPSelectionRect* self, int param1, int param2, void** param3) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_Metacall_IsBase(true);
        return vqcpselectionrect->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPSelectionRect::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnMetacall(QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_Metacall_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
void QCPSelectionRect_QBaseStartSelection(QCPSelectionRect* self, QMouseEvent* event) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_StartSelection_IsBase(true);
        vqcpselectionrect->startSelection(event);
    } else {
        ((VirtualQCPSelectionRect*)self)->startSelection(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnStartSelection(QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_StartSelection_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_StartSelection_Callback>(slot));
    }
}

// Base class handler implementation
void QCPSelectionRect_QBaseMoveSelection(QCPSelectionRect* self, QMouseEvent* event) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_MoveSelection_IsBase(true);
        vqcpselectionrect->moveSelection(event);
    } else {
        ((VirtualQCPSelectionRect*)self)->moveSelection(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnMoveSelection(QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_MoveSelection_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_MoveSelection_Callback>(slot));
    }
}

// Base class handler implementation
void QCPSelectionRect_QBaseEndSelection(QCPSelectionRect* self, QMouseEvent* event) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_EndSelection_IsBase(true);
        vqcpselectionrect->endSelection(event);
    } else {
        ((VirtualQCPSelectionRect*)self)->endSelection(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnEndSelection(QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_EndSelection_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_EndSelection_Callback>(slot));
    }
}

// Base class handler implementation
void QCPSelectionRect_QBaseKeyPressEvent(QCPSelectionRect* self, QKeyEvent* event) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_KeyPressEvent_IsBase(true);
        vqcpselectionrect->keyPressEvent(event);
    } else {
        ((VirtualQCPSelectionRect*)self)->keyPressEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnKeyPressEvent(QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_KeyPressEvent_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_KeyPressEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPSelectionRect_QBaseApplyDefaultAntialiasingHint(const QCPSelectionRect* self, QCPPainter* painter) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcpselectionrect->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPSelectionRect*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnApplyDefaultAntialiasingHint(const QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Base class handler implementation
void QCPSelectionRect_QBaseDraw(QCPSelectionRect* self, QCPPainter* painter) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_Draw_IsBase(true);
        vqcpselectionrect->draw(painter);
    } else {
        ((VirtualQCPSelectionRect*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnDraw(QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_Draw_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_Draw_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPSelectionRect_SelectTest(const QCPSelectionRect* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        return vqcpselectionrect->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPSelectionRect::selectTest(*pos, onlySelectable, details);
    }
}

// Base class handler implementation
double QCPSelectionRect_QBaseSelectTest(const QCPSelectionRect* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_SelectTest_IsBase(true);
        return vqcpselectionrect->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPSelectionRect::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnSelectTest(const QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_SelectTest_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_SelectTest_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPSelectionRect_ParentPlotInitialized(QCPSelectionRect* self, QCustomPlot* parentPlot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPSelectionRect*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPSelectionRect_QBaseParentPlotInitialized(QCPSelectionRect* self, QCustomPlot* parentPlot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_ParentPlotInitialized_IsBase(true);
        vqcpselectionrect->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPSelectionRect*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnParentPlotInitialized(QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPSelectionRect_SelectionCategory(const QCPSelectionRect* self) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        return static_cast<int>(vqcpselectionrect->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPSelectionRect*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPSelectionRect_QBaseSelectionCategory(const QCPSelectionRect* self) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcpselectionrect->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPSelectionRect*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnSelectionCategory(const QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_SelectionCategory_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPSelectionRect_ClipRect(const QCPSelectionRect* self) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        return new QRect(vqcpselectionrect->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPSelectionRect_QBaseClipRect(const QCPSelectionRect* self) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_ClipRect_IsBase(true);
        return new QRect(vqcpselectionrect->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnClipRect(const QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_ClipRect_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPSelectionRect_SelectEvent(QCPSelectionRect* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPSelectionRect*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPSelectionRect_QBaseSelectEvent(QCPSelectionRect* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_SelectEvent_IsBase(true);
        vqcpselectionrect->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPSelectionRect*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnSelectEvent(QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_SelectEvent_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPSelectionRect_DeselectEvent(QCPSelectionRect* self, bool* selectionStateChanged) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPSelectionRect*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPSelectionRect_QBaseDeselectEvent(QCPSelectionRect* self, bool* selectionStateChanged) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_DeselectEvent_IsBase(true);
        vqcpselectionrect->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPSelectionRect*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnDeselectEvent(QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_DeselectEvent_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPSelectionRect_MousePressEvent(QCPSelectionRect* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPSelectionRect*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPSelectionRect_QBaseMousePressEvent(QCPSelectionRect* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_MousePressEvent_IsBase(true);
        vqcpselectionrect->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPSelectionRect*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnMousePressEvent(QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_MousePressEvent_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPSelectionRect_MouseMoveEvent(QCPSelectionRect* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPSelectionRect*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPSelectionRect_QBaseMouseMoveEvent(QCPSelectionRect* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_MouseMoveEvent_IsBase(true);
        vqcpselectionrect->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPSelectionRect*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnMouseMoveEvent(QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPSelectionRect_MouseReleaseEvent(QCPSelectionRect* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPSelectionRect*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPSelectionRect_QBaseMouseReleaseEvent(QCPSelectionRect* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_MouseReleaseEvent_IsBase(true);
        vqcpselectionrect->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPSelectionRect*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnMouseReleaseEvent(QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPSelectionRect_MouseDoubleClickEvent(QCPSelectionRect* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPSelectionRect*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPSelectionRect_QBaseMouseDoubleClickEvent(QCPSelectionRect* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_MouseDoubleClickEvent_IsBase(true);
        vqcpselectionrect->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPSelectionRect*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnMouseDoubleClickEvent(QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPSelectionRect_WheelEvent(QCPSelectionRect* self, QWheelEvent* event) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->wheelEvent(event);
    } else {
        ((VirtualQCPSelectionRect*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPSelectionRect_QBaseWheelEvent(QCPSelectionRect* self, QWheelEvent* event) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_WheelEvent_IsBase(true);
        vqcpselectionrect->wheelEvent(event);
    } else {
        ((VirtualQCPSelectionRect*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnWheelEvent(QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_WheelEvent_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPSelectionRect_Event(QCPSelectionRect* self, QEvent* event) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        return vqcpselectionrect->event(event);
    } else {
        return self->QCPSelectionRect::event(event);
    }
}

// Base class handler implementation
bool QCPSelectionRect_QBaseEvent(QCPSelectionRect* self, QEvent* event) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_Event_IsBase(true);
        return vqcpselectionrect->event(event);
    } else {
        return self->QCPSelectionRect::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnEvent(QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_Event_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPSelectionRect_EventFilter(QCPSelectionRect* self, QObject* watched, QEvent* event) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        return vqcpselectionrect->eventFilter(watched, event);
    } else {
        return self->QCPSelectionRect::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPSelectionRect_QBaseEventFilter(QCPSelectionRect* self, QObject* watched, QEvent* event) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_EventFilter_IsBase(true);
        return vqcpselectionrect->eventFilter(watched, event);
    } else {
        return self->QCPSelectionRect::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnEventFilter(QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_EventFilter_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPSelectionRect_TimerEvent(QCPSelectionRect* self, QTimerEvent* event) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->timerEvent(event);
    } else {
        ((VirtualQCPSelectionRect*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPSelectionRect_QBaseTimerEvent(QCPSelectionRect* self, QTimerEvent* event) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_TimerEvent_IsBase(true);
        vqcpselectionrect->timerEvent(event);
    } else {
        ((VirtualQCPSelectionRect*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnTimerEvent(QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_TimerEvent_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPSelectionRect_ChildEvent(QCPSelectionRect* self, QChildEvent* event) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->childEvent(event);
    } else {
        ((VirtualQCPSelectionRect*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPSelectionRect_QBaseChildEvent(QCPSelectionRect* self, QChildEvent* event) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_ChildEvent_IsBase(true);
        vqcpselectionrect->childEvent(event);
    } else {
        ((VirtualQCPSelectionRect*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnChildEvent(QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_ChildEvent_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPSelectionRect_CustomEvent(QCPSelectionRect* self, QEvent* event) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->customEvent(event);
    } else {
        ((VirtualQCPSelectionRect*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPSelectionRect_QBaseCustomEvent(QCPSelectionRect* self, QEvent* event) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_CustomEvent_IsBase(true);
        vqcpselectionrect->customEvent(event);
    } else {
        ((VirtualQCPSelectionRect*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnCustomEvent(QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_CustomEvent_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPSelectionRect_ConnectNotify(QCPSelectionRect* self, const QMetaMethod* signal) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->connectNotify(*signal);
    } else {
        ((VirtualQCPSelectionRect*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPSelectionRect_QBaseConnectNotify(QCPSelectionRect* self, const QMetaMethod* signal) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_ConnectNotify_IsBase(true);
        vqcpselectionrect->connectNotify(*signal);
    } else {
        ((VirtualQCPSelectionRect*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnConnectNotify(QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_ConnectNotify_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPSelectionRect_DisconnectNotify(QCPSelectionRect* self, const QMetaMethod* signal) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->disconnectNotify(*signal);
    } else {
        ((VirtualQCPSelectionRect*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPSelectionRect_QBaseDisconnectNotify(QCPSelectionRect* self, const QMetaMethod* signal) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_DisconnectNotify_IsBase(true);
        vqcpselectionrect->disconnectNotify(*signal);
    } else {
        ((VirtualQCPSelectionRect*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnDisconnectNotify(QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPSelectionRect_InitializeParentPlot(QCPSelectionRect* self, QCustomPlot* parentPlot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPSelectionRect*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPSelectionRect_QBaseInitializeParentPlot(QCPSelectionRect* self, QCustomPlot* parentPlot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_InitializeParentPlot_IsBase(true);
        vqcpselectionrect->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPSelectionRect*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnInitializeParentPlot(QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPSelectionRect_SetParentLayerable(QCPSelectionRect* self, QCPLayerable* parentLayerable) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPSelectionRect*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPSelectionRect_QBaseSetParentLayerable(QCPSelectionRect* self, QCPLayerable* parentLayerable) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_SetParentLayerable_IsBase(true);
        vqcpselectionrect->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPSelectionRect*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnSetParentLayerable(QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPSelectionRect_MoveToLayer(QCPSelectionRect* self, QCPLayer* layer, bool prepend) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        return vqcpselectionrect->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPSelectionRect*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPSelectionRect_QBaseMoveToLayer(QCPSelectionRect* self, QCPLayer* layer, bool prepend) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_MoveToLayer_IsBase(true);
        return vqcpselectionrect->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPSelectionRect*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnMoveToLayer(QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = dynamic_cast<VirtualQCPSelectionRect*>(self);
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_MoveToLayer_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPSelectionRect_ApplyAntialiasingHint(const QCPSelectionRect* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPSelectionRect*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPSelectionRect_QBaseApplyAntialiasingHint(const QCPSelectionRect* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_ApplyAntialiasingHint_IsBase(true);
        vqcpselectionrect->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPSelectionRect*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnApplyAntialiasingHint(const QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPSelectionRect_Sender(const QCPSelectionRect* self) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        return vqcpselectionrect->sender();
    } else {
        return ((VirtualQCPSelectionRect*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPSelectionRect_QBaseSender(const QCPSelectionRect* self) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_Sender_IsBase(true);
        return vqcpselectionrect->sender();
    } else {
        return ((VirtualQCPSelectionRect*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnSender(const QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_Sender_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPSelectionRect_SenderSignalIndex(const QCPSelectionRect* self) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        return vqcpselectionrect->senderSignalIndex();
    } else {
        return ((VirtualQCPSelectionRect*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPSelectionRect_QBaseSenderSignalIndex(const QCPSelectionRect* self) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_SenderSignalIndex_IsBase(true);
        return vqcpselectionrect->senderSignalIndex();
    } else {
        return ((VirtualQCPSelectionRect*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnSenderSignalIndex(const QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPSelectionRect_Receivers(const QCPSelectionRect* self, const char* signal) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        return vqcpselectionrect->receivers(signal);
    } else {
        return ((VirtualQCPSelectionRect*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPSelectionRect_QBaseReceivers(const QCPSelectionRect* self, const char* signal) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_Receivers_IsBase(true);
        return vqcpselectionrect->receivers(signal);
    } else {
        return ((VirtualQCPSelectionRect*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnReceivers(const QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_Receivers_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPSelectionRect_IsSignalConnected(const QCPSelectionRect* self, const QMetaMethod* signal) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        return vqcpselectionrect->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPSelectionRect*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPSelectionRect_QBaseIsSignalConnected(const QCPSelectionRect* self, const QMetaMethod* signal) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_IsSignalConnected_IsBase(true);
        return vqcpselectionrect->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPSelectionRect*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionRect_OnIsSignalConnected(const QCPSelectionRect* self, intptr_t slot) {
    auto* vqcpselectionrect = const_cast<VirtualQCPSelectionRect*>(dynamic_cast<const VirtualQCPSelectionRect*>(self));
    if (vqcpselectionrect && vqcpselectionrect->isVirtualQCPSelectionRect) {
        vqcpselectionrect->setQCPSelectionRect_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPSelectionRect::QCPSelectionRect_IsSignalConnected_Callback>(slot));
    }
}

void QCPSelectionRect_Delete(QCPSelectionRect* self) {
    delete self;
}

QCPMarginGroup* QCPMarginGroup_new(QCustomPlot* parentPlot) {
    return new VirtualQCPMarginGroup(parentPlot);
}

QMetaObject* QCPMarginGroup_MetaObject(const QCPMarginGroup* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPMarginGroup_Metacast(QCPMarginGroup* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPMarginGroup_Metacall(QCPMarginGroup* self, int param1, int param2, void** param3) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPMarginGroup*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPMarginGroup_Tr(const char* s) {
    QString _ret = QCPMarginGroup::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_list /* of QCPLayoutElement* */ QCPMarginGroup_Elements(const QCPMarginGroup* self, int side) {
    QList<QCPLayoutElement*> _ret = self->elements(static_cast<QCP::MarginSide>(side));
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

bool QCPMarginGroup_IsEmpty(const QCPMarginGroup* self) {
    return self->isEmpty();
}

void QCPMarginGroup_Clear(QCPMarginGroup* self) {
    self->clear();
}

int QCPMarginGroup_CommonMargin(const QCPMarginGroup* self, int side) {
    auto* vqcpmargingroup = dynamic_cast<const VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        return vqcpmargingroup->commonMargin(static_cast<QCP::MarginSide>(side));
    }
    return {};
}

libqt_string QCPMarginGroup_Tr2(const char* s, const char* c) {
    QString _ret = QCPMarginGroup::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPMarginGroup_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPMarginGroup::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPMarginGroup_QBaseMetacall(QCPMarginGroup* self, int param1, int param2, void** param3) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_Metacall_IsBase(true);
        return vqcpmargingroup->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPMarginGroup::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPMarginGroup_OnMetacall(QCPMarginGroup* self, intptr_t slot) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_Metacall_Callback(reinterpret_cast<VirtualQCPMarginGroup::QCPMarginGroup_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
int QCPMarginGroup_QBaseCommonMargin(const QCPMarginGroup* self, int side) {
    auto* vqcpmargingroup = const_cast<VirtualQCPMarginGroup*>(dynamic_cast<const VirtualQCPMarginGroup*>(self));
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_CommonMargin_IsBase(true);
        return vqcpmargingroup->commonMargin(static_cast<QCP::MarginSide>(side));
    } else {
        return ((VirtualQCPMarginGroup*)self)->commonMargin(static_cast<QCP::MarginSide>(side));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPMarginGroup_OnCommonMargin(const QCPMarginGroup* self, intptr_t slot) {
    auto* vqcpmargingroup = const_cast<VirtualQCPMarginGroup*>(dynamic_cast<const VirtualQCPMarginGroup*>(self));
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_CommonMargin_Callback(reinterpret_cast<VirtualQCPMarginGroup::QCPMarginGroup_CommonMargin_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPMarginGroup_Event(QCPMarginGroup* self, QEvent* event) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        return vqcpmargingroup->event(event);
    } else {
        return self->QCPMarginGroup::event(event);
    }
}

// Base class handler implementation
bool QCPMarginGroup_QBaseEvent(QCPMarginGroup* self, QEvent* event) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_Event_IsBase(true);
        return vqcpmargingroup->event(event);
    } else {
        return self->QCPMarginGroup::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPMarginGroup_OnEvent(QCPMarginGroup* self, intptr_t slot) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_Event_Callback(reinterpret_cast<VirtualQCPMarginGroup::QCPMarginGroup_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPMarginGroup_EventFilter(QCPMarginGroup* self, QObject* watched, QEvent* event) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        return vqcpmargingroup->eventFilter(watched, event);
    } else {
        return self->QCPMarginGroup::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPMarginGroup_QBaseEventFilter(QCPMarginGroup* self, QObject* watched, QEvent* event) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_EventFilter_IsBase(true);
        return vqcpmargingroup->eventFilter(watched, event);
    } else {
        return self->QCPMarginGroup::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPMarginGroup_OnEventFilter(QCPMarginGroup* self, intptr_t slot) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_EventFilter_Callback(reinterpret_cast<VirtualQCPMarginGroup::QCPMarginGroup_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPMarginGroup_TimerEvent(QCPMarginGroup* self, QTimerEvent* event) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->timerEvent(event);
    } else {
        ((VirtualQCPMarginGroup*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPMarginGroup_QBaseTimerEvent(QCPMarginGroup* self, QTimerEvent* event) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_TimerEvent_IsBase(true);
        vqcpmargingroup->timerEvent(event);
    } else {
        ((VirtualQCPMarginGroup*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPMarginGroup_OnTimerEvent(QCPMarginGroup* self, intptr_t slot) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_TimerEvent_Callback(reinterpret_cast<VirtualQCPMarginGroup::QCPMarginGroup_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPMarginGroup_ChildEvent(QCPMarginGroup* self, QChildEvent* event) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->childEvent(event);
    } else {
        ((VirtualQCPMarginGroup*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPMarginGroup_QBaseChildEvent(QCPMarginGroup* self, QChildEvent* event) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_ChildEvent_IsBase(true);
        vqcpmargingroup->childEvent(event);
    } else {
        ((VirtualQCPMarginGroup*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPMarginGroup_OnChildEvent(QCPMarginGroup* self, intptr_t slot) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_ChildEvent_Callback(reinterpret_cast<VirtualQCPMarginGroup::QCPMarginGroup_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPMarginGroup_CustomEvent(QCPMarginGroup* self, QEvent* event) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->customEvent(event);
    } else {
        ((VirtualQCPMarginGroup*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPMarginGroup_QBaseCustomEvent(QCPMarginGroup* self, QEvent* event) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_CustomEvent_IsBase(true);
        vqcpmargingroup->customEvent(event);
    } else {
        ((VirtualQCPMarginGroup*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPMarginGroup_OnCustomEvent(QCPMarginGroup* self, intptr_t slot) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_CustomEvent_Callback(reinterpret_cast<VirtualQCPMarginGroup::QCPMarginGroup_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPMarginGroup_ConnectNotify(QCPMarginGroup* self, const QMetaMethod* signal) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->connectNotify(*signal);
    } else {
        ((VirtualQCPMarginGroup*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPMarginGroup_QBaseConnectNotify(QCPMarginGroup* self, const QMetaMethod* signal) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_ConnectNotify_IsBase(true);
        vqcpmargingroup->connectNotify(*signal);
    } else {
        ((VirtualQCPMarginGroup*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPMarginGroup_OnConnectNotify(QCPMarginGroup* self, intptr_t slot) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_ConnectNotify_Callback(reinterpret_cast<VirtualQCPMarginGroup::QCPMarginGroup_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPMarginGroup_DisconnectNotify(QCPMarginGroup* self, const QMetaMethod* signal) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->disconnectNotify(*signal);
    } else {
        ((VirtualQCPMarginGroup*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPMarginGroup_QBaseDisconnectNotify(QCPMarginGroup* self, const QMetaMethod* signal) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_DisconnectNotify_IsBase(true);
        vqcpmargingroup->disconnectNotify(*signal);
    } else {
        ((VirtualQCPMarginGroup*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPMarginGroup_OnDisconnectNotify(QCPMarginGroup* self, intptr_t slot) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPMarginGroup::QCPMarginGroup_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPMarginGroup_AddChild(QCPMarginGroup* self, int side, QCPLayoutElement* element) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->addChild(static_cast<QCP::MarginSide>(side), element);
    } else {
        ((VirtualQCPMarginGroup*)self)->addChild(static_cast<QCP::MarginSide>(side), element);
    }
}

// Base class handler implementation
void QCPMarginGroup_QBaseAddChild(QCPMarginGroup* self, int side, QCPLayoutElement* element) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_AddChild_IsBase(true);
        vqcpmargingroup->addChild(static_cast<QCP::MarginSide>(side), element);
    } else {
        ((VirtualQCPMarginGroup*)self)->addChild(static_cast<QCP::MarginSide>(side), element);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPMarginGroup_OnAddChild(QCPMarginGroup* self, intptr_t slot) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_AddChild_Callback(reinterpret_cast<VirtualQCPMarginGroup::QCPMarginGroup_AddChild_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPMarginGroup_RemoveChild(QCPMarginGroup* self, int side, QCPLayoutElement* element) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->removeChild(static_cast<QCP::MarginSide>(side), element);
    } else {
        ((VirtualQCPMarginGroup*)self)->removeChild(static_cast<QCP::MarginSide>(side), element);
    }
}

// Base class handler implementation
void QCPMarginGroup_QBaseRemoveChild(QCPMarginGroup* self, int side, QCPLayoutElement* element) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_RemoveChild_IsBase(true);
        vqcpmargingroup->removeChild(static_cast<QCP::MarginSide>(side), element);
    } else {
        ((VirtualQCPMarginGroup*)self)->removeChild(static_cast<QCP::MarginSide>(side), element);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPMarginGroup_OnRemoveChild(QCPMarginGroup* self, intptr_t slot) {
    auto* vqcpmargingroup = dynamic_cast<VirtualQCPMarginGroup*>(self);
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_RemoveChild_Callback(reinterpret_cast<VirtualQCPMarginGroup::QCPMarginGroup_RemoveChild_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPMarginGroup_Sender(const QCPMarginGroup* self) {
    auto* vqcpmargingroup = const_cast<VirtualQCPMarginGroup*>(dynamic_cast<const VirtualQCPMarginGroup*>(self));
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        return vqcpmargingroup->sender();
    } else {
        return ((VirtualQCPMarginGroup*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPMarginGroup_QBaseSender(const QCPMarginGroup* self) {
    auto* vqcpmargingroup = const_cast<VirtualQCPMarginGroup*>(dynamic_cast<const VirtualQCPMarginGroup*>(self));
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_Sender_IsBase(true);
        return vqcpmargingroup->sender();
    } else {
        return ((VirtualQCPMarginGroup*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPMarginGroup_OnSender(const QCPMarginGroup* self, intptr_t slot) {
    auto* vqcpmargingroup = const_cast<VirtualQCPMarginGroup*>(dynamic_cast<const VirtualQCPMarginGroup*>(self));
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_Sender_Callback(reinterpret_cast<VirtualQCPMarginGroup::QCPMarginGroup_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPMarginGroup_SenderSignalIndex(const QCPMarginGroup* self) {
    auto* vqcpmargingroup = const_cast<VirtualQCPMarginGroup*>(dynamic_cast<const VirtualQCPMarginGroup*>(self));
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        return vqcpmargingroup->senderSignalIndex();
    } else {
        return ((VirtualQCPMarginGroup*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPMarginGroup_QBaseSenderSignalIndex(const QCPMarginGroup* self) {
    auto* vqcpmargingroup = const_cast<VirtualQCPMarginGroup*>(dynamic_cast<const VirtualQCPMarginGroup*>(self));
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_SenderSignalIndex_IsBase(true);
        return vqcpmargingroup->senderSignalIndex();
    } else {
        return ((VirtualQCPMarginGroup*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPMarginGroup_OnSenderSignalIndex(const QCPMarginGroup* self, intptr_t slot) {
    auto* vqcpmargingroup = const_cast<VirtualQCPMarginGroup*>(dynamic_cast<const VirtualQCPMarginGroup*>(self));
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPMarginGroup::QCPMarginGroup_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPMarginGroup_Receivers(const QCPMarginGroup* self, const char* signal) {
    auto* vqcpmargingroup = const_cast<VirtualQCPMarginGroup*>(dynamic_cast<const VirtualQCPMarginGroup*>(self));
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        return vqcpmargingroup->receivers(signal);
    } else {
        return ((VirtualQCPMarginGroup*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPMarginGroup_QBaseReceivers(const QCPMarginGroup* self, const char* signal) {
    auto* vqcpmargingroup = const_cast<VirtualQCPMarginGroup*>(dynamic_cast<const VirtualQCPMarginGroup*>(self));
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_Receivers_IsBase(true);
        return vqcpmargingroup->receivers(signal);
    } else {
        return ((VirtualQCPMarginGroup*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPMarginGroup_OnReceivers(const QCPMarginGroup* self, intptr_t slot) {
    auto* vqcpmargingroup = const_cast<VirtualQCPMarginGroup*>(dynamic_cast<const VirtualQCPMarginGroup*>(self));
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_Receivers_Callback(reinterpret_cast<VirtualQCPMarginGroup::QCPMarginGroup_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPMarginGroup_IsSignalConnected(const QCPMarginGroup* self, const QMetaMethod* signal) {
    auto* vqcpmargingroup = const_cast<VirtualQCPMarginGroup*>(dynamic_cast<const VirtualQCPMarginGroup*>(self));
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        return vqcpmargingroup->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPMarginGroup*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPMarginGroup_QBaseIsSignalConnected(const QCPMarginGroup* self, const QMetaMethod* signal) {
    auto* vqcpmargingroup = const_cast<VirtualQCPMarginGroup*>(dynamic_cast<const VirtualQCPMarginGroup*>(self));
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_IsSignalConnected_IsBase(true);
        return vqcpmargingroup->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPMarginGroup*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPMarginGroup_OnIsSignalConnected(const QCPMarginGroup* self, intptr_t slot) {
    auto* vqcpmargingroup = const_cast<VirtualQCPMarginGroup*>(dynamic_cast<const VirtualQCPMarginGroup*>(self));
    if (vqcpmargingroup && vqcpmargingroup->isVirtualQCPMarginGroup) {
        vqcpmargingroup->setQCPMarginGroup_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPMarginGroup::QCPMarginGroup_IsSignalConnected_Callback>(slot));
    }
}

void QCPMarginGroup_Delete(QCPMarginGroup* self) {
    delete self;
}

QCPLayoutElement* QCPLayoutElement_new() {
    return new VirtualQCPLayoutElement();
}

QCPLayoutElement* QCPLayoutElement_new2(QCustomPlot* parentPlot) {
    return new VirtualQCPLayoutElement(parentPlot);
}

QMetaObject* QCPLayoutElement_MetaObject(const QCPLayoutElement* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPLayoutElement_Metacast(QCPLayoutElement* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPLayoutElement_Metacall(QCPLayoutElement* self, int param1, int param2, void** param3) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPLayoutElement*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPLayoutElement_Tr(const char* s) {
    QString _ret = QCPLayoutElement::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

QCPLayout* QCPLayoutElement_Layout(const QCPLayoutElement* self) {
    return self->layout();
}

QRect* QCPLayoutElement_Rect(const QCPLayoutElement* self) {
    return new QRect(self->rect());
}

QRect* QCPLayoutElement_OuterRect(const QCPLayoutElement* self) {
    return new QRect(self->outerRect());
}

QMargins* QCPLayoutElement_Margins(const QCPLayoutElement* self) {
    return new QMargins(self->margins());
}

QMargins* QCPLayoutElement_MinimumMargins(const QCPLayoutElement* self) {
    return new QMargins(self->minimumMargins());
}

int QCPLayoutElement_AutoMargins(const QCPLayoutElement* self) {
    return static_cast<int>(self->autoMargins());
}

QSize* QCPLayoutElement_MinimumSize(const QCPLayoutElement* self) {
    return new QSize(self->minimumSize());
}

QSize* QCPLayoutElement_MaximumSize(const QCPLayoutElement* self) {
    return new QSize(self->maximumSize());
}

int QCPLayoutElement_SizeConstraintRect(const QCPLayoutElement* self) {
    return static_cast<int>(self->sizeConstraintRect());
}

QCPMarginGroup* QCPLayoutElement_MarginGroup(const QCPLayoutElement* self, int side) {
    return self->marginGroup(static_cast<QCP::MarginSide>(side));
}

libqt_map /* of int to QCPMarginGroup* */ QCPLayoutElement_MarginGroups(const QCPLayoutElement* self) {
    QHash<QCP::MarginSide, QCPMarginGroup*> _ret = self->marginGroups();
    // Convert QHash<> from C++ memory to manually-managed C memory
    int* _karr = static_cast<int*>(malloc(sizeof(int) * _ret.size()));
    QCPMarginGroup** _varr = static_cast<QCPMarginGroup**>(malloc(sizeof(QCPMarginGroup*) * _ret.size()));
    int _ctr = 0;
    for (auto _itr = _ret.keyValueBegin(); _itr != _ret.keyValueEnd(); ++_itr) {
        _karr[_ctr] = static_cast<int>(_itr->first);
        _varr[_ctr] = _itr->second;
        _ctr++;
    }
    libqt_map _out;
    _out.len = _ret.size();
    _out.keys = static_cast<void*>(_karr);
    _out.values = static_cast<void*>(_varr);
    return _out;
}

void QCPLayoutElement_SetOuterRect(QCPLayoutElement* self, const QRect* rect) {
    self->setOuterRect(*rect);
}

void QCPLayoutElement_SetMargins(QCPLayoutElement* self, const QMargins* margins) {
    self->setMargins(*margins);
}

void QCPLayoutElement_SetMinimumMargins(QCPLayoutElement* self, const QMargins* margins) {
    self->setMinimumMargins(*margins);
}

void QCPLayoutElement_SetAutoMargins(QCPLayoutElement* self, int sides) {
    self->setAutoMargins(static_cast<QCP::MarginSides>(sides));
}

void QCPLayoutElement_SetMinimumSize(QCPLayoutElement* self, const QSize* size) {
    self->setMinimumSize(*size);
}

void QCPLayoutElement_SetMinimumSize2(QCPLayoutElement* self, int width, int height) {
    self->setMinimumSize(static_cast<int>(width), static_cast<int>(height));
}

void QCPLayoutElement_SetMaximumSize(QCPLayoutElement* self, const QSize* size) {
    self->setMaximumSize(*size);
}

void QCPLayoutElement_SetMaximumSize2(QCPLayoutElement* self, int width, int height) {
    self->setMaximumSize(static_cast<int>(width), static_cast<int>(height));
}

void QCPLayoutElement_SetSizeConstraintRect(QCPLayoutElement* self, int constraintRect) {
    self->setSizeConstraintRect(static_cast<QCPLayoutElement::SizeConstraintRect>(constraintRect));
}

void QCPLayoutElement_SetMarginGroup(QCPLayoutElement* self, int sides, QCPMarginGroup* group) {
    self->setMarginGroup(static_cast<QCP::MarginSides>(sides), group);
}

void QCPLayoutElement_Update(QCPLayoutElement* self, int phase) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        self->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    } else {
        ((VirtualQCPLayoutElement*)self)->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    }
}

QSize* QCPLayoutElement_MinimumOuterSizeHint(const QCPLayoutElement* self) {
    auto* vqcplayoutelement = dynamic_cast<const VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        return new QSize(self->minimumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPLayoutElement*)self)->minimumOuterSizeHint());
    }
}

QSize* QCPLayoutElement_MaximumOuterSizeHint(const QCPLayoutElement* self) {
    auto* vqcplayoutelement = dynamic_cast<const VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        return new QSize(self->maximumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPLayoutElement*)self)->maximumOuterSizeHint());
    }
}

libqt_list /* of QCPLayoutElement* */ QCPLayoutElement_Elements(const QCPLayoutElement* self, bool recursive) {
    auto* vqcplayoutelement = dynamic_cast<const VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        QList<QCPLayoutElement*> _ret = self->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayoutElement*> _ret = ((VirtualQCPLayoutElement*)self)->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

double QCPLayoutElement_SelectTest(const QCPLayoutElement* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcplayoutelement = dynamic_cast<const VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPLayoutElement*)self)->selectTest(*pos, onlySelectable, details);
    }
}

int QCPLayoutElement_CalculateAutoMargin(QCPLayoutElement* self, int side) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        return vqcplayoutelement->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    }
    return {};
}

void QCPLayoutElement_LayoutChanged(QCPLayoutElement* self) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->layoutChanged();
    }
}

void QCPLayoutElement_ApplyDefaultAntialiasingHint(const QCPLayoutElement* self, QCPPainter* painter) {
    auto* vqcplayoutelement = dynamic_cast<const VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->applyDefaultAntialiasingHint(painter);
    }
}

void QCPLayoutElement_Draw(QCPLayoutElement* self, QCPPainter* painter) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->draw(painter);
    }
}

void QCPLayoutElement_ParentPlotInitialized(QCPLayoutElement* self, QCustomPlot* parentPlot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->parentPlotInitialized(parentPlot);
    }
}

libqt_string QCPLayoutElement_Tr2(const char* s, const char* c) {
    QString _ret = QCPLayoutElement::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPLayoutElement_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPLayoutElement::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPLayoutElement_QBaseMetacall(QCPLayoutElement* self, int param1, int param2, void** param3) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_Metacall_IsBase(true);
        return vqcplayoutelement->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPLayoutElement::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnMetacall(QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_Metacall_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLayoutElement_QBaseUpdate(QCPLayoutElement* self, int phase) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_Update_IsBase(true);
        vqcplayoutelement->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    } else {
        self->QCPLayoutElement::update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnUpdate(QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_Update_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_Update_Callback>(slot));
    }
}

// Base class handler implementation
QSize* QCPLayoutElement_QBaseMinimumOuterSizeHint(const QCPLayoutElement* self) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_MinimumOuterSizeHint_IsBase(true);
        return new QSize(vqcplayoutelement->minimumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPLayoutElement*)self)->minimumOuterSizeHint());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnMinimumOuterSizeHint(const QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_MinimumOuterSizeHint_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_MinimumOuterSizeHint_Callback>(slot));
    }
}

// Base class handler implementation
QSize* QCPLayoutElement_QBaseMaximumOuterSizeHint(const QCPLayoutElement* self) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_MaximumOuterSizeHint_IsBase(true);
        return new QSize(vqcplayoutelement->maximumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPLayoutElement*)self)->maximumOuterSizeHint());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnMaximumOuterSizeHint(const QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_MaximumOuterSizeHint_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_MaximumOuterSizeHint_Callback>(slot));
    }
}

// Base class handler implementation
libqt_list /* of QCPLayoutElement* */ QCPLayoutElement_QBaseElements(const QCPLayoutElement* self, bool recursive) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_Elements_IsBase(true);
        QList<QCPLayoutElement*> _ret = vqcplayoutelement->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayoutElement*> _ret = self->QCPLayoutElement::elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnElements(const QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_Elements_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_Elements_Callback>(slot));
    }
}

// Base class handler implementation
double QCPLayoutElement_QBaseSelectTest(const QCPLayoutElement* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_SelectTest_IsBase(true);
        return vqcplayoutelement->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPLayoutElement::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnSelectTest(const QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_SelectTest_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
int QCPLayoutElement_QBaseCalculateAutoMargin(QCPLayoutElement* self, int side) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_CalculateAutoMargin_IsBase(true);
        return vqcplayoutelement->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    } else {
        return ((VirtualQCPLayoutElement*)self)->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnCalculateAutoMargin(QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_CalculateAutoMargin_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_CalculateAutoMargin_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLayoutElement_QBaseLayoutChanged(QCPLayoutElement* self) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_LayoutChanged_IsBase(true);
        vqcplayoutelement->layoutChanged();
    } else {
        ((VirtualQCPLayoutElement*)self)->layoutChanged();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnLayoutChanged(QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_LayoutChanged_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_LayoutChanged_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLayoutElement_QBaseApplyDefaultAntialiasingHint(const QCPLayoutElement* self, QCPPainter* painter) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcplayoutelement->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPLayoutElement*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnApplyDefaultAntialiasingHint(const QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLayoutElement_QBaseDraw(QCPLayoutElement* self, QCPPainter* painter) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_Draw_IsBase(true);
        vqcplayoutelement->draw(painter);
    } else {
        ((VirtualQCPLayoutElement*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnDraw(QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_Draw_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_Draw_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLayoutElement_QBaseParentPlotInitialized(QCPLayoutElement* self, QCustomPlot* parentPlot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_ParentPlotInitialized_IsBase(true);
        vqcplayoutelement->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPLayoutElement*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnParentPlotInitialized(QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPLayoutElement_SelectionCategory(const QCPLayoutElement* self) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        return static_cast<int>(vqcplayoutelement->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPLayoutElement*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPLayoutElement_QBaseSelectionCategory(const QCPLayoutElement* self) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcplayoutelement->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPLayoutElement*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnSelectionCategory(const QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_SelectionCategory_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPLayoutElement_ClipRect(const QCPLayoutElement* self) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        return new QRect(vqcplayoutelement->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPLayoutElement_QBaseClipRect(const QCPLayoutElement* self) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_ClipRect_IsBase(true);
        return new QRect(vqcplayoutelement->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnClipRect(const QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_ClipRect_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutElement_SelectEvent(QCPLayoutElement* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPLayoutElement*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPLayoutElement_QBaseSelectEvent(QCPLayoutElement* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_SelectEvent_IsBase(true);
        vqcplayoutelement->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPLayoutElement*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnSelectEvent(QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_SelectEvent_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutElement_DeselectEvent(QCPLayoutElement* self, bool* selectionStateChanged) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPLayoutElement*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPLayoutElement_QBaseDeselectEvent(QCPLayoutElement* self, bool* selectionStateChanged) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_DeselectEvent_IsBase(true);
        vqcplayoutelement->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPLayoutElement*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnDeselectEvent(QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_DeselectEvent_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutElement_MousePressEvent(QCPLayoutElement* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPLayoutElement*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPLayoutElement_QBaseMousePressEvent(QCPLayoutElement* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_MousePressEvent_IsBase(true);
        vqcplayoutelement->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPLayoutElement*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnMousePressEvent(QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_MousePressEvent_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutElement_MouseMoveEvent(QCPLayoutElement* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPLayoutElement*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPLayoutElement_QBaseMouseMoveEvent(QCPLayoutElement* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_MouseMoveEvent_IsBase(true);
        vqcplayoutelement->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPLayoutElement*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnMouseMoveEvent(QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutElement_MouseReleaseEvent(QCPLayoutElement* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPLayoutElement*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPLayoutElement_QBaseMouseReleaseEvent(QCPLayoutElement* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_MouseReleaseEvent_IsBase(true);
        vqcplayoutelement->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPLayoutElement*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnMouseReleaseEvent(QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutElement_MouseDoubleClickEvent(QCPLayoutElement* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPLayoutElement*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPLayoutElement_QBaseMouseDoubleClickEvent(QCPLayoutElement* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_MouseDoubleClickEvent_IsBase(true);
        vqcplayoutelement->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPLayoutElement*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnMouseDoubleClickEvent(QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutElement_WheelEvent(QCPLayoutElement* self, QWheelEvent* event) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->wheelEvent(event);
    } else {
        ((VirtualQCPLayoutElement*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPLayoutElement_QBaseWheelEvent(QCPLayoutElement* self, QWheelEvent* event) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_WheelEvent_IsBase(true);
        vqcplayoutelement->wheelEvent(event);
    } else {
        ((VirtualQCPLayoutElement*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnWheelEvent(QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_WheelEvent_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLayoutElement_Event(QCPLayoutElement* self, QEvent* event) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        return vqcplayoutelement->event(event);
    } else {
        return self->QCPLayoutElement::event(event);
    }
}

// Base class handler implementation
bool QCPLayoutElement_QBaseEvent(QCPLayoutElement* self, QEvent* event) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_Event_IsBase(true);
        return vqcplayoutelement->event(event);
    } else {
        return self->QCPLayoutElement::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnEvent(QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_Event_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLayoutElement_EventFilter(QCPLayoutElement* self, QObject* watched, QEvent* event) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        return vqcplayoutelement->eventFilter(watched, event);
    } else {
        return self->QCPLayoutElement::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPLayoutElement_QBaseEventFilter(QCPLayoutElement* self, QObject* watched, QEvent* event) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_EventFilter_IsBase(true);
        return vqcplayoutelement->eventFilter(watched, event);
    } else {
        return self->QCPLayoutElement::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnEventFilter(QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_EventFilter_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutElement_TimerEvent(QCPLayoutElement* self, QTimerEvent* event) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->timerEvent(event);
    } else {
        ((VirtualQCPLayoutElement*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPLayoutElement_QBaseTimerEvent(QCPLayoutElement* self, QTimerEvent* event) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_TimerEvent_IsBase(true);
        vqcplayoutelement->timerEvent(event);
    } else {
        ((VirtualQCPLayoutElement*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnTimerEvent(QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_TimerEvent_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutElement_ChildEvent(QCPLayoutElement* self, QChildEvent* event) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->childEvent(event);
    } else {
        ((VirtualQCPLayoutElement*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPLayoutElement_QBaseChildEvent(QCPLayoutElement* self, QChildEvent* event) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_ChildEvent_IsBase(true);
        vqcplayoutelement->childEvent(event);
    } else {
        ((VirtualQCPLayoutElement*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnChildEvent(QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_ChildEvent_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutElement_CustomEvent(QCPLayoutElement* self, QEvent* event) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->customEvent(event);
    } else {
        ((VirtualQCPLayoutElement*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPLayoutElement_QBaseCustomEvent(QCPLayoutElement* self, QEvent* event) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_CustomEvent_IsBase(true);
        vqcplayoutelement->customEvent(event);
    } else {
        ((VirtualQCPLayoutElement*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnCustomEvent(QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_CustomEvent_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutElement_ConnectNotify(QCPLayoutElement* self, const QMetaMethod* signal) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->connectNotify(*signal);
    } else {
        ((VirtualQCPLayoutElement*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPLayoutElement_QBaseConnectNotify(QCPLayoutElement* self, const QMetaMethod* signal) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_ConnectNotify_IsBase(true);
        vqcplayoutelement->connectNotify(*signal);
    } else {
        ((VirtualQCPLayoutElement*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnConnectNotify(QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_ConnectNotify_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutElement_DisconnectNotify(QCPLayoutElement* self, const QMetaMethod* signal) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->disconnectNotify(*signal);
    } else {
        ((VirtualQCPLayoutElement*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPLayoutElement_QBaseDisconnectNotify(QCPLayoutElement* self, const QMetaMethod* signal) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_DisconnectNotify_IsBase(true);
        vqcplayoutelement->disconnectNotify(*signal);
    } else {
        ((VirtualQCPLayoutElement*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnDisconnectNotify(QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutElement_InitializeParentPlot(QCPLayoutElement* self, QCustomPlot* parentPlot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPLayoutElement*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPLayoutElement_QBaseInitializeParentPlot(QCPLayoutElement* self, QCustomPlot* parentPlot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_InitializeParentPlot_IsBase(true);
        vqcplayoutelement->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPLayoutElement*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnInitializeParentPlot(QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutElement_SetParentLayerable(QCPLayoutElement* self, QCPLayerable* parentLayerable) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPLayoutElement*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPLayoutElement_QBaseSetParentLayerable(QCPLayoutElement* self, QCPLayerable* parentLayerable) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_SetParentLayerable_IsBase(true);
        vqcplayoutelement->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPLayoutElement*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnSetParentLayerable(QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLayoutElement_MoveToLayer(QCPLayoutElement* self, QCPLayer* layer, bool prepend) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        return vqcplayoutelement->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPLayoutElement*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPLayoutElement_QBaseMoveToLayer(QCPLayoutElement* self, QCPLayer* layer, bool prepend) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_MoveToLayer_IsBase(true);
        return vqcplayoutelement->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPLayoutElement*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnMoveToLayer(QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = dynamic_cast<VirtualQCPLayoutElement*>(self);
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_MoveToLayer_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutElement_ApplyAntialiasingHint(const QCPLayoutElement* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPLayoutElement*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPLayoutElement_QBaseApplyAntialiasingHint(const QCPLayoutElement* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_ApplyAntialiasingHint_IsBase(true);
        vqcplayoutelement->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPLayoutElement*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnApplyAntialiasingHint(const QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPLayoutElement_Sender(const QCPLayoutElement* self) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        return vqcplayoutelement->sender();
    } else {
        return ((VirtualQCPLayoutElement*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPLayoutElement_QBaseSender(const QCPLayoutElement* self) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_Sender_IsBase(true);
        return vqcplayoutelement->sender();
    } else {
        return ((VirtualQCPLayoutElement*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnSender(const QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_Sender_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPLayoutElement_SenderSignalIndex(const QCPLayoutElement* self) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        return vqcplayoutelement->senderSignalIndex();
    } else {
        return ((VirtualQCPLayoutElement*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPLayoutElement_QBaseSenderSignalIndex(const QCPLayoutElement* self) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_SenderSignalIndex_IsBase(true);
        return vqcplayoutelement->senderSignalIndex();
    } else {
        return ((VirtualQCPLayoutElement*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnSenderSignalIndex(const QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPLayoutElement_Receivers(const QCPLayoutElement* self, const char* signal) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        return vqcplayoutelement->receivers(signal);
    } else {
        return ((VirtualQCPLayoutElement*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPLayoutElement_QBaseReceivers(const QCPLayoutElement* self, const char* signal) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_Receivers_IsBase(true);
        return vqcplayoutelement->receivers(signal);
    } else {
        return ((VirtualQCPLayoutElement*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnReceivers(const QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_Receivers_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLayoutElement_IsSignalConnected(const QCPLayoutElement* self, const QMetaMethod* signal) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        return vqcplayoutelement->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPLayoutElement*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPLayoutElement_QBaseIsSignalConnected(const QCPLayoutElement* self, const QMetaMethod* signal) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_IsSignalConnected_IsBase(true);
        return vqcplayoutelement->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPLayoutElement*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutElement_OnIsSignalConnected(const QCPLayoutElement* self, intptr_t slot) {
    auto* vqcplayoutelement = const_cast<VirtualQCPLayoutElement*>(dynamic_cast<const VirtualQCPLayoutElement*>(self));
    if (vqcplayoutelement && vqcplayoutelement->isVirtualQCPLayoutElement) {
        vqcplayoutelement->setQCPLayoutElement_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPLayoutElement::QCPLayoutElement_IsSignalConnected_Callback>(slot));
    }
}

void QCPLayoutElement_Delete(QCPLayoutElement* self) {
    delete self;
}

QCPLayout* QCPLayout_new() {
    return new VirtualQCPLayout();
}

QMetaObject* QCPLayout_MetaObject(const QCPLayout* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPLayout_Metacast(QCPLayout* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPLayout_Metacall(QCPLayout* self, int param1, int param2, void** param3) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPLayout*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPLayout_Tr(const char* s) {
    QString _ret = QCPLayout::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

void QCPLayout_Update(QCPLayout* self, int phase) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        self->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    } else {
        ((VirtualQCPLayout*)self)->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    }
}

libqt_list /* of QCPLayoutElement* */ QCPLayout_Elements(const QCPLayout* self, bool recursive) {
    auto* vqcplayout = dynamic_cast<const VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        QList<QCPLayoutElement*> _ret = self->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayoutElement*> _ret = ((VirtualQCPLayout*)self)->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

int QCPLayout_ElementCount(const QCPLayout* self) {
    auto* vqcplayout = dynamic_cast<const VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        return vqcplayout->elementCount();
    } else {
        return ((VirtualQCPLayout*)self)->elementCount();
    }
}

QCPLayoutElement* QCPLayout_ElementAt(const QCPLayout* self, int index) {
    auto* vqcplayout = dynamic_cast<const VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        return vqcplayout->elementAt(static_cast<int>(index));
    } else {
        return ((VirtualQCPLayout*)self)->elementAt(static_cast<int>(index));
    }
}

QCPLayoutElement* QCPLayout_TakeAt(QCPLayout* self, int index) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        return vqcplayout->takeAt(static_cast<int>(index));
    } else {
        return ((VirtualQCPLayout*)self)->takeAt(static_cast<int>(index));
    }
}

bool QCPLayout_Take(QCPLayout* self, QCPLayoutElement* element) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        return vqcplayout->take(element);
    } else {
        return ((VirtualQCPLayout*)self)->take(element);
    }
}

void QCPLayout_Simplify(QCPLayout* self) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        self->simplify();
    } else {
        ((VirtualQCPLayout*)self)->simplify();
    }
}

bool QCPLayout_RemoveAt(QCPLayout* self, int index) {
    return self->removeAt(static_cast<int>(index));
}

bool QCPLayout_Remove(QCPLayout* self, QCPLayoutElement* element) {
    return self->remove(element);
}

void QCPLayout_Clear(QCPLayout* self) {
    self->clear();
}

void QCPLayout_UpdateLayout(QCPLayout* self) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->updateLayout();
    }
}

libqt_string QCPLayout_Tr2(const char* s, const char* c) {
    QString _ret = QCPLayout::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPLayout_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPLayout::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPLayout_QBaseMetacall(QCPLayout* self, int param1, int param2, void** param3) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_Metacall_IsBase(true);
        return vqcplayout->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPLayout::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnMetacall(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_Metacall_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLayout_QBaseUpdate(QCPLayout* self, int phase) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_Update_IsBase(true);
        vqcplayout->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    } else {
        self->QCPLayout::update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnUpdate(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_Update_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_Update_Callback>(slot));
    }
}

// Base class handler implementation
libqt_list /* of QCPLayoutElement* */ QCPLayout_QBaseElements(const QCPLayout* self, bool recursive) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_Elements_IsBase(true);
        QList<QCPLayoutElement*> _ret = vqcplayout->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayoutElement*> _ret = self->QCPLayout::elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnElements(const QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_Elements_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_Elements_Callback>(slot));
    }
}

// Base class handler implementation
int QCPLayout_QBaseElementCount(const QCPLayout* self) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_ElementCount_IsBase(true);
        return vqcplayout->elementCount();
    } else {
        return ((VirtualQCPLayout*)self)->elementCount();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnElementCount(const QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_ElementCount_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_ElementCount_Callback>(slot));
    }
}

// Base class handler implementation
QCPLayoutElement* QCPLayout_QBaseElementAt(const QCPLayout* self, int index) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_ElementAt_IsBase(true);
        return vqcplayout->elementAt(static_cast<int>(index));
    } else {
        return ((VirtualQCPLayout*)self)->elementAt(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnElementAt(const QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_ElementAt_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_ElementAt_Callback>(slot));
    }
}

// Base class handler implementation
QCPLayoutElement* QCPLayout_QBaseTakeAt(QCPLayout* self, int index) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_TakeAt_IsBase(true);
        return vqcplayout->takeAt(static_cast<int>(index));
    } else {
        return ((VirtualQCPLayout*)self)->takeAt(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnTakeAt(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_TakeAt_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_TakeAt_Callback>(slot));
    }
}

// Base class handler implementation
bool QCPLayout_QBaseTake(QCPLayout* self, QCPLayoutElement* element) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_Take_IsBase(true);
        return vqcplayout->take(element);
    } else {
        return ((VirtualQCPLayout*)self)->take(element);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnTake(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_Take_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_Take_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLayout_QBaseSimplify(QCPLayout* self) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_Simplify_IsBase(true);
        vqcplayout->simplify();
    } else {
        self->QCPLayout::simplify();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnSimplify(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_Simplify_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_Simplify_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLayout_QBaseUpdateLayout(QCPLayout* self) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_UpdateLayout_IsBase(true);
        vqcplayout->updateLayout();
    } else {
        ((VirtualQCPLayout*)self)->updateLayout();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnUpdateLayout(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_UpdateLayout_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_UpdateLayout_Callback>(slot));
    }
}

// Derived class handler implementation
QSize* QCPLayout_MinimumOuterSizeHint(const QCPLayout* self) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        return new QSize(vqcplayout->minimumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPLayout*)self)->minimumOuterSizeHint());
    }
}

// Base class handler implementation
QSize* QCPLayout_QBaseMinimumOuterSizeHint(const QCPLayout* self) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_MinimumOuterSizeHint_IsBase(true);
        return new QSize(vqcplayout->minimumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPLayout*)self)->minimumOuterSizeHint());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnMinimumOuterSizeHint(const QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_MinimumOuterSizeHint_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_MinimumOuterSizeHint_Callback>(slot));
    }
}

// Derived class handler implementation
QSize* QCPLayout_MaximumOuterSizeHint(const QCPLayout* self) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        return new QSize(vqcplayout->maximumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPLayout*)self)->maximumOuterSizeHint());
    }
}

// Base class handler implementation
QSize* QCPLayout_QBaseMaximumOuterSizeHint(const QCPLayout* self) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_MaximumOuterSizeHint_IsBase(true);
        return new QSize(vqcplayout->maximumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPLayout*)self)->maximumOuterSizeHint());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnMaximumOuterSizeHint(const QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_MaximumOuterSizeHint_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_MaximumOuterSizeHint_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPLayout_SelectTest(const QCPLayout* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        return vqcplayout->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPLayout::selectTest(*pos, onlySelectable, details);
    }
}

// Base class handler implementation
double QCPLayout_QBaseSelectTest(const QCPLayout* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_SelectTest_IsBase(true);
        return vqcplayout->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPLayout::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnSelectTest(const QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_SelectTest_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_SelectTest_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPLayout_CalculateAutoMargin(QCPLayout* self, int side) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        return vqcplayout->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    } else {
        return ((VirtualQCPLayout*)self)->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    }
}

// Base class handler implementation
int QCPLayout_QBaseCalculateAutoMargin(QCPLayout* self, int side) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_CalculateAutoMargin_IsBase(true);
        return vqcplayout->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    } else {
        return ((VirtualQCPLayout*)self)->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnCalculateAutoMargin(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_CalculateAutoMargin_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_CalculateAutoMargin_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayout_LayoutChanged(QCPLayout* self) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->layoutChanged();
    } else {
        ((VirtualQCPLayout*)self)->layoutChanged();
    }
}

// Base class handler implementation
void QCPLayout_QBaseLayoutChanged(QCPLayout* self) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_LayoutChanged_IsBase(true);
        vqcplayout->layoutChanged();
    } else {
        ((VirtualQCPLayout*)self)->layoutChanged();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnLayoutChanged(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_LayoutChanged_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_LayoutChanged_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayout_ApplyDefaultAntialiasingHint(const QCPLayout* self, QCPPainter* painter) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPLayout*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPLayout_QBaseApplyDefaultAntialiasingHint(const QCPLayout* self, QCPPainter* painter) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcplayout->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPLayout*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnApplyDefaultAntialiasingHint(const QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayout_Draw(QCPLayout* self, QCPPainter* painter) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->draw(painter);
    } else {
        ((VirtualQCPLayout*)self)->draw(painter);
    }
}

// Base class handler implementation
void QCPLayout_QBaseDraw(QCPLayout* self, QCPPainter* painter) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_Draw_IsBase(true);
        vqcplayout->draw(painter);
    } else {
        ((VirtualQCPLayout*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnDraw(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_Draw_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_Draw_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayout_ParentPlotInitialized(QCPLayout* self, QCustomPlot* parentPlot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPLayout*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPLayout_QBaseParentPlotInitialized(QCPLayout* self, QCustomPlot* parentPlot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_ParentPlotInitialized_IsBase(true);
        vqcplayout->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPLayout*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnParentPlotInitialized(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPLayout_SelectionCategory(const QCPLayout* self) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        return static_cast<int>(vqcplayout->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPLayout*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPLayout_QBaseSelectionCategory(const QCPLayout* self) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcplayout->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPLayout*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnSelectionCategory(const QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_SelectionCategory_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPLayout_ClipRect(const QCPLayout* self) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        return new QRect(vqcplayout->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPLayout_QBaseClipRect(const QCPLayout* self) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_ClipRect_IsBase(true);
        return new QRect(vqcplayout->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnClipRect(const QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_ClipRect_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayout_SelectEvent(QCPLayout* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPLayout*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPLayout_QBaseSelectEvent(QCPLayout* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_SelectEvent_IsBase(true);
        vqcplayout->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPLayout*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnSelectEvent(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_SelectEvent_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayout_DeselectEvent(QCPLayout* self, bool* selectionStateChanged) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPLayout*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPLayout_QBaseDeselectEvent(QCPLayout* self, bool* selectionStateChanged) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_DeselectEvent_IsBase(true);
        vqcplayout->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPLayout*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnDeselectEvent(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_DeselectEvent_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayout_MousePressEvent(QCPLayout* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPLayout*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPLayout_QBaseMousePressEvent(QCPLayout* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_MousePressEvent_IsBase(true);
        vqcplayout->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPLayout*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnMousePressEvent(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_MousePressEvent_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayout_MouseMoveEvent(QCPLayout* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPLayout*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPLayout_QBaseMouseMoveEvent(QCPLayout* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_MouseMoveEvent_IsBase(true);
        vqcplayout->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPLayout*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnMouseMoveEvent(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayout_MouseReleaseEvent(QCPLayout* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPLayout*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPLayout_QBaseMouseReleaseEvent(QCPLayout* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_MouseReleaseEvent_IsBase(true);
        vqcplayout->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPLayout*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnMouseReleaseEvent(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayout_MouseDoubleClickEvent(QCPLayout* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPLayout*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPLayout_QBaseMouseDoubleClickEvent(QCPLayout* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_MouseDoubleClickEvent_IsBase(true);
        vqcplayout->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPLayout*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnMouseDoubleClickEvent(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayout_WheelEvent(QCPLayout* self, QWheelEvent* event) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->wheelEvent(event);
    } else {
        ((VirtualQCPLayout*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPLayout_QBaseWheelEvent(QCPLayout* self, QWheelEvent* event) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_WheelEvent_IsBase(true);
        vqcplayout->wheelEvent(event);
    } else {
        ((VirtualQCPLayout*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnWheelEvent(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_WheelEvent_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLayout_Event(QCPLayout* self, QEvent* event) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        return vqcplayout->event(event);
    } else {
        return self->QCPLayout::event(event);
    }
}

// Base class handler implementation
bool QCPLayout_QBaseEvent(QCPLayout* self, QEvent* event) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_Event_IsBase(true);
        return vqcplayout->event(event);
    } else {
        return self->QCPLayout::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnEvent(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_Event_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLayout_EventFilter(QCPLayout* self, QObject* watched, QEvent* event) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        return vqcplayout->eventFilter(watched, event);
    } else {
        return self->QCPLayout::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPLayout_QBaseEventFilter(QCPLayout* self, QObject* watched, QEvent* event) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_EventFilter_IsBase(true);
        return vqcplayout->eventFilter(watched, event);
    } else {
        return self->QCPLayout::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnEventFilter(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_EventFilter_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayout_TimerEvent(QCPLayout* self, QTimerEvent* event) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->timerEvent(event);
    } else {
        ((VirtualQCPLayout*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPLayout_QBaseTimerEvent(QCPLayout* self, QTimerEvent* event) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_TimerEvent_IsBase(true);
        vqcplayout->timerEvent(event);
    } else {
        ((VirtualQCPLayout*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnTimerEvent(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_TimerEvent_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayout_ChildEvent(QCPLayout* self, QChildEvent* event) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->childEvent(event);
    } else {
        ((VirtualQCPLayout*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPLayout_QBaseChildEvent(QCPLayout* self, QChildEvent* event) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_ChildEvent_IsBase(true);
        vqcplayout->childEvent(event);
    } else {
        ((VirtualQCPLayout*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnChildEvent(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_ChildEvent_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayout_CustomEvent(QCPLayout* self, QEvent* event) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->customEvent(event);
    } else {
        ((VirtualQCPLayout*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPLayout_QBaseCustomEvent(QCPLayout* self, QEvent* event) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_CustomEvent_IsBase(true);
        vqcplayout->customEvent(event);
    } else {
        ((VirtualQCPLayout*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnCustomEvent(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_CustomEvent_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayout_ConnectNotify(QCPLayout* self, const QMetaMethod* signal) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->connectNotify(*signal);
    } else {
        ((VirtualQCPLayout*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPLayout_QBaseConnectNotify(QCPLayout* self, const QMetaMethod* signal) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_ConnectNotify_IsBase(true);
        vqcplayout->connectNotify(*signal);
    } else {
        ((VirtualQCPLayout*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnConnectNotify(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_ConnectNotify_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayout_DisconnectNotify(QCPLayout* self, const QMetaMethod* signal) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->disconnectNotify(*signal);
    } else {
        ((VirtualQCPLayout*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPLayout_QBaseDisconnectNotify(QCPLayout* self, const QMetaMethod* signal) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_DisconnectNotify_IsBase(true);
        vqcplayout->disconnectNotify(*signal);
    } else {
        ((VirtualQCPLayout*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnDisconnectNotify(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayout_SizeConstraintsChanged(const QCPLayout* self) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->sizeConstraintsChanged();
    } else {
        ((VirtualQCPLayout*)self)->sizeConstraintsChanged();
    }
}

// Base class handler implementation
void QCPLayout_QBaseSizeConstraintsChanged(const QCPLayout* self) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_SizeConstraintsChanged_IsBase(true);
        vqcplayout->sizeConstraintsChanged();
    } else {
        ((VirtualQCPLayout*)self)->sizeConstraintsChanged();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnSizeConstraintsChanged(const QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_SizeConstraintsChanged_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_SizeConstraintsChanged_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayout_AdoptElement(QCPLayout* self, QCPLayoutElement* el) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->adoptElement(el);
    } else {
        ((VirtualQCPLayout*)self)->adoptElement(el);
    }
}

// Base class handler implementation
void QCPLayout_QBaseAdoptElement(QCPLayout* self, QCPLayoutElement* el) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_AdoptElement_IsBase(true);
        vqcplayout->adoptElement(el);
    } else {
        ((VirtualQCPLayout*)self)->adoptElement(el);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnAdoptElement(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_AdoptElement_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_AdoptElement_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayout_ReleaseElement(QCPLayout* self, QCPLayoutElement* el) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->releaseElement(el);
    } else {
        ((VirtualQCPLayout*)self)->releaseElement(el);
    }
}

// Base class handler implementation
void QCPLayout_QBaseReleaseElement(QCPLayout* self, QCPLayoutElement* el) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_ReleaseElement_IsBase(true);
        vqcplayout->releaseElement(el);
    } else {
        ((VirtualQCPLayout*)self)->releaseElement(el);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnReleaseElement(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_ReleaseElement_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_ReleaseElement_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of int */ QCPLayout_GetSectionSizes(const QCPLayout* self, libqt_list /* of int */ maxSizes, libqt_list /* of int */ minSizes, libqt_list /* of double */ stretchFactors, int totalSize) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    QVector<int> maxSizes_QVector;
    maxSizes_QVector.reserve(maxSizes.len);
    int* maxSizes_arr = static_cast<int*>(maxSizes.data);
    for (size_t i = 0; i < maxSizes.len; ++i) {
        maxSizes_QVector.push_back(static_cast<int>(maxSizes_arr[i]));
    }
    QVector<int> minSizes_QVector;
    minSizes_QVector.reserve(minSizes.len);
    int* minSizes_arr = static_cast<int*>(minSizes.data);
    for (size_t i = 0; i < minSizes.len; ++i) {
        minSizes_QVector.push_back(static_cast<int>(minSizes_arr[i]));
    }
    QVector<double> stretchFactors_QVector;
    stretchFactors_QVector.reserve(stretchFactors.len);
    double* stretchFactors_arr = static_cast<double*>(stretchFactors.data);
    for (size_t i = 0; i < stretchFactors.len; ++i) {
        stretchFactors_QVector.push_back(static_cast<double>(stretchFactors_arr[i]));
    }
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        QVector<int> _ret = vqcplayout->getSectionSizes(maxSizes_QVector, minSizes_QVector, stretchFactors_QVector, static_cast<int>(totalSize));
        // Convert QVector<> from C++ memory to manually-managed C memory
        int* _arr = static_cast<int*>(malloc(sizeof(int) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<int> _ret = ((VirtualQCPLayout*)self)->getSectionSizes(maxSizes_QVector, minSizes_QVector, stretchFactors_QVector, static_cast<int>(totalSize));
        // Convert QVector<> from C++ memory to manually-managed C memory
        int* _arr = static_cast<int*>(malloc(sizeof(int) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of int */ QCPLayout_QBaseGetSectionSizes(const QCPLayout* self, libqt_list /* of int */ maxSizes, libqt_list /* of int */ minSizes, libqt_list /* of double */ stretchFactors, int totalSize) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    QVector<int> maxSizes_QVector;
    maxSizes_QVector.reserve(maxSizes.len);
    int* maxSizes_arr = static_cast<int*>(maxSizes.data);
    for (size_t i = 0; i < maxSizes.len; ++i) {
        maxSizes_QVector.push_back(static_cast<int>(maxSizes_arr[i]));
    }
    QVector<int> minSizes_QVector;
    minSizes_QVector.reserve(minSizes.len);
    int* minSizes_arr = static_cast<int*>(minSizes.data);
    for (size_t i = 0; i < minSizes.len; ++i) {
        minSizes_QVector.push_back(static_cast<int>(minSizes_arr[i]));
    }
    QVector<double> stretchFactors_QVector;
    stretchFactors_QVector.reserve(stretchFactors.len);
    double* stretchFactors_arr = static_cast<double*>(stretchFactors.data);
    for (size_t i = 0; i < stretchFactors.len; ++i) {
        stretchFactors_QVector.push_back(static_cast<double>(stretchFactors_arr[i]));
    }
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_GetSectionSizes_IsBase(true);
        QVector<int> _ret = vqcplayout->getSectionSizes(maxSizes_QVector, minSizes_QVector, stretchFactors_QVector, static_cast<int>(totalSize));
        // Convert QVector<> from C++ memory to manually-managed C memory
        int* _arr = static_cast<int*>(malloc(sizeof(int) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<int> _ret = ((VirtualQCPLayout*)self)->getSectionSizes(maxSizes_QVector, minSizes_QVector, stretchFactors_QVector, static_cast<int>(totalSize));
        // Convert QVector<> from C++ memory to manually-managed C memory
        int* _arr = static_cast<int*>(malloc(sizeof(int) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnGetSectionSizes(const QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_GetSectionSizes_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_GetSectionSizes_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayout_InitializeParentPlot(QCPLayout* self, QCustomPlot* parentPlot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPLayout*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPLayout_QBaseInitializeParentPlot(QCPLayout* self, QCustomPlot* parentPlot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_InitializeParentPlot_IsBase(true);
        vqcplayout->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPLayout*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnInitializeParentPlot(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayout_SetParentLayerable(QCPLayout* self, QCPLayerable* parentLayerable) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPLayout*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPLayout_QBaseSetParentLayerable(QCPLayout* self, QCPLayerable* parentLayerable) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_SetParentLayerable_IsBase(true);
        vqcplayout->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPLayout*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnSetParentLayerable(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLayout_MoveToLayer(QCPLayout* self, QCPLayer* layer, bool prepend) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        return vqcplayout->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPLayout*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPLayout_QBaseMoveToLayer(QCPLayout* self, QCPLayer* layer, bool prepend) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_MoveToLayer_IsBase(true);
        return vqcplayout->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPLayout*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnMoveToLayer(QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = dynamic_cast<VirtualQCPLayout*>(self);
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_MoveToLayer_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayout_ApplyAntialiasingHint(const QCPLayout* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPLayout*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPLayout_QBaseApplyAntialiasingHint(const QCPLayout* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_ApplyAntialiasingHint_IsBase(true);
        vqcplayout->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPLayout*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnApplyAntialiasingHint(const QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPLayout_Sender(const QCPLayout* self) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        return vqcplayout->sender();
    } else {
        return ((VirtualQCPLayout*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPLayout_QBaseSender(const QCPLayout* self) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_Sender_IsBase(true);
        return vqcplayout->sender();
    } else {
        return ((VirtualQCPLayout*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnSender(const QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_Sender_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPLayout_SenderSignalIndex(const QCPLayout* self) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        return vqcplayout->senderSignalIndex();
    } else {
        return ((VirtualQCPLayout*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPLayout_QBaseSenderSignalIndex(const QCPLayout* self) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_SenderSignalIndex_IsBase(true);
        return vqcplayout->senderSignalIndex();
    } else {
        return ((VirtualQCPLayout*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnSenderSignalIndex(const QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPLayout_Receivers(const QCPLayout* self, const char* signal) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        return vqcplayout->receivers(signal);
    } else {
        return ((VirtualQCPLayout*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPLayout_QBaseReceivers(const QCPLayout* self, const char* signal) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_Receivers_IsBase(true);
        return vqcplayout->receivers(signal);
    } else {
        return ((VirtualQCPLayout*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnReceivers(const QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_Receivers_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLayout_IsSignalConnected(const QCPLayout* self, const QMetaMethod* signal) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        return vqcplayout->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPLayout*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPLayout_QBaseIsSignalConnected(const QCPLayout* self, const QMetaMethod* signal) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_IsSignalConnected_IsBase(true);
        return vqcplayout->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPLayout*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayout_OnIsSignalConnected(const QCPLayout* self, intptr_t slot) {
    auto* vqcplayout = const_cast<VirtualQCPLayout*>(dynamic_cast<const VirtualQCPLayout*>(self));
    if (vqcplayout && vqcplayout->isVirtualQCPLayout) {
        vqcplayout->setQCPLayout_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPLayout::QCPLayout_IsSignalConnected_Callback>(slot));
    }
}

void QCPLayout_Delete(QCPLayout* self) {
    delete self;
}

QCPLayoutGrid* QCPLayoutGrid_new() {
    return new VirtualQCPLayoutGrid();
}

QMetaObject* QCPLayoutGrid_MetaObject(const QCPLayoutGrid* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPLayoutGrid_Metacast(QCPLayoutGrid* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPLayoutGrid_Metacall(QCPLayoutGrid* self, int param1, int param2, void** param3) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPLayoutGrid*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPLayoutGrid_Tr(const char* s) {
    QString _ret = QCPLayoutGrid::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

int QCPLayoutGrid_RowCount(const QCPLayoutGrid* self) {
    return self->rowCount();
}

int QCPLayoutGrid_ColumnCount(const QCPLayoutGrid* self) {
    return self->columnCount();
}

libqt_list /* of double */ QCPLayoutGrid_ColumnStretchFactors(const QCPLayoutGrid* self) {
    QList<double> _ret = self->columnStretchFactors();
    // Convert QList<> from C++ memory to manually-managed C memory
    double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

libqt_list /* of double */ QCPLayoutGrid_RowStretchFactors(const QCPLayoutGrid* self) {
    QList<double> _ret = self->rowStretchFactors();
    // Convert QList<> from C++ memory to manually-managed C memory
    double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

int QCPLayoutGrid_ColumnSpacing(const QCPLayoutGrid* self) {
    return self->columnSpacing();
}

int QCPLayoutGrid_RowSpacing(const QCPLayoutGrid* self) {
    return self->rowSpacing();
}

int QCPLayoutGrid_Wrap(const QCPLayoutGrid* self) {
    return self->wrap();
}

int QCPLayoutGrid_FillOrder(const QCPLayoutGrid* self) {
    return static_cast<int>(self->fillOrder());
}

void QCPLayoutGrid_SetColumnStretchFactor(QCPLayoutGrid* self, int column, double factor) {
    self->setColumnStretchFactor(static_cast<int>(column), static_cast<double>(factor));
}

void QCPLayoutGrid_SetColumnStretchFactors(QCPLayoutGrid* self, const libqt_list /* of double */ factors) {
    QList<double> factors_QList;
    factors_QList.reserve(factors.len);
    double* factors_arr = static_cast<double*>(factors.data);
    for (size_t i = 0; i < factors.len; ++i) {
        factors_QList.push_back(static_cast<double>(factors_arr[i]));
    }
    self->setColumnStretchFactors(factors_QList);
}

void QCPLayoutGrid_SetRowStretchFactor(QCPLayoutGrid* self, int row, double factor) {
    self->setRowStretchFactor(static_cast<int>(row), static_cast<double>(factor));
}

void QCPLayoutGrid_SetRowStretchFactors(QCPLayoutGrid* self, const libqt_list /* of double */ factors) {
    QList<double> factors_QList;
    factors_QList.reserve(factors.len);
    double* factors_arr = static_cast<double*>(factors.data);
    for (size_t i = 0; i < factors.len; ++i) {
        factors_QList.push_back(static_cast<double>(factors_arr[i]));
    }
    self->setRowStretchFactors(factors_QList);
}

void QCPLayoutGrid_SetColumnSpacing(QCPLayoutGrid* self, int pixels) {
    self->setColumnSpacing(static_cast<int>(pixels));
}

void QCPLayoutGrid_SetRowSpacing(QCPLayoutGrid* self, int pixels) {
    self->setRowSpacing(static_cast<int>(pixels));
}

void QCPLayoutGrid_SetWrap(QCPLayoutGrid* self, int count) {
    self->setWrap(static_cast<int>(count));
}

void QCPLayoutGrid_SetFillOrder(QCPLayoutGrid* self, int order) {
    self->setFillOrder(static_cast<QCPLayoutGrid::FillOrder>(order));
}

void QCPLayoutGrid_UpdateLayout(QCPLayoutGrid* self) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        self->updateLayout();
    } else {
        ((VirtualQCPLayoutGrid*)self)->updateLayout();
    }
}

int QCPLayoutGrid_ElementCount(const QCPLayoutGrid* self) {
    auto* vqcplayoutgrid = dynamic_cast<const VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        return self->elementCount();
    } else {
        return ((VirtualQCPLayoutGrid*)self)->elementCount();
    }
}

QCPLayoutElement* QCPLayoutGrid_ElementAt(const QCPLayoutGrid* self, int index) {
    auto* vqcplayoutgrid = dynamic_cast<const VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        return self->elementAt(static_cast<int>(index));
    } else {
        return ((VirtualQCPLayoutGrid*)self)->elementAt(static_cast<int>(index));
    }
}

QCPLayoutElement* QCPLayoutGrid_TakeAt(QCPLayoutGrid* self, int index) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        return self->takeAt(static_cast<int>(index));
    } else {
        return ((VirtualQCPLayoutGrid*)self)->takeAt(static_cast<int>(index));
    }
}

bool QCPLayoutGrid_Take(QCPLayoutGrid* self, QCPLayoutElement* element) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        return self->take(element);
    } else {
        return ((VirtualQCPLayoutGrid*)self)->take(element);
    }
}

libqt_list /* of QCPLayoutElement* */ QCPLayoutGrid_Elements(const QCPLayoutGrid* self, bool recursive) {
    auto* vqcplayoutgrid = dynamic_cast<const VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        QList<QCPLayoutElement*> _ret = self->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayoutElement*> _ret = ((VirtualQCPLayoutGrid*)self)->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

void QCPLayoutGrid_Simplify(QCPLayoutGrid* self) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        self->simplify();
    } else {
        ((VirtualQCPLayoutGrid*)self)->simplify();
    }
}

QSize* QCPLayoutGrid_MinimumOuterSizeHint(const QCPLayoutGrid* self) {
    auto* vqcplayoutgrid = dynamic_cast<const VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        return new QSize(self->minimumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPLayoutGrid*)self)->minimumOuterSizeHint());
    }
}

QSize* QCPLayoutGrid_MaximumOuterSizeHint(const QCPLayoutGrid* self) {
    auto* vqcplayoutgrid = dynamic_cast<const VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        return new QSize(self->maximumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPLayoutGrid*)self)->maximumOuterSizeHint());
    }
}

QCPLayoutElement* QCPLayoutGrid_Element(const QCPLayoutGrid* self, int row, int column) {
    return self->element(static_cast<int>(row), static_cast<int>(column));
}

bool QCPLayoutGrid_AddElement(QCPLayoutGrid* self, int row, int column, QCPLayoutElement* element) {
    return self->addElement(static_cast<int>(row), static_cast<int>(column), element);
}

bool QCPLayoutGrid_AddElement2(QCPLayoutGrid* self, QCPLayoutElement* element) {
    return self->addElement(element);
}

bool QCPLayoutGrid_HasElement(QCPLayoutGrid* self, int row, int column) {
    return self->hasElement(static_cast<int>(row), static_cast<int>(column));
}

void QCPLayoutGrid_ExpandTo(QCPLayoutGrid* self, int newRowCount, int newColumnCount) {
    self->expandTo(static_cast<int>(newRowCount), static_cast<int>(newColumnCount));
}

void QCPLayoutGrid_InsertRow(QCPLayoutGrid* self, int newIndex) {
    self->insertRow(static_cast<int>(newIndex));
}

void QCPLayoutGrid_InsertColumn(QCPLayoutGrid* self, int newIndex) {
    self->insertColumn(static_cast<int>(newIndex));
}

int QCPLayoutGrid_RowColToIndex(const QCPLayoutGrid* self, int row, int column) {
    return self->rowColToIndex(static_cast<int>(row), static_cast<int>(column));
}

void QCPLayoutGrid_IndexToRowCol(const QCPLayoutGrid* self, int index, int* row, int* column) {
    self->indexToRowCol(static_cast<int>(index), static_cast<int&>(*row), static_cast<int&>(*column));
}

libqt_string QCPLayoutGrid_Tr2(const char* s, const char* c) {
    QString _ret = QCPLayoutGrid::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPLayoutGrid_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPLayoutGrid::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

void QCPLayoutGrid_SetFillOrder2(QCPLayoutGrid* self, int order, bool rearrange) {
    self->setFillOrder(static_cast<QCPLayoutGrid::FillOrder>(order), rearrange);
}

// Base class handler implementation
int QCPLayoutGrid_QBaseMetacall(QCPLayoutGrid* self, int param1, int param2, void** param3) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_Metacall_IsBase(true);
        return vqcplayoutgrid->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPLayoutGrid::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnMetacall(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_Metacall_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseUpdateLayout(QCPLayoutGrid* self) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_UpdateLayout_IsBase(true);
        vqcplayoutgrid->updateLayout();
    } else {
        self->QCPLayoutGrid::updateLayout();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnUpdateLayout(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_UpdateLayout_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_UpdateLayout_Callback>(slot));
    }
}

// Base class handler implementation
int QCPLayoutGrid_QBaseElementCount(const QCPLayoutGrid* self) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_ElementCount_IsBase(true);
        return vqcplayoutgrid->elementCount();
    } else {
        return self->QCPLayoutGrid::elementCount();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnElementCount(const QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_ElementCount_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_ElementCount_Callback>(slot));
    }
}

// Base class handler implementation
QCPLayoutElement* QCPLayoutGrid_QBaseElementAt(const QCPLayoutGrid* self, int index) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_ElementAt_IsBase(true);
        return vqcplayoutgrid->elementAt(static_cast<int>(index));
    } else {
        return self->QCPLayoutGrid::elementAt(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnElementAt(const QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_ElementAt_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_ElementAt_Callback>(slot));
    }
}

// Base class handler implementation
QCPLayoutElement* QCPLayoutGrid_QBaseTakeAt(QCPLayoutGrid* self, int index) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_TakeAt_IsBase(true);
        return vqcplayoutgrid->takeAt(static_cast<int>(index));
    } else {
        return self->QCPLayoutGrid::takeAt(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnTakeAt(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_TakeAt_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_TakeAt_Callback>(slot));
    }
}

// Base class handler implementation
bool QCPLayoutGrid_QBaseTake(QCPLayoutGrid* self, QCPLayoutElement* element) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_Take_IsBase(true);
        return vqcplayoutgrid->take(element);
    } else {
        return self->QCPLayoutGrid::take(element);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnTake(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_Take_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_Take_Callback>(slot));
    }
}

// Base class handler implementation
libqt_list /* of QCPLayoutElement* */ QCPLayoutGrid_QBaseElements(const QCPLayoutGrid* self, bool recursive) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_Elements_IsBase(true);
        QList<QCPLayoutElement*> _ret = vqcplayoutgrid->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayoutElement*> _ret = self->QCPLayoutGrid::elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnElements(const QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_Elements_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_Elements_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseSimplify(QCPLayoutGrid* self) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_Simplify_IsBase(true);
        vqcplayoutgrid->simplify();
    } else {
        self->QCPLayoutGrid::simplify();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnSimplify(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_Simplify_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_Simplify_Callback>(slot));
    }
}

// Base class handler implementation
QSize* QCPLayoutGrid_QBaseMinimumOuterSizeHint(const QCPLayoutGrid* self) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_MinimumOuterSizeHint_IsBase(true);
        return new QSize(vqcplayoutgrid->minimumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPLayoutGrid*)self)->minimumOuterSizeHint());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnMinimumOuterSizeHint(const QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_MinimumOuterSizeHint_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_MinimumOuterSizeHint_Callback>(slot));
    }
}

// Base class handler implementation
QSize* QCPLayoutGrid_QBaseMaximumOuterSizeHint(const QCPLayoutGrid* self) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_MaximumOuterSizeHint_IsBase(true);
        return new QSize(vqcplayoutgrid->maximumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPLayoutGrid*)self)->maximumOuterSizeHint());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnMaximumOuterSizeHint(const QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_MaximumOuterSizeHint_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_MaximumOuterSizeHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutGrid_Update(QCPLayoutGrid* self, int phase) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    } else {
        self->QCPLayoutGrid::update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseUpdate(QCPLayoutGrid* self, int phase) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_Update_IsBase(true);
        vqcplayoutgrid->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    } else {
        self->QCPLayoutGrid::update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnUpdate(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_Update_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_Update_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPLayoutGrid_SelectTest(const QCPLayoutGrid* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        return vqcplayoutgrid->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPLayoutGrid::selectTest(*pos, onlySelectable, details);
    }
}

// Base class handler implementation
double QCPLayoutGrid_QBaseSelectTest(const QCPLayoutGrid* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_SelectTest_IsBase(true);
        return vqcplayoutgrid->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPLayoutGrid::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnSelectTest(const QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_SelectTest_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_SelectTest_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPLayoutGrid_CalculateAutoMargin(QCPLayoutGrid* self, int side) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        return vqcplayoutgrid->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    } else {
        return ((VirtualQCPLayoutGrid*)self)->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    }
}

// Base class handler implementation
int QCPLayoutGrid_QBaseCalculateAutoMargin(QCPLayoutGrid* self, int side) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_CalculateAutoMargin_IsBase(true);
        return vqcplayoutgrid->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    } else {
        return ((VirtualQCPLayoutGrid*)self)->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnCalculateAutoMargin(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_CalculateAutoMargin_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_CalculateAutoMargin_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutGrid_LayoutChanged(QCPLayoutGrid* self) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->layoutChanged();
    } else {
        ((VirtualQCPLayoutGrid*)self)->layoutChanged();
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseLayoutChanged(QCPLayoutGrid* self) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_LayoutChanged_IsBase(true);
        vqcplayoutgrid->layoutChanged();
    } else {
        ((VirtualQCPLayoutGrid*)self)->layoutChanged();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnLayoutChanged(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_LayoutChanged_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_LayoutChanged_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutGrid_ApplyDefaultAntialiasingHint(const QCPLayoutGrid* self, QCPPainter* painter) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPLayoutGrid*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseApplyDefaultAntialiasingHint(const QCPLayoutGrid* self, QCPPainter* painter) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcplayoutgrid->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPLayoutGrid*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnApplyDefaultAntialiasingHint(const QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutGrid_Draw(QCPLayoutGrid* self, QCPPainter* painter) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->draw(painter);
    } else {
        ((VirtualQCPLayoutGrid*)self)->draw(painter);
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseDraw(QCPLayoutGrid* self, QCPPainter* painter) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_Draw_IsBase(true);
        vqcplayoutgrid->draw(painter);
    } else {
        ((VirtualQCPLayoutGrid*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnDraw(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_Draw_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_Draw_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutGrid_ParentPlotInitialized(QCPLayoutGrid* self, QCustomPlot* parentPlot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPLayoutGrid*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseParentPlotInitialized(QCPLayoutGrid* self, QCustomPlot* parentPlot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_ParentPlotInitialized_IsBase(true);
        vqcplayoutgrid->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPLayoutGrid*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnParentPlotInitialized(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPLayoutGrid_SelectionCategory(const QCPLayoutGrid* self) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        return static_cast<int>(vqcplayoutgrid->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPLayoutGrid*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPLayoutGrid_QBaseSelectionCategory(const QCPLayoutGrid* self) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcplayoutgrid->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPLayoutGrid*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnSelectionCategory(const QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_SelectionCategory_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPLayoutGrid_ClipRect(const QCPLayoutGrid* self) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        return new QRect(vqcplayoutgrid->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPLayoutGrid_QBaseClipRect(const QCPLayoutGrid* self) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_ClipRect_IsBase(true);
        return new QRect(vqcplayoutgrid->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnClipRect(const QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_ClipRect_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutGrid_SelectEvent(QCPLayoutGrid* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPLayoutGrid*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseSelectEvent(QCPLayoutGrid* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_SelectEvent_IsBase(true);
        vqcplayoutgrid->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPLayoutGrid*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnSelectEvent(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_SelectEvent_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutGrid_DeselectEvent(QCPLayoutGrid* self, bool* selectionStateChanged) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPLayoutGrid*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseDeselectEvent(QCPLayoutGrid* self, bool* selectionStateChanged) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_DeselectEvent_IsBase(true);
        vqcplayoutgrid->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPLayoutGrid*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnDeselectEvent(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_DeselectEvent_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutGrid_MousePressEvent(QCPLayoutGrid* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPLayoutGrid*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseMousePressEvent(QCPLayoutGrid* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_MousePressEvent_IsBase(true);
        vqcplayoutgrid->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPLayoutGrid*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnMousePressEvent(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_MousePressEvent_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutGrid_MouseMoveEvent(QCPLayoutGrid* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPLayoutGrid*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseMouseMoveEvent(QCPLayoutGrid* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_MouseMoveEvent_IsBase(true);
        vqcplayoutgrid->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPLayoutGrid*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnMouseMoveEvent(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutGrid_MouseReleaseEvent(QCPLayoutGrid* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPLayoutGrid*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseMouseReleaseEvent(QCPLayoutGrid* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_MouseReleaseEvent_IsBase(true);
        vqcplayoutgrid->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPLayoutGrid*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnMouseReleaseEvent(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutGrid_MouseDoubleClickEvent(QCPLayoutGrid* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPLayoutGrid*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseMouseDoubleClickEvent(QCPLayoutGrid* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_MouseDoubleClickEvent_IsBase(true);
        vqcplayoutgrid->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPLayoutGrid*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnMouseDoubleClickEvent(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutGrid_WheelEvent(QCPLayoutGrid* self, QWheelEvent* event) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->wheelEvent(event);
    } else {
        ((VirtualQCPLayoutGrid*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseWheelEvent(QCPLayoutGrid* self, QWheelEvent* event) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_WheelEvent_IsBase(true);
        vqcplayoutgrid->wheelEvent(event);
    } else {
        ((VirtualQCPLayoutGrid*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnWheelEvent(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_WheelEvent_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLayoutGrid_Event(QCPLayoutGrid* self, QEvent* event) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        return vqcplayoutgrid->event(event);
    } else {
        return self->QCPLayoutGrid::event(event);
    }
}

// Base class handler implementation
bool QCPLayoutGrid_QBaseEvent(QCPLayoutGrid* self, QEvent* event) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_Event_IsBase(true);
        return vqcplayoutgrid->event(event);
    } else {
        return self->QCPLayoutGrid::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnEvent(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_Event_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLayoutGrid_EventFilter(QCPLayoutGrid* self, QObject* watched, QEvent* event) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        return vqcplayoutgrid->eventFilter(watched, event);
    } else {
        return self->QCPLayoutGrid::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPLayoutGrid_QBaseEventFilter(QCPLayoutGrid* self, QObject* watched, QEvent* event) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_EventFilter_IsBase(true);
        return vqcplayoutgrid->eventFilter(watched, event);
    } else {
        return self->QCPLayoutGrid::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnEventFilter(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_EventFilter_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutGrid_TimerEvent(QCPLayoutGrid* self, QTimerEvent* event) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->timerEvent(event);
    } else {
        ((VirtualQCPLayoutGrid*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseTimerEvent(QCPLayoutGrid* self, QTimerEvent* event) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_TimerEvent_IsBase(true);
        vqcplayoutgrid->timerEvent(event);
    } else {
        ((VirtualQCPLayoutGrid*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnTimerEvent(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_TimerEvent_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutGrid_ChildEvent(QCPLayoutGrid* self, QChildEvent* event) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->childEvent(event);
    } else {
        ((VirtualQCPLayoutGrid*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseChildEvent(QCPLayoutGrid* self, QChildEvent* event) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_ChildEvent_IsBase(true);
        vqcplayoutgrid->childEvent(event);
    } else {
        ((VirtualQCPLayoutGrid*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnChildEvent(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_ChildEvent_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutGrid_CustomEvent(QCPLayoutGrid* self, QEvent* event) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->customEvent(event);
    } else {
        ((VirtualQCPLayoutGrid*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseCustomEvent(QCPLayoutGrid* self, QEvent* event) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_CustomEvent_IsBase(true);
        vqcplayoutgrid->customEvent(event);
    } else {
        ((VirtualQCPLayoutGrid*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnCustomEvent(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_CustomEvent_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutGrid_ConnectNotify(QCPLayoutGrid* self, const QMetaMethod* signal) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->connectNotify(*signal);
    } else {
        ((VirtualQCPLayoutGrid*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseConnectNotify(QCPLayoutGrid* self, const QMetaMethod* signal) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_ConnectNotify_IsBase(true);
        vqcplayoutgrid->connectNotify(*signal);
    } else {
        ((VirtualQCPLayoutGrid*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnConnectNotify(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_ConnectNotify_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutGrid_DisconnectNotify(QCPLayoutGrid* self, const QMetaMethod* signal) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->disconnectNotify(*signal);
    } else {
        ((VirtualQCPLayoutGrid*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseDisconnectNotify(QCPLayoutGrid* self, const QMetaMethod* signal) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_DisconnectNotify_IsBase(true);
        vqcplayoutgrid->disconnectNotify(*signal);
    } else {
        ((VirtualQCPLayoutGrid*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnDisconnectNotify(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutGrid_GetMinimumRowColSizes(const QCPLayoutGrid* self, libqt_list /* of int */ minColWidths, libqt_list /* of int */ minRowHeights) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    QVector<int> minColWidths_QVector;
    minColWidths_QVector.reserve(minColWidths.len);
    int* minColWidths_arr = static_cast<int*>(minColWidths.data);
    for (size_t i = 0; i < minColWidths.len; ++i) {
        minColWidths_QVector.push_back(static_cast<int>(minColWidths_arr[i]));
    }
    QVector<int> minRowHeights_QVector;
    minRowHeights_QVector.reserve(minRowHeights.len);
    int* minRowHeights_arr = static_cast<int*>(minRowHeights.data);
    for (size_t i = 0; i < minRowHeights.len; ++i) {
        minRowHeights_QVector.push_back(static_cast<int>(minRowHeights_arr[i]));
    }
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->getMinimumRowColSizes(&minColWidths_QVector, &minRowHeights_QVector);
    } else {
        ((VirtualQCPLayoutGrid*)self)->getMinimumRowColSizes(&minColWidths_QVector, &minRowHeights_QVector);
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseGetMinimumRowColSizes(const QCPLayoutGrid* self, libqt_list /* of int */ minColWidths, libqt_list /* of int */ minRowHeights) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    QVector<int> minColWidths_QVector;
    minColWidths_QVector.reserve(minColWidths.len);
    int* minColWidths_arr = static_cast<int*>(minColWidths.data);
    for (size_t i = 0; i < minColWidths.len; ++i) {
        minColWidths_QVector.push_back(static_cast<int>(minColWidths_arr[i]));
    }
    QVector<int> minRowHeights_QVector;
    minRowHeights_QVector.reserve(minRowHeights.len);
    int* minRowHeights_arr = static_cast<int*>(minRowHeights.data);
    for (size_t i = 0; i < minRowHeights.len; ++i) {
        minRowHeights_QVector.push_back(static_cast<int>(minRowHeights_arr[i]));
    }
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_GetMinimumRowColSizes_IsBase(true);
        vqcplayoutgrid->getMinimumRowColSizes(&minColWidths_QVector, &minRowHeights_QVector);
    } else {
        ((VirtualQCPLayoutGrid*)self)->getMinimumRowColSizes(&minColWidths_QVector, &minRowHeights_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnGetMinimumRowColSizes(const QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_GetMinimumRowColSizes_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_GetMinimumRowColSizes_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutGrid_GetMaximumRowColSizes(const QCPLayoutGrid* self, libqt_list /* of int */ maxColWidths, libqt_list /* of int */ maxRowHeights) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    QVector<int> maxColWidths_QVector;
    maxColWidths_QVector.reserve(maxColWidths.len);
    int* maxColWidths_arr = static_cast<int*>(maxColWidths.data);
    for (size_t i = 0; i < maxColWidths.len; ++i) {
        maxColWidths_QVector.push_back(static_cast<int>(maxColWidths_arr[i]));
    }
    QVector<int> maxRowHeights_QVector;
    maxRowHeights_QVector.reserve(maxRowHeights.len);
    int* maxRowHeights_arr = static_cast<int*>(maxRowHeights.data);
    for (size_t i = 0; i < maxRowHeights.len; ++i) {
        maxRowHeights_QVector.push_back(static_cast<int>(maxRowHeights_arr[i]));
    }
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->getMaximumRowColSizes(&maxColWidths_QVector, &maxRowHeights_QVector);
    } else {
        ((VirtualQCPLayoutGrid*)self)->getMaximumRowColSizes(&maxColWidths_QVector, &maxRowHeights_QVector);
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseGetMaximumRowColSizes(const QCPLayoutGrid* self, libqt_list /* of int */ maxColWidths, libqt_list /* of int */ maxRowHeights) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    QVector<int> maxColWidths_QVector;
    maxColWidths_QVector.reserve(maxColWidths.len);
    int* maxColWidths_arr = static_cast<int*>(maxColWidths.data);
    for (size_t i = 0; i < maxColWidths.len; ++i) {
        maxColWidths_QVector.push_back(static_cast<int>(maxColWidths_arr[i]));
    }
    QVector<int> maxRowHeights_QVector;
    maxRowHeights_QVector.reserve(maxRowHeights.len);
    int* maxRowHeights_arr = static_cast<int*>(maxRowHeights.data);
    for (size_t i = 0; i < maxRowHeights.len; ++i) {
        maxRowHeights_QVector.push_back(static_cast<int>(maxRowHeights_arr[i]));
    }
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_GetMaximumRowColSizes_IsBase(true);
        vqcplayoutgrid->getMaximumRowColSizes(&maxColWidths_QVector, &maxRowHeights_QVector);
    } else {
        ((VirtualQCPLayoutGrid*)self)->getMaximumRowColSizes(&maxColWidths_QVector, &maxRowHeights_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnGetMaximumRowColSizes(const QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_GetMaximumRowColSizes_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_GetMaximumRowColSizes_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutGrid_SizeConstraintsChanged(const QCPLayoutGrid* self) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->sizeConstraintsChanged();
    } else {
        ((VirtualQCPLayoutGrid*)self)->sizeConstraintsChanged();
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseSizeConstraintsChanged(const QCPLayoutGrid* self) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_SizeConstraintsChanged_IsBase(true);
        vqcplayoutgrid->sizeConstraintsChanged();
    } else {
        ((VirtualQCPLayoutGrid*)self)->sizeConstraintsChanged();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnSizeConstraintsChanged(const QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_SizeConstraintsChanged_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_SizeConstraintsChanged_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutGrid_AdoptElement(QCPLayoutGrid* self, QCPLayoutElement* el) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->adoptElement(el);
    } else {
        ((VirtualQCPLayoutGrid*)self)->adoptElement(el);
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseAdoptElement(QCPLayoutGrid* self, QCPLayoutElement* el) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_AdoptElement_IsBase(true);
        vqcplayoutgrid->adoptElement(el);
    } else {
        ((VirtualQCPLayoutGrid*)self)->adoptElement(el);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnAdoptElement(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_AdoptElement_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_AdoptElement_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutGrid_ReleaseElement(QCPLayoutGrid* self, QCPLayoutElement* el) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->releaseElement(el);
    } else {
        ((VirtualQCPLayoutGrid*)self)->releaseElement(el);
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseReleaseElement(QCPLayoutGrid* self, QCPLayoutElement* el) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_ReleaseElement_IsBase(true);
        vqcplayoutgrid->releaseElement(el);
    } else {
        ((VirtualQCPLayoutGrid*)self)->releaseElement(el);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnReleaseElement(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_ReleaseElement_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_ReleaseElement_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of int */ QCPLayoutGrid_GetSectionSizes(const QCPLayoutGrid* self, libqt_list /* of int */ maxSizes, libqt_list /* of int */ minSizes, libqt_list /* of double */ stretchFactors, int totalSize) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    QVector<int> maxSizes_QVector;
    maxSizes_QVector.reserve(maxSizes.len);
    int* maxSizes_arr = static_cast<int*>(maxSizes.data);
    for (size_t i = 0; i < maxSizes.len; ++i) {
        maxSizes_QVector.push_back(static_cast<int>(maxSizes_arr[i]));
    }
    QVector<int> minSizes_QVector;
    minSizes_QVector.reserve(minSizes.len);
    int* minSizes_arr = static_cast<int*>(minSizes.data);
    for (size_t i = 0; i < minSizes.len; ++i) {
        minSizes_QVector.push_back(static_cast<int>(minSizes_arr[i]));
    }
    QVector<double> stretchFactors_QVector;
    stretchFactors_QVector.reserve(stretchFactors.len);
    double* stretchFactors_arr = static_cast<double*>(stretchFactors.data);
    for (size_t i = 0; i < stretchFactors.len; ++i) {
        stretchFactors_QVector.push_back(static_cast<double>(stretchFactors_arr[i]));
    }
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        QVector<int> _ret = vqcplayoutgrid->getSectionSizes(maxSizes_QVector, minSizes_QVector, stretchFactors_QVector, static_cast<int>(totalSize));
        // Convert QVector<> from C++ memory to manually-managed C memory
        int* _arr = static_cast<int*>(malloc(sizeof(int) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<int> _ret = ((VirtualQCPLayoutGrid*)self)->getSectionSizes(maxSizes_QVector, minSizes_QVector, stretchFactors_QVector, static_cast<int>(totalSize));
        // Convert QVector<> from C++ memory to manually-managed C memory
        int* _arr = static_cast<int*>(malloc(sizeof(int) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of int */ QCPLayoutGrid_QBaseGetSectionSizes(const QCPLayoutGrid* self, libqt_list /* of int */ maxSizes, libqt_list /* of int */ minSizes, libqt_list /* of double */ stretchFactors, int totalSize) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    QVector<int> maxSizes_QVector;
    maxSizes_QVector.reserve(maxSizes.len);
    int* maxSizes_arr = static_cast<int*>(maxSizes.data);
    for (size_t i = 0; i < maxSizes.len; ++i) {
        maxSizes_QVector.push_back(static_cast<int>(maxSizes_arr[i]));
    }
    QVector<int> minSizes_QVector;
    minSizes_QVector.reserve(minSizes.len);
    int* minSizes_arr = static_cast<int*>(minSizes.data);
    for (size_t i = 0; i < minSizes.len; ++i) {
        minSizes_QVector.push_back(static_cast<int>(minSizes_arr[i]));
    }
    QVector<double> stretchFactors_QVector;
    stretchFactors_QVector.reserve(stretchFactors.len);
    double* stretchFactors_arr = static_cast<double*>(stretchFactors.data);
    for (size_t i = 0; i < stretchFactors.len; ++i) {
        stretchFactors_QVector.push_back(static_cast<double>(stretchFactors_arr[i]));
    }
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_GetSectionSizes_IsBase(true);
        QVector<int> _ret = vqcplayoutgrid->getSectionSizes(maxSizes_QVector, minSizes_QVector, stretchFactors_QVector, static_cast<int>(totalSize));
        // Convert QVector<> from C++ memory to manually-managed C memory
        int* _arr = static_cast<int*>(malloc(sizeof(int) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<int> _ret = ((VirtualQCPLayoutGrid*)self)->getSectionSizes(maxSizes_QVector, minSizes_QVector, stretchFactors_QVector, static_cast<int>(totalSize));
        // Convert QVector<> from C++ memory to manually-managed C memory
        int* _arr = static_cast<int*>(malloc(sizeof(int) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnGetSectionSizes(const QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_GetSectionSizes_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_GetSectionSizes_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutGrid_InitializeParentPlot(QCPLayoutGrid* self, QCustomPlot* parentPlot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPLayoutGrid*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseInitializeParentPlot(QCPLayoutGrid* self, QCustomPlot* parentPlot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_InitializeParentPlot_IsBase(true);
        vqcplayoutgrid->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPLayoutGrid*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnInitializeParentPlot(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutGrid_SetParentLayerable(QCPLayoutGrid* self, QCPLayerable* parentLayerable) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPLayoutGrid*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseSetParentLayerable(QCPLayoutGrid* self, QCPLayerable* parentLayerable) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_SetParentLayerable_IsBase(true);
        vqcplayoutgrid->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPLayoutGrid*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnSetParentLayerable(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLayoutGrid_MoveToLayer(QCPLayoutGrid* self, QCPLayer* layer, bool prepend) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        return vqcplayoutgrid->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPLayoutGrid*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPLayoutGrid_QBaseMoveToLayer(QCPLayoutGrid* self, QCPLayer* layer, bool prepend) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_MoveToLayer_IsBase(true);
        return vqcplayoutgrid->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPLayoutGrid*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnMoveToLayer(QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = dynamic_cast<VirtualQCPLayoutGrid*>(self);
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_MoveToLayer_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutGrid_ApplyAntialiasingHint(const QCPLayoutGrid* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPLayoutGrid*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPLayoutGrid_QBaseApplyAntialiasingHint(const QCPLayoutGrid* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_ApplyAntialiasingHint_IsBase(true);
        vqcplayoutgrid->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPLayoutGrid*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnApplyAntialiasingHint(const QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPLayoutGrid_Sender(const QCPLayoutGrid* self) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        return vqcplayoutgrid->sender();
    } else {
        return ((VirtualQCPLayoutGrid*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPLayoutGrid_QBaseSender(const QCPLayoutGrid* self) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_Sender_IsBase(true);
        return vqcplayoutgrid->sender();
    } else {
        return ((VirtualQCPLayoutGrid*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnSender(const QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_Sender_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPLayoutGrid_SenderSignalIndex(const QCPLayoutGrid* self) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        return vqcplayoutgrid->senderSignalIndex();
    } else {
        return ((VirtualQCPLayoutGrid*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPLayoutGrid_QBaseSenderSignalIndex(const QCPLayoutGrid* self) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_SenderSignalIndex_IsBase(true);
        return vqcplayoutgrid->senderSignalIndex();
    } else {
        return ((VirtualQCPLayoutGrid*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnSenderSignalIndex(const QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPLayoutGrid_Receivers(const QCPLayoutGrid* self, const char* signal) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        return vqcplayoutgrid->receivers(signal);
    } else {
        return ((VirtualQCPLayoutGrid*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPLayoutGrid_QBaseReceivers(const QCPLayoutGrid* self, const char* signal) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_Receivers_IsBase(true);
        return vqcplayoutgrid->receivers(signal);
    } else {
        return ((VirtualQCPLayoutGrid*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnReceivers(const QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_Receivers_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLayoutGrid_IsSignalConnected(const QCPLayoutGrid* self, const QMetaMethod* signal) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        return vqcplayoutgrid->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPLayoutGrid*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPLayoutGrid_QBaseIsSignalConnected(const QCPLayoutGrid* self, const QMetaMethod* signal) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_IsSignalConnected_IsBase(true);
        return vqcplayoutgrid->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPLayoutGrid*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutGrid_OnIsSignalConnected(const QCPLayoutGrid* self, intptr_t slot) {
    auto* vqcplayoutgrid = const_cast<VirtualQCPLayoutGrid*>(dynamic_cast<const VirtualQCPLayoutGrid*>(self));
    if (vqcplayoutgrid && vqcplayoutgrid->isVirtualQCPLayoutGrid) {
        vqcplayoutgrid->setQCPLayoutGrid_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPLayoutGrid::QCPLayoutGrid_IsSignalConnected_Callback>(slot));
    }
}

void QCPLayoutGrid_Delete(QCPLayoutGrid* self) {
    delete self;
}

QCPLayoutInset* QCPLayoutInset_new() {
    return new VirtualQCPLayoutInset();
}

QMetaObject* QCPLayoutInset_MetaObject(const QCPLayoutInset* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPLayoutInset_Metacast(QCPLayoutInset* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPLayoutInset_Metacall(QCPLayoutInset* self, int param1, int param2, void** param3) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPLayoutInset*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPLayoutInset_Tr(const char* s) {
    QString _ret = QCPLayoutInset::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

int QCPLayoutInset_InsetPlacement(const QCPLayoutInset* self, int index) {
    return static_cast<int>(self->insetPlacement(static_cast<int>(index)));
}

int QCPLayoutInset_InsetAlignment(const QCPLayoutInset* self, int index) {
    return static_cast<int>(self->insetAlignment(static_cast<int>(index)));
}

QRectF* QCPLayoutInset_InsetRect(const QCPLayoutInset* self, int index) {
    return new QRectF(self->insetRect(static_cast<int>(index)));
}

void QCPLayoutInset_SetInsetPlacement(QCPLayoutInset* self, int index, int placement) {
    self->setInsetPlacement(static_cast<int>(index), static_cast<QCPLayoutInset::InsetPlacement>(placement));
}

void QCPLayoutInset_SetInsetAlignment(QCPLayoutInset* self, int index, int alignment) {
    self->setInsetAlignment(static_cast<int>(index), static_cast<Qt::Alignment>(alignment));
}

void QCPLayoutInset_SetInsetRect(QCPLayoutInset* self, int index, const QRectF* rect) {
    self->setInsetRect(static_cast<int>(index), *rect);
}

void QCPLayoutInset_UpdateLayout(QCPLayoutInset* self) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        self->updateLayout();
    } else {
        ((VirtualQCPLayoutInset*)self)->updateLayout();
    }
}

int QCPLayoutInset_ElementCount(const QCPLayoutInset* self) {
    auto* vqcplayoutinset = dynamic_cast<const VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        return self->elementCount();
    } else {
        return ((VirtualQCPLayoutInset*)self)->elementCount();
    }
}

QCPLayoutElement* QCPLayoutInset_ElementAt(const QCPLayoutInset* self, int index) {
    auto* vqcplayoutinset = dynamic_cast<const VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        return self->elementAt(static_cast<int>(index));
    } else {
        return ((VirtualQCPLayoutInset*)self)->elementAt(static_cast<int>(index));
    }
}

QCPLayoutElement* QCPLayoutInset_TakeAt(QCPLayoutInset* self, int index) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        return self->takeAt(static_cast<int>(index));
    } else {
        return ((VirtualQCPLayoutInset*)self)->takeAt(static_cast<int>(index));
    }
}

bool QCPLayoutInset_Take(QCPLayoutInset* self, QCPLayoutElement* element) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        return self->take(element);
    } else {
        return ((VirtualQCPLayoutInset*)self)->take(element);
    }
}

void QCPLayoutInset_Simplify(QCPLayoutInset* self) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        self->simplify();
    } else {
        ((VirtualQCPLayoutInset*)self)->simplify();
    }
}

double QCPLayoutInset_SelectTest(const QCPLayoutInset* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcplayoutinset = dynamic_cast<const VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPLayoutInset*)self)->selectTest(*pos, onlySelectable, details);
    }
}

void QCPLayoutInset_AddElement(QCPLayoutInset* self, QCPLayoutElement* element, int alignment) {
    self->addElement(element, static_cast<Qt::Alignment>(alignment));
}

void QCPLayoutInset_AddElement2(QCPLayoutInset* self, QCPLayoutElement* element, const QRectF* rect) {
    self->addElement(element, *rect);
}

libqt_string QCPLayoutInset_Tr2(const char* s, const char* c) {
    QString _ret = QCPLayoutInset::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPLayoutInset_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPLayoutInset::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPLayoutInset_QBaseMetacall(QCPLayoutInset* self, int param1, int param2, void** param3) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_Metacall_IsBase(true);
        return vqcplayoutinset->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPLayoutInset::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnMetacall(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_Metacall_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLayoutInset_QBaseUpdateLayout(QCPLayoutInset* self) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_UpdateLayout_IsBase(true);
        vqcplayoutinset->updateLayout();
    } else {
        self->QCPLayoutInset::updateLayout();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnUpdateLayout(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_UpdateLayout_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_UpdateLayout_Callback>(slot));
    }
}

// Base class handler implementation
int QCPLayoutInset_QBaseElementCount(const QCPLayoutInset* self) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_ElementCount_IsBase(true);
        return vqcplayoutinset->elementCount();
    } else {
        return self->QCPLayoutInset::elementCount();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnElementCount(const QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_ElementCount_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_ElementCount_Callback>(slot));
    }
}

// Base class handler implementation
QCPLayoutElement* QCPLayoutInset_QBaseElementAt(const QCPLayoutInset* self, int index) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_ElementAt_IsBase(true);
        return vqcplayoutinset->elementAt(static_cast<int>(index));
    } else {
        return self->QCPLayoutInset::elementAt(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnElementAt(const QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_ElementAt_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_ElementAt_Callback>(slot));
    }
}

// Base class handler implementation
QCPLayoutElement* QCPLayoutInset_QBaseTakeAt(QCPLayoutInset* self, int index) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_TakeAt_IsBase(true);
        return vqcplayoutinset->takeAt(static_cast<int>(index));
    } else {
        return self->QCPLayoutInset::takeAt(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnTakeAt(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_TakeAt_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_TakeAt_Callback>(slot));
    }
}

// Base class handler implementation
bool QCPLayoutInset_QBaseTake(QCPLayoutInset* self, QCPLayoutElement* element) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_Take_IsBase(true);
        return vqcplayoutinset->take(element);
    } else {
        return self->QCPLayoutInset::take(element);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnTake(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_Take_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_Take_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLayoutInset_QBaseSimplify(QCPLayoutInset* self) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_Simplify_IsBase(true);
        vqcplayoutinset->simplify();
    } else {
        self->QCPLayoutInset::simplify();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnSimplify(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_Simplify_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_Simplify_Callback>(slot));
    }
}

// Base class handler implementation
double QCPLayoutInset_QBaseSelectTest(const QCPLayoutInset* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_SelectTest_IsBase(true);
        return vqcplayoutinset->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPLayoutInset::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnSelectTest(const QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_SelectTest_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_SelectTest_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutInset_Update(QCPLayoutInset* self, int phase) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    } else {
        self->QCPLayoutInset::update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    }
}

// Base class handler implementation
void QCPLayoutInset_QBaseUpdate(QCPLayoutInset* self, int phase) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_Update_IsBase(true);
        vqcplayoutinset->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    } else {
        self->QCPLayoutInset::update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnUpdate(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_Update_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_Update_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of QCPLayoutElement* */ QCPLayoutInset_Elements(const QCPLayoutInset* self, bool recursive) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        QList<QCPLayoutElement*> _ret = vqcplayoutinset->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayoutElement*> _ret = self->QCPLayoutInset::elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of QCPLayoutElement* */ QCPLayoutInset_QBaseElements(const QCPLayoutInset* self, bool recursive) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_Elements_IsBase(true);
        QList<QCPLayoutElement*> _ret = vqcplayoutinset->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayoutElement*> _ret = self->QCPLayoutInset::elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnElements(const QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_Elements_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_Elements_Callback>(slot));
    }
}

// Derived class handler implementation
QSize* QCPLayoutInset_MinimumOuterSizeHint(const QCPLayoutInset* self) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        return new QSize(vqcplayoutinset->minimumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPLayoutInset*)self)->minimumOuterSizeHint());
    }
}

// Base class handler implementation
QSize* QCPLayoutInset_QBaseMinimumOuterSizeHint(const QCPLayoutInset* self) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_MinimumOuterSizeHint_IsBase(true);
        return new QSize(vqcplayoutinset->minimumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPLayoutInset*)self)->minimumOuterSizeHint());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnMinimumOuterSizeHint(const QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_MinimumOuterSizeHint_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_MinimumOuterSizeHint_Callback>(slot));
    }
}

// Derived class handler implementation
QSize* QCPLayoutInset_MaximumOuterSizeHint(const QCPLayoutInset* self) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        return new QSize(vqcplayoutinset->maximumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPLayoutInset*)self)->maximumOuterSizeHint());
    }
}

// Base class handler implementation
QSize* QCPLayoutInset_QBaseMaximumOuterSizeHint(const QCPLayoutInset* self) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_MaximumOuterSizeHint_IsBase(true);
        return new QSize(vqcplayoutinset->maximumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPLayoutInset*)self)->maximumOuterSizeHint());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnMaximumOuterSizeHint(const QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_MaximumOuterSizeHint_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_MaximumOuterSizeHint_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPLayoutInset_CalculateAutoMargin(QCPLayoutInset* self, int side) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        return vqcplayoutinset->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    } else {
        return ((VirtualQCPLayoutInset*)self)->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    }
}

// Base class handler implementation
int QCPLayoutInset_QBaseCalculateAutoMargin(QCPLayoutInset* self, int side) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_CalculateAutoMargin_IsBase(true);
        return vqcplayoutinset->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    } else {
        return ((VirtualQCPLayoutInset*)self)->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnCalculateAutoMargin(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_CalculateAutoMargin_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_CalculateAutoMargin_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutInset_LayoutChanged(QCPLayoutInset* self) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->layoutChanged();
    } else {
        ((VirtualQCPLayoutInset*)self)->layoutChanged();
    }
}

// Base class handler implementation
void QCPLayoutInset_QBaseLayoutChanged(QCPLayoutInset* self) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_LayoutChanged_IsBase(true);
        vqcplayoutinset->layoutChanged();
    } else {
        ((VirtualQCPLayoutInset*)self)->layoutChanged();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnLayoutChanged(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_LayoutChanged_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_LayoutChanged_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutInset_ApplyDefaultAntialiasingHint(const QCPLayoutInset* self, QCPPainter* painter) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPLayoutInset*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPLayoutInset_QBaseApplyDefaultAntialiasingHint(const QCPLayoutInset* self, QCPPainter* painter) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcplayoutinset->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPLayoutInset*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnApplyDefaultAntialiasingHint(const QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutInset_Draw(QCPLayoutInset* self, QCPPainter* painter) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->draw(painter);
    } else {
        ((VirtualQCPLayoutInset*)self)->draw(painter);
    }
}

// Base class handler implementation
void QCPLayoutInset_QBaseDraw(QCPLayoutInset* self, QCPPainter* painter) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_Draw_IsBase(true);
        vqcplayoutinset->draw(painter);
    } else {
        ((VirtualQCPLayoutInset*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnDraw(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_Draw_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_Draw_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutInset_ParentPlotInitialized(QCPLayoutInset* self, QCustomPlot* parentPlot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPLayoutInset*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPLayoutInset_QBaseParentPlotInitialized(QCPLayoutInset* self, QCustomPlot* parentPlot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_ParentPlotInitialized_IsBase(true);
        vqcplayoutinset->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPLayoutInset*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnParentPlotInitialized(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPLayoutInset_SelectionCategory(const QCPLayoutInset* self) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        return static_cast<int>(vqcplayoutinset->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPLayoutInset*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPLayoutInset_QBaseSelectionCategory(const QCPLayoutInset* self) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcplayoutinset->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPLayoutInset*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnSelectionCategory(const QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_SelectionCategory_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPLayoutInset_ClipRect(const QCPLayoutInset* self) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        return new QRect(vqcplayoutinset->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPLayoutInset_QBaseClipRect(const QCPLayoutInset* self) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_ClipRect_IsBase(true);
        return new QRect(vqcplayoutinset->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnClipRect(const QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_ClipRect_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutInset_SelectEvent(QCPLayoutInset* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPLayoutInset*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPLayoutInset_QBaseSelectEvent(QCPLayoutInset* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_SelectEvent_IsBase(true);
        vqcplayoutinset->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPLayoutInset*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnSelectEvent(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_SelectEvent_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutInset_DeselectEvent(QCPLayoutInset* self, bool* selectionStateChanged) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPLayoutInset*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPLayoutInset_QBaseDeselectEvent(QCPLayoutInset* self, bool* selectionStateChanged) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_DeselectEvent_IsBase(true);
        vqcplayoutinset->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPLayoutInset*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnDeselectEvent(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_DeselectEvent_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutInset_MousePressEvent(QCPLayoutInset* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPLayoutInset*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPLayoutInset_QBaseMousePressEvent(QCPLayoutInset* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_MousePressEvent_IsBase(true);
        vqcplayoutinset->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPLayoutInset*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnMousePressEvent(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_MousePressEvent_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutInset_MouseMoveEvent(QCPLayoutInset* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPLayoutInset*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPLayoutInset_QBaseMouseMoveEvent(QCPLayoutInset* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_MouseMoveEvent_IsBase(true);
        vqcplayoutinset->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPLayoutInset*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnMouseMoveEvent(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutInset_MouseReleaseEvent(QCPLayoutInset* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPLayoutInset*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPLayoutInset_QBaseMouseReleaseEvent(QCPLayoutInset* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_MouseReleaseEvent_IsBase(true);
        vqcplayoutinset->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPLayoutInset*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnMouseReleaseEvent(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutInset_MouseDoubleClickEvent(QCPLayoutInset* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPLayoutInset*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPLayoutInset_QBaseMouseDoubleClickEvent(QCPLayoutInset* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_MouseDoubleClickEvent_IsBase(true);
        vqcplayoutinset->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPLayoutInset*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnMouseDoubleClickEvent(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutInset_WheelEvent(QCPLayoutInset* self, QWheelEvent* event) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->wheelEvent(event);
    } else {
        ((VirtualQCPLayoutInset*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPLayoutInset_QBaseWheelEvent(QCPLayoutInset* self, QWheelEvent* event) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_WheelEvent_IsBase(true);
        vqcplayoutinset->wheelEvent(event);
    } else {
        ((VirtualQCPLayoutInset*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnWheelEvent(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_WheelEvent_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLayoutInset_Event(QCPLayoutInset* self, QEvent* event) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        return vqcplayoutinset->event(event);
    } else {
        return self->QCPLayoutInset::event(event);
    }
}

// Base class handler implementation
bool QCPLayoutInset_QBaseEvent(QCPLayoutInset* self, QEvent* event) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_Event_IsBase(true);
        return vqcplayoutinset->event(event);
    } else {
        return self->QCPLayoutInset::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnEvent(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_Event_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLayoutInset_EventFilter(QCPLayoutInset* self, QObject* watched, QEvent* event) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        return vqcplayoutinset->eventFilter(watched, event);
    } else {
        return self->QCPLayoutInset::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPLayoutInset_QBaseEventFilter(QCPLayoutInset* self, QObject* watched, QEvent* event) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_EventFilter_IsBase(true);
        return vqcplayoutinset->eventFilter(watched, event);
    } else {
        return self->QCPLayoutInset::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnEventFilter(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_EventFilter_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutInset_TimerEvent(QCPLayoutInset* self, QTimerEvent* event) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->timerEvent(event);
    } else {
        ((VirtualQCPLayoutInset*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPLayoutInset_QBaseTimerEvent(QCPLayoutInset* self, QTimerEvent* event) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_TimerEvent_IsBase(true);
        vqcplayoutinset->timerEvent(event);
    } else {
        ((VirtualQCPLayoutInset*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnTimerEvent(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_TimerEvent_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutInset_ChildEvent(QCPLayoutInset* self, QChildEvent* event) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->childEvent(event);
    } else {
        ((VirtualQCPLayoutInset*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPLayoutInset_QBaseChildEvent(QCPLayoutInset* self, QChildEvent* event) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_ChildEvent_IsBase(true);
        vqcplayoutinset->childEvent(event);
    } else {
        ((VirtualQCPLayoutInset*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnChildEvent(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_ChildEvent_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutInset_CustomEvent(QCPLayoutInset* self, QEvent* event) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->customEvent(event);
    } else {
        ((VirtualQCPLayoutInset*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPLayoutInset_QBaseCustomEvent(QCPLayoutInset* self, QEvent* event) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_CustomEvent_IsBase(true);
        vqcplayoutinset->customEvent(event);
    } else {
        ((VirtualQCPLayoutInset*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnCustomEvent(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_CustomEvent_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutInset_ConnectNotify(QCPLayoutInset* self, const QMetaMethod* signal) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->connectNotify(*signal);
    } else {
        ((VirtualQCPLayoutInset*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPLayoutInset_QBaseConnectNotify(QCPLayoutInset* self, const QMetaMethod* signal) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_ConnectNotify_IsBase(true);
        vqcplayoutinset->connectNotify(*signal);
    } else {
        ((VirtualQCPLayoutInset*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnConnectNotify(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_ConnectNotify_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutInset_DisconnectNotify(QCPLayoutInset* self, const QMetaMethod* signal) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->disconnectNotify(*signal);
    } else {
        ((VirtualQCPLayoutInset*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPLayoutInset_QBaseDisconnectNotify(QCPLayoutInset* self, const QMetaMethod* signal) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_DisconnectNotify_IsBase(true);
        vqcplayoutinset->disconnectNotify(*signal);
    } else {
        ((VirtualQCPLayoutInset*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnDisconnectNotify(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutInset_SizeConstraintsChanged(const QCPLayoutInset* self) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->sizeConstraintsChanged();
    } else {
        ((VirtualQCPLayoutInset*)self)->sizeConstraintsChanged();
    }
}

// Base class handler implementation
void QCPLayoutInset_QBaseSizeConstraintsChanged(const QCPLayoutInset* self) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_SizeConstraintsChanged_IsBase(true);
        vqcplayoutinset->sizeConstraintsChanged();
    } else {
        ((VirtualQCPLayoutInset*)self)->sizeConstraintsChanged();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnSizeConstraintsChanged(const QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_SizeConstraintsChanged_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_SizeConstraintsChanged_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutInset_AdoptElement(QCPLayoutInset* self, QCPLayoutElement* el) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->adoptElement(el);
    } else {
        ((VirtualQCPLayoutInset*)self)->adoptElement(el);
    }
}

// Base class handler implementation
void QCPLayoutInset_QBaseAdoptElement(QCPLayoutInset* self, QCPLayoutElement* el) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_AdoptElement_IsBase(true);
        vqcplayoutinset->adoptElement(el);
    } else {
        ((VirtualQCPLayoutInset*)self)->adoptElement(el);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnAdoptElement(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_AdoptElement_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_AdoptElement_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutInset_ReleaseElement(QCPLayoutInset* self, QCPLayoutElement* el) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->releaseElement(el);
    } else {
        ((VirtualQCPLayoutInset*)self)->releaseElement(el);
    }
}

// Base class handler implementation
void QCPLayoutInset_QBaseReleaseElement(QCPLayoutInset* self, QCPLayoutElement* el) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_ReleaseElement_IsBase(true);
        vqcplayoutinset->releaseElement(el);
    } else {
        ((VirtualQCPLayoutInset*)self)->releaseElement(el);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnReleaseElement(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_ReleaseElement_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_ReleaseElement_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of int */ QCPLayoutInset_GetSectionSizes(const QCPLayoutInset* self, libqt_list /* of int */ maxSizes, libqt_list /* of int */ minSizes, libqt_list /* of double */ stretchFactors, int totalSize) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    QVector<int> maxSizes_QVector;
    maxSizes_QVector.reserve(maxSizes.len);
    int* maxSizes_arr = static_cast<int*>(maxSizes.data);
    for (size_t i = 0; i < maxSizes.len; ++i) {
        maxSizes_QVector.push_back(static_cast<int>(maxSizes_arr[i]));
    }
    QVector<int> minSizes_QVector;
    minSizes_QVector.reserve(minSizes.len);
    int* minSizes_arr = static_cast<int*>(minSizes.data);
    for (size_t i = 0; i < minSizes.len; ++i) {
        minSizes_QVector.push_back(static_cast<int>(minSizes_arr[i]));
    }
    QVector<double> stretchFactors_QVector;
    stretchFactors_QVector.reserve(stretchFactors.len);
    double* stretchFactors_arr = static_cast<double*>(stretchFactors.data);
    for (size_t i = 0; i < stretchFactors.len; ++i) {
        stretchFactors_QVector.push_back(static_cast<double>(stretchFactors_arr[i]));
    }
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        QVector<int> _ret = vqcplayoutinset->getSectionSizes(maxSizes_QVector, minSizes_QVector, stretchFactors_QVector, static_cast<int>(totalSize));
        // Convert QVector<> from C++ memory to manually-managed C memory
        int* _arr = static_cast<int*>(malloc(sizeof(int) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<int> _ret = ((VirtualQCPLayoutInset*)self)->getSectionSizes(maxSizes_QVector, minSizes_QVector, stretchFactors_QVector, static_cast<int>(totalSize));
        // Convert QVector<> from C++ memory to manually-managed C memory
        int* _arr = static_cast<int*>(malloc(sizeof(int) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of int */ QCPLayoutInset_QBaseGetSectionSizes(const QCPLayoutInset* self, libqt_list /* of int */ maxSizes, libqt_list /* of int */ minSizes, libqt_list /* of double */ stretchFactors, int totalSize) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    QVector<int> maxSizes_QVector;
    maxSizes_QVector.reserve(maxSizes.len);
    int* maxSizes_arr = static_cast<int*>(maxSizes.data);
    for (size_t i = 0; i < maxSizes.len; ++i) {
        maxSizes_QVector.push_back(static_cast<int>(maxSizes_arr[i]));
    }
    QVector<int> minSizes_QVector;
    minSizes_QVector.reserve(minSizes.len);
    int* minSizes_arr = static_cast<int*>(minSizes.data);
    for (size_t i = 0; i < minSizes.len; ++i) {
        minSizes_QVector.push_back(static_cast<int>(minSizes_arr[i]));
    }
    QVector<double> stretchFactors_QVector;
    stretchFactors_QVector.reserve(stretchFactors.len);
    double* stretchFactors_arr = static_cast<double*>(stretchFactors.data);
    for (size_t i = 0; i < stretchFactors.len; ++i) {
        stretchFactors_QVector.push_back(static_cast<double>(stretchFactors_arr[i]));
    }
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_GetSectionSizes_IsBase(true);
        QVector<int> _ret = vqcplayoutinset->getSectionSizes(maxSizes_QVector, minSizes_QVector, stretchFactors_QVector, static_cast<int>(totalSize));
        // Convert QVector<> from C++ memory to manually-managed C memory
        int* _arr = static_cast<int*>(malloc(sizeof(int) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<int> _ret = ((VirtualQCPLayoutInset*)self)->getSectionSizes(maxSizes_QVector, minSizes_QVector, stretchFactors_QVector, static_cast<int>(totalSize));
        // Convert QVector<> from C++ memory to manually-managed C memory
        int* _arr = static_cast<int*>(malloc(sizeof(int) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnGetSectionSizes(const QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_GetSectionSizes_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_GetSectionSizes_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutInset_InitializeParentPlot(QCPLayoutInset* self, QCustomPlot* parentPlot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPLayoutInset*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPLayoutInset_QBaseInitializeParentPlot(QCPLayoutInset* self, QCustomPlot* parentPlot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_InitializeParentPlot_IsBase(true);
        vqcplayoutinset->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPLayoutInset*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnInitializeParentPlot(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutInset_SetParentLayerable(QCPLayoutInset* self, QCPLayerable* parentLayerable) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPLayoutInset*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPLayoutInset_QBaseSetParentLayerable(QCPLayoutInset* self, QCPLayerable* parentLayerable) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_SetParentLayerable_IsBase(true);
        vqcplayoutinset->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPLayoutInset*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnSetParentLayerable(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLayoutInset_MoveToLayer(QCPLayoutInset* self, QCPLayer* layer, bool prepend) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        return vqcplayoutinset->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPLayoutInset*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPLayoutInset_QBaseMoveToLayer(QCPLayoutInset* self, QCPLayer* layer, bool prepend) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_MoveToLayer_IsBase(true);
        return vqcplayoutinset->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPLayoutInset*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnMoveToLayer(QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = dynamic_cast<VirtualQCPLayoutInset*>(self);
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_MoveToLayer_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLayoutInset_ApplyAntialiasingHint(const QCPLayoutInset* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPLayoutInset*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPLayoutInset_QBaseApplyAntialiasingHint(const QCPLayoutInset* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_ApplyAntialiasingHint_IsBase(true);
        vqcplayoutinset->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPLayoutInset*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnApplyAntialiasingHint(const QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPLayoutInset_Sender(const QCPLayoutInset* self) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        return vqcplayoutinset->sender();
    } else {
        return ((VirtualQCPLayoutInset*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPLayoutInset_QBaseSender(const QCPLayoutInset* self) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_Sender_IsBase(true);
        return vqcplayoutinset->sender();
    } else {
        return ((VirtualQCPLayoutInset*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnSender(const QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_Sender_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPLayoutInset_SenderSignalIndex(const QCPLayoutInset* self) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        return vqcplayoutinset->senderSignalIndex();
    } else {
        return ((VirtualQCPLayoutInset*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPLayoutInset_QBaseSenderSignalIndex(const QCPLayoutInset* self) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_SenderSignalIndex_IsBase(true);
        return vqcplayoutinset->senderSignalIndex();
    } else {
        return ((VirtualQCPLayoutInset*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnSenderSignalIndex(const QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPLayoutInset_Receivers(const QCPLayoutInset* self, const char* signal) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        return vqcplayoutinset->receivers(signal);
    } else {
        return ((VirtualQCPLayoutInset*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPLayoutInset_QBaseReceivers(const QCPLayoutInset* self, const char* signal) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_Receivers_IsBase(true);
        return vqcplayoutinset->receivers(signal);
    } else {
        return ((VirtualQCPLayoutInset*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnReceivers(const QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_Receivers_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLayoutInset_IsSignalConnected(const QCPLayoutInset* self, const QMetaMethod* signal) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        return vqcplayoutinset->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPLayoutInset*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPLayoutInset_QBaseIsSignalConnected(const QCPLayoutInset* self, const QMetaMethod* signal) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_IsSignalConnected_IsBase(true);
        return vqcplayoutinset->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPLayoutInset*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLayoutInset_OnIsSignalConnected(const QCPLayoutInset* self, intptr_t slot) {
    auto* vqcplayoutinset = const_cast<VirtualQCPLayoutInset*>(dynamic_cast<const VirtualQCPLayoutInset*>(self));
    if (vqcplayoutinset && vqcplayoutinset->isVirtualQCPLayoutInset) {
        vqcplayoutinset->setQCPLayoutInset_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPLayoutInset::QCPLayoutInset_IsSignalConnected_Callback>(slot));
    }
}

void QCPLayoutInset_Delete(QCPLayoutInset* self) {
    delete self;
}

QCPLineEnding* QCPLineEnding_new(const QCPLineEnding* other) {
    return new QCPLineEnding(*other);
}

QCPLineEnding* QCPLineEnding_new2(QCPLineEnding* other) {
    return new QCPLineEnding(std::move(*other));
}

QCPLineEnding* QCPLineEnding_new3() {
    return new QCPLineEnding();
}

QCPLineEnding* QCPLineEnding_new4(int style) {
    return new QCPLineEnding(static_cast<QCPLineEnding::EndingStyle>(style));
}

QCPLineEnding* QCPLineEnding_new5(const QCPLineEnding* param1) {
    return new QCPLineEnding(*param1);
}

QCPLineEnding* QCPLineEnding_new6(int style, double width) {
    return new QCPLineEnding(static_cast<QCPLineEnding::EndingStyle>(style), static_cast<double>(width));
}

QCPLineEnding* QCPLineEnding_new7(int style, double width, double length) {
    return new QCPLineEnding(static_cast<QCPLineEnding::EndingStyle>(style), static_cast<double>(width), static_cast<double>(length));
}

QCPLineEnding* QCPLineEnding_new8(int style, double width, double length, bool inverted) {
    return new QCPLineEnding(static_cast<QCPLineEnding::EndingStyle>(style), static_cast<double>(width), static_cast<double>(length), inverted);
}

void QCPLineEnding_CopyAssign(QCPLineEnding* self, QCPLineEnding* other) {
    *self = *other;
}

void QCPLineEnding_MoveAssign(QCPLineEnding* self, QCPLineEnding* other) {
    *self = std::move(*other);
}

int QCPLineEnding_Style(const QCPLineEnding* self) {
    return static_cast<int>(self->style());
}

double QCPLineEnding_Width(const QCPLineEnding* self) {
    return self->width();
}

double QCPLineEnding_Length(const QCPLineEnding* self) {
    return self->length();
}

bool QCPLineEnding_Inverted(const QCPLineEnding* self) {
    return self->inverted();
}

void QCPLineEnding_SetStyle(QCPLineEnding* self, int style) {
    self->setStyle(static_cast<QCPLineEnding::EndingStyle>(style));
}

void QCPLineEnding_SetWidth(QCPLineEnding* self, double width) {
    self->setWidth(static_cast<double>(width));
}

void QCPLineEnding_SetLength(QCPLineEnding* self, double length) {
    self->setLength(static_cast<double>(length));
}

void QCPLineEnding_SetInverted(QCPLineEnding* self, bool inverted) {
    self->setInverted(inverted);
}

double QCPLineEnding_BoundingDistance(const QCPLineEnding* self) {
    return self->boundingDistance();
}

double QCPLineEnding_RealLength(const QCPLineEnding* self) {
    return self->realLength();
}

void QCPLineEnding_Draw(const QCPLineEnding* self, QCPPainter* painter, const QCPVector2D* pos, const QCPVector2D* dir) {
    self->draw(painter, *pos, *dir);
}

void QCPLineEnding_Draw2(const QCPLineEnding* self, QCPPainter* painter, const QCPVector2D* pos, double angle) {
    self->draw(painter, *pos, static_cast<double>(angle));
}

void QCPLineEnding_Delete(QCPLineEnding* self) {
    delete self;
}

QCPAxisTicker* QCPAxisTicker_new() {
    return new VirtualQCPAxisTicker();
}

int QCPAxisTicker_TickStepStrategy(const QCPAxisTicker* self) {
    return static_cast<int>(self->tickStepStrategy());
}

int QCPAxisTicker_TickCount(const QCPAxisTicker* self) {
    return self->tickCount();
}

double QCPAxisTicker_TickOrigin(const QCPAxisTicker* self) {
    return self->tickOrigin();
}

void QCPAxisTicker_SetTickStepStrategy(QCPAxisTicker* self, int strategy) {
    self->setTickStepStrategy(static_cast<QCPAxisTicker::TickStepStrategy>(strategy));
}

void QCPAxisTicker_SetTickCount(QCPAxisTicker* self, int count) {
    self->setTickCount(static_cast<int>(count));
}

void QCPAxisTicker_SetTickOrigin(QCPAxisTicker* self, double origin) {
    self->setTickOrigin(static_cast<double>(origin));
}

void QCPAxisTicker_Generate(QCPAxisTicker* self, const QCPRange* range, const QLocale* locale, QChar* formatChar, int precision, libqt_list /* of double */ ticks, libqt_list /* of double */ subTicks, libqt_list /* of libqt_string */ tickLabels) {
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    QVector<double> subTicks_QVector;
    subTicks_QVector.reserve(subTicks.len);
    double* subTicks_arr = static_cast<double*>(subTicks.data);
    for (size_t i = 0; i < subTicks.len; ++i) {
        subTicks_QVector.push_back(static_cast<double>(subTicks_arr[i]));
    }
    QVector<QString> tickLabels_QVector;
    tickLabels_QVector.reserve(tickLabels.len);
    libqt_string* tickLabels_arr = static_cast<libqt_string*>(tickLabels.data);
    for (size_t i = 0; i < tickLabels.len; ++i) {
        QString tickLabels_arr_i_QString = QString::fromUtf8(tickLabels_arr[i].data, tickLabels_arr[i].len);
        tickLabels_QVector.push_back(tickLabels_arr_i_QString);
    }
    auto* vqcpaxisticker = dynamic_cast<VirtualQCPAxisTicker*>(self);
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        self->generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    } else {
        ((VirtualQCPAxisTicker*)self)->generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    }
}

double QCPAxisTicker_GetTickStep(QCPAxisTicker* self, const QCPRange* range) {
    auto* vqcpaxisticker = dynamic_cast<VirtualQCPAxisTicker*>(self);
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        return vqcpaxisticker->getTickStep(*range);
    }
    return {};
}

int QCPAxisTicker_GetSubTickCount(QCPAxisTicker* self, double tickStep) {
    auto* vqcpaxisticker = dynamic_cast<VirtualQCPAxisTicker*>(self);
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        return vqcpaxisticker->getSubTickCount(static_cast<double>(tickStep));
    }
    return {};
}

libqt_string QCPAxisTicker_GetTickLabel(QCPAxisTicker* self, double tick, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxisticker = dynamic_cast<VirtualQCPAxisTicker*>(self);
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        QString _ret = vqcpaxisticker->getTickLabel(static_cast<double>(tick), *locale, *formatChar, static_cast<int>(precision));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    }
    return {};
}

libqt_list /* of double */ QCPAxisTicker_CreateTickVector(QCPAxisTicker* self, double tickStep, const QCPRange* range) {
    auto* vqcpaxisticker = dynamic_cast<VirtualQCPAxisTicker*>(self);
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        QVector<double> _ret = vqcpaxisticker->createTickVector(static_cast<double>(tickStep), *range);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
    return {};
}

libqt_list /* of double */ QCPAxisTicker_CreateSubTickVector(QCPAxisTicker* self, int subTickCount, const libqt_list /* of double */ ticks) {
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    auto* vqcpaxisticker = dynamic_cast<VirtualQCPAxisTicker*>(self);
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        QVector<double> _ret = vqcpaxisticker->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
    return {};
}

libqt_list /* of libqt_string */ QCPAxisTicker_CreateLabelVector(QCPAxisTicker* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision) {
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    auto* vqcpaxisticker = dynamic_cast<VirtualQCPAxisTicker*>(self);
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        QVector<QString> _ret = vqcpaxisticker->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
    return {};
}

// Base class handler implementation
void QCPAxisTicker_QBaseGenerate(QCPAxisTicker* self, const QCPRange* range, const QLocale* locale, QChar* formatChar, int precision, libqt_list /* of double */ ticks, libqt_list /* of double */ subTicks, libqt_list /* of libqt_string */ tickLabels) {
    auto* vqcpaxisticker = dynamic_cast<VirtualQCPAxisTicker*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    QVector<double> subTicks_QVector;
    subTicks_QVector.reserve(subTicks.len);
    double* subTicks_arr = static_cast<double*>(subTicks.data);
    for (size_t i = 0; i < subTicks.len; ++i) {
        subTicks_QVector.push_back(static_cast<double>(subTicks_arr[i]));
    }
    QVector<QString> tickLabels_QVector;
    tickLabels_QVector.reserve(tickLabels.len);
    libqt_string* tickLabels_arr = static_cast<libqt_string*>(tickLabels.data);
    for (size_t i = 0; i < tickLabels.len; ++i) {
        QString tickLabels_arr_i_QString = QString::fromUtf8(tickLabels_arr[i].data, tickLabels_arr[i].len);
        tickLabels_QVector.push_back(tickLabels_arr_i_QString);
    }
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        vqcpaxisticker->setQCPAxisTicker_Generate_IsBase(true);
        vqcpaxisticker->generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    } else {
        self->QCPAxisTicker::generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTicker_OnGenerate(QCPAxisTicker* self, intptr_t slot) {
    auto* vqcpaxisticker = dynamic_cast<VirtualQCPAxisTicker*>(self);
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        vqcpaxisticker->setQCPAxisTicker_Generate_Callback(reinterpret_cast<VirtualQCPAxisTicker::QCPAxisTicker_Generate_Callback>(slot));
    }
}

// Base class handler implementation
double QCPAxisTicker_QBaseGetTickStep(QCPAxisTicker* self, const QCPRange* range) {
    auto* vqcpaxisticker = dynamic_cast<VirtualQCPAxisTicker*>(self);
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        vqcpaxisticker->setQCPAxisTicker_GetTickStep_IsBase(true);
        return vqcpaxisticker->getTickStep(*range);
    } else {
        return ((VirtualQCPAxisTicker*)self)->getTickStep(*range);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTicker_OnGetTickStep(QCPAxisTicker* self, intptr_t slot) {
    auto* vqcpaxisticker = dynamic_cast<VirtualQCPAxisTicker*>(self);
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        vqcpaxisticker->setQCPAxisTicker_GetTickStep_Callback(reinterpret_cast<VirtualQCPAxisTicker::QCPAxisTicker_GetTickStep_Callback>(slot));
    }
}

// Base class handler implementation
int QCPAxisTicker_QBaseGetSubTickCount(QCPAxisTicker* self, double tickStep) {
    auto* vqcpaxisticker = dynamic_cast<VirtualQCPAxisTicker*>(self);
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        vqcpaxisticker->setQCPAxisTicker_GetSubTickCount_IsBase(true);
        return vqcpaxisticker->getSubTickCount(static_cast<double>(tickStep));
    } else {
        return ((VirtualQCPAxisTicker*)self)->getSubTickCount(static_cast<double>(tickStep));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTicker_OnGetSubTickCount(QCPAxisTicker* self, intptr_t slot) {
    auto* vqcpaxisticker = dynamic_cast<VirtualQCPAxisTicker*>(self);
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        vqcpaxisticker->setQCPAxisTicker_GetSubTickCount_Callback(reinterpret_cast<VirtualQCPAxisTicker::QCPAxisTicker_GetSubTickCount_Callback>(slot));
    }
}

// Base class handler implementation
libqt_string QCPAxisTicker_QBaseGetTickLabel(QCPAxisTicker* self, double tick, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxisticker = dynamic_cast<VirtualQCPAxisTicker*>(self);
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        vqcpaxisticker->setQCPAxisTicker_GetTickLabel_IsBase(true);
        QString _ret = vqcpaxisticker->getTickLabel(static_cast<double>(tick), *locale, *formatChar, static_cast<int>(precision));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    } else {
        QString _ret = ((VirtualQCPAxisTicker*)self)->getTickLabel(static_cast<double>(tick), *locale, *formatChar, static_cast<int>(precision));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTicker_OnGetTickLabel(QCPAxisTicker* self, intptr_t slot) {
    auto* vqcpaxisticker = dynamic_cast<VirtualQCPAxisTicker*>(self);
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        vqcpaxisticker->setQCPAxisTicker_GetTickLabel_Callback(reinterpret_cast<VirtualQCPAxisTicker::QCPAxisTicker_GetTickLabel_Callback>(slot));
    }
}

// Base class handler implementation
libqt_list /* of double */ QCPAxisTicker_QBaseCreateTickVector(QCPAxisTicker* self, double tickStep, const QCPRange* range) {
    auto* vqcpaxisticker = dynamic_cast<VirtualQCPAxisTicker*>(self);
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        vqcpaxisticker->setQCPAxisTicker_CreateTickVector_IsBase(true);
        QVector<double> _ret = vqcpaxisticker->createTickVector(static_cast<double>(tickStep), *range);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<double> _ret = ((VirtualQCPAxisTicker*)self)->createTickVector(static_cast<double>(tickStep), *range);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTicker_OnCreateTickVector(QCPAxisTicker* self, intptr_t slot) {
    auto* vqcpaxisticker = dynamic_cast<VirtualQCPAxisTicker*>(self);
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        vqcpaxisticker->setQCPAxisTicker_CreateTickVector_Callback(reinterpret_cast<VirtualQCPAxisTicker::QCPAxisTicker_CreateTickVector_Callback>(slot));
    }
}

// Base class handler implementation
libqt_list /* of double */ QCPAxisTicker_QBaseCreateSubTickVector(QCPAxisTicker* self, int subTickCount, const libqt_list /* of double */ ticks) {
    auto* vqcpaxisticker = dynamic_cast<VirtualQCPAxisTicker*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        vqcpaxisticker->setQCPAxisTicker_CreateSubTickVector_IsBase(true);
        QVector<double> _ret = vqcpaxisticker->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<double> _ret = ((VirtualQCPAxisTicker*)self)->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTicker_OnCreateSubTickVector(QCPAxisTicker* self, intptr_t slot) {
    auto* vqcpaxisticker = dynamic_cast<VirtualQCPAxisTicker*>(self);
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        vqcpaxisticker->setQCPAxisTicker_CreateSubTickVector_Callback(reinterpret_cast<VirtualQCPAxisTicker::QCPAxisTicker_CreateSubTickVector_Callback>(slot));
    }
}

// Base class handler implementation
libqt_list /* of libqt_string */ QCPAxisTicker_QBaseCreateLabelVector(QCPAxisTicker* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxisticker = dynamic_cast<VirtualQCPAxisTicker*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        vqcpaxisticker->setQCPAxisTicker_CreateLabelVector_IsBase(true);
        QVector<QString> _ret = vqcpaxisticker->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QString> _ret = ((VirtualQCPAxisTicker*)self)->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTicker_OnCreateLabelVector(QCPAxisTicker* self, intptr_t slot) {
    auto* vqcpaxisticker = dynamic_cast<VirtualQCPAxisTicker*>(self);
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        vqcpaxisticker->setQCPAxisTicker_CreateLabelVector_Callback(reinterpret_cast<VirtualQCPAxisTicker::QCPAxisTicker_CreateLabelVector_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisTicker_TrimTicks(const QCPAxisTicker* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier) {
    auto* vqcpaxisticker = const_cast<VirtualQCPAxisTicker*>(dynamic_cast<const VirtualQCPAxisTicker*>(self));
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        vqcpaxisticker->trimTicks(*range, ticks_QVector, keepOneOutlier);
    } else {
        ((VirtualQCPAxisTicker*)self)->trimTicks(*range, ticks_QVector, keepOneOutlier);
    }
}

// Base class handler implementation
void QCPAxisTicker_QBaseTrimTicks(const QCPAxisTicker* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier) {
    auto* vqcpaxisticker = const_cast<VirtualQCPAxisTicker*>(dynamic_cast<const VirtualQCPAxisTicker*>(self));
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        vqcpaxisticker->setQCPAxisTicker_TrimTicks_IsBase(true);
        vqcpaxisticker->trimTicks(*range, ticks_QVector, keepOneOutlier);
    } else {
        ((VirtualQCPAxisTicker*)self)->trimTicks(*range, ticks_QVector, keepOneOutlier);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTicker_OnTrimTicks(const QCPAxisTicker* self, intptr_t slot) {
    auto* vqcpaxisticker = const_cast<VirtualQCPAxisTicker*>(dynamic_cast<const VirtualQCPAxisTicker*>(self));
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        vqcpaxisticker->setQCPAxisTicker_TrimTicks_Callback(reinterpret_cast<VirtualQCPAxisTicker::QCPAxisTicker_TrimTicks_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPAxisTicker_PickClosest(const QCPAxisTicker* self, double target, const libqt_list /* of double */ candidates) {
    auto* vqcpaxisticker = const_cast<VirtualQCPAxisTicker*>(dynamic_cast<const VirtualQCPAxisTicker*>(self));
    QVector<double> candidates_QVector;
    candidates_QVector.reserve(candidates.len);
    double* candidates_arr = static_cast<double*>(candidates.data);
    for (size_t i = 0; i < candidates.len; ++i) {
        candidates_QVector.push_back(static_cast<double>(candidates_arr[i]));
    }
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        return vqcpaxisticker->pickClosest(static_cast<double>(target), candidates_QVector);
    } else {
        return ((VirtualQCPAxisTicker*)self)->pickClosest(static_cast<double>(target), candidates_QVector);
    }
}

// Base class handler implementation
double QCPAxisTicker_QBasePickClosest(const QCPAxisTicker* self, double target, const libqt_list /* of double */ candidates) {
    auto* vqcpaxisticker = const_cast<VirtualQCPAxisTicker*>(dynamic_cast<const VirtualQCPAxisTicker*>(self));
    QVector<double> candidates_QVector;
    candidates_QVector.reserve(candidates.len);
    double* candidates_arr = static_cast<double*>(candidates.data);
    for (size_t i = 0; i < candidates.len; ++i) {
        candidates_QVector.push_back(static_cast<double>(candidates_arr[i]));
    }
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        vqcpaxisticker->setQCPAxisTicker_PickClosest_IsBase(true);
        return vqcpaxisticker->pickClosest(static_cast<double>(target), candidates_QVector);
    } else {
        return ((VirtualQCPAxisTicker*)self)->pickClosest(static_cast<double>(target), candidates_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTicker_OnPickClosest(const QCPAxisTicker* self, intptr_t slot) {
    auto* vqcpaxisticker = const_cast<VirtualQCPAxisTicker*>(dynamic_cast<const VirtualQCPAxisTicker*>(self));
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        vqcpaxisticker->setQCPAxisTicker_PickClosest_Callback(reinterpret_cast<VirtualQCPAxisTicker::QCPAxisTicker_PickClosest_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPAxisTicker_GetMantissa(const QCPAxisTicker* self, double input) {
    auto* vqcpaxisticker = const_cast<VirtualQCPAxisTicker*>(dynamic_cast<const VirtualQCPAxisTicker*>(self));
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        return vqcpaxisticker->getMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTicker*)self)->getMantissa(static_cast<double>(input));
    }
}

// Base class handler implementation
double QCPAxisTicker_QBaseGetMantissa(const QCPAxisTicker* self, double input) {
    auto* vqcpaxisticker = const_cast<VirtualQCPAxisTicker*>(dynamic_cast<const VirtualQCPAxisTicker*>(self));
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        vqcpaxisticker->setQCPAxisTicker_GetMantissa_IsBase(true);
        return vqcpaxisticker->getMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTicker*)self)->getMantissa(static_cast<double>(input));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTicker_OnGetMantissa(const QCPAxisTicker* self, intptr_t slot) {
    auto* vqcpaxisticker = const_cast<VirtualQCPAxisTicker*>(dynamic_cast<const VirtualQCPAxisTicker*>(self));
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        vqcpaxisticker->setQCPAxisTicker_GetMantissa_Callback(reinterpret_cast<VirtualQCPAxisTicker::QCPAxisTicker_GetMantissa_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPAxisTicker_CleanMantissa(const QCPAxisTicker* self, double input) {
    auto* vqcpaxisticker = const_cast<VirtualQCPAxisTicker*>(dynamic_cast<const VirtualQCPAxisTicker*>(self));
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        return vqcpaxisticker->cleanMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTicker*)self)->cleanMantissa(static_cast<double>(input));
    }
}

// Base class handler implementation
double QCPAxisTicker_QBaseCleanMantissa(const QCPAxisTicker* self, double input) {
    auto* vqcpaxisticker = const_cast<VirtualQCPAxisTicker*>(dynamic_cast<const VirtualQCPAxisTicker*>(self));
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        vqcpaxisticker->setQCPAxisTicker_CleanMantissa_IsBase(true);
        return vqcpaxisticker->cleanMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTicker*)self)->cleanMantissa(static_cast<double>(input));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTicker_OnCleanMantissa(const QCPAxisTicker* self, intptr_t slot) {
    auto* vqcpaxisticker = const_cast<VirtualQCPAxisTicker*>(dynamic_cast<const VirtualQCPAxisTicker*>(self));
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        vqcpaxisticker->setQCPAxisTicker_CleanMantissa_Callback(reinterpret_cast<VirtualQCPAxisTicker::QCPAxisTicker_CleanMantissa_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPAxisTicker_GetMantissa2(const QCPAxisTicker* self, double input, double* magnitude) {
    auto* vqcpaxisticker = const_cast<VirtualQCPAxisTicker*>(dynamic_cast<const VirtualQCPAxisTicker*>(self));
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        return vqcpaxisticker->getMantissa(static_cast<double>(input), static_cast<double*>(magnitude));
    } else {
        return ((VirtualQCPAxisTicker*)self)->getMantissa(static_cast<double>(input), static_cast<double*>(magnitude));
    }
}

// Base class handler implementation
double QCPAxisTicker_QBaseGetMantissa2(const QCPAxisTicker* self, double input, double* magnitude) {
    auto* vqcpaxisticker = const_cast<VirtualQCPAxisTicker*>(dynamic_cast<const VirtualQCPAxisTicker*>(self));
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        vqcpaxisticker->setQCPAxisTicker_GetMantissa2_IsBase(true);
        return vqcpaxisticker->getMantissa(static_cast<double>(input), static_cast<double*>(magnitude));
    } else {
        return ((VirtualQCPAxisTicker*)self)->getMantissa(static_cast<double>(input), static_cast<double*>(magnitude));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTicker_OnGetMantissa2(const QCPAxisTicker* self, intptr_t slot) {
    auto* vqcpaxisticker = const_cast<VirtualQCPAxisTicker*>(dynamic_cast<const VirtualQCPAxisTicker*>(self));
    if (vqcpaxisticker && vqcpaxisticker->isVirtualQCPAxisTicker) {
        vqcpaxisticker->setQCPAxisTicker_GetMantissa2_Callback(reinterpret_cast<VirtualQCPAxisTicker::QCPAxisTicker_GetMantissa2_Callback>(slot));
    }
}

void QCPAxisTicker_Delete(QCPAxisTicker* self) {
    delete self;
}

QCPAxisTickerDateTime* QCPAxisTickerDateTime_new() {
    return new VirtualQCPAxisTickerDateTime();
}

libqt_string QCPAxisTickerDateTime_DateTimeFormat(const QCPAxisTickerDateTime* self) {
    QString _ret = self->dateTimeFormat();
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

int QCPAxisTickerDateTime_DateTimeSpec(const QCPAxisTickerDateTime* self) {
    return static_cast<int>(self->dateTimeSpec());
}

QTimeZone* QCPAxisTickerDateTime_TimeZone(const QCPAxisTickerDateTime* self) {
    return new QTimeZone(self->timeZone());
}

void QCPAxisTickerDateTime_SetDateTimeFormat(QCPAxisTickerDateTime* self, const libqt_string format) {
    QString format_QString = QString::fromUtf8(format.data, format.len);
    self->setDateTimeFormat(format_QString);
}

void QCPAxisTickerDateTime_SetDateTimeSpec(QCPAxisTickerDateTime* self, int spec) {
    self->setDateTimeSpec(static_cast<Qt::TimeSpec>(spec));
}

void QCPAxisTickerDateTime_SetTimeZone(QCPAxisTickerDateTime* self, const QTimeZone* zone) {
    self->setTimeZone(*zone);
}

void QCPAxisTickerDateTime_SetTickOrigin(QCPAxisTickerDateTime* self, double origin) {
    self->setTickOrigin(static_cast<double>(origin));
}

void QCPAxisTickerDateTime_SetTickOrigin2(QCPAxisTickerDateTime* self, const QDateTime* origin) {
    self->setTickOrigin(*origin);
}

QDateTime* QCPAxisTickerDateTime_KeyToDateTime(double key) {
    return new QDateTime(QCPAxisTickerDateTime::keyToDateTime(static_cast<double>(key)));
}

double QCPAxisTickerDateTime_DateTimeToKey(const QDateTime* dateTime) {
    return QCPAxisTickerDateTime::dateTimeToKey(*dateTime);
}

double QCPAxisTickerDateTime_DateTimeToKey2(const QDate* date) {
    return QCPAxisTickerDateTime::dateTimeToKey(*date);
}

double QCPAxisTickerDateTime_GetTickStep(QCPAxisTickerDateTime* self, const QCPRange* range) {
    auto* vqcpaxistickerdatetime = dynamic_cast<VirtualQCPAxisTickerDateTime*>(self);
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        return vqcpaxistickerdatetime->getTickStep(*range);
    }
    return {};
}

int QCPAxisTickerDateTime_GetSubTickCount(QCPAxisTickerDateTime* self, double tickStep) {
    auto* vqcpaxistickerdatetime = dynamic_cast<VirtualQCPAxisTickerDateTime*>(self);
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        return vqcpaxistickerdatetime->getSubTickCount(static_cast<double>(tickStep));
    }
    return {};
}

libqt_string QCPAxisTickerDateTime_GetTickLabel(QCPAxisTickerDateTime* self, double tick, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxistickerdatetime = dynamic_cast<VirtualQCPAxisTickerDateTime*>(self);
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        QString _ret = vqcpaxistickerdatetime->getTickLabel(static_cast<double>(tick), *locale, *formatChar, static_cast<int>(precision));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    }
    return {};
}

libqt_list /* of double */ QCPAxisTickerDateTime_CreateTickVector(QCPAxisTickerDateTime* self, double tickStep, const QCPRange* range) {
    auto* vqcpaxistickerdatetime = dynamic_cast<VirtualQCPAxisTickerDateTime*>(self);
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        QVector<double> _ret = vqcpaxistickerdatetime->createTickVector(static_cast<double>(tickStep), *range);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
    return {};
}

double QCPAxisTickerDateTime_DateTimeToKey22(const QDate* date, int timeSpec) {
    return QCPAxisTickerDateTime::dateTimeToKey(*date, static_cast<Qt::TimeSpec>(timeSpec));
}

// Base class handler implementation
double QCPAxisTickerDateTime_QBaseGetTickStep(QCPAxisTickerDateTime* self, const QCPRange* range) {
    auto* vqcpaxistickerdatetime = dynamic_cast<VirtualQCPAxisTickerDateTime*>(self);
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        vqcpaxistickerdatetime->setQCPAxisTickerDateTime_GetTickStep_IsBase(true);
        return vqcpaxistickerdatetime->getTickStep(*range);
    } else {
        return ((VirtualQCPAxisTickerDateTime*)self)->getTickStep(*range);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerDateTime_OnGetTickStep(QCPAxisTickerDateTime* self, intptr_t slot) {
    auto* vqcpaxistickerdatetime = dynamic_cast<VirtualQCPAxisTickerDateTime*>(self);
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        vqcpaxistickerdatetime->setQCPAxisTickerDateTime_GetTickStep_Callback(reinterpret_cast<VirtualQCPAxisTickerDateTime::QCPAxisTickerDateTime_GetTickStep_Callback>(slot));
    }
}

// Base class handler implementation
int QCPAxisTickerDateTime_QBaseGetSubTickCount(QCPAxisTickerDateTime* self, double tickStep) {
    auto* vqcpaxistickerdatetime = dynamic_cast<VirtualQCPAxisTickerDateTime*>(self);
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        vqcpaxistickerdatetime->setQCPAxisTickerDateTime_GetSubTickCount_IsBase(true);
        return vqcpaxistickerdatetime->getSubTickCount(static_cast<double>(tickStep));
    } else {
        return ((VirtualQCPAxisTickerDateTime*)self)->getSubTickCount(static_cast<double>(tickStep));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerDateTime_OnGetSubTickCount(QCPAxisTickerDateTime* self, intptr_t slot) {
    auto* vqcpaxistickerdatetime = dynamic_cast<VirtualQCPAxisTickerDateTime*>(self);
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        vqcpaxistickerdatetime->setQCPAxisTickerDateTime_GetSubTickCount_Callback(reinterpret_cast<VirtualQCPAxisTickerDateTime::QCPAxisTickerDateTime_GetSubTickCount_Callback>(slot));
    }
}

// Base class handler implementation
libqt_string QCPAxisTickerDateTime_QBaseGetTickLabel(QCPAxisTickerDateTime* self, double tick, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxistickerdatetime = dynamic_cast<VirtualQCPAxisTickerDateTime*>(self);
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        vqcpaxistickerdatetime->setQCPAxisTickerDateTime_GetTickLabel_IsBase(true);
        QString _ret = vqcpaxistickerdatetime->getTickLabel(static_cast<double>(tick), *locale, *formatChar, static_cast<int>(precision));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    } else {
        QString _ret = ((VirtualQCPAxisTickerDateTime*)self)->getTickLabel(static_cast<double>(tick), *locale, *formatChar, static_cast<int>(precision));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerDateTime_OnGetTickLabel(QCPAxisTickerDateTime* self, intptr_t slot) {
    auto* vqcpaxistickerdatetime = dynamic_cast<VirtualQCPAxisTickerDateTime*>(self);
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        vqcpaxistickerdatetime->setQCPAxisTickerDateTime_GetTickLabel_Callback(reinterpret_cast<VirtualQCPAxisTickerDateTime::QCPAxisTickerDateTime_GetTickLabel_Callback>(slot));
    }
}

// Base class handler implementation
libqt_list /* of double */ QCPAxisTickerDateTime_QBaseCreateTickVector(QCPAxisTickerDateTime* self, double tickStep, const QCPRange* range) {
    auto* vqcpaxistickerdatetime = dynamic_cast<VirtualQCPAxisTickerDateTime*>(self);
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        vqcpaxistickerdatetime->setQCPAxisTickerDateTime_CreateTickVector_IsBase(true);
        QVector<double> _ret = vqcpaxistickerdatetime->createTickVector(static_cast<double>(tickStep), *range);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<double> _ret = ((VirtualQCPAxisTickerDateTime*)self)->createTickVector(static_cast<double>(tickStep), *range);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerDateTime_OnCreateTickVector(QCPAxisTickerDateTime* self, intptr_t slot) {
    auto* vqcpaxistickerdatetime = dynamic_cast<VirtualQCPAxisTickerDateTime*>(self);
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        vqcpaxistickerdatetime->setQCPAxisTickerDateTime_CreateTickVector_Callback(reinterpret_cast<VirtualQCPAxisTickerDateTime::QCPAxisTickerDateTime_CreateTickVector_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisTickerDateTime_Generate(QCPAxisTickerDateTime* self, const QCPRange* range, const QLocale* locale, QChar* formatChar, int precision, libqt_list /* of double */ ticks, libqt_list /* of double */ subTicks, libqt_list /* of libqt_string */ tickLabels) {
    auto* vqcpaxistickerdatetime = dynamic_cast<VirtualQCPAxisTickerDateTime*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    QVector<double> subTicks_QVector;
    subTicks_QVector.reserve(subTicks.len);
    double* subTicks_arr = static_cast<double*>(subTicks.data);
    for (size_t i = 0; i < subTicks.len; ++i) {
        subTicks_QVector.push_back(static_cast<double>(subTicks_arr[i]));
    }
    QVector<QString> tickLabels_QVector;
    tickLabels_QVector.reserve(tickLabels.len);
    libqt_string* tickLabels_arr = static_cast<libqt_string*>(tickLabels.data);
    for (size_t i = 0; i < tickLabels.len; ++i) {
        QString tickLabels_arr_i_QString = QString::fromUtf8(tickLabels_arr[i].data, tickLabels_arr[i].len);
        tickLabels_QVector.push_back(tickLabels_arr_i_QString);
    }
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        vqcpaxistickerdatetime->generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    } else {
        self->QCPAxisTickerDateTime::generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    }
}

// Base class handler implementation
void QCPAxisTickerDateTime_QBaseGenerate(QCPAxisTickerDateTime* self, const QCPRange* range, const QLocale* locale, QChar* formatChar, int precision, libqt_list /* of double */ ticks, libqt_list /* of double */ subTicks, libqt_list /* of libqt_string */ tickLabels) {
    auto* vqcpaxistickerdatetime = dynamic_cast<VirtualQCPAxisTickerDateTime*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    QVector<double> subTicks_QVector;
    subTicks_QVector.reserve(subTicks.len);
    double* subTicks_arr = static_cast<double*>(subTicks.data);
    for (size_t i = 0; i < subTicks.len; ++i) {
        subTicks_QVector.push_back(static_cast<double>(subTicks_arr[i]));
    }
    QVector<QString> tickLabels_QVector;
    tickLabels_QVector.reserve(tickLabels.len);
    libqt_string* tickLabels_arr = static_cast<libqt_string*>(tickLabels.data);
    for (size_t i = 0; i < tickLabels.len; ++i) {
        QString tickLabels_arr_i_QString = QString::fromUtf8(tickLabels_arr[i].data, tickLabels_arr[i].len);
        tickLabels_QVector.push_back(tickLabels_arr_i_QString);
    }
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        vqcpaxistickerdatetime->setQCPAxisTickerDateTime_Generate_IsBase(true);
        vqcpaxistickerdatetime->generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    } else {
        self->QCPAxisTickerDateTime::generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerDateTime_OnGenerate(QCPAxisTickerDateTime* self, intptr_t slot) {
    auto* vqcpaxistickerdatetime = dynamic_cast<VirtualQCPAxisTickerDateTime*>(self);
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        vqcpaxistickerdatetime->setQCPAxisTickerDateTime_Generate_Callback(reinterpret_cast<VirtualQCPAxisTickerDateTime::QCPAxisTickerDateTime_Generate_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of double */ QCPAxisTickerDateTime_CreateSubTickVector(QCPAxisTickerDateTime* self, int subTickCount, const libqt_list /* of double */ ticks) {
    auto* vqcpaxistickerdatetime = dynamic_cast<VirtualQCPAxisTickerDateTime*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        QVector<double> _ret = vqcpaxistickerdatetime->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<double> _ret = ((VirtualQCPAxisTickerDateTime*)self)->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of double */ QCPAxisTickerDateTime_QBaseCreateSubTickVector(QCPAxisTickerDateTime* self, int subTickCount, const libqt_list /* of double */ ticks) {
    auto* vqcpaxistickerdatetime = dynamic_cast<VirtualQCPAxisTickerDateTime*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        vqcpaxistickerdatetime->setQCPAxisTickerDateTime_CreateSubTickVector_IsBase(true);
        QVector<double> _ret = vqcpaxistickerdatetime->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<double> _ret = ((VirtualQCPAxisTickerDateTime*)self)->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerDateTime_OnCreateSubTickVector(QCPAxisTickerDateTime* self, intptr_t slot) {
    auto* vqcpaxistickerdatetime = dynamic_cast<VirtualQCPAxisTickerDateTime*>(self);
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        vqcpaxistickerdatetime->setQCPAxisTickerDateTime_CreateSubTickVector_Callback(reinterpret_cast<VirtualQCPAxisTickerDateTime::QCPAxisTickerDateTime_CreateSubTickVector_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of libqt_string */ QCPAxisTickerDateTime_CreateLabelVector(QCPAxisTickerDateTime* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxistickerdatetime = dynamic_cast<VirtualQCPAxisTickerDateTime*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        QVector<QString> _ret = vqcpaxistickerdatetime->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QString> _ret = ((VirtualQCPAxisTickerDateTime*)self)->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of libqt_string */ QCPAxisTickerDateTime_QBaseCreateLabelVector(QCPAxisTickerDateTime* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxistickerdatetime = dynamic_cast<VirtualQCPAxisTickerDateTime*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        vqcpaxistickerdatetime->setQCPAxisTickerDateTime_CreateLabelVector_IsBase(true);
        QVector<QString> _ret = vqcpaxistickerdatetime->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QString> _ret = ((VirtualQCPAxisTickerDateTime*)self)->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerDateTime_OnCreateLabelVector(QCPAxisTickerDateTime* self, intptr_t slot) {
    auto* vqcpaxistickerdatetime = dynamic_cast<VirtualQCPAxisTickerDateTime*>(self);
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        vqcpaxistickerdatetime->setQCPAxisTickerDateTime_CreateLabelVector_Callback(reinterpret_cast<VirtualQCPAxisTickerDateTime::QCPAxisTickerDateTime_CreateLabelVector_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisTickerDateTime_TrimTicks(const QCPAxisTickerDateTime* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier) {
    auto* vqcpaxistickerdatetime = const_cast<VirtualQCPAxisTickerDateTime*>(dynamic_cast<const VirtualQCPAxisTickerDateTime*>(self));
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        vqcpaxistickerdatetime->trimTicks(*range, ticks_QVector, keepOneOutlier);
    } else {
        ((VirtualQCPAxisTickerDateTime*)self)->trimTicks(*range, ticks_QVector, keepOneOutlier);
    }
}

// Base class handler implementation
void QCPAxisTickerDateTime_QBaseTrimTicks(const QCPAxisTickerDateTime* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier) {
    auto* vqcpaxistickerdatetime = const_cast<VirtualQCPAxisTickerDateTime*>(dynamic_cast<const VirtualQCPAxisTickerDateTime*>(self));
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        vqcpaxistickerdatetime->setQCPAxisTickerDateTime_TrimTicks_IsBase(true);
        vqcpaxistickerdatetime->trimTicks(*range, ticks_QVector, keepOneOutlier);
    } else {
        ((VirtualQCPAxisTickerDateTime*)self)->trimTicks(*range, ticks_QVector, keepOneOutlier);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerDateTime_OnTrimTicks(const QCPAxisTickerDateTime* self, intptr_t slot) {
    auto* vqcpaxistickerdatetime = const_cast<VirtualQCPAxisTickerDateTime*>(dynamic_cast<const VirtualQCPAxisTickerDateTime*>(self));
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        vqcpaxistickerdatetime->setQCPAxisTickerDateTime_TrimTicks_Callback(reinterpret_cast<VirtualQCPAxisTickerDateTime::QCPAxisTickerDateTime_TrimTicks_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPAxisTickerDateTime_PickClosest(const QCPAxisTickerDateTime* self, double target, const libqt_list /* of double */ candidates) {
    auto* vqcpaxistickerdatetime = const_cast<VirtualQCPAxisTickerDateTime*>(dynamic_cast<const VirtualQCPAxisTickerDateTime*>(self));
    QVector<double> candidates_QVector;
    candidates_QVector.reserve(candidates.len);
    double* candidates_arr = static_cast<double*>(candidates.data);
    for (size_t i = 0; i < candidates.len; ++i) {
        candidates_QVector.push_back(static_cast<double>(candidates_arr[i]));
    }
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        return vqcpaxistickerdatetime->pickClosest(static_cast<double>(target), candidates_QVector);
    } else {
        return ((VirtualQCPAxisTickerDateTime*)self)->pickClosest(static_cast<double>(target), candidates_QVector);
    }
}

// Base class handler implementation
double QCPAxisTickerDateTime_QBasePickClosest(const QCPAxisTickerDateTime* self, double target, const libqt_list /* of double */ candidates) {
    auto* vqcpaxistickerdatetime = const_cast<VirtualQCPAxisTickerDateTime*>(dynamic_cast<const VirtualQCPAxisTickerDateTime*>(self));
    QVector<double> candidates_QVector;
    candidates_QVector.reserve(candidates.len);
    double* candidates_arr = static_cast<double*>(candidates.data);
    for (size_t i = 0; i < candidates.len; ++i) {
        candidates_QVector.push_back(static_cast<double>(candidates_arr[i]));
    }
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        vqcpaxistickerdatetime->setQCPAxisTickerDateTime_PickClosest_IsBase(true);
        return vqcpaxistickerdatetime->pickClosest(static_cast<double>(target), candidates_QVector);
    } else {
        return ((VirtualQCPAxisTickerDateTime*)self)->pickClosest(static_cast<double>(target), candidates_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerDateTime_OnPickClosest(const QCPAxisTickerDateTime* self, intptr_t slot) {
    auto* vqcpaxistickerdatetime = const_cast<VirtualQCPAxisTickerDateTime*>(dynamic_cast<const VirtualQCPAxisTickerDateTime*>(self));
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        vqcpaxistickerdatetime->setQCPAxisTickerDateTime_PickClosest_Callback(reinterpret_cast<VirtualQCPAxisTickerDateTime::QCPAxisTickerDateTime_PickClosest_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPAxisTickerDateTime_GetMantissa(const QCPAxisTickerDateTime* self, double input) {
    auto* vqcpaxistickerdatetime = const_cast<VirtualQCPAxisTickerDateTime*>(dynamic_cast<const VirtualQCPAxisTickerDateTime*>(self));
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        return vqcpaxistickerdatetime->getMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTickerDateTime*)self)->getMantissa(static_cast<double>(input));
    }
}

// Base class handler implementation
double QCPAxisTickerDateTime_QBaseGetMantissa(const QCPAxisTickerDateTime* self, double input) {
    auto* vqcpaxistickerdatetime = const_cast<VirtualQCPAxisTickerDateTime*>(dynamic_cast<const VirtualQCPAxisTickerDateTime*>(self));
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        vqcpaxistickerdatetime->setQCPAxisTickerDateTime_GetMantissa_IsBase(true);
        return vqcpaxistickerdatetime->getMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTickerDateTime*)self)->getMantissa(static_cast<double>(input));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerDateTime_OnGetMantissa(const QCPAxisTickerDateTime* self, intptr_t slot) {
    auto* vqcpaxistickerdatetime = const_cast<VirtualQCPAxisTickerDateTime*>(dynamic_cast<const VirtualQCPAxisTickerDateTime*>(self));
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        vqcpaxistickerdatetime->setQCPAxisTickerDateTime_GetMantissa_Callback(reinterpret_cast<VirtualQCPAxisTickerDateTime::QCPAxisTickerDateTime_GetMantissa_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPAxisTickerDateTime_CleanMantissa(const QCPAxisTickerDateTime* self, double input) {
    auto* vqcpaxistickerdatetime = const_cast<VirtualQCPAxisTickerDateTime*>(dynamic_cast<const VirtualQCPAxisTickerDateTime*>(self));
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        return vqcpaxistickerdatetime->cleanMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTickerDateTime*)self)->cleanMantissa(static_cast<double>(input));
    }
}

// Base class handler implementation
double QCPAxisTickerDateTime_QBaseCleanMantissa(const QCPAxisTickerDateTime* self, double input) {
    auto* vqcpaxistickerdatetime = const_cast<VirtualQCPAxisTickerDateTime*>(dynamic_cast<const VirtualQCPAxisTickerDateTime*>(self));
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        vqcpaxistickerdatetime->setQCPAxisTickerDateTime_CleanMantissa_IsBase(true);
        return vqcpaxistickerdatetime->cleanMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTickerDateTime*)self)->cleanMantissa(static_cast<double>(input));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerDateTime_OnCleanMantissa(const QCPAxisTickerDateTime* self, intptr_t slot) {
    auto* vqcpaxistickerdatetime = const_cast<VirtualQCPAxisTickerDateTime*>(dynamic_cast<const VirtualQCPAxisTickerDateTime*>(self));
    if (vqcpaxistickerdatetime && vqcpaxistickerdatetime->isVirtualQCPAxisTickerDateTime) {
        vqcpaxistickerdatetime->setQCPAxisTickerDateTime_CleanMantissa_Callback(reinterpret_cast<VirtualQCPAxisTickerDateTime::QCPAxisTickerDateTime_CleanMantissa_Callback>(slot));
    }
}

void QCPAxisTickerDateTime_Delete(QCPAxisTickerDateTime* self) {
    delete self;
}

QCPAxisTickerTime* QCPAxisTickerTime_new() {
    return new VirtualQCPAxisTickerTime();
}

libqt_string QCPAxisTickerTime_TimeFormat(const QCPAxisTickerTime* self) {
    QString _ret = self->timeFormat();
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

int QCPAxisTickerTime_FieldWidth(const QCPAxisTickerTime* self, int unit) {
    return self->fieldWidth(static_cast<QCPAxisTickerTime::TimeUnit>(unit));
}

void QCPAxisTickerTime_SetTimeFormat(QCPAxisTickerTime* self, const libqt_string format) {
    QString format_QString = QString::fromUtf8(format.data, format.len);
    self->setTimeFormat(format_QString);
}

void QCPAxisTickerTime_SetFieldWidth(QCPAxisTickerTime* self, int unit, int width) {
    self->setFieldWidth(static_cast<QCPAxisTickerTime::TimeUnit>(unit), static_cast<int>(width));
}

double QCPAxisTickerTime_GetTickStep(QCPAxisTickerTime* self, const QCPRange* range) {
    auto* vqcpaxistickertime = dynamic_cast<VirtualQCPAxisTickerTime*>(self);
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        return vqcpaxistickertime->getTickStep(*range);
    }
    return {};
}

int QCPAxisTickerTime_GetSubTickCount(QCPAxisTickerTime* self, double tickStep) {
    auto* vqcpaxistickertime = dynamic_cast<VirtualQCPAxisTickerTime*>(self);
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        return vqcpaxistickertime->getSubTickCount(static_cast<double>(tickStep));
    }
    return {};
}

libqt_string QCPAxisTickerTime_GetTickLabel(QCPAxisTickerTime* self, double tick, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxistickertime = dynamic_cast<VirtualQCPAxisTickerTime*>(self);
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        QString _ret = vqcpaxistickertime->getTickLabel(static_cast<double>(tick), *locale, *formatChar, static_cast<int>(precision));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    }
    return {};
}

// Base class handler implementation
double QCPAxisTickerTime_QBaseGetTickStep(QCPAxisTickerTime* self, const QCPRange* range) {
    auto* vqcpaxistickertime = dynamic_cast<VirtualQCPAxisTickerTime*>(self);
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->setQCPAxisTickerTime_GetTickStep_IsBase(true);
        return vqcpaxistickertime->getTickStep(*range);
    } else {
        return ((VirtualQCPAxisTickerTime*)self)->getTickStep(*range);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerTime_OnGetTickStep(QCPAxisTickerTime* self, intptr_t slot) {
    auto* vqcpaxistickertime = dynamic_cast<VirtualQCPAxisTickerTime*>(self);
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->setQCPAxisTickerTime_GetTickStep_Callback(reinterpret_cast<VirtualQCPAxisTickerTime::QCPAxisTickerTime_GetTickStep_Callback>(slot));
    }
}

// Base class handler implementation
int QCPAxisTickerTime_QBaseGetSubTickCount(QCPAxisTickerTime* self, double tickStep) {
    auto* vqcpaxistickertime = dynamic_cast<VirtualQCPAxisTickerTime*>(self);
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->setQCPAxisTickerTime_GetSubTickCount_IsBase(true);
        return vqcpaxistickertime->getSubTickCount(static_cast<double>(tickStep));
    } else {
        return ((VirtualQCPAxisTickerTime*)self)->getSubTickCount(static_cast<double>(tickStep));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerTime_OnGetSubTickCount(QCPAxisTickerTime* self, intptr_t slot) {
    auto* vqcpaxistickertime = dynamic_cast<VirtualQCPAxisTickerTime*>(self);
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->setQCPAxisTickerTime_GetSubTickCount_Callback(reinterpret_cast<VirtualQCPAxisTickerTime::QCPAxisTickerTime_GetSubTickCount_Callback>(slot));
    }
}

// Base class handler implementation
libqt_string QCPAxisTickerTime_QBaseGetTickLabel(QCPAxisTickerTime* self, double tick, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxistickertime = dynamic_cast<VirtualQCPAxisTickerTime*>(self);
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->setQCPAxisTickerTime_GetTickLabel_IsBase(true);
        QString _ret = vqcpaxistickertime->getTickLabel(static_cast<double>(tick), *locale, *formatChar, static_cast<int>(precision));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    } else {
        QString _ret = ((VirtualQCPAxisTickerTime*)self)->getTickLabel(static_cast<double>(tick), *locale, *formatChar, static_cast<int>(precision));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerTime_OnGetTickLabel(QCPAxisTickerTime* self, intptr_t slot) {
    auto* vqcpaxistickertime = dynamic_cast<VirtualQCPAxisTickerTime*>(self);
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->setQCPAxisTickerTime_GetTickLabel_Callback(reinterpret_cast<VirtualQCPAxisTickerTime::QCPAxisTickerTime_GetTickLabel_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisTickerTime_Generate(QCPAxisTickerTime* self, const QCPRange* range, const QLocale* locale, QChar* formatChar, int precision, libqt_list /* of double */ ticks, libqt_list /* of double */ subTicks, libqt_list /* of libqt_string */ tickLabels) {
    auto* vqcpaxistickertime = dynamic_cast<VirtualQCPAxisTickerTime*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    QVector<double> subTicks_QVector;
    subTicks_QVector.reserve(subTicks.len);
    double* subTicks_arr = static_cast<double*>(subTicks.data);
    for (size_t i = 0; i < subTicks.len; ++i) {
        subTicks_QVector.push_back(static_cast<double>(subTicks_arr[i]));
    }
    QVector<QString> tickLabels_QVector;
    tickLabels_QVector.reserve(tickLabels.len);
    libqt_string* tickLabels_arr = static_cast<libqt_string*>(tickLabels.data);
    for (size_t i = 0; i < tickLabels.len; ++i) {
        QString tickLabels_arr_i_QString = QString::fromUtf8(tickLabels_arr[i].data, tickLabels_arr[i].len);
        tickLabels_QVector.push_back(tickLabels_arr_i_QString);
    }
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    } else {
        self->QCPAxisTickerTime::generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    }
}

// Base class handler implementation
void QCPAxisTickerTime_QBaseGenerate(QCPAxisTickerTime* self, const QCPRange* range, const QLocale* locale, QChar* formatChar, int precision, libqt_list /* of double */ ticks, libqt_list /* of double */ subTicks, libqt_list /* of libqt_string */ tickLabels) {
    auto* vqcpaxistickertime = dynamic_cast<VirtualQCPAxisTickerTime*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    QVector<double> subTicks_QVector;
    subTicks_QVector.reserve(subTicks.len);
    double* subTicks_arr = static_cast<double*>(subTicks.data);
    for (size_t i = 0; i < subTicks.len; ++i) {
        subTicks_QVector.push_back(static_cast<double>(subTicks_arr[i]));
    }
    QVector<QString> tickLabels_QVector;
    tickLabels_QVector.reserve(tickLabels.len);
    libqt_string* tickLabels_arr = static_cast<libqt_string*>(tickLabels.data);
    for (size_t i = 0; i < tickLabels.len; ++i) {
        QString tickLabels_arr_i_QString = QString::fromUtf8(tickLabels_arr[i].data, tickLabels_arr[i].len);
        tickLabels_QVector.push_back(tickLabels_arr_i_QString);
    }
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->setQCPAxisTickerTime_Generate_IsBase(true);
        vqcpaxistickertime->generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    } else {
        self->QCPAxisTickerTime::generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerTime_OnGenerate(QCPAxisTickerTime* self, intptr_t slot) {
    auto* vqcpaxistickertime = dynamic_cast<VirtualQCPAxisTickerTime*>(self);
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->setQCPAxisTickerTime_Generate_Callback(reinterpret_cast<VirtualQCPAxisTickerTime::QCPAxisTickerTime_Generate_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of double */ QCPAxisTickerTime_CreateTickVector(QCPAxisTickerTime* self, double tickStep, const QCPRange* range) {
    auto* vqcpaxistickertime = dynamic_cast<VirtualQCPAxisTickerTime*>(self);
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        QVector<double> _ret = vqcpaxistickertime->createTickVector(static_cast<double>(tickStep), *range);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<double> _ret = ((VirtualQCPAxisTickerTime*)self)->createTickVector(static_cast<double>(tickStep), *range);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of double */ QCPAxisTickerTime_QBaseCreateTickVector(QCPAxisTickerTime* self, double tickStep, const QCPRange* range) {
    auto* vqcpaxistickertime = dynamic_cast<VirtualQCPAxisTickerTime*>(self);
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->setQCPAxisTickerTime_CreateTickVector_IsBase(true);
        QVector<double> _ret = vqcpaxistickertime->createTickVector(static_cast<double>(tickStep), *range);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<double> _ret = ((VirtualQCPAxisTickerTime*)self)->createTickVector(static_cast<double>(tickStep), *range);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerTime_OnCreateTickVector(QCPAxisTickerTime* self, intptr_t slot) {
    auto* vqcpaxistickertime = dynamic_cast<VirtualQCPAxisTickerTime*>(self);
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->setQCPAxisTickerTime_CreateTickVector_Callback(reinterpret_cast<VirtualQCPAxisTickerTime::QCPAxisTickerTime_CreateTickVector_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of double */ QCPAxisTickerTime_CreateSubTickVector(QCPAxisTickerTime* self, int subTickCount, const libqt_list /* of double */ ticks) {
    auto* vqcpaxistickertime = dynamic_cast<VirtualQCPAxisTickerTime*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        QVector<double> _ret = vqcpaxistickertime->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<double> _ret = ((VirtualQCPAxisTickerTime*)self)->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of double */ QCPAxisTickerTime_QBaseCreateSubTickVector(QCPAxisTickerTime* self, int subTickCount, const libqt_list /* of double */ ticks) {
    auto* vqcpaxistickertime = dynamic_cast<VirtualQCPAxisTickerTime*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->setQCPAxisTickerTime_CreateSubTickVector_IsBase(true);
        QVector<double> _ret = vqcpaxistickertime->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<double> _ret = ((VirtualQCPAxisTickerTime*)self)->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerTime_OnCreateSubTickVector(QCPAxisTickerTime* self, intptr_t slot) {
    auto* vqcpaxistickertime = dynamic_cast<VirtualQCPAxisTickerTime*>(self);
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->setQCPAxisTickerTime_CreateSubTickVector_Callback(reinterpret_cast<VirtualQCPAxisTickerTime::QCPAxisTickerTime_CreateSubTickVector_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of libqt_string */ QCPAxisTickerTime_CreateLabelVector(QCPAxisTickerTime* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxistickertime = dynamic_cast<VirtualQCPAxisTickerTime*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        QVector<QString> _ret = vqcpaxistickertime->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QString> _ret = ((VirtualQCPAxisTickerTime*)self)->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of libqt_string */ QCPAxisTickerTime_QBaseCreateLabelVector(QCPAxisTickerTime* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxistickertime = dynamic_cast<VirtualQCPAxisTickerTime*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->setQCPAxisTickerTime_CreateLabelVector_IsBase(true);
        QVector<QString> _ret = vqcpaxistickertime->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QString> _ret = ((VirtualQCPAxisTickerTime*)self)->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerTime_OnCreateLabelVector(QCPAxisTickerTime* self, intptr_t slot) {
    auto* vqcpaxistickertime = dynamic_cast<VirtualQCPAxisTickerTime*>(self);
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->setQCPAxisTickerTime_CreateLabelVector_Callback(reinterpret_cast<VirtualQCPAxisTickerTime::QCPAxisTickerTime_CreateLabelVector_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisTickerTime_ReplaceUnit(const QCPAxisTickerTime* self, libqt_string text, int unit, int value) {
    auto* vqcpaxistickertime = const_cast<VirtualQCPAxisTickerTime*>(dynamic_cast<const VirtualQCPAxisTickerTime*>(self));
    QString text_QString = QString::fromUtf8(text.data, text.len);
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->replaceUnit(text_QString, static_cast<QCPAxisTickerTime::TimeUnit>(unit), static_cast<int>(value));
    } else {
        ((VirtualQCPAxisTickerTime*)self)->replaceUnit(text_QString, static_cast<QCPAxisTickerTime::TimeUnit>(unit), static_cast<int>(value));
    }
}

// Base class handler implementation
void QCPAxisTickerTime_QBaseReplaceUnit(const QCPAxisTickerTime* self, libqt_string text, int unit, int value) {
    auto* vqcpaxistickertime = const_cast<VirtualQCPAxisTickerTime*>(dynamic_cast<const VirtualQCPAxisTickerTime*>(self));
    QString text_QString = QString::fromUtf8(text.data, text.len);
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->setQCPAxisTickerTime_ReplaceUnit_IsBase(true);
        vqcpaxistickertime->replaceUnit(text_QString, static_cast<QCPAxisTickerTime::TimeUnit>(unit), static_cast<int>(value));
    } else {
        ((VirtualQCPAxisTickerTime*)self)->replaceUnit(text_QString, static_cast<QCPAxisTickerTime::TimeUnit>(unit), static_cast<int>(value));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerTime_OnReplaceUnit(const QCPAxisTickerTime* self, intptr_t slot) {
    auto* vqcpaxistickertime = const_cast<VirtualQCPAxisTickerTime*>(dynamic_cast<const VirtualQCPAxisTickerTime*>(self));
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->setQCPAxisTickerTime_ReplaceUnit_Callback(reinterpret_cast<VirtualQCPAxisTickerTime::QCPAxisTickerTime_ReplaceUnit_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisTickerTime_TrimTicks(const QCPAxisTickerTime* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier) {
    auto* vqcpaxistickertime = const_cast<VirtualQCPAxisTickerTime*>(dynamic_cast<const VirtualQCPAxisTickerTime*>(self));
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->trimTicks(*range, ticks_QVector, keepOneOutlier);
    } else {
        ((VirtualQCPAxisTickerTime*)self)->trimTicks(*range, ticks_QVector, keepOneOutlier);
    }
}

// Base class handler implementation
void QCPAxisTickerTime_QBaseTrimTicks(const QCPAxisTickerTime* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier) {
    auto* vqcpaxistickertime = const_cast<VirtualQCPAxisTickerTime*>(dynamic_cast<const VirtualQCPAxisTickerTime*>(self));
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->setQCPAxisTickerTime_TrimTicks_IsBase(true);
        vqcpaxistickertime->trimTicks(*range, ticks_QVector, keepOneOutlier);
    } else {
        ((VirtualQCPAxisTickerTime*)self)->trimTicks(*range, ticks_QVector, keepOneOutlier);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerTime_OnTrimTicks(const QCPAxisTickerTime* self, intptr_t slot) {
    auto* vqcpaxistickertime = const_cast<VirtualQCPAxisTickerTime*>(dynamic_cast<const VirtualQCPAxisTickerTime*>(self));
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->setQCPAxisTickerTime_TrimTicks_Callback(reinterpret_cast<VirtualQCPAxisTickerTime::QCPAxisTickerTime_TrimTicks_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPAxisTickerTime_PickClosest(const QCPAxisTickerTime* self, double target, const libqt_list /* of double */ candidates) {
    auto* vqcpaxistickertime = const_cast<VirtualQCPAxisTickerTime*>(dynamic_cast<const VirtualQCPAxisTickerTime*>(self));
    QVector<double> candidates_QVector;
    candidates_QVector.reserve(candidates.len);
    double* candidates_arr = static_cast<double*>(candidates.data);
    for (size_t i = 0; i < candidates.len; ++i) {
        candidates_QVector.push_back(static_cast<double>(candidates_arr[i]));
    }
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        return vqcpaxistickertime->pickClosest(static_cast<double>(target), candidates_QVector);
    } else {
        return ((VirtualQCPAxisTickerTime*)self)->pickClosest(static_cast<double>(target), candidates_QVector);
    }
}

// Base class handler implementation
double QCPAxisTickerTime_QBasePickClosest(const QCPAxisTickerTime* self, double target, const libqt_list /* of double */ candidates) {
    auto* vqcpaxistickertime = const_cast<VirtualQCPAxisTickerTime*>(dynamic_cast<const VirtualQCPAxisTickerTime*>(self));
    QVector<double> candidates_QVector;
    candidates_QVector.reserve(candidates.len);
    double* candidates_arr = static_cast<double*>(candidates.data);
    for (size_t i = 0; i < candidates.len; ++i) {
        candidates_QVector.push_back(static_cast<double>(candidates_arr[i]));
    }
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->setQCPAxisTickerTime_PickClosest_IsBase(true);
        return vqcpaxistickertime->pickClosest(static_cast<double>(target), candidates_QVector);
    } else {
        return ((VirtualQCPAxisTickerTime*)self)->pickClosest(static_cast<double>(target), candidates_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerTime_OnPickClosest(const QCPAxisTickerTime* self, intptr_t slot) {
    auto* vqcpaxistickertime = const_cast<VirtualQCPAxisTickerTime*>(dynamic_cast<const VirtualQCPAxisTickerTime*>(self));
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->setQCPAxisTickerTime_PickClosest_Callback(reinterpret_cast<VirtualQCPAxisTickerTime::QCPAxisTickerTime_PickClosest_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPAxisTickerTime_GetMantissa(const QCPAxisTickerTime* self, double input) {
    auto* vqcpaxistickertime = const_cast<VirtualQCPAxisTickerTime*>(dynamic_cast<const VirtualQCPAxisTickerTime*>(self));
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        return vqcpaxistickertime->getMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTickerTime*)self)->getMantissa(static_cast<double>(input));
    }
}

// Base class handler implementation
double QCPAxisTickerTime_QBaseGetMantissa(const QCPAxisTickerTime* self, double input) {
    auto* vqcpaxistickertime = const_cast<VirtualQCPAxisTickerTime*>(dynamic_cast<const VirtualQCPAxisTickerTime*>(self));
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->setQCPAxisTickerTime_GetMantissa_IsBase(true);
        return vqcpaxistickertime->getMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTickerTime*)self)->getMantissa(static_cast<double>(input));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerTime_OnGetMantissa(const QCPAxisTickerTime* self, intptr_t slot) {
    auto* vqcpaxistickertime = const_cast<VirtualQCPAxisTickerTime*>(dynamic_cast<const VirtualQCPAxisTickerTime*>(self));
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->setQCPAxisTickerTime_GetMantissa_Callback(reinterpret_cast<VirtualQCPAxisTickerTime::QCPAxisTickerTime_GetMantissa_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPAxisTickerTime_CleanMantissa(const QCPAxisTickerTime* self, double input) {
    auto* vqcpaxistickertime = const_cast<VirtualQCPAxisTickerTime*>(dynamic_cast<const VirtualQCPAxisTickerTime*>(self));
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        return vqcpaxistickertime->cleanMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTickerTime*)self)->cleanMantissa(static_cast<double>(input));
    }
}

// Base class handler implementation
double QCPAxisTickerTime_QBaseCleanMantissa(const QCPAxisTickerTime* self, double input) {
    auto* vqcpaxistickertime = const_cast<VirtualQCPAxisTickerTime*>(dynamic_cast<const VirtualQCPAxisTickerTime*>(self));
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->setQCPAxisTickerTime_CleanMantissa_IsBase(true);
        return vqcpaxistickertime->cleanMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTickerTime*)self)->cleanMantissa(static_cast<double>(input));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerTime_OnCleanMantissa(const QCPAxisTickerTime* self, intptr_t slot) {
    auto* vqcpaxistickertime = const_cast<VirtualQCPAxisTickerTime*>(dynamic_cast<const VirtualQCPAxisTickerTime*>(self));
    if (vqcpaxistickertime && vqcpaxistickertime->isVirtualQCPAxisTickerTime) {
        vqcpaxistickertime->setQCPAxisTickerTime_CleanMantissa_Callback(reinterpret_cast<VirtualQCPAxisTickerTime::QCPAxisTickerTime_CleanMantissa_Callback>(slot));
    }
}

void QCPAxisTickerTime_Delete(QCPAxisTickerTime* self) {
    delete self;
}

QCPAxisTickerFixed* QCPAxisTickerFixed_new() {
    return new VirtualQCPAxisTickerFixed();
}

double QCPAxisTickerFixed_TickStep(const QCPAxisTickerFixed* self) {
    return self->tickStep();
}

int QCPAxisTickerFixed_ScaleStrategy(const QCPAxisTickerFixed* self) {
    return static_cast<int>(self->scaleStrategy());
}

void QCPAxisTickerFixed_SetTickStep(QCPAxisTickerFixed* self, double step) {
    self->setTickStep(static_cast<double>(step));
}

void QCPAxisTickerFixed_SetScaleStrategy(QCPAxisTickerFixed* self, int strategy) {
    self->setScaleStrategy(static_cast<QCPAxisTickerFixed::ScaleStrategy>(strategy));
}

double QCPAxisTickerFixed_GetTickStep(QCPAxisTickerFixed* self, const QCPRange* range) {
    auto* vqcpaxistickerfixed = dynamic_cast<VirtualQCPAxisTickerFixed*>(self);
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        return vqcpaxistickerfixed->getTickStep(*range);
    }
    return {};
}

// Base class handler implementation
double QCPAxisTickerFixed_QBaseGetTickStep(QCPAxisTickerFixed* self, const QCPRange* range) {
    auto* vqcpaxistickerfixed = dynamic_cast<VirtualQCPAxisTickerFixed*>(self);
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        vqcpaxistickerfixed->setQCPAxisTickerFixed_GetTickStep_IsBase(true);
        return vqcpaxistickerfixed->getTickStep(*range);
    } else {
        return ((VirtualQCPAxisTickerFixed*)self)->getTickStep(*range);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerFixed_OnGetTickStep(QCPAxisTickerFixed* self, intptr_t slot) {
    auto* vqcpaxistickerfixed = dynamic_cast<VirtualQCPAxisTickerFixed*>(self);
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        vqcpaxistickerfixed->setQCPAxisTickerFixed_GetTickStep_Callback(reinterpret_cast<VirtualQCPAxisTickerFixed::QCPAxisTickerFixed_GetTickStep_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisTickerFixed_Generate(QCPAxisTickerFixed* self, const QCPRange* range, const QLocale* locale, QChar* formatChar, int precision, libqt_list /* of double */ ticks, libqt_list /* of double */ subTicks, libqt_list /* of libqt_string */ tickLabels) {
    auto* vqcpaxistickerfixed = dynamic_cast<VirtualQCPAxisTickerFixed*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    QVector<double> subTicks_QVector;
    subTicks_QVector.reserve(subTicks.len);
    double* subTicks_arr = static_cast<double*>(subTicks.data);
    for (size_t i = 0; i < subTicks.len; ++i) {
        subTicks_QVector.push_back(static_cast<double>(subTicks_arr[i]));
    }
    QVector<QString> tickLabels_QVector;
    tickLabels_QVector.reserve(tickLabels.len);
    libqt_string* tickLabels_arr = static_cast<libqt_string*>(tickLabels.data);
    for (size_t i = 0; i < tickLabels.len; ++i) {
        QString tickLabels_arr_i_QString = QString::fromUtf8(tickLabels_arr[i].data, tickLabels_arr[i].len);
        tickLabels_QVector.push_back(tickLabels_arr_i_QString);
    }
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        vqcpaxistickerfixed->generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    } else {
        self->QCPAxisTickerFixed::generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    }
}

// Base class handler implementation
void QCPAxisTickerFixed_QBaseGenerate(QCPAxisTickerFixed* self, const QCPRange* range, const QLocale* locale, QChar* formatChar, int precision, libqt_list /* of double */ ticks, libqt_list /* of double */ subTicks, libqt_list /* of libqt_string */ tickLabels) {
    auto* vqcpaxistickerfixed = dynamic_cast<VirtualQCPAxisTickerFixed*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    QVector<double> subTicks_QVector;
    subTicks_QVector.reserve(subTicks.len);
    double* subTicks_arr = static_cast<double*>(subTicks.data);
    for (size_t i = 0; i < subTicks.len; ++i) {
        subTicks_QVector.push_back(static_cast<double>(subTicks_arr[i]));
    }
    QVector<QString> tickLabels_QVector;
    tickLabels_QVector.reserve(tickLabels.len);
    libqt_string* tickLabels_arr = static_cast<libqt_string*>(tickLabels.data);
    for (size_t i = 0; i < tickLabels.len; ++i) {
        QString tickLabels_arr_i_QString = QString::fromUtf8(tickLabels_arr[i].data, tickLabels_arr[i].len);
        tickLabels_QVector.push_back(tickLabels_arr_i_QString);
    }
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        vqcpaxistickerfixed->setQCPAxisTickerFixed_Generate_IsBase(true);
        vqcpaxistickerfixed->generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    } else {
        self->QCPAxisTickerFixed::generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerFixed_OnGenerate(QCPAxisTickerFixed* self, intptr_t slot) {
    auto* vqcpaxistickerfixed = dynamic_cast<VirtualQCPAxisTickerFixed*>(self);
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        vqcpaxistickerfixed->setQCPAxisTickerFixed_Generate_Callback(reinterpret_cast<VirtualQCPAxisTickerFixed::QCPAxisTickerFixed_Generate_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPAxisTickerFixed_GetSubTickCount(QCPAxisTickerFixed* self, double tickStep) {
    auto* vqcpaxistickerfixed = dynamic_cast<VirtualQCPAxisTickerFixed*>(self);
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        return vqcpaxistickerfixed->getSubTickCount(static_cast<double>(tickStep));
    } else {
        return ((VirtualQCPAxisTickerFixed*)self)->getSubTickCount(static_cast<double>(tickStep));
    }
}

// Base class handler implementation
int QCPAxisTickerFixed_QBaseGetSubTickCount(QCPAxisTickerFixed* self, double tickStep) {
    auto* vqcpaxistickerfixed = dynamic_cast<VirtualQCPAxisTickerFixed*>(self);
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        vqcpaxistickerfixed->setQCPAxisTickerFixed_GetSubTickCount_IsBase(true);
        return vqcpaxistickerfixed->getSubTickCount(static_cast<double>(tickStep));
    } else {
        return ((VirtualQCPAxisTickerFixed*)self)->getSubTickCount(static_cast<double>(tickStep));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerFixed_OnGetSubTickCount(QCPAxisTickerFixed* self, intptr_t slot) {
    auto* vqcpaxistickerfixed = dynamic_cast<VirtualQCPAxisTickerFixed*>(self);
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        vqcpaxistickerfixed->setQCPAxisTickerFixed_GetSubTickCount_Callback(reinterpret_cast<VirtualQCPAxisTickerFixed::QCPAxisTickerFixed_GetSubTickCount_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_string QCPAxisTickerFixed_GetTickLabel(QCPAxisTickerFixed* self, double tick, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxistickerfixed = dynamic_cast<VirtualQCPAxisTickerFixed*>(self);
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        QString _ret = vqcpaxistickerfixed->getTickLabel(static_cast<double>(tick), *locale, *formatChar, static_cast<int>(precision));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    } else {
        QString _ret = ((VirtualQCPAxisTickerFixed*)self)->getTickLabel(static_cast<double>(tick), *locale, *formatChar, static_cast<int>(precision));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    }
}

// Base class handler implementation
libqt_string QCPAxisTickerFixed_QBaseGetTickLabel(QCPAxisTickerFixed* self, double tick, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxistickerfixed = dynamic_cast<VirtualQCPAxisTickerFixed*>(self);
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        vqcpaxistickerfixed->setQCPAxisTickerFixed_GetTickLabel_IsBase(true);
        QString _ret = vqcpaxistickerfixed->getTickLabel(static_cast<double>(tick), *locale, *formatChar, static_cast<int>(precision));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    } else {
        QString _ret = ((VirtualQCPAxisTickerFixed*)self)->getTickLabel(static_cast<double>(tick), *locale, *formatChar, static_cast<int>(precision));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerFixed_OnGetTickLabel(QCPAxisTickerFixed* self, intptr_t slot) {
    auto* vqcpaxistickerfixed = dynamic_cast<VirtualQCPAxisTickerFixed*>(self);
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        vqcpaxistickerfixed->setQCPAxisTickerFixed_GetTickLabel_Callback(reinterpret_cast<VirtualQCPAxisTickerFixed::QCPAxisTickerFixed_GetTickLabel_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of double */ QCPAxisTickerFixed_CreateTickVector(QCPAxisTickerFixed* self, double tickStep, const QCPRange* range) {
    auto* vqcpaxistickerfixed = dynamic_cast<VirtualQCPAxisTickerFixed*>(self);
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        QVector<double> _ret = vqcpaxistickerfixed->createTickVector(static_cast<double>(tickStep), *range);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<double> _ret = ((VirtualQCPAxisTickerFixed*)self)->createTickVector(static_cast<double>(tickStep), *range);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of double */ QCPAxisTickerFixed_QBaseCreateTickVector(QCPAxisTickerFixed* self, double tickStep, const QCPRange* range) {
    auto* vqcpaxistickerfixed = dynamic_cast<VirtualQCPAxisTickerFixed*>(self);
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        vqcpaxistickerfixed->setQCPAxisTickerFixed_CreateTickVector_IsBase(true);
        QVector<double> _ret = vqcpaxistickerfixed->createTickVector(static_cast<double>(tickStep), *range);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<double> _ret = ((VirtualQCPAxisTickerFixed*)self)->createTickVector(static_cast<double>(tickStep), *range);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerFixed_OnCreateTickVector(QCPAxisTickerFixed* self, intptr_t slot) {
    auto* vqcpaxistickerfixed = dynamic_cast<VirtualQCPAxisTickerFixed*>(self);
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        vqcpaxistickerfixed->setQCPAxisTickerFixed_CreateTickVector_Callback(reinterpret_cast<VirtualQCPAxisTickerFixed::QCPAxisTickerFixed_CreateTickVector_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of double */ QCPAxisTickerFixed_CreateSubTickVector(QCPAxisTickerFixed* self, int subTickCount, const libqt_list /* of double */ ticks) {
    auto* vqcpaxistickerfixed = dynamic_cast<VirtualQCPAxisTickerFixed*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        QVector<double> _ret = vqcpaxistickerfixed->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<double> _ret = ((VirtualQCPAxisTickerFixed*)self)->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of double */ QCPAxisTickerFixed_QBaseCreateSubTickVector(QCPAxisTickerFixed* self, int subTickCount, const libqt_list /* of double */ ticks) {
    auto* vqcpaxistickerfixed = dynamic_cast<VirtualQCPAxisTickerFixed*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        vqcpaxistickerfixed->setQCPAxisTickerFixed_CreateSubTickVector_IsBase(true);
        QVector<double> _ret = vqcpaxistickerfixed->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<double> _ret = ((VirtualQCPAxisTickerFixed*)self)->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerFixed_OnCreateSubTickVector(QCPAxisTickerFixed* self, intptr_t slot) {
    auto* vqcpaxistickerfixed = dynamic_cast<VirtualQCPAxisTickerFixed*>(self);
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        vqcpaxistickerfixed->setQCPAxisTickerFixed_CreateSubTickVector_Callback(reinterpret_cast<VirtualQCPAxisTickerFixed::QCPAxisTickerFixed_CreateSubTickVector_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of libqt_string */ QCPAxisTickerFixed_CreateLabelVector(QCPAxisTickerFixed* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxistickerfixed = dynamic_cast<VirtualQCPAxisTickerFixed*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        QVector<QString> _ret = vqcpaxistickerfixed->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QString> _ret = ((VirtualQCPAxisTickerFixed*)self)->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of libqt_string */ QCPAxisTickerFixed_QBaseCreateLabelVector(QCPAxisTickerFixed* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxistickerfixed = dynamic_cast<VirtualQCPAxisTickerFixed*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        vqcpaxistickerfixed->setQCPAxisTickerFixed_CreateLabelVector_IsBase(true);
        QVector<QString> _ret = vqcpaxistickerfixed->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QString> _ret = ((VirtualQCPAxisTickerFixed*)self)->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerFixed_OnCreateLabelVector(QCPAxisTickerFixed* self, intptr_t slot) {
    auto* vqcpaxistickerfixed = dynamic_cast<VirtualQCPAxisTickerFixed*>(self);
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        vqcpaxistickerfixed->setQCPAxisTickerFixed_CreateLabelVector_Callback(reinterpret_cast<VirtualQCPAxisTickerFixed::QCPAxisTickerFixed_CreateLabelVector_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisTickerFixed_TrimTicks(const QCPAxisTickerFixed* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier) {
    auto* vqcpaxistickerfixed = const_cast<VirtualQCPAxisTickerFixed*>(dynamic_cast<const VirtualQCPAxisTickerFixed*>(self));
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        vqcpaxistickerfixed->trimTicks(*range, ticks_QVector, keepOneOutlier);
    } else {
        ((VirtualQCPAxisTickerFixed*)self)->trimTicks(*range, ticks_QVector, keepOneOutlier);
    }
}

// Base class handler implementation
void QCPAxisTickerFixed_QBaseTrimTicks(const QCPAxisTickerFixed* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier) {
    auto* vqcpaxistickerfixed = const_cast<VirtualQCPAxisTickerFixed*>(dynamic_cast<const VirtualQCPAxisTickerFixed*>(self));
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        vqcpaxistickerfixed->setQCPAxisTickerFixed_TrimTicks_IsBase(true);
        vqcpaxistickerfixed->trimTicks(*range, ticks_QVector, keepOneOutlier);
    } else {
        ((VirtualQCPAxisTickerFixed*)self)->trimTicks(*range, ticks_QVector, keepOneOutlier);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerFixed_OnTrimTicks(const QCPAxisTickerFixed* self, intptr_t slot) {
    auto* vqcpaxistickerfixed = const_cast<VirtualQCPAxisTickerFixed*>(dynamic_cast<const VirtualQCPAxisTickerFixed*>(self));
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        vqcpaxistickerfixed->setQCPAxisTickerFixed_TrimTicks_Callback(reinterpret_cast<VirtualQCPAxisTickerFixed::QCPAxisTickerFixed_TrimTicks_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPAxisTickerFixed_PickClosest(const QCPAxisTickerFixed* self, double target, const libqt_list /* of double */ candidates) {
    auto* vqcpaxistickerfixed = const_cast<VirtualQCPAxisTickerFixed*>(dynamic_cast<const VirtualQCPAxisTickerFixed*>(self));
    QVector<double> candidates_QVector;
    candidates_QVector.reserve(candidates.len);
    double* candidates_arr = static_cast<double*>(candidates.data);
    for (size_t i = 0; i < candidates.len; ++i) {
        candidates_QVector.push_back(static_cast<double>(candidates_arr[i]));
    }
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        return vqcpaxistickerfixed->pickClosest(static_cast<double>(target), candidates_QVector);
    } else {
        return ((VirtualQCPAxisTickerFixed*)self)->pickClosest(static_cast<double>(target), candidates_QVector);
    }
}

// Base class handler implementation
double QCPAxisTickerFixed_QBasePickClosest(const QCPAxisTickerFixed* self, double target, const libqt_list /* of double */ candidates) {
    auto* vqcpaxistickerfixed = const_cast<VirtualQCPAxisTickerFixed*>(dynamic_cast<const VirtualQCPAxisTickerFixed*>(self));
    QVector<double> candidates_QVector;
    candidates_QVector.reserve(candidates.len);
    double* candidates_arr = static_cast<double*>(candidates.data);
    for (size_t i = 0; i < candidates.len; ++i) {
        candidates_QVector.push_back(static_cast<double>(candidates_arr[i]));
    }
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        vqcpaxistickerfixed->setQCPAxisTickerFixed_PickClosest_IsBase(true);
        return vqcpaxistickerfixed->pickClosest(static_cast<double>(target), candidates_QVector);
    } else {
        return ((VirtualQCPAxisTickerFixed*)self)->pickClosest(static_cast<double>(target), candidates_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerFixed_OnPickClosest(const QCPAxisTickerFixed* self, intptr_t slot) {
    auto* vqcpaxistickerfixed = const_cast<VirtualQCPAxisTickerFixed*>(dynamic_cast<const VirtualQCPAxisTickerFixed*>(self));
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        vqcpaxistickerfixed->setQCPAxisTickerFixed_PickClosest_Callback(reinterpret_cast<VirtualQCPAxisTickerFixed::QCPAxisTickerFixed_PickClosest_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPAxisTickerFixed_GetMantissa(const QCPAxisTickerFixed* self, double input) {
    auto* vqcpaxistickerfixed = const_cast<VirtualQCPAxisTickerFixed*>(dynamic_cast<const VirtualQCPAxisTickerFixed*>(self));
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        return vqcpaxistickerfixed->getMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTickerFixed*)self)->getMantissa(static_cast<double>(input));
    }
}

// Base class handler implementation
double QCPAxisTickerFixed_QBaseGetMantissa(const QCPAxisTickerFixed* self, double input) {
    auto* vqcpaxistickerfixed = const_cast<VirtualQCPAxisTickerFixed*>(dynamic_cast<const VirtualQCPAxisTickerFixed*>(self));
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        vqcpaxistickerfixed->setQCPAxisTickerFixed_GetMantissa_IsBase(true);
        return vqcpaxistickerfixed->getMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTickerFixed*)self)->getMantissa(static_cast<double>(input));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerFixed_OnGetMantissa(const QCPAxisTickerFixed* self, intptr_t slot) {
    auto* vqcpaxistickerfixed = const_cast<VirtualQCPAxisTickerFixed*>(dynamic_cast<const VirtualQCPAxisTickerFixed*>(self));
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        vqcpaxistickerfixed->setQCPAxisTickerFixed_GetMantissa_Callback(reinterpret_cast<VirtualQCPAxisTickerFixed::QCPAxisTickerFixed_GetMantissa_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPAxisTickerFixed_CleanMantissa(const QCPAxisTickerFixed* self, double input) {
    auto* vqcpaxistickerfixed = const_cast<VirtualQCPAxisTickerFixed*>(dynamic_cast<const VirtualQCPAxisTickerFixed*>(self));
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        return vqcpaxistickerfixed->cleanMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTickerFixed*)self)->cleanMantissa(static_cast<double>(input));
    }
}

// Base class handler implementation
double QCPAxisTickerFixed_QBaseCleanMantissa(const QCPAxisTickerFixed* self, double input) {
    auto* vqcpaxistickerfixed = const_cast<VirtualQCPAxisTickerFixed*>(dynamic_cast<const VirtualQCPAxisTickerFixed*>(self));
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        vqcpaxistickerfixed->setQCPAxisTickerFixed_CleanMantissa_IsBase(true);
        return vqcpaxistickerfixed->cleanMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTickerFixed*)self)->cleanMantissa(static_cast<double>(input));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerFixed_OnCleanMantissa(const QCPAxisTickerFixed* self, intptr_t slot) {
    auto* vqcpaxistickerfixed = const_cast<VirtualQCPAxisTickerFixed*>(dynamic_cast<const VirtualQCPAxisTickerFixed*>(self));
    if (vqcpaxistickerfixed && vqcpaxistickerfixed->isVirtualQCPAxisTickerFixed) {
        vqcpaxistickerfixed->setQCPAxisTickerFixed_CleanMantissa_Callback(reinterpret_cast<VirtualQCPAxisTickerFixed::QCPAxisTickerFixed_CleanMantissa_Callback>(slot));
    }
}

void QCPAxisTickerFixed_Delete(QCPAxisTickerFixed* self) {
    delete self;
}

QCPAxisTickerText* QCPAxisTickerText_new() {
    return new VirtualQCPAxisTickerText();
}

libqt_map /* of double to libqt_string */ QCPAxisTickerText_Ticks(QCPAxisTickerText* self) {
    QMap<double, QString>& _ret = self->ticks();
    // Convert QMap<> from C++ memory to manually-managed C memory
    double* _karr = static_cast<double*>(malloc(sizeof(double) * _ret.size()));
    libqt_string* _varr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * _ret.size()));
    int _ctr = 0;
    for (auto _itr = _ret.keyValueBegin(); _itr != _ret.keyValueEnd(); ++_itr) {
        _karr[_ctr] = _itr->first;
        QString _mapval_ret = _itr->second;
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _mapval_b = _mapval_ret.toUtf8();
        libqt_string _mapval_str;
        _mapval_str.len = _mapval_b.length();
        _mapval_str.data = static_cast<const char*>(malloc(_mapval_str.len + 1));
        memcpy((void*)_mapval_str.data, _mapval_b.data(), _mapval_str.len);
        ((char*)_mapval_str.data)[_mapval_str.len] = '\0';
        _varr[_ctr] = _mapval_str;
        _ctr++;
    }
    libqt_map _out;
    _out.len = _ret.size();
    _out.keys = static_cast<void*>(_karr);
    _out.values = static_cast<void*>(_varr);
    return _out;
}

int QCPAxisTickerText_SubTickCount(const QCPAxisTickerText* self) {
    return self->subTickCount();
}

void QCPAxisTickerText_SetTicks(QCPAxisTickerText* self, const libqt_map /* of double to libqt_string */ ticks) {
    QMap<double, QString> ticks_QMap;
    double* ticks_karr = static_cast<double*>(ticks.keys);
    libqt_string* ticks_varr = static_cast<libqt_string*>(ticks.values);
    for (size_t i = 0; i < ticks.len; ++i) {
        QString ticks_varr_i_QString = QString::fromUtf8(ticks_varr[i].data, ticks_varr[i].len);
        ticks_QMap[static_cast<double>(ticks_karr[i])] = ticks_varr_i_QString;
    }
    self->setTicks(ticks_QMap);
}

void QCPAxisTickerText_SetTicks2(QCPAxisTickerText* self, const libqt_list /* of double */ positions, const libqt_list /* of libqt_string */ labels) {
    QVector<double> positions_QVector;
    positions_QVector.reserve(positions.len);
    double* positions_arr = static_cast<double*>(positions.data);
    for (size_t i = 0; i < positions.len; ++i) {
        positions_QVector.push_back(static_cast<double>(positions_arr[i]));
    }
    QVector<QString> labels_QVector;
    labels_QVector.reserve(labels.len);
    libqt_string* labels_arr = static_cast<libqt_string*>(labels.data);
    for (size_t i = 0; i < labels.len; ++i) {
        QString labels_arr_i_QString = QString::fromUtf8(labels_arr[i].data, labels_arr[i].len);
        labels_QVector.push_back(labels_arr_i_QString);
    }
    self->setTicks(positions_QVector, labels_QVector);
}

void QCPAxisTickerText_SetSubTickCount(QCPAxisTickerText* self, int subTicks) {
    self->setSubTickCount(static_cast<int>(subTicks));
}

void QCPAxisTickerText_Clear(QCPAxisTickerText* self) {
    self->clear();
}

void QCPAxisTickerText_AddTick(QCPAxisTickerText* self, double position, const libqt_string label) {
    QString label_QString = QString::fromUtf8(label.data, label.len);
    self->addTick(static_cast<double>(position), label_QString);
}

void QCPAxisTickerText_AddTicks(QCPAxisTickerText* self, const libqt_map /* of double to libqt_string */ ticks) {
    QMap<double, QString> ticks_QMap;
    double* ticks_karr = static_cast<double*>(ticks.keys);
    libqt_string* ticks_varr = static_cast<libqt_string*>(ticks.values);
    for (size_t i = 0; i < ticks.len; ++i) {
        QString ticks_varr_i_QString = QString::fromUtf8(ticks_varr[i].data, ticks_varr[i].len);
        ticks_QMap[static_cast<double>(ticks_karr[i])] = ticks_varr_i_QString;
    }
    self->addTicks(ticks_QMap);
}

void QCPAxisTickerText_AddTicks2(QCPAxisTickerText* self, const libqt_list /* of double */ positions, const libqt_list /* of libqt_string */ labels) {
    QVector<double> positions_QVector;
    positions_QVector.reserve(positions.len);
    double* positions_arr = static_cast<double*>(positions.data);
    for (size_t i = 0; i < positions.len; ++i) {
        positions_QVector.push_back(static_cast<double>(positions_arr[i]));
    }
    QVector<QString> labels_QVector;
    labels_QVector.reserve(labels.len);
    libqt_string* labels_arr = static_cast<libqt_string*>(labels.data);
    for (size_t i = 0; i < labels.len; ++i) {
        QString labels_arr_i_QString = QString::fromUtf8(labels_arr[i].data, labels_arr[i].len);
        labels_QVector.push_back(labels_arr_i_QString);
    }
    self->addTicks(positions_QVector, labels_QVector);
}

double QCPAxisTickerText_GetTickStep(QCPAxisTickerText* self, const QCPRange* range) {
    auto* vqcpaxistickertext = dynamic_cast<VirtualQCPAxisTickerText*>(self);
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        return vqcpaxistickertext->getTickStep(*range);
    }
    return {};
}

int QCPAxisTickerText_GetSubTickCount(QCPAxisTickerText* self, double tickStep) {
    auto* vqcpaxistickertext = dynamic_cast<VirtualQCPAxisTickerText*>(self);
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        return vqcpaxistickertext->getSubTickCount(static_cast<double>(tickStep));
    }
    return {};
}

libqt_string QCPAxisTickerText_GetTickLabel(QCPAxisTickerText* self, double tick, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxistickertext = dynamic_cast<VirtualQCPAxisTickerText*>(self);
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        QString _ret = vqcpaxistickertext->getTickLabel(static_cast<double>(tick), *locale, *formatChar, static_cast<int>(precision));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    }
    return {};
}

libqt_list /* of double */ QCPAxisTickerText_CreateTickVector(QCPAxisTickerText* self, double tickStep, const QCPRange* range) {
    auto* vqcpaxistickertext = dynamic_cast<VirtualQCPAxisTickerText*>(self);
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        QVector<double> _ret = vqcpaxistickertext->createTickVector(static_cast<double>(tickStep), *range);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
    return {};
}

// Base class handler implementation
double QCPAxisTickerText_QBaseGetTickStep(QCPAxisTickerText* self, const QCPRange* range) {
    auto* vqcpaxistickertext = dynamic_cast<VirtualQCPAxisTickerText*>(self);
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        vqcpaxistickertext->setQCPAxisTickerText_GetTickStep_IsBase(true);
        return vqcpaxistickertext->getTickStep(*range);
    } else {
        return ((VirtualQCPAxisTickerText*)self)->getTickStep(*range);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerText_OnGetTickStep(QCPAxisTickerText* self, intptr_t slot) {
    auto* vqcpaxistickertext = dynamic_cast<VirtualQCPAxisTickerText*>(self);
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        vqcpaxistickertext->setQCPAxisTickerText_GetTickStep_Callback(reinterpret_cast<VirtualQCPAxisTickerText::QCPAxisTickerText_GetTickStep_Callback>(slot));
    }
}

// Base class handler implementation
int QCPAxisTickerText_QBaseGetSubTickCount(QCPAxisTickerText* self, double tickStep) {
    auto* vqcpaxistickertext = dynamic_cast<VirtualQCPAxisTickerText*>(self);
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        vqcpaxistickertext->setQCPAxisTickerText_GetSubTickCount_IsBase(true);
        return vqcpaxistickertext->getSubTickCount(static_cast<double>(tickStep));
    } else {
        return ((VirtualQCPAxisTickerText*)self)->getSubTickCount(static_cast<double>(tickStep));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerText_OnGetSubTickCount(QCPAxisTickerText* self, intptr_t slot) {
    auto* vqcpaxistickertext = dynamic_cast<VirtualQCPAxisTickerText*>(self);
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        vqcpaxistickertext->setQCPAxisTickerText_GetSubTickCount_Callback(reinterpret_cast<VirtualQCPAxisTickerText::QCPAxisTickerText_GetSubTickCount_Callback>(slot));
    }
}

// Base class handler implementation
libqt_string QCPAxisTickerText_QBaseGetTickLabel(QCPAxisTickerText* self, double tick, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxistickertext = dynamic_cast<VirtualQCPAxisTickerText*>(self);
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        vqcpaxistickertext->setQCPAxisTickerText_GetTickLabel_IsBase(true);
        QString _ret = vqcpaxistickertext->getTickLabel(static_cast<double>(tick), *locale, *formatChar, static_cast<int>(precision));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    } else {
        QString _ret = ((VirtualQCPAxisTickerText*)self)->getTickLabel(static_cast<double>(tick), *locale, *formatChar, static_cast<int>(precision));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerText_OnGetTickLabel(QCPAxisTickerText* self, intptr_t slot) {
    auto* vqcpaxistickertext = dynamic_cast<VirtualQCPAxisTickerText*>(self);
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        vqcpaxistickertext->setQCPAxisTickerText_GetTickLabel_Callback(reinterpret_cast<VirtualQCPAxisTickerText::QCPAxisTickerText_GetTickLabel_Callback>(slot));
    }
}

// Base class handler implementation
libqt_list /* of double */ QCPAxisTickerText_QBaseCreateTickVector(QCPAxisTickerText* self, double tickStep, const QCPRange* range) {
    auto* vqcpaxistickertext = dynamic_cast<VirtualQCPAxisTickerText*>(self);
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        vqcpaxistickertext->setQCPAxisTickerText_CreateTickVector_IsBase(true);
        QVector<double> _ret = vqcpaxistickertext->createTickVector(static_cast<double>(tickStep), *range);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<double> _ret = ((VirtualQCPAxisTickerText*)self)->createTickVector(static_cast<double>(tickStep), *range);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerText_OnCreateTickVector(QCPAxisTickerText* self, intptr_t slot) {
    auto* vqcpaxistickertext = dynamic_cast<VirtualQCPAxisTickerText*>(self);
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        vqcpaxistickertext->setQCPAxisTickerText_CreateTickVector_Callback(reinterpret_cast<VirtualQCPAxisTickerText::QCPAxisTickerText_CreateTickVector_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisTickerText_Generate(QCPAxisTickerText* self, const QCPRange* range, const QLocale* locale, QChar* formatChar, int precision, libqt_list /* of double */ ticks, libqt_list /* of double */ subTicks, libqt_list /* of libqt_string */ tickLabels) {
    auto* vqcpaxistickertext = dynamic_cast<VirtualQCPAxisTickerText*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    QVector<double> subTicks_QVector;
    subTicks_QVector.reserve(subTicks.len);
    double* subTicks_arr = static_cast<double*>(subTicks.data);
    for (size_t i = 0; i < subTicks.len; ++i) {
        subTicks_QVector.push_back(static_cast<double>(subTicks_arr[i]));
    }
    QVector<QString> tickLabels_QVector;
    tickLabels_QVector.reserve(tickLabels.len);
    libqt_string* tickLabels_arr = static_cast<libqt_string*>(tickLabels.data);
    for (size_t i = 0; i < tickLabels.len; ++i) {
        QString tickLabels_arr_i_QString = QString::fromUtf8(tickLabels_arr[i].data, tickLabels_arr[i].len);
        tickLabels_QVector.push_back(tickLabels_arr_i_QString);
    }
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        vqcpaxistickertext->generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    } else {
        self->QCPAxisTickerText::generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    }
}

// Base class handler implementation
void QCPAxisTickerText_QBaseGenerate(QCPAxisTickerText* self, const QCPRange* range, const QLocale* locale, QChar* formatChar, int precision, libqt_list /* of double */ ticks, libqt_list /* of double */ subTicks, libqt_list /* of libqt_string */ tickLabels) {
    auto* vqcpaxistickertext = dynamic_cast<VirtualQCPAxisTickerText*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    QVector<double> subTicks_QVector;
    subTicks_QVector.reserve(subTicks.len);
    double* subTicks_arr = static_cast<double*>(subTicks.data);
    for (size_t i = 0; i < subTicks.len; ++i) {
        subTicks_QVector.push_back(static_cast<double>(subTicks_arr[i]));
    }
    QVector<QString> tickLabels_QVector;
    tickLabels_QVector.reserve(tickLabels.len);
    libqt_string* tickLabels_arr = static_cast<libqt_string*>(tickLabels.data);
    for (size_t i = 0; i < tickLabels.len; ++i) {
        QString tickLabels_arr_i_QString = QString::fromUtf8(tickLabels_arr[i].data, tickLabels_arr[i].len);
        tickLabels_QVector.push_back(tickLabels_arr_i_QString);
    }
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        vqcpaxistickertext->setQCPAxisTickerText_Generate_IsBase(true);
        vqcpaxistickertext->generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    } else {
        self->QCPAxisTickerText::generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerText_OnGenerate(QCPAxisTickerText* self, intptr_t slot) {
    auto* vqcpaxistickertext = dynamic_cast<VirtualQCPAxisTickerText*>(self);
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        vqcpaxistickertext->setQCPAxisTickerText_Generate_Callback(reinterpret_cast<VirtualQCPAxisTickerText::QCPAxisTickerText_Generate_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of double */ QCPAxisTickerText_CreateSubTickVector(QCPAxisTickerText* self, int subTickCount, const libqt_list /* of double */ ticks) {
    auto* vqcpaxistickertext = dynamic_cast<VirtualQCPAxisTickerText*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        QVector<double> _ret = vqcpaxistickertext->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<double> _ret = ((VirtualQCPAxisTickerText*)self)->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of double */ QCPAxisTickerText_QBaseCreateSubTickVector(QCPAxisTickerText* self, int subTickCount, const libqt_list /* of double */ ticks) {
    auto* vqcpaxistickertext = dynamic_cast<VirtualQCPAxisTickerText*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        vqcpaxistickertext->setQCPAxisTickerText_CreateSubTickVector_IsBase(true);
        QVector<double> _ret = vqcpaxistickertext->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<double> _ret = ((VirtualQCPAxisTickerText*)self)->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerText_OnCreateSubTickVector(QCPAxisTickerText* self, intptr_t slot) {
    auto* vqcpaxistickertext = dynamic_cast<VirtualQCPAxisTickerText*>(self);
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        vqcpaxistickertext->setQCPAxisTickerText_CreateSubTickVector_Callback(reinterpret_cast<VirtualQCPAxisTickerText::QCPAxisTickerText_CreateSubTickVector_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of libqt_string */ QCPAxisTickerText_CreateLabelVector(QCPAxisTickerText* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxistickertext = dynamic_cast<VirtualQCPAxisTickerText*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        QVector<QString> _ret = vqcpaxistickertext->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QString> _ret = ((VirtualQCPAxisTickerText*)self)->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of libqt_string */ QCPAxisTickerText_QBaseCreateLabelVector(QCPAxisTickerText* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxistickertext = dynamic_cast<VirtualQCPAxisTickerText*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        vqcpaxistickertext->setQCPAxisTickerText_CreateLabelVector_IsBase(true);
        QVector<QString> _ret = vqcpaxistickertext->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QString> _ret = ((VirtualQCPAxisTickerText*)self)->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerText_OnCreateLabelVector(QCPAxisTickerText* self, intptr_t slot) {
    auto* vqcpaxistickertext = dynamic_cast<VirtualQCPAxisTickerText*>(self);
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        vqcpaxistickertext->setQCPAxisTickerText_CreateLabelVector_Callback(reinterpret_cast<VirtualQCPAxisTickerText::QCPAxisTickerText_CreateLabelVector_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisTickerText_TrimTicks(const QCPAxisTickerText* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier) {
    auto* vqcpaxistickertext = const_cast<VirtualQCPAxisTickerText*>(dynamic_cast<const VirtualQCPAxisTickerText*>(self));
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        vqcpaxistickertext->trimTicks(*range, ticks_QVector, keepOneOutlier);
    } else {
        ((VirtualQCPAxisTickerText*)self)->trimTicks(*range, ticks_QVector, keepOneOutlier);
    }
}

// Base class handler implementation
void QCPAxisTickerText_QBaseTrimTicks(const QCPAxisTickerText* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier) {
    auto* vqcpaxistickertext = const_cast<VirtualQCPAxisTickerText*>(dynamic_cast<const VirtualQCPAxisTickerText*>(self));
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        vqcpaxistickertext->setQCPAxisTickerText_TrimTicks_IsBase(true);
        vqcpaxistickertext->trimTicks(*range, ticks_QVector, keepOneOutlier);
    } else {
        ((VirtualQCPAxisTickerText*)self)->trimTicks(*range, ticks_QVector, keepOneOutlier);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerText_OnTrimTicks(const QCPAxisTickerText* self, intptr_t slot) {
    auto* vqcpaxistickertext = const_cast<VirtualQCPAxisTickerText*>(dynamic_cast<const VirtualQCPAxisTickerText*>(self));
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        vqcpaxistickertext->setQCPAxisTickerText_TrimTicks_Callback(reinterpret_cast<VirtualQCPAxisTickerText::QCPAxisTickerText_TrimTicks_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPAxisTickerText_PickClosest(const QCPAxisTickerText* self, double target, const libqt_list /* of double */ candidates) {
    auto* vqcpaxistickertext = const_cast<VirtualQCPAxisTickerText*>(dynamic_cast<const VirtualQCPAxisTickerText*>(self));
    QVector<double> candidates_QVector;
    candidates_QVector.reserve(candidates.len);
    double* candidates_arr = static_cast<double*>(candidates.data);
    for (size_t i = 0; i < candidates.len; ++i) {
        candidates_QVector.push_back(static_cast<double>(candidates_arr[i]));
    }
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        return vqcpaxistickertext->pickClosest(static_cast<double>(target), candidates_QVector);
    } else {
        return ((VirtualQCPAxisTickerText*)self)->pickClosest(static_cast<double>(target), candidates_QVector);
    }
}

// Base class handler implementation
double QCPAxisTickerText_QBasePickClosest(const QCPAxisTickerText* self, double target, const libqt_list /* of double */ candidates) {
    auto* vqcpaxistickertext = const_cast<VirtualQCPAxisTickerText*>(dynamic_cast<const VirtualQCPAxisTickerText*>(self));
    QVector<double> candidates_QVector;
    candidates_QVector.reserve(candidates.len);
    double* candidates_arr = static_cast<double*>(candidates.data);
    for (size_t i = 0; i < candidates.len; ++i) {
        candidates_QVector.push_back(static_cast<double>(candidates_arr[i]));
    }
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        vqcpaxistickertext->setQCPAxisTickerText_PickClosest_IsBase(true);
        return vqcpaxistickertext->pickClosest(static_cast<double>(target), candidates_QVector);
    } else {
        return ((VirtualQCPAxisTickerText*)self)->pickClosest(static_cast<double>(target), candidates_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerText_OnPickClosest(const QCPAxisTickerText* self, intptr_t slot) {
    auto* vqcpaxistickertext = const_cast<VirtualQCPAxisTickerText*>(dynamic_cast<const VirtualQCPAxisTickerText*>(self));
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        vqcpaxistickertext->setQCPAxisTickerText_PickClosest_Callback(reinterpret_cast<VirtualQCPAxisTickerText::QCPAxisTickerText_PickClosest_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPAxisTickerText_GetMantissa(const QCPAxisTickerText* self, double input) {
    auto* vqcpaxistickertext = const_cast<VirtualQCPAxisTickerText*>(dynamic_cast<const VirtualQCPAxisTickerText*>(self));
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        return vqcpaxistickertext->getMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTickerText*)self)->getMantissa(static_cast<double>(input));
    }
}

// Base class handler implementation
double QCPAxisTickerText_QBaseGetMantissa(const QCPAxisTickerText* self, double input) {
    auto* vqcpaxistickertext = const_cast<VirtualQCPAxisTickerText*>(dynamic_cast<const VirtualQCPAxisTickerText*>(self));
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        vqcpaxistickertext->setQCPAxisTickerText_GetMantissa_IsBase(true);
        return vqcpaxistickertext->getMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTickerText*)self)->getMantissa(static_cast<double>(input));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerText_OnGetMantissa(const QCPAxisTickerText* self, intptr_t slot) {
    auto* vqcpaxistickertext = const_cast<VirtualQCPAxisTickerText*>(dynamic_cast<const VirtualQCPAxisTickerText*>(self));
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        vqcpaxistickertext->setQCPAxisTickerText_GetMantissa_Callback(reinterpret_cast<VirtualQCPAxisTickerText::QCPAxisTickerText_GetMantissa_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPAxisTickerText_CleanMantissa(const QCPAxisTickerText* self, double input) {
    auto* vqcpaxistickertext = const_cast<VirtualQCPAxisTickerText*>(dynamic_cast<const VirtualQCPAxisTickerText*>(self));
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        return vqcpaxistickertext->cleanMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTickerText*)self)->cleanMantissa(static_cast<double>(input));
    }
}

// Base class handler implementation
double QCPAxisTickerText_QBaseCleanMantissa(const QCPAxisTickerText* self, double input) {
    auto* vqcpaxistickertext = const_cast<VirtualQCPAxisTickerText*>(dynamic_cast<const VirtualQCPAxisTickerText*>(self));
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        vqcpaxistickertext->setQCPAxisTickerText_CleanMantissa_IsBase(true);
        return vqcpaxistickertext->cleanMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTickerText*)self)->cleanMantissa(static_cast<double>(input));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerText_OnCleanMantissa(const QCPAxisTickerText* self, intptr_t slot) {
    auto* vqcpaxistickertext = const_cast<VirtualQCPAxisTickerText*>(dynamic_cast<const VirtualQCPAxisTickerText*>(self));
    if (vqcpaxistickertext && vqcpaxistickertext->isVirtualQCPAxisTickerText) {
        vqcpaxistickertext->setQCPAxisTickerText_CleanMantissa_Callback(reinterpret_cast<VirtualQCPAxisTickerText::QCPAxisTickerText_CleanMantissa_Callback>(slot));
    }
}

void QCPAxisTickerText_Delete(QCPAxisTickerText* self) {
    delete self;
}

QCPAxisTickerPi* QCPAxisTickerPi_new() {
    return new VirtualQCPAxisTickerPi();
}

libqt_string QCPAxisTickerPi_PiSymbol(const QCPAxisTickerPi* self) {
    QString _ret = self->piSymbol();
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

double QCPAxisTickerPi_PiValue(const QCPAxisTickerPi* self) {
    return self->piValue();
}

bool QCPAxisTickerPi_Periodicity(const QCPAxisTickerPi* self) {
    return self->periodicity();
}

int QCPAxisTickerPi_FractionStyle(const QCPAxisTickerPi* self) {
    return static_cast<int>(self->fractionStyle());
}

void QCPAxisTickerPi_SetPiSymbol(QCPAxisTickerPi* self, libqt_string symbol) {
    QString symbol_QString = QString::fromUtf8(symbol.data, symbol.len);
    self->setPiSymbol(symbol_QString);
}

void QCPAxisTickerPi_SetPiValue(QCPAxisTickerPi* self, double pi) {
    self->setPiValue(static_cast<double>(pi));
}

void QCPAxisTickerPi_SetPeriodicity(QCPAxisTickerPi* self, int multiplesOfPi) {
    self->setPeriodicity(static_cast<int>(multiplesOfPi));
}

void QCPAxisTickerPi_SetFractionStyle(QCPAxisTickerPi* self, int style) {
    self->setFractionStyle(static_cast<QCPAxisTickerPi::FractionStyle>(style));
}

double QCPAxisTickerPi_GetTickStep(QCPAxisTickerPi* self, const QCPRange* range) {
    auto* vqcpaxistickerpi = dynamic_cast<VirtualQCPAxisTickerPi*>(self);
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        return vqcpaxistickerpi->getTickStep(*range);
    }
    return {};
}

int QCPAxisTickerPi_GetSubTickCount(QCPAxisTickerPi* self, double tickStep) {
    auto* vqcpaxistickerpi = dynamic_cast<VirtualQCPAxisTickerPi*>(self);
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        return vqcpaxistickerpi->getSubTickCount(static_cast<double>(tickStep));
    }
    return {};
}

libqt_string QCPAxisTickerPi_GetTickLabel(QCPAxisTickerPi* self, double tick, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxistickerpi = dynamic_cast<VirtualQCPAxisTickerPi*>(self);
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        QString _ret = vqcpaxistickerpi->getTickLabel(static_cast<double>(tick), *locale, *formatChar, static_cast<int>(precision));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    }
    return {};
}

// Base class handler implementation
double QCPAxisTickerPi_QBaseGetTickStep(QCPAxisTickerPi* self, const QCPRange* range) {
    auto* vqcpaxistickerpi = dynamic_cast<VirtualQCPAxisTickerPi*>(self);
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_GetTickStep_IsBase(true);
        return vqcpaxistickerpi->getTickStep(*range);
    } else {
        return ((VirtualQCPAxisTickerPi*)self)->getTickStep(*range);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerPi_OnGetTickStep(QCPAxisTickerPi* self, intptr_t slot) {
    auto* vqcpaxistickerpi = dynamic_cast<VirtualQCPAxisTickerPi*>(self);
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_GetTickStep_Callback(reinterpret_cast<VirtualQCPAxisTickerPi::QCPAxisTickerPi_GetTickStep_Callback>(slot));
    }
}

// Base class handler implementation
int QCPAxisTickerPi_QBaseGetSubTickCount(QCPAxisTickerPi* self, double tickStep) {
    auto* vqcpaxistickerpi = dynamic_cast<VirtualQCPAxisTickerPi*>(self);
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_GetSubTickCount_IsBase(true);
        return vqcpaxistickerpi->getSubTickCount(static_cast<double>(tickStep));
    } else {
        return ((VirtualQCPAxisTickerPi*)self)->getSubTickCount(static_cast<double>(tickStep));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerPi_OnGetSubTickCount(QCPAxisTickerPi* self, intptr_t slot) {
    auto* vqcpaxistickerpi = dynamic_cast<VirtualQCPAxisTickerPi*>(self);
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_GetSubTickCount_Callback(reinterpret_cast<VirtualQCPAxisTickerPi::QCPAxisTickerPi_GetSubTickCount_Callback>(slot));
    }
}

// Base class handler implementation
libqt_string QCPAxisTickerPi_QBaseGetTickLabel(QCPAxisTickerPi* self, double tick, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxistickerpi = dynamic_cast<VirtualQCPAxisTickerPi*>(self);
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_GetTickLabel_IsBase(true);
        QString _ret = vqcpaxistickerpi->getTickLabel(static_cast<double>(tick), *locale, *formatChar, static_cast<int>(precision));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    } else {
        QString _ret = ((VirtualQCPAxisTickerPi*)self)->getTickLabel(static_cast<double>(tick), *locale, *formatChar, static_cast<int>(precision));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerPi_OnGetTickLabel(QCPAxisTickerPi* self, intptr_t slot) {
    auto* vqcpaxistickerpi = dynamic_cast<VirtualQCPAxisTickerPi*>(self);
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_GetTickLabel_Callback(reinterpret_cast<VirtualQCPAxisTickerPi::QCPAxisTickerPi_GetTickLabel_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisTickerPi_Generate(QCPAxisTickerPi* self, const QCPRange* range, const QLocale* locale, QChar* formatChar, int precision, libqt_list /* of double */ ticks, libqt_list /* of double */ subTicks, libqt_list /* of libqt_string */ tickLabels) {
    auto* vqcpaxistickerpi = dynamic_cast<VirtualQCPAxisTickerPi*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    QVector<double> subTicks_QVector;
    subTicks_QVector.reserve(subTicks.len);
    double* subTicks_arr = static_cast<double*>(subTicks.data);
    for (size_t i = 0; i < subTicks.len; ++i) {
        subTicks_QVector.push_back(static_cast<double>(subTicks_arr[i]));
    }
    QVector<QString> tickLabels_QVector;
    tickLabels_QVector.reserve(tickLabels.len);
    libqt_string* tickLabels_arr = static_cast<libqt_string*>(tickLabels.data);
    for (size_t i = 0; i < tickLabels.len; ++i) {
        QString tickLabels_arr_i_QString = QString::fromUtf8(tickLabels_arr[i].data, tickLabels_arr[i].len);
        tickLabels_QVector.push_back(tickLabels_arr_i_QString);
    }
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    } else {
        self->QCPAxisTickerPi::generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    }
}

// Base class handler implementation
void QCPAxisTickerPi_QBaseGenerate(QCPAxisTickerPi* self, const QCPRange* range, const QLocale* locale, QChar* formatChar, int precision, libqt_list /* of double */ ticks, libqt_list /* of double */ subTicks, libqt_list /* of libqt_string */ tickLabels) {
    auto* vqcpaxistickerpi = dynamic_cast<VirtualQCPAxisTickerPi*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    QVector<double> subTicks_QVector;
    subTicks_QVector.reserve(subTicks.len);
    double* subTicks_arr = static_cast<double*>(subTicks.data);
    for (size_t i = 0; i < subTicks.len; ++i) {
        subTicks_QVector.push_back(static_cast<double>(subTicks_arr[i]));
    }
    QVector<QString> tickLabels_QVector;
    tickLabels_QVector.reserve(tickLabels.len);
    libqt_string* tickLabels_arr = static_cast<libqt_string*>(tickLabels.data);
    for (size_t i = 0; i < tickLabels.len; ++i) {
        QString tickLabels_arr_i_QString = QString::fromUtf8(tickLabels_arr[i].data, tickLabels_arr[i].len);
        tickLabels_QVector.push_back(tickLabels_arr_i_QString);
    }
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_Generate_IsBase(true);
        vqcpaxistickerpi->generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    } else {
        self->QCPAxisTickerPi::generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerPi_OnGenerate(QCPAxisTickerPi* self, intptr_t slot) {
    auto* vqcpaxistickerpi = dynamic_cast<VirtualQCPAxisTickerPi*>(self);
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_Generate_Callback(reinterpret_cast<VirtualQCPAxisTickerPi::QCPAxisTickerPi_Generate_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of double */ QCPAxisTickerPi_CreateTickVector(QCPAxisTickerPi* self, double tickStep, const QCPRange* range) {
    auto* vqcpaxistickerpi = dynamic_cast<VirtualQCPAxisTickerPi*>(self);
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        QVector<double> _ret = vqcpaxistickerpi->createTickVector(static_cast<double>(tickStep), *range);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<double> _ret = ((VirtualQCPAxisTickerPi*)self)->createTickVector(static_cast<double>(tickStep), *range);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of double */ QCPAxisTickerPi_QBaseCreateTickVector(QCPAxisTickerPi* self, double tickStep, const QCPRange* range) {
    auto* vqcpaxistickerpi = dynamic_cast<VirtualQCPAxisTickerPi*>(self);
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_CreateTickVector_IsBase(true);
        QVector<double> _ret = vqcpaxistickerpi->createTickVector(static_cast<double>(tickStep), *range);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<double> _ret = ((VirtualQCPAxisTickerPi*)self)->createTickVector(static_cast<double>(tickStep), *range);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerPi_OnCreateTickVector(QCPAxisTickerPi* self, intptr_t slot) {
    auto* vqcpaxistickerpi = dynamic_cast<VirtualQCPAxisTickerPi*>(self);
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_CreateTickVector_Callback(reinterpret_cast<VirtualQCPAxisTickerPi::QCPAxisTickerPi_CreateTickVector_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of double */ QCPAxisTickerPi_CreateSubTickVector(QCPAxisTickerPi* self, int subTickCount, const libqt_list /* of double */ ticks) {
    auto* vqcpaxistickerpi = dynamic_cast<VirtualQCPAxisTickerPi*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        QVector<double> _ret = vqcpaxistickerpi->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<double> _ret = ((VirtualQCPAxisTickerPi*)self)->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of double */ QCPAxisTickerPi_QBaseCreateSubTickVector(QCPAxisTickerPi* self, int subTickCount, const libqt_list /* of double */ ticks) {
    auto* vqcpaxistickerpi = dynamic_cast<VirtualQCPAxisTickerPi*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_CreateSubTickVector_IsBase(true);
        QVector<double> _ret = vqcpaxistickerpi->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<double> _ret = ((VirtualQCPAxisTickerPi*)self)->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerPi_OnCreateSubTickVector(QCPAxisTickerPi* self, intptr_t slot) {
    auto* vqcpaxistickerpi = dynamic_cast<VirtualQCPAxisTickerPi*>(self);
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_CreateSubTickVector_Callback(reinterpret_cast<VirtualQCPAxisTickerPi::QCPAxisTickerPi_CreateSubTickVector_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of libqt_string */ QCPAxisTickerPi_CreateLabelVector(QCPAxisTickerPi* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxistickerpi = dynamic_cast<VirtualQCPAxisTickerPi*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        QVector<QString> _ret = vqcpaxistickerpi->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QString> _ret = ((VirtualQCPAxisTickerPi*)self)->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of libqt_string */ QCPAxisTickerPi_QBaseCreateLabelVector(QCPAxisTickerPi* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxistickerpi = dynamic_cast<VirtualQCPAxisTickerPi*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_CreateLabelVector_IsBase(true);
        QVector<QString> _ret = vqcpaxistickerpi->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QString> _ret = ((VirtualQCPAxisTickerPi*)self)->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerPi_OnCreateLabelVector(QCPAxisTickerPi* self, intptr_t slot) {
    auto* vqcpaxistickerpi = dynamic_cast<VirtualQCPAxisTickerPi*>(self);
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_CreateLabelVector_Callback(reinterpret_cast<VirtualQCPAxisTickerPi::QCPAxisTickerPi_CreateLabelVector_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisTickerPi_SimplifyFraction(const QCPAxisTickerPi* self, int* numerator, int* denominator) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->simplifyFraction(static_cast<int&>(*numerator), static_cast<int&>(*denominator));
    } else {
        ((VirtualQCPAxisTickerPi*)self)->simplifyFraction(static_cast<int&>(*numerator), static_cast<int&>(*denominator));
    }
}

// Base class handler implementation
void QCPAxisTickerPi_QBaseSimplifyFraction(const QCPAxisTickerPi* self, int* numerator, int* denominator) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_SimplifyFraction_IsBase(true);
        vqcpaxistickerpi->simplifyFraction(static_cast<int&>(*numerator), static_cast<int&>(*denominator));
    } else {
        ((VirtualQCPAxisTickerPi*)self)->simplifyFraction(static_cast<int&>(*numerator), static_cast<int&>(*denominator));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerPi_OnSimplifyFraction(const QCPAxisTickerPi* self, intptr_t slot) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_SimplifyFraction_Callback(reinterpret_cast<VirtualQCPAxisTickerPi::QCPAxisTickerPi_SimplifyFraction_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_string QCPAxisTickerPi_FractionToString(const QCPAxisTickerPi* self, int numerator, int denominator) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        QString _ret = vqcpaxistickerpi->fractionToString(static_cast<int>(numerator), static_cast<int>(denominator));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    } else {
        QString _ret = ((VirtualQCPAxisTickerPi*)self)->fractionToString(static_cast<int>(numerator), static_cast<int>(denominator));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    }
}

// Base class handler implementation
libqt_string QCPAxisTickerPi_QBaseFractionToString(const QCPAxisTickerPi* self, int numerator, int denominator) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_FractionToString_IsBase(true);
        QString _ret = vqcpaxistickerpi->fractionToString(static_cast<int>(numerator), static_cast<int>(denominator));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    } else {
        QString _ret = ((VirtualQCPAxisTickerPi*)self)->fractionToString(static_cast<int>(numerator), static_cast<int>(denominator));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerPi_OnFractionToString(const QCPAxisTickerPi* self, intptr_t slot) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_FractionToString_Callback(reinterpret_cast<VirtualQCPAxisTickerPi::QCPAxisTickerPi_FractionToString_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_string QCPAxisTickerPi_UnicodeFraction(const QCPAxisTickerPi* self, int numerator, int denominator) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        QString _ret = vqcpaxistickerpi->unicodeFraction(static_cast<int>(numerator), static_cast<int>(denominator));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    } else {
        QString _ret = ((VirtualQCPAxisTickerPi*)self)->unicodeFraction(static_cast<int>(numerator), static_cast<int>(denominator));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    }
}

// Base class handler implementation
libqt_string QCPAxisTickerPi_QBaseUnicodeFraction(const QCPAxisTickerPi* self, int numerator, int denominator) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_UnicodeFraction_IsBase(true);
        QString _ret = vqcpaxistickerpi->unicodeFraction(static_cast<int>(numerator), static_cast<int>(denominator));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    } else {
        QString _ret = ((VirtualQCPAxisTickerPi*)self)->unicodeFraction(static_cast<int>(numerator), static_cast<int>(denominator));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerPi_OnUnicodeFraction(const QCPAxisTickerPi* self, intptr_t slot) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_UnicodeFraction_Callback(reinterpret_cast<VirtualQCPAxisTickerPi::QCPAxisTickerPi_UnicodeFraction_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_string QCPAxisTickerPi_UnicodeSuperscript(const QCPAxisTickerPi* self, int number) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        QString _ret = vqcpaxistickerpi->unicodeSuperscript(static_cast<int>(number));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    } else {
        QString _ret = ((VirtualQCPAxisTickerPi*)self)->unicodeSuperscript(static_cast<int>(number));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    }
}

// Base class handler implementation
libqt_string QCPAxisTickerPi_QBaseUnicodeSuperscript(const QCPAxisTickerPi* self, int number) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_UnicodeSuperscript_IsBase(true);
        QString _ret = vqcpaxistickerpi->unicodeSuperscript(static_cast<int>(number));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    } else {
        QString _ret = ((VirtualQCPAxisTickerPi*)self)->unicodeSuperscript(static_cast<int>(number));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerPi_OnUnicodeSuperscript(const QCPAxisTickerPi* self, intptr_t slot) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_UnicodeSuperscript_Callback(reinterpret_cast<VirtualQCPAxisTickerPi::QCPAxisTickerPi_UnicodeSuperscript_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_string QCPAxisTickerPi_UnicodeSubscript(const QCPAxisTickerPi* self, int number) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        QString _ret = vqcpaxistickerpi->unicodeSubscript(static_cast<int>(number));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    } else {
        QString _ret = ((VirtualQCPAxisTickerPi*)self)->unicodeSubscript(static_cast<int>(number));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    }
}

// Base class handler implementation
libqt_string QCPAxisTickerPi_QBaseUnicodeSubscript(const QCPAxisTickerPi* self, int number) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_UnicodeSubscript_IsBase(true);
        QString _ret = vqcpaxistickerpi->unicodeSubscript(static_cast<int>(number));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    } else {
        QString _ret = ((VirtualQCPAxisTickerPi*)self)->unicodeSubscript(static_cast<int>(number));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerPi_OnUnicodeSubscript(const QCPAxisTickerPi* self, intptr_t slot) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_UnicodeSubscript_Callback(reinterpret_cast<VirtualQCPAxisTickerPi::QCPAxisTickerPi_UnicodeSubscript_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisTickerPi_TrimTicks(const QCPAxisTickerPi* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->trimTicks(*range, ticks_QVector, keepOneOutlier);
    } else {
        ((VirtualQCPAxisTickerPi*)self)->trimTicks(*range, ticks_QVector, keepOneOutlier);
    }
}

// Base class handler implementation
void QCPAxisTickerPi_QBaseTrimTicks(const QCPAxisTickerPi* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_TrimTicks_IsBase(true);
        vqcpaxistickerpi->trimTicks(*range, ticks_QVector, keepOneOutlier);
    } else {
        ((VirtualQCPAxisTickerPi*)self)->trimTicks(*range, ticks_QVector, keepOneOutlier);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerPi_OnTrimTicks(const QCPAxisTickerPi* self, intptr_t slot) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_TrimTicks_Callback(reinterpret_cast<VirtualQCPAxisTickerPi::QCPAxisTickerPi_TrimTicks_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPAxisTickerPi_PickClosest(const QCPAxisTickerPi* self, double target, const libqt_list /* of double */ candidates) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    QVector<double> candidates_QVector;
    candidates_QVector.reserve(candidates.len);
    double* candidates_arr = static_cast<double*>(candidates.data);
    for (size_t i = 0; i < candidates.len; ++i) {
        candidates_QVector.push_back(static_cast<double>(candidates_arr[i]));
    }
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        return vqcpaxistickerpi->pickClosest(static_cast<double>(target), candidates_QVector);
    } else {
        return ((VirtualQCPAxisTickerPi*)self)->pickClosest(static_cast<double>(target), candidates_QVector);
    }
}

// Base class handler implementation
double QCPAxisTickerPi_QBasePickClosest(const QCPAxisTickerPi* self, double target, const libqt_list /* of double */ candidates) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    QVector<double> candidates_QVector;
    candidates_QVector.reserve(candidates.len);
    double* candidates_arr = static_cast<double*>(candidates.data);
    for (size_t i = 0; i < candidates.len; ++i) {
        candidates_QVector.push_back(static_cast<double>(candidates_arr[i]));
    }
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_PickClosest_IsBase(true);
        return vqcpaxistickerpi->pickClosest(static_cast<double>(target), candidates_QVector);
    } else {
        return ((VirtualQCPAxisTickerPi*)self)->pickClosest(static_cast<double>(target), candidates_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerPi_OnPickClosest(const QCPAxisTickerPi* self, intptr_t slot) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_PickClosest_Callback(reinterpret_cast<VirtualQCPAxisTickerPi::QCPAxisTickerPi_PickClosest_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPAxisTickerPi_GetMantissa(const QCPAxisTickerPi* self, double input) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        return vqcpaxistickerpi->getMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTickerPi*)self)->getMantissa(static_cast<double>(input));
    }
}

// Base class handler implementation
double QCPAxisTickerPi_QBaseGetMantissa(const QCPAxisTickerPi* self, double input) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_GetMantissa_IsBase(true);
        return vqcpaxistickerpi->getMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTickerPi*)self)->getMantissa(static_cast<double>(input));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerPi_OnGetMantissa(const QCPAxisTickerPi* self, intptr_t slot) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_GetMantissa_Callback(reinterpret_cast<VirtualQCPAxisTickerPi::QCPAxisTickerPi_GetMantissa_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPAxisTickerPi_CleanMantissa(const QCPAxisTickerPi* self, double input) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        return vqcpaxistickerpi->cleanMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTickerPi*)self)->cleanMantissa(static_cast<double>(input));
    }
}

// Base class handler implementation
double QCPAxisTickerPi_QBaseCleanMantissa(const QCPAxisTickerPi* self, double input) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_CleanMantissa_IsBase(true);
        return vqcpaxistickerpi->cleanMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTickerPi*)self)->cleanMantissa(static_cast<double>(input));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerPi_OnCleanMantissa(const QCPAxisTickerPi* self, intptr_t slot) {
    auto* vqcpaxistickerpi = const_cast<VirtualQCPAxisTickerPi*>(dynamic_cast<const VirtualQCPAxisTickerPi*>(self));
    if (vqcpaxistickerpi && vqcpaxistickerpi->isVirtualQCPAxisTickerPi) {
        vqcpaxistickerpi->setQCPAxisTickerPi_CleanMantissa_Callback(reinterpret_cast<VirtualQCPAxisTickerPi::QCPAxisTickerPi_CleanMantissa_Callback>(slot));
    }
}

void QCPAxisTickerPi_Delete(QCPAxisTickerPi* self) {
    delete self;
}

QCPAxisTickerLog* QCPAxisTickerLog_new() {
    return new VirtualQCPAxisTickerLog();
}

double QCPAxisTickerLog_LogBase(const QCPAxisTickerLog* self) {
    return self->logBase();
}

int QCPAxisTickerLog_SubTickCount(const QCPAxisTickerLog* self) {
    return self->subTickCount();
}

void QCPAxisTickerLog_SetLogBase(QCPAxisTickerLog* self, double base) {
    self->setLogBase(static_cast<double>(base));
}

void QCPAxisTickerLog_SetSubTickCount(QCPAxisTickerLog* self, int subTicks) {
    self->setSubTickCount(static_cast<int>(subTicks));
}

int QCPAxisTickerLog_GetSubTickCount(QCPAxisTickerLog* self, double tickStep) {
    auto* vqcpaxistickerlog = dynamic_cast<VirtualQCPAxisTickerLog*>(self);
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        return vqcpaxistickerlog->getSubTickCount(static_cast<double>(tickStep));
    }
    return {};
}

libqt_list /* of double */ QCPAxisTickerLog_CreateTickVector(QCPAxisTickerLog* self, double tickStep, const QCPRange* range) {
    auto* vqcpaxistickerlog = dynamic_cast<VirtualQCPAxisTickerLog*>(self);
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        QVector<double> _ret = vqcpaxistickerlog->createTickVector(static_cast<double>(tickStep), *range);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
    return {};
}

// Base class handler implementation
int QCPAxisTickerLog_QBaseGetSubTickCount(QCPAxisTickerLog* self, double tickStep) {
    auto* vqcpaxistickerlog = dynamic_cast<VirtualQCPAxisTickerLog*>(self);
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        vqcpaxistickerlog->setQCPAxisTickerLog_GetSubTickCount_IsBase(true);
        return vqcpaxistickerlog->getSubTickCount(static_cast<double>(tickStep));
    } else {
        return ((VirtualQCPAxisTickerLog*)self)->getSubTickCount(static_cast<double>(tickStep));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerLog_OnGetSubTickCount(QCPAxisTickerLog* self, intptr_t slot) {
    auto* vqcpaxistickerlog = dynamic_cast<VirtualQCPAxisTickerLog*>(self);
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        vqcpaxistickerlog->setQCPAxisTickerLog_GetSubTickCount_Callback(reinterpret_cast<VirtualQCPAxisTickerLog::QCPAxisTickerLog_GetSubTickCount_Callback>(slot));
    }
}

// Base class handler implementation
libqt_list /* of double */ QCPAxisTickerLog_QBaseCreateTickVector(QCPAxisTickerLog* self, double tickStep, const QCPRange* range) {
    auto* vqcpaxistickerlog = dynamic_cast<VirtualQCPAxisTickerLog*>(self);
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        vqcpaxistickerlog->setQCPAxisTickerLog_CreateTickVector_IsBase(true);
        QVector<double> _ret = vqcpaxistickerlog->createTickVector(static_cast<double>(tickStep), *range);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<double> _ret = ((VirtualQCPAxisTickerLog*)self)->createTickVector(static_cast<double>(tickStep), *range);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerLog_OnCreateTickVector(QCPAxisTickerLog* self, intptr_t slot) {
    auto* vqcpaxistickerlog = dynamic_cast<VirtualQCPAxisTickerLog*>(self);
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        vqcpaxistickerlog->setQCPAxisTickerLog_CreateTickVector_Callback(reinterpret_cast<VirtualQCPAxisTickerLog::QCPAxisTickerLog_CreateTickVector_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisTickerLog_Generate(QCPAxisTickerLog* self, const QCPRange* range, const QLocale* locale, QChar* formatChar, int precision, libqt_list /* of double */ ticks, libqt_list /* of double */ subTicks, libqt_list /* of libqt_string */ tickLabels) {
    auto* vqcpaxistickerlog = dynamic_cast<VirtualQCPAxisTickerLog*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    QVector<double> subTicks_QVector;
    subTicks_QVector.reserve(subTicks.len);
    double* subTicks_arr = static_cast<double*>(subTicks.data);
    for (size_t i = 0; i < subTicks.len; ++i) {
        subTicks_QVector.push_back(static_cast<double>(subTicks_arr[i]));
    }
    QVector<QString> tickLabels_QVector;
    tickLabels_QVector.reserve(tickLabels.len);
    libqt_string* tickLabels_arr = static_cast<libqt_string*>(tickLabels.data);
    for (size_t i = 0; i < tickLabels.len; ++i) {
        QString tickLabels_arr_i_QString = QString::fromUtf8(tickLabels_arr[i].data, tickLabels_arr[i].len);
        tickLabels_QVector.push_back(tickLabels_arr_i_QString);
    }
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        vqcpaxistickerlog->generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    } else {
        self->QCPAxisTickerLog::generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    }
}

// Base class handler implementation
void QCPAxisTickerLog_QBaseGenerate(QCPAxisTickerLog* self, const QCPRange* range, const QLocale* locale, QChar* formatChar, int precision, libqt_list /* of double */ ticks, libqt_list /* of double */ subTicks, libqt_list /* of libqt_string */ tickLabels) {
    auto* vqcpaxistickerlog = dynamic_cast<VirtualQCPAxisTickerLog*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    QVector<double> subTicks_QVector;
    subTicks_QVector.reserve(subTicks.len);
    double* subTicks_arr = static_cast<double*>(subTicks.data);
    for (size_t i = 0; i < subTicks.len; ++i) {
        subTicks_QVector.push_back(static_cast<double>(subTicks_arr[i]));
    }
    QVector<QString> tickLabels_QVector;
    tickLabels_QVector.reserve(tickLabels.len);
    libqt_string* tickLabels_arr = static_cast<libqt_string*>(tickLabels.data);
    for (size_t i = 0; i < tickLabels.len; ++i) {
        QString tickLabels_arr_i_QString = QString::fromUtf8(tickLabels_arr[i].data, tickLabels_arr[i].len);
        tickLabels_QVector.push_back(tickLabels_arr_i_QString);
    }
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        vqcpaxistickerlog->setQCPAxisTickerLog_Generate_IsBase(true);
        vqcpaxistickerlog->generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    } else {
        self->QCPAxisTickerLog::generate(*range, *locale, *formatChar, static_cast<int>(precision), ticks_QVector, &subTicks_QVector, &tickLabels_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerLog_OnGenerate(QCPAxisTickerLog* self, intptr_t slot) {
    auto* vqcpaxistickerlog = dynamic_cast<VirtualQCPAxisTickerLog*>(self);
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        vqcpaxistickerlog->setQCPAxisTickerLog_Generate_Callback(reinterpret_cast<VirtualQCPAxisTickerLog::QCPAxisTickerLog_Generate_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPAxisTickerLog_GetTickStep(QCPAxisTickerLog* self, const QCPRange* range) {
    auto* vqcpaxistickerlog = dynamic_cast<VirtualQCPAxisTickerLog*>(self);
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        return vqcpaxistickerlog->getTickStep(*range);
    } else {
        return ((VirtualQCPAxisTickerLog*)self)->getTickStep(*range);
    }
}

// Base class handler implementation
double QCPAxisTickerLog_QBaseGetTickStep(QCPAxisTickerLog* self, const QCPRange* range) {
    auto* vqcpaxistickerlog = dynamic_cast<VirtualQCPAxisTickerLog*>(self);
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        vqcpaxistickerlog->setQCPAxisTickerLog_GetTickStep_IsBase(true);
        return vqcpaxistickerlog->getTickStep(*range);
    } else {
        return ((VirtualQCPAxisTickerLog*)self)->getTickStep(*range);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerLog_OnGetTickStep(QCPAxisTickerLog* self, intptr_t slot) {
    auto* vqcpaxistickerlog = dynamic_cast<VirtualQCPAxisTickerLog*>(self);
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        vqcpaxistickerlog->setQCPAxisTickerLog_GetTickStep_Callback(reinterpret_cast<VirtualQCPAxisTickerLog::QCPAxisTickerLog_GetTickStep_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_string QCPAxisTickerLog_GetTickLabel(QCPAxisTickerLog* self, double tick, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxistickerlog = dynamic_cast<VirtualQCPAxisTickerLog*>(self);
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        QString _ret = vqcpaxistickerlog->getTickLabel(static_cast<double>(tick), *locale, *formatChar, static_cast<int>(precision));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    } else {
        QString _ret = ((VirtualQCPAxisTickerLog*)self)->getTickLabel(static_cast<double>(tick), *locale, *formatChar, static_cast<int>(precision));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    }
}

// Base class handler implementation
libqt_string QCPAxisTickerLog_QBaseGetTickLabel(QCPAxisTickerLog* self, double tick, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxistickerlog = dynamic_cast<VirtualQCPAxisTickerLog*>(self);
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        vqcpaxistickerlog->setQCPAxisTickerLog_GetTickLabel_IsBase(true);
        QString _ret = vqcpaxistickerlog->getTickLabel(static_cast<double>(tick), *locale, *formatChar, static_cast<int>(precision));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    } else {
        QString _ret = ((VirtualQCPAxisTickerLog*)self)->getTickLabel(static_cast<double>(tick), *locale, *formatChar, static_cast<int>(precision));
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _b = _ret.toUtf8();
        libqt_string _str;
        _str.len = _b.length();
        _str.data = static_cast<const char*>(malloc(_str.len + 1));
        memcpy((void*)_str.data, _b.data(), _str.len);
        ((char*)_str.data)[_str.len] = '\0';
        return _str;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerLog_OnGetTickLabel(QCPAxisTickerLog* self, intptr_t slot) {
    auto* vqcpaxistickerlog = dynamic_cast<VirtualQCPAxisTickerLog*>(self);
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        vqcpaxistickerlog->setQCPAxisTickerLog_GetTickLabel_Callback(reinterpret_cast<VirtualQCPAxisTickerLog::QCPAxisTickerLog_GetTickLabel_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of double */ QCPAxisTickerLog_CreateSubTickVector(QCPAxisTickerLog* self, int subTickCount, const libqt_list /* of double */ ticks) {
    auto* vqcpaxistickerlog = dynamic_cast<VirtualQCPAxisTickerLog*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        QVector<double> _ret = vqcpaxistickerlog->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<double> _ret = ((VirtualQCPAxisTickerLog*)self)->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of double */ QCPAxisTickerLog_QBaseCreateSubTickVector(QCPAxisTickerLog* self, int subTickCount, const libqt_list /* of double */ ticks) {
    auto* vqcpaxistickerlog = dynamic_cast<VirtualQCPAxisTickerLog*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        vqcpaxistickerlog->setQCPAxisTickerLog_CreateSubTickVector_IsBase(true);
        QVector<double> _ret = vqcpaxistickerlog->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<double> _ret = ((VirtualQCPAxisTickerLog*)self)->createSubTickVector(static_cast<int>(subTickCount), ticks_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerLog_OnCreateSubTickVector(QCPAxisTickerLog* self, intptr_t slot) {
    auto* vqcpaxistickerlog = dynamic_cast<VirtualQCPAxisTickerLog*>(self);
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        vqcpaxistickerlog->setQCPAxisTickerLog_CreateSubTickVector_Callback(reinterpret_cast<VirtualQCPAxisTickerLog::QCPAxisTickerLog_CreateSubTickVector_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of libqt_string */ QCPAxisTickerLog_CreateLabelVector(QCPAxisTickerLog* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxistickerlog = dynamic_cast<VirtualQCPAxisTickerLog*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        QVector<QString> _ret = vqcpaxistickerlog->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QString> _ret = ((VirtualQCPAxisTickerLog*)self)->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of libqt_string */ QCPAxisTickerLog_QBaseCreateLabelVector(QCPAxisTickerLog* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision) {
    auto* vqcpaxistickerlog = dynamic_cast<VirtualQCPAxisTickerLog*>(self);
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        vqcpaxistickerlog->setQCPAxisTickerLog_CreateLabelVector_IsBase(true);
        QVector<QString> _ret = vqcpaxistickerlog->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QString> _ret = ((VirtualQCPAxisTickerLog*)self)->createLabelVector(ticks_QVector, *locale, *formatChar, static_cast<int>(precision));
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QString _vv_ret = _ret[i];
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray _vv_b = _vv_ret.toUtf8();
            libqt_string _vv_str;
            _vv_str.len = _vv_b.length();
            _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
            memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
            ((char*)_vv_str.data)[_vv_str.len] = '\0';
            _arr[i] = _vv_str;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerLog_OnCreateLabelVector(QCPAxisTickerLog* self, intptr_t slot) {
    auto* vqcpaxistickerlog = dynamic_cast<VirtualQCPAxisTickerLog*>(self);
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        vqcpaxistickerlog->setQCPAxisTickerLog_CreateLabelVector_Callback(reinterpret_cast<VirtualQCPAxisTickerLog::QCPAxisTickerLog_CreateLabelVector_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisTickerLog_TrimTicks(const QCPAxisTickerLog* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier) {
    auto* vqcpaxistickerlog = const_cast<VirtualQCPAxisTickerLog*>(dynamic_cast<const VirtualQCPAxisTickerLog*>(self));
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        vqcpaxistickerlog->trimTicks(*range, ticks_QVector, keepOneOutlier);
    } else {
        ((VirtualQCPAxisTickerLog*)self)->trimTicks(*range, ticks_QVector, keepOneOutlier);
    }
}

// Base class handler implementation
void QCPAxisTickerLog_QBaseTrimTicks(const QCPAxisTickerLog* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier) {
    auto* vqcpaxistickerlog = const_cast<VirtualQCPAxisTickerLog*>(dynamic_cast<const VirtualQCPAxisTickerLog*>(self));
    QVector<double> ticks_QVector;
    ticks_QVector.reserve(ticks.len);
    double* ticks_arr = static_cast<double*>(ticks.data);
    for (size_t i = 0; i < ticks.len; ++i) {
        ticks_QVector.push_back(static_cast<double>(ticks_arr[i]));
    }
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        vqcpaxistickerlog->setQCPAxisTickerLog_TrimTicks_IsBase(true);
        vqcpaxistickerlog->trimTicks(*range, ticks_QVector, keepOneOutlier);
    } else {
        ((VirtualQCPAxisTickerLog*)self)->trimTicks(*range, ticks_QVector, keepOneOutlier);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerLog_OnTrimTicks(const QCPAxisTickerLog* self, intptr_t slot) {
    auto* vqcpaxistickerlog = const_cast<VirtualQCPAxisTickerLog*>(dynamic_cast<const VirtualQCPAxisTickerLog*>(self));
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        vqcpaxistickerlog->setQCPAxisTickerLog_TrimTicks_Callback(reinterpret_cast<VirtualQCPAxisTickerLog::QCPAxisTickerLog_TrimTicks_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPAxisTickerLog_PickClosest(const QCPAxisTickerLog* self, double target, const libqt_list /* of double */ candidates) {
    auto* vqcpaxistickerlog = const_cast<VirtualQCPAxisTickerLog*>(dynamic_cast<const VirtualQCPAxisTickerLog*>(self));
    QVector<double> candidates_QVector;
    candidates_QVector.reserve(candidates.len);
    double* candidates_arr = static_cast<double*>(candidates.data);
    for (size_t i = 0; i < candidates.len; ++i) {
        candidates_QVector.push_back(static_cast<double>(candidates_arr[i]));
    }
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        return vqcpaxistickerlog->pickClosest(static_cast<double>(target), candidates_QVector);
    } else {
        return ((VirtualQCPAxisTickerLog*)self)->pickClosest(static_cast<double>(target), candidates_QVector);
    }
}

// Base class handler implementation
double QCPAxisTickerLog_QBasePickClosest(const QCPAxisTickerLog* self, double target, const libqt_list /* of double */ candidates) {
    auto* vqcpaxistickerlog = const_cast<VirtualQCPAxisTickerLog*>(dynamic_cast<const VirtualQCPAxisTickerLog*>(self));
    QVector<double> candidates_QVector;
    candidates_QVector.reserve(candidates.len);
    double* candidates_arr = static_cast<double*>(candidates.data);
    for (size_t i = 0; i < candidates.len; ++i) {
        candidates_QVector.push_back(static_cast<double>(candidates_arr[i]));
    }
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        vqcpaxistickerlog->setQCPAxisTickerLog_PickClosest_IsBase(true);
        return vqcpaxistickerlog->pickClosest(static_cast<double>(target), candidates_QVector);
    } else {
        return ((VirtualQCPAxisTickerLog*)self)->pickClosest(static_cast<double>(target), candidates_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerLog_OnPickClosest(const QCPAxisTickerLog* self, intptr_t slot) {
    auto* vqcpaxistickerlog = const_cast<VirtualQCPAxisTickerLog*>(dynamic_cast<const VirtualQCPAxisTickerLog*>(self));
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        vqcpaxistickerlog->setQCPAxisTickerLog_PickClosest_Callback(reinterpret_cast<VirtualQCPAxisTickerLog::QCPAxisTickerLog_PickClosest_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPAxisTickerLog_GetMantissa(const QCPAxisTickerLog* self, double input) {
    auto* vqcpaxistickerlog = const_cast<VirtualQCPAxisTickerLog*>(dynamic_cast<const VirtualQCPAxisTickerLog*>(self));
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        return vqcpaxistickerlog->getMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTickerLog*)self)->getMantissa(static_cast<double>(input));
    }
}

// Base class handler implementation
double QCPAxisTickerLog_QBaseGetMantissa(const QCPAxisTickerLog* self, double input) {
    auto* vqcpaxistickerlog = const_cast<VirtualQCPAxisTickerLog*>(dynamic_cast<const VirtualQCPAxisTickerLog*>(self));
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        vqcpaxistickerlog->setQCPAxisTickerLog_GetMantissa_IsBase(true);
        return vqcpaxistickerlog->getMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTickerLog*)self)->getMantissa(static_cast<double>(input));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerLog_OnGetMantissa(const QCPAxisTickerLog* self, intptr_t slot) {
    auto* vqcpaxistickerlog = const_cast<VirtualQCPAxisTickerLog*>(dynamic_cast<const VirtualQCPAxisTickerLog*>(self));
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        vqcpaxistickerlog->setQCPAxisTickerLog_GetMantissa_Callback(reinterpret_cast<VirtualQCPAxisTickerLog::QCPAxisTickerLog_GetMantissa_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPAxisTickerLog_CleanMantissa(const QCPAxisTickerLog* self, double input) {
    auto* vqcpaxistickerlog = const_cast<VirtualQCPAxisTickerLog*>(dynamic_cast<const VirtualQCPAxisTickerLog*>(self));
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        return vqcpaxistickerlog->cleanMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTickerLog*)self)->cleanMantissa(static_cast<double>(input));
    }
}

// Base class handler implementation
double QCPAxisTickerLog_QBaseCleanMantissa(const QCPAxisTickerLog* self, double input) {
    auto* vqcpaxistickerlog = const_cast<VirtualQCPAxisTickerLog*>(dynamic_cast<const VirtualQCPAxisTickerLog*>(self));
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        vqcpaxistickerlog->setQCPAxisTickerLog_CleanMantissa_IsBase(true);
        return vqcpaxistickerlog->cleanMantissa(static_cast<double>(input));
    } else {
        return ((VirtualQCPAxisTickerLog*)self)->cleanMantissa(static_cast<double>(input));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisTickerLog_OnCleanMantissa(const QCPAxisTickerLog* self, intptr_t slot) {
    auto* vqcpaxistickerlog = const_cast<VirtualQCPAxisTickerLog*>(dynamic_cast<const VirtualQCPAxisTickerLog*>(self));
    if (vqcpaxistickerlog && vqcpaxistickerlog->isVirtualQCPAxisTickerLog) {
        vqcpaxistickerlog->setQCPAxisTickerLog_CleanMantissa_Callback(reinterpret_cast<VirtualQCPAxisTickerLog::QCPAxisTickerLog_CleanMantissa_Callback>(slot));
    }
}

void QCPAxisTickerLog_Delete(QCPAxisTickerLog* self) {
    delete self;
}

QCPGrid* QCPGrid_new(QCPAxis* parentAxis) {
    return new VirtualQCPGrid(parentAxis);
}

QMetaObject* QCPGrid_MetaObject(const QCPGrid* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPGrid_Metacast(QCPGrid* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPGrid_Metacall(QCPGrid* self, int param1, int param2, void** param3) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPGrid*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPGrid_Tr(const char* s) {
    QString _ret = QCPGrid::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

bool QCPGrid_SubGridVisible(const QCPGrid* self) {
    return self->subGridVisible();
}

bool QCPGrid_AntialiasedSubGrid(const QCPGrid* self) {
    return self->antialiasedSubGrid();
}

bool QCPGrid_AntialiasedZeroLine(const QCPGrid* self) {
    return self->antialiasedZeroLine();
}

QPen* QCPGrid_Pen(const QCPGrid* self) {
    return new QPen(self->pen());
}

QPen* QCPGrid_SubGridPen(const QCPGrid* self) {
    return new QPen(self->subGridPen());
}

QPen* QCPGrid_ZeroLinePen(const QCPGrid* self) {
    return new QPen(self->zeroLinePen());
}

void QCPGrid_SetSubGridVisible(QCPGrid* self, bool visible) {
    self->setSubGridVisible(visible);
}

void QCPGrid_SetAntialiasedSubGrid(QCPGrid* self, bool enabled) {
    self->setAntialiasedSubGrid(enabled);
}

void QCPGrid_SetAntialiasedZeroLine(QCPGrid* self, bool enabled) {
    self->setAntialiasedZeroLine(enabled);
}

void QCPGrid_SetPen(QCPGrid* self, const QPen* pen) {
    self->setPen(*pen);
}

void QCPGrid_SetSubGridPen(QCPGrid* self, const QPen* pen) {
    self->setSubGridPen(*pen);
}

void QCPGrid_SetZeroLinePen(QCPGrid* self, const QPen* pen) {
    self->setZeroLinePen(*pen);
}

void QCPGrid_ApplyDefaultAntialiasingHint(const QCPGrid* self, QCPPainter* painter) {
    auto* vqcpgrid = dynamic_cast<const VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->applyDefaultAntialiasingHint(painter);
    }
}

void QCPGrid_Draw(QCPGrid* self, QCPPainter* painter) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->draw(painter);
    }
}

libqt_string QCPGrid_Tr2(const char* s, const char* c) {
    QString _ret = QCPGrid::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPGrid_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPGrid::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPGrid_QBaseMetacall(QCPGrid* self, int param1, int param2, void** param3) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_Metacall_IsBase(true);
        return vqcpgrid->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPGrid::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnMetacall(QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_Metacall_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
void QCPGrid_QBaseApplyDefaultAntialiasingHint(const QCPGrid* self, QCPPainter* painter) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcpgrid->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPGrid*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnApplyDefaultAntialiasingHint(const QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Base class handler implementation
void QCPGrid_QBaseDraw(QCPGrid* self, QCPPainter* painter) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_Draw_IsBase(true);
        vqcpgrid->draw(painter);
    } else {
        ((VirtualQCPGrid*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnDraw(QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_Draw_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_Draw_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPGrid_SelectTest(const QCPGrid* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        return vqcpgrid->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPGrid::selectTest(*pos, onlySelectable, details);
    }
}

// Base class handler implementation
double QCPGrid_QBaseSelectTest(const QCPGrid* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_SelectTest_IsBase(true);
        return vqcpgrid->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPGrid::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnSelectTest(const QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_SelectTest_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_SelectTest_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGrid_ParentPlotInitialized(QCPGrid* self, QCustomPlot* parentPlot) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPGrid*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPGrid_QBaseParentPlotInitialized(QCPGrid* self, QCustomPlot* parentPlot) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_ParentPlotInitialized_IsBase(true);
        vqcpgrid->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPGrid*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnParentPlotInitialized(QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPGrid_SelectionCategory(const QCPGrid* self) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        return static_cast<int>(vqcpgrid->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPGrid*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPGrid_QBaseSelectionCategory(const QCPGrid* self) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcpgrid->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPGrid*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnSelectionCategory(const QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_SelectionCategory_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPGrid_ClipRect(const QCPGrid* self) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        return new QRect(vqcpgrid->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPGrid_QBaseClipRect(const QCPGrid* self) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_ClipRect_IsBase(true);
        return new QRect(vqcpgrid->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnClipRect(const QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_ClipRect_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGrid_SelectEvent(QCPGrid* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPGrid*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPGrid_QBaseSelectEvent(QCPGrid* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_SelectEvent_IsBase(true);
        vqcpgrid->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPGrid*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnSelectEvent(QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_SelectEvent_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGrid_DeselectEvent(QCPGrid* self, bool* selectionStateChanged) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPGrid*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPGrid_QBaseDeselectEvent(QCPGrid* self, bool* selectionStateChanged) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_DeselectEvent_IsBase(true);
        vqcpgrid->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPGrid*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnDeselectEvent(QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_DeselectEvent_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGrid_MousePressEvent(QCPGrid* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPGrid*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPGrid_QBaseMousePressEvent(QCPGrid* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_MousePressEvent_IsBase(true);
        vqcpgrid->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPGrid*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnMousePressEvent(QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_MousePressEvent_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGrid_MouseMoveEvent(QCPGrid* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPGrid*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPGrid_QBaseMouseMoveEvent(QCPGrid* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_MouseMoveEvent_IsBase(true);
        vqcpgrid->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPGrid*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnMouseMoveEvent(QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGrid_MouseReleaseEvent(QCPGrid* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPGrid*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPGrid_QBaseMouseReleaseEvent(QCPGrid* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_MouseReleaseEvent_IsBase(true);
        vqcpgrid->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPGrid*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnMouseReleaseEvent(QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGrid_MouseDoubleClickEvent(QCPGrid* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPGrid*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPGrid_QBaseMouseDoubleClickEvent(QCPGrid* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_MouseDoubleClickEvent_IsBase(true);
        vqcpgrid->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPGrid*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnMouseDoubleClickEvent(QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGrid_WheelEvent(QCPGrid* self, QWheelEvent* event) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->wheelEvent(event);
    } else {
        ((VirtualQCPGrid*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPGrid_QBaseWheelEvent(QCPGrid* self, QWheelEvent* event) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_WheelEvent_IsBase(true);
        vqcpgrid->wheelEvent(event);
    } else {
        ((VirtualQCPGrid*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnWheelEvent(QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_WheelEvent_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPGrid_Event(QCPGrid* self, QEvent* event) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        return vqcpgrid->event(event);
    } else {
        return self->QCPGrid::event(event);
    }
}

// Base class handler implementation
bool QCPGrid_QBaseEvent(QCPGrid* self, QEvent* event) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_Event_IsBase(true);
        return vqcpgrid->event(event);
    } else {
        return self->QCPGrid::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnEvent(QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_Event_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPGrid_EventFilter(QCPGrid* self, QObject* watched, QEvent* event) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        return vqcpgrid->eventFilter(watched, event);
    } else {
        return self->QCPGrid::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPGrid_QBaseEventFilter(QCPGrid* self, QObject* watched, QEvent* event) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_EventFilter_IsBase(true);
        return vqcpgrid->eventFilter(watched, event);
    } else {
        return self->QCPGrid::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnEventFilter(QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_EventFilter_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGrid_TimerEvent(QCPGrid* self, QTimerEvent* event) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->timerEvent(event);
    } else {
        ((VirtualQCPGrid*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPGrid_QBaseTimerEvent(QCPGrid* self, QTimerEvent* event) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_TimerEvent_IsBase(true);
        vqcpgrid->timerEvent(event);
    } else {
        ((VirtualQCPGrid*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnTimerEvent(QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_TimerEvent_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGrid_ChildEvent(QCPGrid* self, QChildEvent* event) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->childEvent(event);
    } else {
        ((VirtualQCPGrid*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPGrid_QBaseChildEvent(QCPGrid* self, QChildEvent* event) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_ChildEvent_IsBase(true);
        vqcpgrid->childEvent(event);
    } else {
        ((VirtualQCPGrid*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnChildEvent(QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_ChildEvent_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGrid_CustomEvent(QCPGrid* self, QEvent* event) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->customEvent(event);
    } else {
        ((VirtualQCPGrid*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPGrid_QBaseCustomEvent(QCPGrid* self, QEvent* event) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_CustomEvent_IsBase(true);
        vqcpgrid->customEvent(event);
    } else {
        ((VirtualQCPGrid*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnCustomEvent(QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_CustomEvent_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGrid_ConnectNotify(QCPGrid* self, const QMetaMethod* signal) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->connectNotify(*signal);
    } else {
        ((VirtualQCPGrid*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPGrid_QBaseConnectNotify(QCPGrid* self, const QMetaMethod* signal) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_ConnectNotify_IsBase(true);
        vqcpgrid->connectNotify(*signal);
    } else {
        ((VirtualQCPGrid*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnConnectNotify(QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_ConnectNotify_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGrid_DisconnectNotify(QCPGrid* self, const QMetaMethod* signal) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->disconnectNotify(*signal);
    } else {
        ((VirtualQCPGrid*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPGrid_QBaseDisconnectNotify(QCPGrid* self, const QMetaMethod* signal) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_DisconnectNotify_IsBase(true);
        vqcpgrid->disconnectNotify(*signal);
    } else {
        ((VirtualQCPGrid*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnDisconnectNotify(QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGrid_DrawGridLines(const QCPGrid* self, QCPPainter* painter) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->drawGridLines(painter);
    } else {
        ((VirtualQCPGrid*)self)->drawGridLines(painter);
    }
}

// Base class handler implementation
void QCPGrid_QBaseDrawGridLines(const QCPGrid* self, QCPPainter* painter) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_DrawGridLines_IsBase(true);
        vqcpgrid->drawGridLines(painter);
    } else {
        ((VirtualQCPGrid*)self)->drawGridLines(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnDrawGridLines(const QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_DrawGridLines_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_DrawGridLines_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGrid_DrawSubGridLines(const QCPGrid* self, QCPPainter* painter) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->drawSubGridLines(painter);
    } else {
        ((VirtualQCPGrid*)self)->drawSubGridLines(painter);
    }
}

// Base class handler implementation
void QCPGrid_QBaseDrawSubGridLines(const QCPGrid* self, QCPPainter* painter) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_DrawSubGridLines_IsBase(true);
        vqcpgrid->drawSubGridLines(painter);
    } else {
        ((VirtualQCPGrid*)self)->drawSubGridLines(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnDrawSubGridLines(const QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_DrawSubGridLines_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_DrawSubGridLines_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGrid_InitializeParentPlot(QCPGrid* self, QCustomPlot* parentPlot) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPGrid*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPGrid_QBaseInitializeParentPlot(QCPGrid* self, QCustomPlot* parentPlot) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_InitializeParentPlot_IsBase(true);
        vqcpgrid->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPGrid*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnInitializeParentPlot(QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGrid_SetParentLayerable(QCPGrid* self, QCPLayerable* parentLayerable) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPGrid*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPGrid_QBaseSetParentLayerable(QCPGrid* self, QCPLayerable* parentLayerable) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_SetParentLayerable_IsBase(true);
        vqcpgrid->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPGrid*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnSetParentLayerable(QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPGrid_MoveToLayer(QCPGrid* self, QCPLayer* layer, bool prepend) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        return vqcpgrid->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPGrid*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPGrid_QBaseMoveToLayer(QCPGrid* self, QCPLayer* layer, bool prepend) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_MoveToLayer_IsBase(true);
        return vqcpgrid->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPGrid*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnMoveToLayer(QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = dynamic_cast<VirtualQCPGrid*>(self);
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_MoveToLayer_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGrid_ApplyAntialiasingHint(const QCPGrid* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPGrid*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPGrid_QBaseApplyAntialiasingHint(const QCPGrid* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_ApplyAntialiasingHint_IsBase(true);
        vqcpgrid->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPGrid*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnApplyAntialiasingHint(const QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPGrid_Sender(const QCPGrid* self) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        return vqcpgrid->sender();
    } else {
        return ((VirtualQCPGrid*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPGrid_QBaseSender(const QCPGrid* self) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_Sender_IsBase(true);
        return vqcpgrid->sender();
    } else {
        return ((VirtualQCPGrid*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnSender(const QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_Sender_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPGrid_SenderSignalIndex(const QCPGrid* self) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        return vqcpgrid->senderSignalIndex();
    } else {
        return ((VirtualQCPGrid*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPGrid_QBaseSenderSignalIndex(const QCPGrid* self) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_SenderSignalIndex_IsBase(true);
        return vqcpgrid->senderSignalIndex();
    } else {
        return ((VirtualQCPGrid*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnSenderSignalIndex(const QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPGrid_Receivers(const QCPGrid* self, const char* signal) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        return vqcpgrid->receivers(signal);
    } else {
        return ((VirtualQCPGrid*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPGrid_QBaseReceivers(const QCPGrid* self, const char* signal) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_Receivers_IsBase(true);
        return vqcpgrid->receivers(signal);
    } else {
        return ((VirtualQCPGrid*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnReceivers(const QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_Receivers_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPGrid_IsSignalConnected(const QCPGrid* self, const QMetaMethod* signal) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        return vqcpgrid->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPGrid*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPGrid_QBaseIsSignalConnected(const QCPGrid* self, const QMetaMethod* signal) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_IsSignalConnected_IsBase(true);
        return vqcpgrid->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPGrid*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGrid_OnIsSignalConnected(const QCPGrid* self, intptr_t slot) {
    auto* vqcpgrid = const_cast<VirtualQCPGrid*>(dynamic_cast<const VirtualQCPGrid*>(self));
    if (vqcpgrid && vqcpgrid->isVirtualQCPGrid) {
        vqcpgrid->setQCPGrid_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPGrid::QCPGrid_IsSignalConnected_Callback>(slot));
    }
}

void QCPGrid_Delete(QCPGrid* self) {
    delete self;
}

QCPAxis* QCPAxis_new(QCPAxisRect* parent, int typeVal) {
    return new VirtualQCPAxis(parent, static_cast<QCPAxis::AxisType>(typeVal));
}

QMetaObject* QCPAxis_MetaObject(const QCPAxis* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPAxis_Metacast(QCPAxis* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPAxis_Metacall(QCPAxis* self, int param1, int param2, void** param3) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPAxis*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPAxis_Tr(const char* s) {
    QString _ret = QCPAxis::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

int QCPAxis_AxisType(const QCPAxis* self) {
    return static_cast<int>(self->axisType());
}

QCPAxisRect* QCPAxis_AxisRect(const QCPAxis* self) {
    return self->axisRect();
}

int QCPAxis_ScaleType(const QCPAxis* self) {
    return static_cast<int>(self->scaleType());
}

QCPRange* QCPAxis_Range(const QCPAxis* self) {
    return new QCPRange(self->range());
}

bool QCPAxis_RangeReversed(const QCPAxis* self) {
    return self->rangeReversed();
}

bool QCPAxis_Ticks(const QCPAxis* self) {
    return self->ticks();
}

bool QCPAxis_TickLabels(const QCPAxis* self) {
    return self->tickLabels();
}

int QCPAxis_TickLabelPadding(const QCPAxis* self) {
    return self->tickLabelPadding();
}

QFont* QCPAxis_TickLabelFont(const QCPAxis* self) {
    return new QFont(self->tickLabelFont());
}

QColor* QCPAxis_TickLabelColor(const QCPAxis* self) {
    return new QColor(self->tickLabelColor());
}

double QCPAxis_TickLabelRotation(const QCPAxis* self) {
    return self->tickLabelRotation();
}

int QCPAxis_TickLabelSide(const QCPAxis* self) {
    return static_cast<int>(self->tickLabelSide());
}

libqt_string QCPAxis_NumberFormat(const QCPAxis* self) {
    QString _ret = self->numberFormat();
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

int QCPAxis_NumberPrecision(const QCPAxis* self) {
    return self->numberPrecision();
}

libqt_list /* of double */ QCPAxis_TickVector(const QCPAxis* self) {
    QVector<double> _ret = self->tickVector();
    // Convert QVector<> from C++ memory to manually-managed C memory
    double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

libqt_list /* of libqt_string */ QCPAxis_TickVectorLabels(const QCPAxis* self) {
    QVector<QString> _ret = self->tickVectorLabels();
    // Convert QVector<> from C++ memory to manually-managed C memory
    libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        QString _vv_ret = _ret[i];
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _vv_b = _vv_ret.toUtf8();
        libqt_string _vv_str;
        _vv_str.len = _vv_b.length();
        _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
        memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
        ((char*)_vv_str.data)[_vv_str.len] = '\0';
        _arr[i] = _vv_str;
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

int QCPAxis_TickLengthIn(const QCPAxis* self) {
    return self->tickLengthIn();
}

int QCPAxis_TickLengthOut(const QCPAxis* self) {
    return self->tickLengthOut();
}

bool QCPAxis_SubTicks(const QCPAxis* self) {
    return self->subTicks();
}

int QCPAxis_SubTickLengthIn(const QCPAxis* self) {
    return self->subTickLengthIn();
}

int QCPAxis_SubTickLengthOut(const QCPAxis* self) {
    return self->subTickLengthOut();
}

QPen* QCPAxis_BasePen(const QCPAxis* self) {
    return new QPen(self->basePen());
}

QPen* QCPAxis_TickPen(const QCPAxis* self) {
    return new QPen(self->tickPen());
}

QPen* QCPAxis_SubTickPen(const QCPAxis* self) {
    return new QPen(self->subTickPen());
}

QFont* QCPAxis_LabelFont(const QCPAxis* self) {
    return new QFont(self->labelFont());
}

QColor* QCPAxis_LabelColor(const QCPAxis* self) {
    return new QColor(self->labelColor());
}

libqt_string QCPAxis_Label(const QCPAxis* self) {
    QString _ret = self->label();
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

int QCPAxis_LabelPadding(const QCPAxis* self) {
    return self->labelPadding();
}

int QCPAxis_Padding(const QCPAxis* self) {
    return self->padding();
}

int QCPAxis_Offset(const QCPAxis* self) {
    return self->offset();
}

int QCPAxis_SelectedParts(const QCPAxis* self) {
    return static_cast<int>(self->selectedParts());
}

int QCPAxis_SelectableParts(const QCPAxis* self) {
    return static_cast<int>(self->selectableParts());
}

QFont* QCPAxis_SelectedTickLabelFont(const QCPAxis* self) {
    return new QFont(self->selectedTickLabelFont());
}

QFont* QCPAxis_SelectedLabelFont(const QCPAxis* self) {
    return new QFont(self->selectedLabelFont());
}

QColor* QCPAxis_SelectedTickLabelColor(const QCPAxis* self) {
    return new QColor(self->selectedTickLabelColor());
}

QColor* QCPAxis_SelectedLabelColor(const QCPAxis* self) {
    return new QColor(self->selectedLabelColor());
}

QPen* QCPAxis_SelectedBasePen(const QCPAxis* self) {
    return new QPen(self->selectedBasePen());
}

QPen* QCPAxis_SelectedTickPen(const QCPAxis* self) {
    return new QPen(self->selectedTickPen());
}

QPen* QCPAxis_SelectedSubTickPen(const QCPAxis* self) {
    return new QPen(self->selectedSubTickPen());
}

QCPLineEnding* QCPAxis_LowerEnding(const QCPAxis* self) {
    return new QCPLineEnding(self->lowerEnding());
}

QCPLineEnding* QCPAxis_UpperEnding(const QCPAxis* self) {
    return new QCPLineEnding(self->upperEnding());
}

QCPGrid* QCPAxis_Grid(const QCPAxis* self) {
    return self->grid();
}

void QCPAxis_SetScaleType(QCPAxis* self, int typeVal) {
    self->setScaleType(static_cast<QCPAxis::ScaleType>(typeVal));
}

void QCPAxis_SetRange(QCPAxis* self, const QCPRange* range) {
    self->setRange(*range);
}

void QCPAxis_SetRange2(QCPAxis* self, double lower, double upper) {
    self->setRange(static_cast<double>(lower), static_cast<double>(upper));
}

void QCPAxis_SetRange3(QCPAxis* self, double position, double size, int alignment) {
    self->setRange(static_cast<double>(position), static_cast<double>(size), static_cast<Qt::AlignmentFlag>(alignment));
}

void QCPAxis_SetRangeLower(QCPAxis* self, double lower) {
    self->setRangeLower(static_cast<double>(lower));
}

void QCPAxis_SetRangeUpper(QCPAxis* self, double upper) {
    self->setRangeUpper(static_cast<double>(upper));
}

void QCPAxis_SetRangeReversed(QCPAxis* self, bool reversed) {
    self->setRangeReversed(reversed);
}

void QCPAxis_SetTicks(QCPAxis* self, bool show) {
    self->setTicks(show);
}

void QCPAxis_SetTickLabels(QCPAxis* self, bool show) {
    self->setTickLabels(show);
}

void QCPAxis_SetTickLabelPadding(QCPAxis* self, int padding) {
    self->setTickLabelPadding(static_cast<int>(padding));
}

void QCPAxis_SetTickLabelFont(QCPAxis* self, const QFont* font) {
    self->setTickLabelFont(*font);
}

void QCPAxis_SetTickLabelColor(QCPAxis* self, const QColor* color) {
    self->setTickLabelColor(*color);
}

void QCPAxis_SetTickLabelRotation(QCPAxis* self, double degrees) {
    self->setTickLabelRotation(static_cast<double>(degrees));
}

void QCPAxis_SetTickLabelSide(QCPAxis* self, int side) {
    self->setTickLabelSide(static_cast<QCPAxis::LabelSide>(side));
}

void QCPAxis_SetNumberFormat(QCPAxis* self, const libqt_string formatCode) {
    QString formatCode_QString = QString::fromUtf8(formatCode.data, formatCode.len);
    self->setNumberFormat(formatCode_QString);
}

void QCPAxis_SetNumberPrecision(QCPAxis* self, int precision) {
    self->setNumberPrecision(static_cast<int>(precision));
}

void QCPAxis_SetTickLength(QCPAxis* self, int inside) {
    self->setTickLength(static_cast<int>(inside));
}

void QCPAxis_SetTickLengthIn(QCPAxis* self, int inside) {
    self->setTickLengthIn(static_cast<int>(inside));
}

void QCPAxis_SetTickLengthOut(QCPAxis* self, int outside) {
    self->setTickLengthOut(static_cast<int>(outside));
}

void QCPAxis_SetSubTicks(QCPAxis* self, bool show) {
    self->setSubTicks(show);
}

void QCPAxis_SetSubTickLength(QCPAxis* self, int inside) {
    self->setSubTickLength(static_cast<int>(inside));
}

void QCPAxis_SetSubTickLengthIn(QCPAxis* self, int inside) {
    self->setSubTickLengthIn(static_cast<int>(inside));
}

void QCPAxis_SetSubTickLengthOut(QCPAxis* self, int outside) {
    self->setSubTickLengthOut(static_cast<int>(outside));
}

void QCPAxis_SetBasePen(QCPAxis* self, const QPen* pen) {
    self->setBasePen(*pen);
}

void QCPAxis_SetTickPen(QCPAxis* self, const QPen* pen) {
    self->setTickPen(*pen);
}

void QCPAxis_SetSubTickPen(QCPAxis* self, const QPen* pen) {
    self->setSubTickPen(*pen);
}

void QCPAxis_SetLabelFont(QCPAxis* self, const QFont* font) {
    self->setLabelFont(*font);
}

void QCPAxis_SetLabelColor(QCPAxis* self, const QColor* color) {
    self->setLabelColor(*color);
}

void QCPAxis_SetLabel(QCPAxis* self, const libqt_string str) {
    QString str_QString = QString::fromUtf8(str.data, str.len);
    self->setLabel(str_QString);
}

void QCPAxis_SetLabelPadding(QCPAxis* self, int padding) {
    self->setLabelPadding(static_cast<int>(padding));
}

void QCPAxis_SetPadding(QCPAxis* self, int padding) {
    self->setPadding(static_cast<int>(padding));
}

void QCPAxis_SetOffset(QCPAxis* self, int offset) {
    self->setOffset(static_cast<int>(offset));
}

void QCPAxis_SetSelectedTickLabelFont(QCPAxis* self, const QFont* font) {
    self->setSelectedTickLabelFont(*font);
}

void QCPAxis_SetSelectedLabelFont(QCPAxis* self, const QFont* font) {
    self->setSelectedLabelFont(*font);
}

void QCPAxis_SetSelectedTickLabelColor(QCPAxis* self, const QColor* color) {
    self->setSelectedTickLabelColor(*color);
}

void QCPAxis_SetSelectedLabelColor(QCPAxis* self, const QColor* color) {
    self->setSelectedLabelColor(*color);
}

void QCPAxis_SetSelectedBasePen(QCPAxis* self, const QPen* pen) {
    self->setSelectedBasePen(*pen);
}

void QCPAxis_SetSelectedTickPen(QCPAxis* self, const QPen* pen) {
    self->setSelectedTickPen(*pen);
}

void QCPAxis_SetSelectedSubTickPen(QCPAxis* self, const QPen* pen) {
    self->setSelectedSubTickPen(*pen);
}

void QCPAxis_SetSelectableParts(QCPAxis* self, const int* selectableParts) {
    self->setSelectableParts((const QCPAxis::SelectableParts&)(*selectableParts));
}

void QCPAxis_SetSelectedParts(QCPAxis* self, const int* selectedParts) {
    self->setSelectedParts((const QCPAxis::SelectableParts&)(*selectedParts));
}

void QCPAxis_SetLowerEnding(QCPAxis* self, const QCPLineEnding* ending) {
    self->setLowerEnding(*ending);
}

void QCPAxis_SetUpperEnding(QCPAxis* self, const QCPLineEnding* ending) {
    self->setUpperEnding(*ending);
}

double QCPAxis_SelectTest(const QCPAxis* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpaxis = dynamic_cast<const VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPAxis*)self)->selectTest(*pos, onlySelectable, details);
    }
}

int QCPAxis_Orientation(const QCPAxis* self) {
    return static_cast<int>(self->orientation());
}

int QCPAxis_PixelOrientation(const QCPAxis* self) {
    return self->pixelOrientation();
}

void QCPAxis_MoveRange(QCPAxis* self, double diff) {
    self->moveRange(static_cast<double>(diff));
}

void QCPAxis_ScaleRange(QCPAxis* self, double factor) {
    self->scaleRange(static_cast<double>(factor));
}

void QCPAxis_ScaleRange2(QCPAxis* self, double factor, double center) {
    self->scaleRange(static_cast<double>(factor), static_cast<double>(center));
}

void QCPAxis_SetScaleRatio(QCPAxis* self, const QCPAxis* otherAxis) {
    self->setScaleRatio(otherAxis);
}

void QCPAxis_Rescale(QCPAxis* self) {
    self->rescale();
}

double QCPAxis_PixelToCoord(const QCPAxis* self, double value) {
    return self->pixelToCoord(static_cast<double>(value));
}

double QCPAxis_CoordToPixel(const QCPAxis* self, double value) {
    return self->coordToPixel(static_cast<double>(value));
}

int QCPAxis_GetPartAt(const QCPAxis* self, const QPointF* pos) {
    return static_cast<int>(self->getPartAt(*pos));
}

libqt_list /* of QCPAbstractPlottable* */ QCPAxis_Plottables(const QCPAxis* self) {
    QList<QCPAbstractPlottable*> _ret = self->plottables();
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPAbstractPlottable** _arr = static_cast<QCPAbstractPlottable**>(malloc(sizeof(QCPAbstractPlottable*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

libqt_list /* of QCPGraph* */ QCPAxis_Graphs(const QCPAxis* self) {
    QList<QCPGraph*> _ret = self->graphs();
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPGraph** _arr = static_cast<QCPGraph**>(malloc(sizeof(QCPGraph*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

libqt_list /* of QCPAbstractItem* */ QCPAxis_Items(const QCPAxis* self) {
    QList<QCPAbstractItem*> _ret = self->items();
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPAbstractItem** _arr = static_cast<QCPAbstractItem**>(malloc(sizeof(QCPAbstractItem*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

int QCPAxis_MarginSideToAxisType(int side) {
    return static_cast<int>(QCPAxis::marginSideToAxisType(static_cast<QCP::MarginSide>(side)));
}

int QCPAxis_Orientation2(int typeVal) {
    return static_cast<int>(QCPAxis::orientation(static_cast<QCPAxis::AxisType>(typeVal)));
}

int QCPAxis_Opposite(int typeVal) {
    return static_cast<int>(QCPAxis::opposite(static_cast<QCPAxis::AxisType>(typeVal)));
}

void QCPAxis_RangeChanged(QCPAxis* self, const QCPRange* newRange) {
    self->rangeChanged(*newRange);
}

void QCPAxis_RangeChanged2(QCPAxis* self, const QCPRange* newRange, const QCPRange* oldRange) {
    self->rangeChanged(*newRange, *oldRange);
}

void QCPAxis_ScaleTypeChanged(QCPAxis* self, int scaleType) {
    self->scaleTypeChanged(static_cast<QCPAxis::ScaleType>(scaleType));
}

void QCPAxis_SelectionChanged(QCPAxis* self, const int* parts) {
    self->selectionChanged((const QCPAxis::SelectableParts&)(*parts));
}

void QCPAxis_SelectableChanged(QCPAxis* self, const int* parts) {
    self->selectableChanged((const QCPAxis::SelectableParts&)(*parts));
}

int QCPAxis_CalculateMargin(QCPAxis* self) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        return vqcpaxis->calculateMargin();
    }
    return {};
}

void QCPAxis_ApplyDefaultAntialiasingHint(const QCPAxis* self, QCPPainter* painter) {
    auto* vqcpaxis = dynamic_cast<const VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->applyDefaultAntialiasingHint(painter);
    }
}

void QCPAxis_Draw(QCPAxis* self, QCPPainter* painter) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->draw(painter);
    }
}

int QCPAxis_SelectionCategory(const QCPAxis* self) {
    auto* vqcpaxis = dynamic_cast<const VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        return static_cast<int>(vqcpaxis->selectionCategory());
    }
    return {};
}

void QCPAxis_SelectEvent(QCPAxis* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

void QCPAxis_DeselectEvent(QCPAxis* self, bool* selectionStateChanged) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->deselectEvent(selectionStateChanged);
    }
}

void QCPAxis_MousePressEvent(QCPAxis* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->mousePressEvent(event, *details);
    }
}

void QCPAxis_MouseMoveEvent(QCPAxis* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->mouseMoveEvent(event, *startPos);
    }
}

void QCPAxis_MouseReleaseEvent(QCPAxis* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->mouseReleaseEvent(event, *startPos);
    }
}

void QCPAxis_WheelEvent(QCPAxis* self, QWheelEvent* event) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->wheelEvent(event);
    }
}

libqt_string QCPAxis_Tr2(const char* s, const char* c) {
    QString _ret = QCPAxis::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPAxis_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPAxis::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

void QCPAxis_SetTickLength2(QCPAxis* self, int inside, int outside) {
    self->setTickLength(static_cast<int>(inside), static_cast<int>(outside));
}

void QCPAxis_SetSubTickLength2(QCPAxis* self, int inside, int outside) {
    self->setSubTickLength(static_cast<int>(inside), static_cast<int>(outside));
}

void QCPAxis_SetScaleRatio2(QCPAxis* self, const QCPAxis* otherAxis, double ratio) {
    self->setScaleRatio(otherAxis, static_cast<double>(ratio));
}

void QCPAxis_Rescale1(QCPAxis* self, bool onlyVisiblePlottables) {
    self->rescale(onlyVisiblePlottables);
}

// Base class handler implementation
int QCPAxis_QBaseMetacall(QCPAxis* self, int param1, int param2, void** param3) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_Metacall_IsBase(true);
        return vqcpaxis->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPAxis::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnMetacall(QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_Metacall_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
double QCPAxis_QBaseSelectTest(const QCPAxis* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_SelectTest_IsBase(true);
        return vqcpaxis->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPAxis::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnSelectTest(const QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_SelectTest_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
int QCPAxis_QBaseCalculateMargin(QCPAxis* self) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_CalculateMargin_IsBase(true);
        return vqcpaxis->calculateMargin();
    } else {
        return ((VirtualQCPAxis*)self)->calculateMargin();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnCalculateMargin(QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_CalculateMargin_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_CalculateMargin_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAxis_QBaseApplyDefaultAntialiasingHint(const QCPAxis* self, QCPPainter* painter) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcpaxis->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPAxis*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnApplyDefaultAntialiasingHint(const QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAxis_QBaseDraw(QCPAxis* self, QCPPainter* painter) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_Draw_IsBase(true);
        vqcpaxis->draw(painter);
    } else {
        ((VirtualQCPAxis*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnDraw(QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_Draw_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_Draw_Callback>(slot));
    }
}

// Base class handler implementation
int QCPAxis_QBaseSelectionCategory(const QCPAxis* self) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcpaxis->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPAxis*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnSelectionCategory(const QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_SelectionCategory_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_SelectionCategory_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAxis_QBaseSelectEvent(QCPAxis* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_SelectEvent_IsBase(true);
        vqcpaxis->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPAxis*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnSelectEvent(QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_SelectEvent_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_SelectEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAxis_QBaseDeselectEvent(QCPAxis* self, bool* selectionStateChanged) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_DeselectEvent_IsBase(true);
        vqcpaxis->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPAxis*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnDeselectEvent(QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_DeselectEvent_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_DeselectEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAxis_QBaseMousePressEvent(QCPAxis* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_MousePressEvent_IsBase(true);
        vqcpaxis->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPAxis*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnMousePressEvent(QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_MousePressEvent_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_MousePressEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAxis_QBaseMouseMoveEvent(QCPAxis* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_MouseMoveEvent_IsBase(true);
        vqcpaxis->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPAxis*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnMouseMoveEvent(QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_MouseMoveEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAxis_QBaseMouseReleaseEvent(QCPAxis* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_MouseReleaseEvent_IsBase(true);
        vqcpaxis->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPAxis*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnMouseReleaseEvent(QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_MouseReleaseEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAxis_QBaseWheelEvent(QCPAxis* self, QWheelEvent* event) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_WheelEvent_IsBase(true);
        vqcpaxis->wheelEvent(event);
    } else {
        ((VirtualQCPAxis*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnWheelEvent(QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_WheelEvent_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxis_ParentPlotInitialized(QCPAxis* self, QCustomPlot* parentPlot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPAxis*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPAxis_QBaseParentPlotInitialized(QCPAxis* self, QCustomPlot* parentPlot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_ParentPlotInitialized_IsBase(true);
        vqcpaxis->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPAxis*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnParentPlotInitialized(QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPAxis_ClipRect(const QCPAxis* self) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        return new QRect(vqcpaxis->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPAxis_QBaseClipRect(const QCPAxis* self) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_ClipRect_IsBase(true);
        return new QRect(vqcpaxis->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnClipRect(const QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_ClipRect_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxis_MouseDoubleClickEvent(QCPAxis* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPAxis*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPAxis_QBaseMouseDoubleClickEvent(QCPAxis* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_MouseDoubleClickEvent_IsBase(true);
        vqcpaxis->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPAxis*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnMouseDoubleClickEvent(QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPAxis_Event(QCPAxis* self, QEvent* event) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        return vqcpaxis->event(event);
    } else {
        return self->QCPAxis::event(event);
    }
}

// Base class handler implementation
bool QCPAxis_QBaseEvent(QCPAxis* self, QEvent* event) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_Event_IsBase(true);
        return vqcpaxis->event(event);
    } else {
        return self->QCPAxis::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnEvent(QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_Event_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPAxis_EventFilter(QCPAxis* self, QObject* watched, QEvent* event) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        return vqcpaxis->eventFilter(watched, event);
    } else {
        return self->QCPAxis::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPAxis_QBaseEventFilter(QCPAxis* self, QObject* watched, QEvent* event) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_EventFilter_IsBase(true);
        return vqcpaxis->eventFilter(watched, event);
    } else {
        return self->QCPAxis::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnEventFilter(QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_EventFilter_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxis_TimerEvent(QCPAxis* self, QTimerEvent* event) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->timerEvent(event);
    } else {
        ((VirtualQCPAxis*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPAxis_QBaseTimerEvent(QCPAxis* self, QTimerEvent* event) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_TimerEvent_IsBase(true);
        vqcpaxis->timerEvent(event);
    } else {
        ((VirtualQCPAxis*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnTimerEvent(QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_TimerEvent_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxis_ChildEvent(QCPAxis* self, QChildEvent* event) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->childEvent(event);
    } else {
        ((VirtualQCPAxis*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPAxis_QBaseChildEvent(QCPAxis* self, QChildEvent* event) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_ChildEvent_IsBase(true);
        vqcpaxis->childEvent(event);
    } else {
        ((VirtualQCPAxis*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnChildEvent(QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_ChildEvent_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxis_CustomEvent(QCPAxis* self, QEvent* event) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->customEvent(event);
    } else {
        ((VirtualQCPAxis*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPAxis_QBaseCustomEvent(QCPAxis* self, QEvent* event) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_CustomEvent_IsBase(true);
        vqcpaxis->customEvent(event);
    } else {
        ((VirtualQCPAxis*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnCustomEvent(QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_CustomEvent_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxis_ConnectNotify(QCPAxis* self, const QMetaMethod* signal) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->connectNotify(*signal);
    } else {
        ((VirtualQCPAxis*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPAxis_QBaseConnectNotify(QCPAxis* self, const QMetaMethod* signal) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_ConnectNotify_IsBase(true);
        vqcpaxis->connectNotify(*signal);
    } else {
        ((VirtualQCPAxis*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnConnectNotify(QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_ConnectNotify_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxis_DisconnectNotify(QCPAxis* self, const QMetaMethod* signal) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->disconnectNotify(*signal);
    } else {
        ((VirtualQCPAxis*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPAxis_QBaseDisconnectNotify(QCPAxis* self, const QMetaMethod* signal) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_DisconnectNotify_IsBase(true);
        vqcpaxis->disconnectNotify(*signal);
    } else {
        ((VirtualQCPAxis*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnDisconnectNotify(QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxis_SetupTickVectors(QCPAxis* self) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setupTickVectors();
    } else {
        ((VirtualQCPAxis*)self)->setupTickVectors();
    }
}

// Base class handler implementation
void QCPAxis_QBaseSetupTickVectors(QCPAxis* self) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_SetupTickVectors_IsBase(true);
        vqcpaxis->setupTickVectors();
    } else {
        ((VirtualQCPAxis*)self)->setupTickVectors();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnSetupTickVectors(QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_SetupTickVectors_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_SetupTickVectors_Callback>(slot));
    }
}

// Derived class handler implementation
QPen* QCPAxis_GetBasePen(const QCPAxis* self) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        return new QPen(vqcpaxis->getBasePen());
    }
    return {};
}

// Base class handler implementation
QPen* QCPAxis_QBaseGetBasePen(const QCPAxis* self) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_GetBasePen_IsBase(true);
        return new QPen(vqcpaxis->getBasePen());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnGetBasePen(const QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_GetBasePen_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_GetBasePen_Callback>(slot));
    }
}

// Derived class handler implementation
QPen* QCPAxis_GetTickPen(const QCPAxis* self) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        return new QPen(vqcpaxis->getTickPen());
    }
    return {};
}

// Base class handler implementation
QPen* QCPAxis_QBaseGetTickPen(const QCPAxis* self) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_GetTickPen_IsBase(true);
        return new QPen(vqcpaxis->getTickPen());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnGetTickPen(const QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_GetTickPen_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_GetTickPen_Callback>(slot));
    }
}

// Derived class handler implementation
QPen* QCPAxis_GetSubTickPen(const QCPAxis* self) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        return new QPen(vqcpaxis->getSubTickPen());
    }
    return {};
}

// Base class handler implementation
QPen* QCPAxis_QBaseGetSubTickPen(const QCPAxis* self) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_GetSubTickPen_IsBase(true);
        return new QPen(vqcpaxis->getSubTickPen());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnGetSubTickPen(const QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_GetSubTickPen_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_GetSubTickPen_Callback>(slot));
    }
}

// Derived class handler implementation
QFont* QCPAxis_GetTickLabelFont(const QCPAxis* self) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        return new QFont(vqcpaxis->getTickLabelFont());
    }
    return {};
}

// Base class handler implementation
QFont* QCPAxis_QBaseGetTickLabelFont(const QCPAxis* self) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_GetTickLabelFont_IsBase(true);
        return new QFont(vqcpaxis->getTickLabelFont());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnGetTickLabelFont(const QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_GetTickLabelFont_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_GetTickLabelFont_Callback>(slot));
    }
}

// Derived class handler implementation
QFont* QCPAxis_GetLabelFont(const QCPAxis* self) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        return new QFont(vqcpaxis->getLabelFont());
    }
    return {};
}

// Base class handler implementation
QFont* QCPAxis_QBaseGetLabelFont(const QCPAxis* self) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_GetLabelFont_IsBase(true);
        return new QFont(vqcpaxis->getLabelFont());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnGetLabelFont(const QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_GetLabelFont_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_GetLabelFont_Callback>(slot));
    }
}

// Derived class handler implementation
QColor* QCPAxis_GetTickLabelColor(const QCPAxis* self) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        return new QColor(vqcpaxis->getTickLabelColor());
    }
    return {};
}

// Base class handler implementation
QColor* QCPAxis_QBaseGetTickLabelColor(const QCPAxis* self) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_GetTickLabelColor_IsBase(true);
        return new QColor(vqcpaxis->getTickLabelColor());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnGetTickLabelColor(const QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_GetTickLabelColor_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_GetTickLabelColor_Callback>(slot));
    }
}

// Derived class handler implementation
QColor* QCPAxis_GetLabelColor(const QCPAxis* self) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        return new QColor(vqcpaxis->getLabelColor());
    }
    return {};
}

// Base class handler implementation
QColor* QCPAxis_QBaseGetLabelColor(const QCPAxis* self) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_GetLabelColor_IsBase(true);
        return new QColor(vqcpaxis->getLabelColor());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnGetLabelColor(const QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_GetLabelColor_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_GetLabelColor_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxis_InitializeParentPlot(QCPAxis* self, QCustomPlot* parentPlot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPAxis*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPAxis_QBaseInitializeParentPlot(QCPAxis* self, QCustomPlot* parentPlot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_InitializeParentPlot_IsBase(true);
        vqcpaxis->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPAxis*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnInitializeParentPlot(QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxis_SetParentLayerable(QCPAxis* self, QCPLayerable* parentLayerable) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPAxis*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPAxis_QBaseSetParentLayerable(QCPAxis* self, QCPLayerable* parentLayerable) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_SetParentLayerable_IsBase(true);
        vqcpaxis->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPAxis*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnSetParentLayerable(QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPAxis_MoveToLayer(QCPAxis* self, QCPLayer* layer, bool prepend) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        return vqcpaxis->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPAxis*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPAxis_QBaseMoveToLayer(QCPAxis* self, QCPLayer* layer, bool prepend) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_MoveToLayer_IsBase(true);
        return vqcpaxis->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPAxis*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnMoveToLayer(QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = dynamic_cast<VirtualQCPAxis*>(self);
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_MoveToLayer_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxis_ApplyAntialiasingHint(const QCPAxis* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPAxis*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPAxis_QBaseApplyAntialiasingHint(const QCPAxis* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_ApplyAntialiasingHint_IsBase(true);
        vqcpaxis->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPAxis*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnApplyAntialiasingHint(const QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPAxis_Sender(const QCPAxis* self) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        return vqcpaxis->sender();
    } else {
        return ((VirtualQCPAxis*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPAxis_QBaseSender(const QCPAxis* self) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_Sender_IsBase(true);
        return vqcpaxis->sender();
    } else {
        return ((VirtualQCPAxis*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnSender(const QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_Sender_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPAxis_SenderSignalIndex(const QCPAxis* self) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        return vqcpaxis->senderSignalIndex();
    } else {
        return ((VirtualQCPAxis*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPAxis_QBaseSenderSignalIndex(const QCPAxis* self) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_SenderSignalIndex_IsBase(true);
        return vqcpaxis->senderSignalIndex();
    } else {
        return ((VirtualQCPAxis*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnSenderSignalIndex(const QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPAxis_Receivers(const QCPAxis* self, const char* signal) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        return vqcpaxis->receivers(signal);
    } else {
        return ((VirtualQCPAxis*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPAxis_QBaseReceivers(const QCPAxis* self, const char* signal) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_Receivers_IsBase(true);
        return vqcpaxis->receivers(signal);
    } else {
        return ((VirtualQCPAxis*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnReceivers(const QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_Receivers_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPAxis_IsSignalConnected(const QCPAxis* self, const QMetaMethod* signal) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        return vqcpaxis->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPAxis*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPAxis_QBaseIsSignalConnected(const QCPAxis* self, const QMetaMethod* signal) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_IsSignalConnected_IsBase(true);
        return vqcpaxis->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPAxis*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxis_OnIsSignalConnected(const QCPAxis* self, intptr_t slot) {
    auto* vqcpaxis = const_cast<VirtualQCPAxis*>(dynamic_cast<const VirtualQCPAxis*>(self));
    if (vqcpaxis && vqcpaxis->isVirtualQCPAxis) {
        vqcpaxis->setQCPAxis_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPAxis::QCPAxis_IsSignalConnected_Callback>(slot));
    }
}

void QCPAxis_Delete(QCPAxis* self) {
    delete self;
}

QCPScatterStyle* QCPScatterStyle_new() {
    return new QCPScatterStyle();
}

QCPScatterStyle* QCPScatterStyle_new2(int shape) {
    return new QCPScatterStyle(static_cast<QCPScatterStyle::ScatterShape>(shape));
}

QCPScatterStyle* QCPScatterStyle_new3(int shape, const QColor* color, double size) {
    return new QCPScatterStyle(static_cast<QCPScatterStyle::ScatterShape>(shape), *color, static_cast<double>(size));
}

QCPScatterStyle* QCPScatterStyle_new4(int shape, const QColor* color, const QColor* fill, double size) {
    return new QCPScatterStyle(static_cast<QCPScatterStyle::ScatterShape>(shape), *color, *fill, static_cast<double>(size));
}

QCPScatterStyle* QCPScatterStyle_new5(int shape, const QPen* pen, const QBrush* brush, double size) {
    return new QCPScatterStyle(static_cast<QCPScatterStyle::ScatterShape>(shape), *pen, *brush, static_cast<double>(size));
}

QCPScatterStyle* QCPScatterStyle_new6(const QPixmap* pixmap) {
    return new QCPScatterStyle(*pixmap);
}

QCPScatterStyle* QCPScatterStyle_new7(const QPainterPath* customPath, const QPen* pen) {
    return new QCPScatterStyle(*customPath, *pen);
}

QCPScatterStyle* QCPScatterStyle_new8(int shape, double size) {
    return new QCPScatterStyle(static_cast<QCPScatterStyle::ScatterShape>(shape), static_cast<double>(size));
}

QCPScatterStyle* QCPScatterStyle_new9(const QPainterPath* customPath, const QPen* pen, const QBrush* brush) {
    return new QCPScatterStyle(*customPath, *pen, *brush);
}

QCPScatterStyle* QCPScatterStyle_new10(const QPainterPath* customPath, const QPen* pen, const QBrush* brush, double size) {
    return new QCPScatterStyle(*customPath, *pen, *brush, static_cast<double>(size));
}

double QCPScatterStyle_Size(const QCPScatterStyle* self) {
    return self->size();
}

int QCPScatterStyle_Shape(const QCPScatterStyle* self) {
    return static_cast<int>(self->shape());
}

QPen* QCPScatterStyle_Pen(const QCPScatterStyle* self) {
    return new QPen(self->pen());
}

QBrush* QCPScatterStyle_Brush(const QCPScatterStyle* self) {
    return new QBrush(self->brush());
}

QPixmap* QCPScatterStyle_Pixmap(const QCPScatterStyle* self) {
    return new QPixmap(self->pixmap());
}

QPainterPath* QCPScatterStyle_CustomPath(const QCPScatterStyle* self) {
    return new QPainterPath(self->customPath());
}

void QCPScatterStyle_SetFromOther(QCPScatterStyle* self, const QCPScatterStyle* other, int properties) {
    self->setFromOther(*other, static_cast<QFlags<QCPScatterStyle::ScatterProperty>>(properties));
}

void QCPScatterStyle_SetSize(QCPScatterStyle* self, double size) {
    self->setSize(static_cast<double>(size));
}

void QCPScatterStyle_SetShape(QCPScatterStyle* self, int shape) {
    self->setShape(static_cast<QCPScatterStyle::ScatterShape>(shape));
}

void QCPScatterStyle_SetPen(QCPScatterStyle* self, const QPen* pen) {
    self->setPen(*pen);
}

void QCPScatterStyle_SetBrush(QCPScatterStyle* self, const QBrush* brush) {
    self->setBrush(*brush);
}

void QCPScatterStyle_SetPixmap(QCPScatterStyle* self, const QPixmap* pixmap) {
    self->setPixmap(*pixmap);
}

void QCPScatterStyle_SetCustomPath(QCPScatterStyle* self, const QPainterPath* customPath) {
    self->setCustomPath(*customPath);
}

bool QCPScatterStyle_IsNone(const QCPScatterStyle* self) {
    return self->isNone();
}

bool QCPScatterStyle_IsPenDefined(const QCPScatterStyle* self) {
    return self->isPenDefined();
}

void QCPScatterStyle_UndefinePen(QCPScatterStyle* self) {
    self->undefinePen();
}

void QCPScatterStyle_ApplyTo(const QCPScatterStyle* self, QCPPainter* painter, const QPen* defaultPen) {
    self->applyTo(painter, *defaultPen);
}

void QCPScatterStyle_DrawShape(const QCPScatterStyle* self, QCPPainter* painter, const QPointF* pos) {
    self->drawShape(painter, *pos);
}

void QCPScatterStyle_DrawShape2(const QCPScatterStyle* self, QCPPainter* painter, double x, double y) {
    self->drawShape(painter, static_cast<double>(x), static_cast<double>(y));
}

void QCPScatterStyle_Delete(QCPScatterStyle* self) {
    delete self;
}

QCPSelectionDecorator* QCPSelectionDecorator_new() {
    return new VirtualQCPSelectionDecorator();
}

QPen* QCPSelectionDecorator_Pen(const QCPSelectionDecorator* self) {
    return new QPen(self->pen());
}

QBrush* QCPSelectionDecorator_Brush(const QCPSelectionDecorator* self) {
    return new QBrush(self->brush());
}

QCPScatterStyle* QCPSelectionDecorator_ScatterStyle(const QCPSelectionDecorator* self) {
    return new QCPScatterStyle(self->scatterStyle());
}

int QCPSelectionDecorator_UsedScatterProperties(const QCPSelectionDecorator* self) {
    return static_cast<int>(self->usedScatterProperties());
}

void QCPSelectionDecorator_SetPen(QCPSelectionDecorator* self, const QPen* pen) {
    self->setPen(*pen);
}

void QCPSelectionDecorator_SetBrush(QCPSelectionDecorator* self, const QBrush* brush) {
    self->setBrush(*brush);
}

void QCPSelectionDecorator_SetScatterStyle(QCPSelectionDecorator* self, const QCPScatterStyle* scatterStyle) {
    self->setScatterStyle(*scatterStyle);
}

void QCPSelectionDecorator_SetUsedScatterProperties(QCPSelectionDecorator* self, const int* properties) {
    self->setUsedScatterProperties((const QCPScatterStyle::ScatterProperties&)(*properties));
}

void QCPSelectionDecorator_ApplyPen(const QCPSelectionDecorator* self, QCPPainter* painter) {
    self->applyPen(painter);
}

void QCPSelectionDecorator_ApplyBrush(const QCPSelectionDecorator* self, QCPPainter* painter) {
    self->applyBrush(painter);
}

QCPScatterStyle* QCPSelectionDecorator_GetFinalScatterStyle(const QCPSelectionDecorator* self, const QCPScatterStyle* unselectedStyle) {
    return new QCPScatterStyle(self->getFinalScatterStyle(*unselectedStyle));
}

void QCPSelectionDecorator_CopyFrom(QCPSelectionDecorator* self, const QCPSelectionDecorator* other) {
    auto* vqcpselectiondecorator = dynamic_cast<VirtualQCPSelectionDecorator*>(self);
    if (vqcpselectiondecorator && vqcpselectiondecorator->isVirtualQCPSelectionDecorator) {
        self->copyFrom(other);
    } else {
        ((VirtualQCPSelectionDecorator*)self)->copyFrom(other);
    }
}

void QCPSelectionDecorator_DrawDecoration(QCPSelectionDecorator* self, QCPPainter* painter, QCPDataSelection* selection) {
    auto* vqcpselectiondecorator = dynamic_cast<VirtualQCPSelectionDecorator*>(self);
    if (vqcpselectiondecorator && vqcpselectiondecorator->isVirtualQCPSelectionDecorator) {
        self->drawDecoration(painter, *selection);
    } else {
        ((VirtualQCPSelectionDecorator*)self)->drawDecoration(painter, *selection);
    }
}

bool QCPSelectionDecorator_RegisterWithPlottable(QCPSelectionDecorator* self, QCPAbstractPlottable* plottable) {
    auto* vqcpselectiondecorator = dynamic_cast<VirtualQCPSelectionDecorator*>(self);
    if (vqcpselectiondecorator && vqcpselectiondecorator->isVirtualQCPSelectionDecorator) {
        return vqcpselectiondecorator->registerWithPlottable(plottable);
    }
    return {};
}

void QCPSelectionDecorator_SetScatterStyle2(QCPSelectionDecorator* self, const QCPScatterStyle* scatterStyle, int usedProperties) {
    self->setScatterStyle(*scatterStyle, static_cast<QCPScatterStyle::ScatterProperties>(usedProperties));
}

// Base class handler implementation
void QCPSelectionDecorator_QBaseCopyFrom(QCPSelectionDecorator* self, const QCPSelectionDecorator* other) {
    auto* vqcpselectiondecorator = dynamic_cast<VirtualQCPSelectionDecorator*>(self);
    if (vqcpselectiondecorator && vqcpselectiondecorator->isVirtualQCPSelectionDecorator) {
        vqcpselectiondecorator->setQCPSelectionDecorator_CopyFrom_IsBase(true);
        vqcpselectiondecorator->copyFrom(other);
    } else {
        self->QCPSelectionDecorator::copyFrom(other);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionDecorator_OnCopyFrom(QCPSelectionDecorator* self, intptr_t slot) {
    auto* vqcpselectiondecorator = dynamic_cast<VirtualQCPSelectionDecorator*>(self);
    if (vqcpselectiondecorator && vqcpselectiondecorator->isVirtualQCPSelectionDecorator) {
        vqcpselectiondecorator->setQCPSelectionDecorator_CopyFrom_Callback(reinterpret_cast<VirtualQCPSelectionDecorator::QCPSelectionDecorator_CopyFrom_Callback>(slot));
    }
}

// Base class handler implementation
void QCPSelectionDecorator_QBaseDrawDecoration(QCPSelectionDecorator* self, QCPPainter* painter, QCPDataSelection* selection) {
    auto* vqcpselectiondecorator = dynamic_cast<VirtualQCPSelectionDecorator*>(self);
    if (vqcpselectiondecorator && vqcpselectiondecorator->isVirtualQCPSelectionDecorator) {
        vqcpselectiondecorator->setQCPSelectionDecorator_DrawDecoration_IsBase(true);
        vqcpselectiondecorator->drawDecoration(painter, *selection);
    } else {
        self->QCPSelectionDecorator::drawDecoration(painter, *selection);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionDecorator_OnDrawDecoration(QCPSelectionDecorator* self, intptr_t slot) {
    auto* vqcpselectiondecorator = dynamic_cast<VirtualQCPSelectionDecorator*>(self);
    if (vqcpselectiondecorator && vqcpselectiondecorator->isVirtualQCPSelectionDecorator) {
        vqcpselectiondecorator->setQCPSelectionDecorator_DrawDecoration_Callback(reinterpret_cast<VirtualQCPSelectionDecorator::QCPSelectionDecorator_DrawDecoration_Callback>(slot));
    }
}

// Base class handler implementation
bool QCPSelectionDecorator_QBaseRegisterWithPlottable(QCPSelectionDecorator* self, QCPAbstractPlottable* plottable) {
    auto* vqcpselectiondecorator = dynamic_cast<VirtualQCPSelectionDecorator*>(self);
    if (vqcpselectiondecorator && vqcpselectiondecorator->isVirtualQCPSelectionDecorator) {
        vqcpselectiondecorator->setQCPSelectionDecorator_RegisterWithPlottable_IsBase(true);
        return vqcpselectiondecorator->registerWithPlottable(plottable);
    } else {
        return ((VirtualQCPSelectionDecorator*)self)->registerWithPlottable(plottable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionDecorator_OnRegisterWithPlottable(QCPSelectionDecorator* self, intptr_t slot) {
    auto* vqcpselectiondecorator = dynamic_cast<VirtualQCPSelectionDecorator*>(self);
    if (vqcpselectiondecorator && vqcpselectiondecorator->isVirtualQCPSelectionDecorator) {
        vqcpselectiondecorator->setQCPSelectionDecorator_RegisterWithPlottable_Callback(reinterpret_cast<VirtualQCPSelectionDecorator::QCPSelectionDecorator_RegisterWithPlottable_Callback>(slot));
    }
}

void QCPSelectionDecorator_Delete(QCPSelectionDecorator* self) {
    delete self;
}

QCPAbstractPlottable* QCPAbstractPlottable_new(QCPAxis* keyAxis, QCPAxis* valueAxis) {
    return new VirtualQCPAbstractPlottable(keyAxis, valueAxis);
}

QMetaObject* QCPAbstractPlottable_MetaObject(const QCPAbstractPlottable* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPAbstractPlottable_Metacast(QCPAbstractPlottable* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPAbstractPlottable_Metacall(QCPAbstractPlottable* self, int param1, int param2, void** param3) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPAbstractPlottable*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPAbstractPlottable_Tr(const char* s) {
    QString _ret = QCPAbstractPlottable::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPAbstractPlottable_Name(const QCPAbstractPlottable* self) {
    QString _ret = self->name();
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

bool QCPAbstractPlottable_AntialiasedFill(const QCPAbstractPlottable* self) {
    return self->antialiasedFill();
}

bool QCPAbstractPlottable_AntialiasedScatters(const QCPAbstractPlottable* self) {
    return self->antialiasedScatters();
}

QPen* QCPAbstractPlottable_Pen(const QCPAbstractPlottable* self) {
    return new QPen(self->pen());
}

QBrush* QCPAbstractPlottable_Brush(const QCPAbstractPlottable* self) {
    return new QBrush(self->brush());
}

QCPAxis* QCPAbstractPlottable_KeyAxis(const QCPAbstractPlottable* self) {
    return self->keyAxis();
}

QCPAxis* QCPAbstractPlottable_ValueAxis(const QCPAbstractPlottable* self) {
    return self->valueAxis();
}

int QCPAbstractPlottable_Selectable(const QCPAbstractPlottable* self) {
    return static_cast<int>(self->selectable());
}

bool QCPAbstractPlottable_Selected(const QCPAbstractPlottable* self) {
    return self->selected();
}

QCPDataSelection* QCPAbstractPlottable_Selection(const QCPAbstractPlottable* self) {
    return new QCPDataSelection(self->selection());
}

QCPSelectionDecorator* QCPAbstractPlottable_SelectionDecorator(const QCPAbstractPlottable* self) {
    return self->selectionDecorator();
}

void QCPAbstractPlottable_SetName(QCPAbstractPlottable* self, const libqt_string name) {
    QString name_QString = QString::fromUtf8(name.data, name.len);
    self->setName(name_QString);
}

void QCPAbstractPlottable_SetAntialiasedFill(QCPAbstractPlottable* self, bool enabled) {
    self->setAntialiasedFill(enabled);
}

void QCPAbstractPlottable_SetAntialiasedScatters(QCPAbstractPlottable* self, bool enabled) {
    self->setAntialiasedScatters(enabled);
}

void QCPAbstractPlottable_SetPen(QCPAbstractPlottable* self, const QPen* pen) {
    self->setPen(*pen);
}

void QCPAbstractPlottable_SetBrush(QCPAbstractPlottable* self, const QBrush* brush) {
    self->setBrush(*brush);
}

void QCPAbstractPlottable_SetKeyAxis(QCPAbstractPlottable* self, QCPAxis* axis) {
    self->setKeyAxis(axis);
}

void QCPAbstractPlottable_SetValueAxis(QCPAbstractPlottable* self, QCPAxis* axis) {
    self->setValueAxis(axis);
}

void QCPAbstractPlottable_SetSelectable(QCPAbstractPlottable* self, int selectable) {
    self->setSelectable(static_cast<QCP::SelectionType>(selectable));
}

void QCPAbstractPlottable_SetSelection(QCPAbstractPlottable* self, QCPDataSelection* selection) {
    self->setSelection(*selection);
}

void QCPAbstractPlottable_SetSelectionDecorator(QCPAbstractPlottable* self, QCPSelectionDecorator* decorator) {
    self->setSelectionDecorator(decorator);
}

double QCPAbstractPlottable_SelectTest(const QCPAbstractPlottable* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpabstractplottable = dynamic_cast<const VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        return vqcpabstractplottable->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPAbstractPlottable*)self)->selectTest(*pos, onlySelectable, details);
    }
}

QCPPlottableInterface1D* QCPAbstractPlottable_Interface1D(QCPAbstractPlottable* self) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        return self->interface1D();
    } else {
        return ((VirtualQCPAbstractPlottable*)self)->interface1D();
    }
}

QCPRange* QCPAbstractPlottable_GetKeyRange(const QCPAbstractPlottable* self, bool* foundRange, int inSignDomain) {
    auto* vqcpabstractplottable = dynamic_cast<const VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        return new QCPRange(vqcpabstractplottable->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    } else {
        return new QCPRange(((VirtualQCPAbstractPlottable*)self)->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    }
}

QCPRange* QCPAbstractPlottable_GetValueRange(const QCPAbstractPlottable* self, bool* foundRange, int inSignDomain, const QCPRange* inKeyRange) {
    auto* vqcpabstractplottable = dynamic_cast<const VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        return new QCPRange(vqcpabstractplottable->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    } else {
        return new QCPRange(((VirtualQCPAbstractPlottable*)self)->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    }
}

void QCPAbstractPlottable_CoordsToPixels(const QCPAbstractPlottable* self, double key, double value, double* x, double* y) {
    self->coordsToPixels(static_cast<double>(key), static_cast<double>(value), static_cast<double&>(*x), static_cast<double&>(*y));
}

QPointF* QCPAbstractPlottable_CoordsToPixels2(const QCPAbstractPlottable* self, double key, double value) {
    return new QPointF(self->coordsToPixels(static_cast<double>(key), static_cast<double>(value)));
}

void QCPAbstractPlottable_PixelsToCoords(const QCPAbstractPlottable* self, double x, double y, double* key, double* value) {
    self->pixelsToCoords(static_cast<double>(x), static_cast<double>(y), static_cast<double&>(*key), static_cast<double&>(*value));
}

void QCPAbstractPlottable_PixelsToCoords2(const QCPAbstractPlottable* self, const QPointF* pixelPos, double* key, double* value) {
    self->pixelsToCoords(*pixelPos, static_cast<double&>(*key), static_cast<double&>(*value));
}

void QCPAbstractPlottable_RescaleAxes(const QCPAbstractPlottable* self) {
    self->rescaleAxes();
}

void QCPAbstractPlottable_RescaleKeyAxis(const QCPAbstractPlottable* self) {
    self->rescaleKeyAxis();
}

void QCPAbstractPlottable_RescaleValueAxis(const QCPAbstractPlottable* self) {
    self->rescaleValueAxis();
}

bool QCPAbstractPlottable_AddToLegend(QCPAbstractPlottable* self, QCPLegend* legend) {
    return self->addToLegend(legend);
}

bool QCPAbstractPlottable_AddToLegend2(QCPAbstractPlottable* self) {
    return self->addToLegend();
}

bool QCPAbstractPlottable_RemoveFromLegend(const QCPAbstractPlottable* self, QCPLegend* legend) {
    return self->removeFromLegend(legend);
}

bool QCPAbstractPlottable_RemoveFromLegend2(const QCPAbstractPlottable* self) {
    return self->removeFromLegend();
}

void QCPAbstractPlottable_SelectionChanged(QCPAbstractPlottable* self, bool selected) {
    self->selectionChanged(selected);
}

void QCPAbstractPlottable_SelectionChanged2(QCPAbstractPlottable* self, const QCPDataSelection* selection) {
    self->selectionChanged(*selection);
}

void QCPAbstractPlottable_SelectableChanged(QCPAbstractPlottable* self, int selectable) {
    self->selectableChanged(static_cast<QCP::SelectionType>(selectable));
}

QRect* QCPAbstractPlottable_ClipRect(const QCPAbstractPlottable* self) {
    auto* vqcpabstractplottable = dynamic_cast<const VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        return new QRect(vqcpabstractplottable->clipRect());
    }
    return {};
}

void QCPAbstractPlottable_Draw(QCPAbstractPlottable* self, QCPPainter* painter) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->draw(painter);
    }
}

int QCPAbstractPlottable_SelectionCategory(const QCPAbstractPlottable* self) {
    auto* vqcpabstractplottable = dynamic_cast<const VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        return static_cast<int>(vqcpabstractplottable->selectionCategory());
    }
    return {};
}

void QCPAbstractPlottable_ApplyDefaultAntialiasingHint(const QCPAbstractPlottable* self, QCPPainter* painter) {
    auto* vqcpabstractplottable = dynamic_cast<const VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->applyDefaultAntialiasingHint(painter);
    }
}

void QCPAbstractPlottable_SelectEvent(QCPAbstractPlottable* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

void QCPAbstractPlottable_DeselectEvent(QCPAbstractPlottable* self, bool* selectionStateChanged) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->deselectEvent(selectionStateChanged);
    }
}

void QCPAbstractPlottable_DrawLegendIcon(const QCPAbstractPlottable* self, QCPPainter* painter, const QRectF* rect) {
    auto* vqcpabstractplottable = dynamic_cast<const VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->drawLegendIcon(painter, *rect);
    }
}

libqt_string QCPAbstractPlottable_Tr2(const char* s, const char* c) {
    QString _ret = QCPAbstractPlottable::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPAbstractPlottable_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPAbstractPlottable::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

void QCPAbstractPlottable_RescaleAxes1(const QCPAbstractPlottable* self, bool onlyEnlarge) {
    self->rescaleAxes(onlyEnlarge);
}

void QCPAbstractPlottable_RescaleKeyAxis1(const QCPAbstractPlottable* self, bool onlyEnlarge) {
    self->rescaleKeyAxis(onlyEnlarge);
}

void QCPAbstractPlottable_RescaleValueAxis1(const QCPAbstractPlottable* self, bool onlyEnlarge) {
    self->rescaleValueAxis(onlyEnlarge);
}

void QCPAbstractPlottable_RescaleValueAxis2(const QCPAbstractPlottable* self, bool onlyEnlarge, bool inKeyRange) {
    self->rescaleValueAxis(onlyEnlarge, inKeyRange);
}

// Base class handler implementation
int QCPAbstractPlottable_QBaseMetacall(QCPAbstractPlottable* self, int param1, int param2, void** param3) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_Metacall_IsBase(true);
        return vqcpabstractplottable->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPAbstractPlottable::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnMetacall(QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_Metacall_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
double QCPAbstractPlottable_QBaseSelectTest(const QCPAbstractPlottable* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_SelectTest_IsBase(true);
        return vqcpabstractplottable->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPAbstractPlottable*)self)->selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnSelectTest(const QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_SelectTest_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
QCPPlottableInterface1D* QCPAbstractPlottable_QBaseInterface1D(QCPAbstractPlottable* self) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_Interface1D_IsBase(true);
        return vqcpabstractplottable->interface1D();
    } else {
        return self->QCPAbstractPlottable::interface1D();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnInterface1D(QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_Interface1D_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_Interface1D_Callback>(slot));
    }
}

// Base class handler implementation
QCPRange* QCPAbstractPlottable_QBaseGetKeyRange(const QCPAbstractPlottable* self, bool* foundRange, int inSignDomain) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_GetKeyRange_IsBase(true);
        return new QCPRange(vqcpabstractplottable->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    } else {
        return new QCPRange(((VirtualQCPAbstractPlottable*)self)->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnGetKeyRange(const QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_GetKeyRange_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_GetKeyRange_Callback>(slot));
    }
}

// Base class handler implementation
QCPRange* QCPAbstractPlottable_QBaseGetValueRange(const QCPAbstractPlottable* self, bool* foundRange, int inSignDomain, const QCPRange* inKeyRange) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_GetValueRange_IsBase(true);
        return new QCPRange(vqcpabstractplottable->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    } else {
        return new QCPRange(((VirtualQCPAbstractPlottable*)self)->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnGetValueRange(const QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_GetValueRange_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_GetValueRange_Callback>(slot));
    }
}

// Base class handler implementation
QRect* QCPAbstractPlottable_QBaseClipRect(const QCPAbstractPlottable* self) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_ClipRect_IsBase(true);
        return new QRect(vqcpabstractplottable->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnClipRect(const QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_ClipRect_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_ClipRect_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAbstractPlottable_QBaseDraw(QCPAbstractPlottable* self, QCPPainter* painter) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_Draw_IsBase(true);
        vqcpabstractplottable->draw(painter);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnDraw(QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_Draw_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_Draw_Callback>(slot));
    }
}

// Base class handler implementation
int QCPAbstractPlottable_QBaseSelectionCategory(const QCPAbstractPlottable* self) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcpabstractplottable->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPAbstractPlottable*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnSelectionCategory(const QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_SelectionCategory_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_SelectionCategory_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAbstractPlottable_QBaseApplyDefaultAntialiasingHint(const QCPAbstractPlottable* self, QCPPainter* painter) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcpabstractplottable->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnApplyDefaultAntialiasingHint(const QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAbstractPlottable_QBaseSelectEvent(QCPAbstractPlottable* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_SelectEvent_IsBase(true);
        vqcpabstractplottable->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnSelectEvent(QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_SelectEvent_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_SelectEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAbstractPlottable_QBaseDeselectEvent(QCPAbstractPlottable* self, bool* selectionStateChanged) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_DeselectEvent_IsBase(true);
        vqcpabstractplottable->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnDeselectEvent(QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_DeselectEvent_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_DeselectEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAbstractPlottable_QBaseDrawLegendIcon(const QCPAbstractPlottable* self, QCPPainter* painter, const QRectF* rect) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_DrawLegendIcon_IsBase(true);
        vqcpabstractplottable->drawLegendIcon(painter, *rect);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->drawLegendIcon(painter, *rect);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnDrawLegendIcon(const QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_DrawLegendIcon_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_DrawLegendIcon_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractPlottable_ParentPlotInitialized(QCPAbstractPlottable* self, QCustomPlot* parentPlot) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPAbstractPlottable_QBaseParentPlotInitialized(QCPAbstractPlottable* self, QCustomPlot* parentPlot) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_ParentPlotInitialized_IsBase(true);
        vqcpabstractplottable->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnParentPlotInitialized(QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractPlottable_MousePressEvent(QCPAbstractPlottable* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPAbstractPlottable_QBaseMousePressEvent(QCPAbstractPlottable* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_MousePressEvent_IsBase(true);
        vqcpabstractplottable->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnMousePressEvent(QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_MousePressEvent_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractPlottable_MouseMoveEvent(QCPAbstractPlottable* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPAbstractPlottable_QBaseMouseMoveEvent(QCPAbstractPlottable* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_MouseMoveEvent_IsBase(true);
        vqcpabstractplottable->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnMouseMoveEvent(QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractPlottable_MouseReleaseEvent(QCPAbstractPlottable* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPAbstractPlottable_QBaseMouseReleaseEvent(QCPAbstractPlottable* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_MouseReleaseEvent_IsBase(true);
        vqcpabstractplottable->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnMouseReleaseEvent(QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractPlottable_MouseDoubleClickEvent(QCPAbstractPlottable* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPAbstractPlottable_QBaseMouseDoubleClickEvent(QCPAbstractPlottable* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_MouseDoubleClickEvent_IsBase(true);
        vqcpabstractplottable->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnMouseDoubleClickEvent(QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractPlottable_WheelEvent(QCPAbstractPlottable* self, QWheelEvent* event) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->wheelEvent(event);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPAbstractPlottable_QBaseWheelEvent(QCPAbstractPlottable* self, QWheelEvent* event) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_WheelEvent_IsBase(true);
        vqcpabstractplottable->wheelEvent(event);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnWheelEvent(QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_WheelEvent_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPAbstractPlottable_Event(QCPAbstractPlottable* self, QEvent* event) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        return vqcpabstractplottable->event(event);
    } else {
        return self->QCPAbstractPlottable::event(event);
    }
}

// Base class handler implementation
bool QCPAbstractPlottable_QBaseEvent(QCPAbstractPlottable* self, QEvent* event) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_Event_IsBase(true);
        return vqcpabstractplottable->event(event);
    } else {
        return self->QCPAbstractPlottable::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnEvent(QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_Event_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPAbstractPlottable_EventFilter(QCPAbstractPlottable* self, QObject* watched, QEvent* event) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        return vqcpabstractplottable->eventFilter(watched, event);
    } else {
        return self->QCPAbstractPlottable::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPAbstractPlottable_QBaseEventFilter(QCPAbstractPlottable* self, QObject* watched, QEvent* event) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_EventFilter_IsBase(true);
        return vqcpabstractplottable->eventFilter(watched, event);
    } else {
        return self->QCPAbstractPlottable::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnEventFilter(QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_EventFilter_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractPlottable_TimerEvent(QCPAbstractPlottable* self, QTimerEvent* event) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->timerEvent(event);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPAbstractPlottable_QBaseTimerEvent(QCPAbstractPlottable* self, QTimerEvent* event) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_TimerEvent_IsBase(true);
        vqcpabstractplottable->timerEvent(event);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnTimerEvent(QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_TimerEvent_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractPlottable_ChildEvent(QCPAbstractPlottable* self, QChildEvent* event) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->childEvent(event);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPAbstractPlottable_QBaseChildEvent(QCPAbstractPlottable* self, QChildEvent* event) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_ChildEvent_IsBase(true);
        vqcpabstractplottable->childEvent(event);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnChildEvent(QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_ChildEvent_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractPlottable_CustomEvent(QCPAbstractPlottable* self, QEvent* event) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->customEvent(event);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPAbstractPlottable_QBaseCustomEvent(QCPAbstractPlottable* self, QEvent* event) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_CustomEvent_IsBase(true);
        vqcpabstractplottable->customEvent(event);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnCustomEvent(QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_CustomEvent_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractPlottable_ConnectNotify(QCPAbstractPlottable* self, const QMetaMethod* signal) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->connectNotify(*signal);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPAbstractPlottable_QBaseConnectNotify(QCPAbstractPlottable* self, const QMetaMethod* signal) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_ConnectNotify_IsBase(true);
        vqcpabstractplottable->connectNotify(*signal);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnConnectNotify(QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_ConnectNotify_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractPlottable_DisconnectNotify(QCPAbstractPlottable* self, const QMetaMethod* signal) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->disconnectNotify(*signal);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPAbstractPlottable_QBaseDisconnectNotify(QCPAbstractPlottable* self, const QMetaMethod* signal) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_DisconnectNotify_IsBase(true);
        vqcpabstractplottable->disconnectNotify(*signal);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnDisconnectNotify(QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractPlottable_ApplyFillAntialiasingHint(const QCPAbstractPlottable* self, QCPPainter* painter) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->applyFillAntialiasingHint(painter);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->applyFillAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPAbstractPlottable_QBaseApplyFillAntialiasingHint(const QCPAbstractPlottable* self, QCPPainter* painter) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_ApplyFillAntialiasingHint_IsBase(true);
        vqcpabstractplottable->applyFillAntialiasingHint(painter);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->applyFillAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnApplyFillAntialiasingHint(const QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_ApplyFillAntialiasingHint_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_ApplyFillAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractPlottable_ApplyScattersAntialiasingHint(const QCPAbstractPlottable* self, QCPPainter* painter) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->applyScattersAntialiasingHint(painter);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->applyScattersAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPAbstractPlottable_QBaseApplyScattersAntialiasingHint(const QCPAbstractPlottable* self, QCPPainter* painter) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_ApplyScattersAntialiasingHint_IsBase(true);
        vqcpabstractplottable->applyScattersAntialiasingHint(painter);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->applyScattersAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnApplyScattersAntialiasingHint(const QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_ApplyScattersAntialiasingHint_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_ApplyScattersAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractPlottable_InitializeParentPlot(QCPAbstractPlottable* self, QCustomPlot* parentPlot) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPAbstractPlottable_QBaseInitializeParentPlot(QCPAbstractPlottable* self, QCustomPlot* parentPlot) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_InitializeParentPlot_IsBase(true);
        vqcpabstractplottable->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnInitializeParentPlot(QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractPlottable_SetParentLayerable(QCPAbstractPlottable* self, QCPLayerable* parentLayerable) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPAbstractPlottable_QBaseSetParentLayerable(QCPAbstractPlottable* self, QCPLayerable* parentLayerable) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_SetParentLayerable_IsBase(true);
        vqcpabstractplottable->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPAbstractPlottable*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnSetParentLayerable(QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPAbstractPlottable_MoveToLayer(QCPAbstractPlottable* self, QCPLayer* layer, bool prepend) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        return vqcpabstractplottable->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPAbstractPlottable*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPAbstractPlottable_QBaseMoveToLayer(QCPAbstractPlottable* self, QCPLayer* layer, bool prepend) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_MoveToLayer_IsBase(true);
        return vqcpabstractplottable->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPAbstractPlottable*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnMoveToLayer(QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = dynamic_cast<VirtualQCPAbstractPlottable*>(self);
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_MoveToLayer_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractPlottable_ApplyAntialiasingHint(const QCPAbstractPlottable* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPAbstractPlottable*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPAbstractPlottable_QBaseApplyAntialiasingHint(const QCPAbstractPlottable* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_ApplyAntialiasingHint_IsBase(true);
        vqcpabstractplottable->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPAbstractPlottable*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnApplyAntialiasingHint(const QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPAbstractPlottable_Sender(const QCPAbstractPlottable* self) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        return vqcpabstractplottable->sender();
    } else {
        return ((VirtualQCPAbstractPlottable*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPAbstractPlottable_QBaseSender(const QCPAbstractPlottable* self) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_Sender_IsBase(true);
        return vqcpabstractplottable->sender();
    } else {
        return ((VirtualQCPAbstractPlottable*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnSender(const QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_Sender_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPAbstractPlottable_SenderSignalIndex(const QCPAbstractPlottable* self) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        return vqcpabstractplottable->senderSignalIndex();
    } else {
        return ((VirtualQCPAbstractPlottable*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPAbstractPlottable_QBaseSenderSignalIndex(const QCPAbstractPlottable* self) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_SenderSignalIndex_IsBase(true);
        return vqcpabstractplottable->senderSignalIndex();
    } else {
        return ((VirtualQCPAbstractPlottable*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnSenderSignalIndex(const QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPAbstractPlottable_Receivers(const QCPAbstractPlottable* self, const char* signal) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        return vqcpabstractplottable->receivers(signal);
    } else {
        return ((VirtualQCPAbstractPlottable*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPAbstractPlottable_QBaseReceivers(const QCPAbstractPlottable* self, const char* signal) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_Receivers_IsBase(true);
        return vqcpabstractplottable->receivers(signal);
    } else {
        return ((VirtualQCPAbstractPlottable*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnReceivers(const QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_Receivers_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPAbstractPlottable_IsSignalConnected(const QCPAbstractPlottable* self, const QMetaMethod* signal) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        return vqcpabstractplottable->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPAbstractPlottable*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPAbstractPlottable_QBaseIsSignalConnected(const QCPAbstractPlottable* self, const QMetaMethod* signal) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_IsSignalConnected_IsBase(true);
        return vqcpabstractplottable->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPAbstractPlottable*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractPlottable_OnIsSignalConnected(const QCPAbstractPlottable* self, intptr_t slot) {
    auto* vqcpabstractplottable = const_cast<VirtualQCPAbstractPlottable*>(dynamic_cast<const VirtualQCPAbstractPlottable*>(self));
    if (vqcpabstractplottable && vqcpabstractplottable->isVirtualQCPAbstractPlottable) {
        vqcpabstractplottable->setQCPAbstractPlottable_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPAbstractPlottable::QCPAbstractPlottable_IsSignalConnected_Callback>(slot));
    }
}

void QCPAbstractPlottable_Delete(QCPAbstractPlottable* self) {
    delete self;
}

QCPItemAnchor* QCPItemAnchor_new(QCustomPlot* parentPlot, QCPAbstractItem* parentItem, const libqt_string name) {
    QString name_QString = QString::fromUtf8(name.data, name.len);
    return new VirtualQCPItemAnchor(parentPlot, parentItem, name_QString);
}

QCPItemAnchor* QCPItemAnchor_new2(QCustomPlot* parentPlot, QCPAbstractItem* parentItem, const libqt_string name, int anchorId) {
    QString name_QString = QString::fromUtf8(name.data, name.len);
    return new VirtualQCPItemAnchor(parentPlot, parentItem, name_QString, static_cast<int>(anchorId));
}

libqt_string QCPItemAnchor_Name(const QCPItemAnchor* self) {
    QString _ret = self->name();
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

QPointF* QCPItemAnchor_PixelPosition(const QCPItemAnchor* self) {
    auto* vqcpitemanchor = dynamic_cast<const VirtualQCPItemAnchor*>(self);
    if (vqcpitemanchor && vqcpitemanchor->isVirtualQCPItemAnchor) {
        return new QPointF(self->pixelPosition());
    } else {
        return new QPointF(((VirtualQCPItemAnchor*)self)->pixelPosition());
    }
}

QCPItemPosition* QCPItemAnchor_ToQCPItemPosition(QCPItemAnchor* self) {
    auto* vqcpitemanchor = dynamic_cast<VirtualQCPItemAnchor*>(self);
    if (vqcpitemanchor && vqcpitemanchor->isVirtualQCPItemAnchor) {
        return vqcpitemanchor->toQCPItemPosition();
    }
    return {};
}

// Base class handler implementation
QPointF* QCPItemAnchor_QBasePixelPosition(const QCPItemAnchor* self) {
    auto* vqcpitemanchor = const_cast<VirtualQCPItemAnchor*>(dynamic_cast<const VirtualQCPItemAnchor*>(self));
    if (vqcpitemanchor && vqcpitemanchor->isVirtualQCPItemAnchor) {
        vqcpitemanchor->setQCPItemAnchor_PixelPosition_IsBase(true);
        return new QPointF(vqcpitemanchor->pixelPosition());
    } else {
        return new QPointF(((VirtualQCPItemAnchor*)self)->pixelPosition());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemAnchor_OnPixelPosition(const QCPItemAnchor* self, intptr_t slot) {
    auto* vqcpitemanchor = const_cast<VirtualQCPItemAnchor*>(dynamic_cast<const VirtualQCPItemAnchor*>(self));
    if (vqcpitemanchor && vqcpitemanchor->isVirtualQCPItemAnchor) {
        vqcpitemanchor->setQCPItemAnchor_PixelPosition_Callback(reinterpret_cast<VirtualQCPItemAnchor::QCPItemAnchor_PixelPosition_Callback>(slot));
    }
}

// Base class handler implementation
QCPItemPosition* QCPItemAnchor_QBaseToQCPItemPosition(QCPItemAnchor* self) {
    auto* vqcpitemanchor = dynamic_cast<VirtualQCPItemAnchor*>(self);
    if (vqcpitemanchor && vqcpitemanchor->isVirtualQCPItemAnchor) {
        vqcpitemanchor->setQCPItemAnchor_ToQCPItemPosition_IsBase(true);
        return vqcpitemanchor->toQCPItemPosition();
    } else {
        return ((VirtualQCPItemAnchor*)self)->toQCPItemPosition();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemAnchor_OnToQCPItemPosition(QCPItemAnchor* self, intptr_t slot) {
    auto* vqcpitemanchor = dynamic_cast<VirtualQCPItemAnchor*>(self);
    if (vqcpitemanchor && vqcpitemanchor->isVirtualQCPItemAnchor) {
        vqcpitemanchor->setQCPItemAnchor_ToQCPItemPosition_Callback(reinterpret_cast<VirtualQCPItemAnchor::QCPItemAnchor_ToQCPItemPosition_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemAnchor_AddChildX(QCPItemAnchor* self, QCPItemPosition* pos) {
    auto* vqcpitemanchor = dynamic_cast<VirtualQCPItemAnchor*>(self);
    if (vqcpitemanchor && vqcpitemanchor->isVirtualQCPItemAnchor) {
        vqcpitemanchor->addChildX(pos);
    } else {
        ((VirtualQCPItemAnchor*)self)->addChildX(pos);
    }
}

// Base class handler implementation
void QCPItemAnchor_QBaseAddChildX(QCPItemAnchor* self, QCPItemPosition* pos) {
    auto* vqcpitemanchor = dynamic_cast<VirtualQCPItemAnchor*>(self);
    if (vqcpitemanchor && vqcpitemanchor->isVirtualQCPItemAnchor) {
        vqcpitemanchor->setQCPItemAnchor_AddChildX_IsBase(true);
        vqcpitemanchor->addChildX(pos);
    } else {
        ((VirtualQCPItemAnchor*)self)->addChildX(pos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemAnchor_OnAddChildX(QCPItemAnchor* self, intptr_t slot) {
    auto* vqcpitemanchor = dynamic_cast<VirtualQCPItemAnchor*>(self);
    if (vqcpitemanchor && vqcpitemanchor->isVirtualQCPItemAnchor) {
        vqcpitemanchor->setQCPItemAnchor_AddChildX_Callback(reinterpret_cast<VirtualQCPItemAnchor::QCPItemAnchor_AddChildX_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemAnchor_RemoveChildX(QCPItemAnchor* self, QCPItemPosition* pos) {
    auto* vqcpitemanchor = dynamic_cast<VirtualQCPItemAnchor*>(self);
    if (vqcpitemanchor && vqcpitemanchor->isVirtualQCPItemAnchor) {
        vqcpitemanchor->removeChildX(pos);
    } else {
        ((VirtualQCPItemAnchor*)self)->removeChildX(pos);
    }
}

// Base class handler implementation
void QCPItemAnchor_QBaseRemoveChildX(QCPItemAnchor* self, QCPItemPosition* pos) {
    auto* vqcpitemanchor = dynamic_cast<VirtualQCPItemAnchor*>(self);
    if (vqcpitemanchor && vqcpitemanchor->isVirtualQCPItemAnchor) {
        vqcpitemanchor->setQCPItemAnchor_RemoveChildX_IsBase(true);
        vqcpitemanchor->removeChildX(pos);
    } else {
        ((VirtualQCPItemAnchor*)self)->removeChildX(pos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemAnchor_OnRemoveChildX(QCPItemAnchor* self, intptr_t slot) {
    auto* vqcpitemanchor = dynamic_cast<VirtualQCPItemAnchor*>(self);
    if (vqcpitemanchor && vqcpitemanchor->isVirtualQCPItemAnchor) {
        vqcpitemanchor->setQCPItemAnchor_RemoveChildX_Callback(reinterpret_cast<VirtualQCPItemAnchor::QCPItemAnchor_RemoveChildX_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemAnchor_AddChildY(QCPItemAnchor* self, QCPItemPosition* pos) {
    auto* vqcpitemanchor = dynamic_cast<VirtualQCPItemAnchor*>(self);
    if (vqcpitemanchor && vqcpitemanchor->isVirtualQCPItemAnchor) {
        vqcpitemanchor->addChildY(pos);
    } else {
        ((VirtualQCPItemAnchor*)self)->addChildY(pos);
    }
}

// Base class handler implementation
void QCPItemAnchor_QBaseAddChildY(QCPItemAnchor* self, QCPItemPosition* pos) {
    auto* vqcpitemanchor = dynamic_cast<VirtualQCPItemAnchor*>(self);
    if (vqcpitemanchor && vqcpitemanchor->isVirtualQCPItemAnchor) {
        vqcpitemanchor->setQCPItemAnchor_AddChildY_IsBase(true);
        vqcpitemanchor->addChildY(pos);
    } else {
        ((VirtualQCPItemAnchor*)self)->addChildY(pos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemAnchor_OnAddChildY(QCPItemAnchor* self, intptr_t slot) {
    auto* vqcpitemanchor = dynamic_cast<VirtualQCPItemAnchor*>(self);
    if (vqcpitemanchor && vqcpitemanchor->isVirtualQCPItemAnchor) {
        vqcpitemanchor->setQCPItemAnchor_AddChildY_Callback(reinterpret_cast<VirtualQCPItemAnchor::QCPItemAnchor_AddChildY_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemAnchor_RemoveChildY(QCPItemAnchor* self, QCPItemPosition* pos) {
    auto* vqcpitemanchor = dynamic_cast<VirtualQCPItemAnchor*>(self);
    if (vqcpitemanchor && vqcpitemanchor->isVirtualQCPItemAnchor) {
        vqcpitemanchor->removeChildY(pos);
    } else {
        ((VirtualQCPItemAnchor*)self)->removeChildY(pos);
    }
}

// Base class handler implementation
void QCPItemAnchor_QBaseRemoveChildY(QCPItemAnchor* self, QCPItemPosition* pos) {
    auto* vqcpitemanchor = dynamic_cast<VirtualQCPItemAnchor*>(self);
    if (vqcpitemanchor && vqcpitemanchor->isVirtualQCPItemAnchor) {
        vqcpitemanchor->setQCPItemAnchor_RemoveChildY_IsBase(true);
        vqcpitemanchor->removeChildY(pos);
    } else {
        ((VirtualQCPItemAnchor*)self)->removeChildY(pos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemAnchor_OnRemoveChildY(QCPItemAnchor* self, intptr_t slot) {
    auto* vqcpitemanchor = dynamic_cast<VirtualQCPItemAnchor*>(self);
    if (vqcpitemanchor && vqcpitemanchor->isVirtualQCPItemAnchor) {
        vqcpitemanchor->setQCPItemAnchor_RemoveChildY_Callback(reinterpret_cast<VirtualQCPItemAnchor::QCPItemAnchor_RemoveChildY_Callback>(slot));
    }
}

void QCPItemAnchor_Delete(QCPItemAnchor* self) {
    delete self;
}

QCPItemPosition* QCPItemPosition_new(QCustomPlot* parentPlot, QCPAbstractItem* parentItem, const libqt_string name) {
    QString name_QString = QString::fromUtf8(name.data, name.len);
    return new VirtualQCPItemPosition(parentPlot, parentItem, name_QString);
}

int QCPItemPosition_Type(const QCPItemPosition* self) {
    return static_cast<int>(self->type());
}

int QCPItemPosition_TypeX(const QCPItemPosition* self) {
    return static_cast<int>(self->typeX());
}

int QCPItemPosition_TypeY(const QCPItemPosition* self) {
    return static_cast<int>(self->typeY());
}

QCPItemAnchor* QCPItemPosition_ParentAnchor(const QCPItemPosition* self) {
    return self->parentAnchor();
}

QCPItemAnchor* QCPItemPosition_ParentAnchorX(const QCPItemPosition* self) {
    return self->parentAnchorX();
}

QCPItemAnchor* QCPItemPosition_ParentAnchorY(const QCPItemPosition* self) {
    return self->parentAnchorY();
}

double QCPItemPosition_Key(const QCPItemPosition* self) {
    return self->key();
}

double QCPItemPosition_Value(const QCPItemPosition* self) {
    return self->value();
}

QPointF* QCPItemPosition_Coords(const QCPItemPosition* self) {
    return new QPointF(self->coords());
}

QCPAxis* QCPItemPosition_KeyAxis(const QCPItemPosition* self) {
    return self->keyAxis();
}

QCPAxis* QCPItemPosition_ValueAxis(const QCPItemPosition* self) {
    return self->valueAxis();
}

QCPAxisRect* QCPItemPosition_AxisRect(const QCPItemPosition* self) {
    return self->axisRect();
}

QPointF* QCPItemPosition_PixelPosition(const QCPItemPosition* self) {
    auto* vqcpitemposition = dynamic_cast<const VirtualQCPItemPosition*>(self);
    if (vqcpitemposition && vqcpitemposition->isVirtualQCPItemPosition) {
        return new QPointF(self->pixelPosition());
    } else {
        return new QPointF(((VirtualQCPItemPosition*)self)->pixelPosition());
    }
}

void QCPItemPosition_SetType(QCPItemPosition* self, int typeVal) {
    self->setType(static_cast<QCPItemPosition::PositionType>(typeVal));
}

void QCPItemPosition_SetTypeX(QCPItemPosition* self, int typeVal) {
    self->setTypeX(static_cast<QCPItemPosition::PositionType>(typeVal));
}

void QCPItemPosition_SetTypeY(QCPItemPosition* self, int typeVal) {
    self->setTypeY(static_cast<QCPItemPosition::PositionType>(typeVal));
}

bool QCPItemPosition_SetParentAnchor(QCPItemPosition* self, QCPItemAnchor* parentAnchor) {
    return self->setParentAnchor(parentAnchor);
}

bool QCPItemPosition_SetParentAnchorX(QCPItemPosition* self, QCPItemAnchor* parentAnchor) {
    return self->setParentAnchorX(parentAnchor);
}

bool QCPItemPosition_SetParentAnchorY(QCPItemPosition* self, QCPItemAnchor* parentAnchor) {
    return self->setParentAnchorY(parentAnchor);
}

void QCPItemPosition_SetCoords(QCPItemPosition* self, double key, double value) {
    self->setCoords(static_cast<double>(key), static_cast<double>(value));
}

void QCPItemPosition_SetCoords2(QCPItemPosition* self, const QPointF* pos) {
    self->setCoords(*pos);
}

void QCPItemPosition_SetAxes(QCPItemPosition* self, QCPAxis* keyAxis, QCPAxis* valueAxis) {
    self->setAxes(keyAxis, valueAxis);
}

void QCPItemPosition_SetAxisRect(QCPItemPosition* self, QCPAxisRect* axisRect) {
    self->setAxisRect(axisRect);
}

void QCPItemPosition_SetPixelPosition(QCPItemPosition* self, const QPointF* pixelPosition) {
    self->setPixelPosition(*pixelPosition);
}

QCPItemPosition* QCPItemPosition_ToQCPItemPosition(QCPItemPosition* self) {
    auto* vqcpitemposition = dynamic_cast<VirtualQCPItemPosition*>(self);
    if (vqcpitemposition && vqcpitemposition->isVirtualQCPItemPosition) {
        return vqcpitemposition->toQCPItemPosition();
    }
    return {};
}

bool QCPItemPosition_SetParentAnchor2(QCPItemPosition* self, QCPItemAnchor* parentAnchor, bool keepPixelPosition) {
    return self->setParentAnchor(parentAnchor, keepPixelPosition);
}

bool QCPItemPosition_SetParentAnchorX2(QCPItemPosition* self, QCPItemAnchor* parentAnchor, bool keepPixelPosition) {
    return self->setParentAnchorX(parentAnchor, keepPixelPosition);
}

bool QCPItemPosition_SetParentAnchorY2(QCPItemPosition* self, QCPItemAnchor* parentAnchor, bool keepPixelPosition) {
    return self->setParentAnchorY(parentAnchor, keepPixelPosition);
}

// Base class handler implementation
QPointF* QCPItemPosition_QBasePixelPosition(const QCPItemPosition* self) {
    auto* vqcpitemposition = const_cast<VirtualQCPItemPosition*>(dynamic_cast<const VirtualQCPItemPosition*>(self));
    if (vqcpitemposition && vqcpitemposition->isVirtualQCPItemPosition) {
        vqcpitemposition->setQCPItemPosition_PixelPosition_IsBase(true);
        return new QPointF(vqcpitemposition->pixelPosition());
    } else {
        return new QPointF(((VirtualQCPItemPosition*)self)->pixelPosition());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPosition_OnPixelPosition(const QCPItemPosition* self, intptr_t slot) {
    auto* vqcpitemposition = const_cast<VirtualQCPItemPosition*>(dynamic_cast<const VirtualQCPItemPosition*>(self));
    if (vqcpitemposition && vqcpitemposition->isVirtualQCPItemPosition) {
        vqcpitemposition->setQCPItemPosition_PixelPosition_Callback(reinterpret_cast<VirtualQCPItemPosition::QCPItemPosition_PixelPosition_Callback>(slot));
    }
}

// Base class handler implementation
QCPItemPosition* QCPItemPosition_QBaseToQCPItemPosition(QCPItemPosition* self) {
    auto* vqcpitemposition = dynamic_cast<VirtualQCPItemPosition*>(self);
    if (vqcpitemposition && vqcpitemposition->isVirtualQCPItemPosition) {
        vqcpitemposition->setQCPItemPosition_ToQCPItemPosition_IsBase(true);
        return vqcpitemposition->toQCPItemPosition();
    } else {
        return ((VirtualQCPItemPosition*)self)->toQCPItemPosition();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPosition_OnToQCPItemPosition(QCPItemPosition* self, intptr_t slot) {
    auto* vqcpitemposition = dynamic_cast<VirtualQCPItemPosition*>(self);
    if (vqcpitemposition && vqcpitemposition->isVirtualQCPItemPosition) {
        vqcpitemposition->setQCPItemPosition_ToQCPItemPosition_Callback(reinterpret_cast<VirtualQCPItemPosition::QCPItemPosition_ToQCPItemPosition_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemPosition_AddChildX(QCPItemPosition* self, QCPItemPosition* pos) {
    auto* vqcpitemposition = dynamic_cast<VirtualQCPItemPosition*>(self);
    if (vqcpitemposition && vqcpitemposition->isVirtualQCPItemPosition) {
        vqcpitemposition->addChildX(pos);
    } else {
        ((VirtualQCPItemPosition*)self)->addChildX(pos);
    }
}

// Base class handler implementation
void QCPItemPosition_QBaseAddChildX(QCPItemPosition* self, QCPItemPosition* pos) {
    auto* vqcpitemposition = dynamic_cast<VirtualQCPItemPosition*>(self);
    if (vqcpitemposition && vqcpitemposition->isVirtualQCPItemPosition) {
        vqcpitemposition->setQCPItemPosition_AddChildX_IsBase(true);
        vqcpitemposition->addChildX(pos);
    } else {
        ((VirtualQCPItemPosition*)self)->addChildX(pos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPosition_OnAddChildX(QCPItemPosition* self, intptr_t slot) {
    auto* vqcpitemposition = dynamic_cast<VirtualQCPItemPosition*>(self);
    if (vqcpitemposition && vqcpitemposition->isVirtualQCPItemPosition) {
        vqcpitemposition->setQCPItemPosition_AddChildX_Callback(reinterpret_cast<VirtualQCPItemPosition::QCPItemPosition_AddChildX_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemPosition_RemoveChildX(QCPItemPosition* self, QCPItemPosition* pos) {
    auto* vqcpitemposition = dynamic_cast<VirtualQCPItemPosition*>(self);
    if (vqcpitemposition && vqcpitemposition->isVirtualQCPItemPosition) {
        vqcpitemposition->removeChildX(pos);
    } else {
        ((VirtualQCPItemPosition*)self)->removeChildX(pos);
    }
}

// Base class handler implementation
void QCPItemPosition_QBaseRemoveChildX(QCPItemPosition* self, QCPItemPosition* pos) {
    auto* vqcpitemposition = dynamic_cast<VirtualQCPItemPosition*>(self);
    if (vqcpitemposition && vqcpitemposition->isVirtualQCPItemPosition) {
        vqcpitemposition->setQCPItemPosition_RemoveChildX_IsBase(true);
        vqcpitemposition->removeChildX(pos);
    } else {
        ((VirtualQCPItemPosition*)self)->removeChildX(pos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPosition_OnRemoveChildX(QCPItemPosition* self, intptr_t slot) {
    auto* vqcpitemposition = dynamic_cast<VirtualQCPItemPosition*>(self);
    if (vqcpitemposition && vqcpitemposition->isVirtualQCPItemPosition) {
        vqcpitemposition->setQCPItemPosition_RemoveChildX_Callback(reinterpret_cast<VirtualQCPItemPosition::QCPItemPosition_RemoveChildX_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemPosition_AddChildY(QCPItemPosition* self, QCPItemPosition* pos) {
    auto* vqcpitemposition = dynamic_cast<VirtualQCPItemPosition*>(self);
    if (vqcpitemposition && vqcpitemposition->isVirtualQCPItemPosition) {
        vqcpitemposition->addChildY(pos);
    } else {
        ((VirtualQCPItemPosition*)self)->addChildY(pos);
    }
}

// Base class handler implementation
void QCPItemPosition_QBaseAddChildY(QCPItemPosition* self, QCPItemPosition* pos) {
    auto* vqcpitemposition = dynamic_cast<VirtualQCPItemPosition*>(self);
    if (vqcpitemposition && vqcpitemposition->isVirtualQCPItemPosition) {
        vqcpitemposition->setQCPItemPosition_AddChildY_IsBase(true);
        vqcpitemposition->addChildY(pos);
    } else {
        ((VirtualQCPItemPosition*)self)->addChildY(pos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPosition_OnAddChildY(QCPItemPosition* self, intptr_t slot) {
    auto* vqcpitemposition = dynamic_cast<VirtualQCPItemPosition*>(self);
    if (vqcpitemposition && vqcpitemposition->isVirtualQCPItemPosition) {
        vqcpitemposition->setQCPItemPosition_AddChildY_Callback(reinterpret_cast<VirtualQCPItemPosition::QCPItemPosition_AddChildY_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemPosition_RemoveChildY(QCPItemPosition* self, QCPItemPosition* pos) {
    auto* vqcpitemposition = dynamic_cast<VirtualQCPItemPosition*>(self);
    if (vqcpitemposition && vqcpitemposition->isVirtualQCPItemPosition) {
        vqcpitemposition->removeChildY(pos);
    } else {
        ((VirtualQCPItemPosition*)self)->removeChildY(pos);
    }
}

// Base class handler implementation
void QCPItemPosition_QBaseRemoveChildY(QCPItemPosition* self, QCPItemPosition* pos) {
    auto* vqcpitemposition = dynamic_cast<VirtualQCPItemPosition*>(self);
    if (vqcpitemposition && vqcpitemposition->isVirtualQCPItemPosition) {
        vqcpitemposition->setQCPItemPosition_RemoveChildY_IsBase(true);
        vqcpitemposition->removeChildY(pos);
    } else {
        ((VirtualQCPItemPosition*)self)->removeChildY(pos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPosition_OnRemoveChildY(QCPItemPosition* self, intptr_t slot) {
    auto* vqcpitemposition = dynamic_cast<VirtualQCPItemPosition*>(self);
    if (vqcpitemposition && vqcpitemposition->isVirtualQCPItemPosition) {
        vqcpitemposition->setQCPItemPosition_RemoveChildY_Callback(reinterpret_cast<VirtualQCPItemPosition::QCPItemPosition_RemoveChildY_Callback>(slot));
    }
}

void QCPItemPosition_Delete(QCPItemPosition* self) {
    delete self;
}

QCPAbstractItem* QCPAbstractItem_new(QCustomPlot* parentPlot) {
    return new VirtualQCPAbstractItem(parentPlot);
}

QMetaObject* QCPAbstractItem_MetaObject(const QCPAbstractItem* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPAbstractItem_Metacast(QCPAbstractItem* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPAbstractItem_Metacall(QCPAbstractItem* self, int param1, int param2, void** param3) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPAbstractItem*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPAbstractItem_Tr(const char* s) {
    QString _ret = QCPAbstractItem::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

bool QCPAbstractItem_ClipToAxisRect(const QCPAbstractItem* self) {
    return self->clipToAxisRect();
}

QCPAxisRect* QCPAbstractItem_ClipAxisRect(const QCPAbstractItem* self) {
    return self->clipAxisRect();
}

bool QCPAbstractItem_Selectable(const QCPAbstractItem* self) {
    return self->selectable();
}

bool QCPAbstractItem_Selected(const QCPAbstractItem* self) {
    return self->selected();
}

void QCPAbstractItem_SetClipToAxisRect(QCPAbstractItem* self, bool clip) {
    self->setClipToAxisRect(clip);
}

void QCPAbstractItem_SetClipAxisRect(QCPAbstractItem* self, QCPAxisRect* rect) {
    self->setClipAxisRect(rect);
}

void QCPAbstractItem_SetSelectable(QCPAbstractItem* self, bool selectable) {
    self->setSelectable(selectable);
}

void QCPAbstractItem_SetSelected(QCPAbstractItem* self, bool selected) {
    self->setSelected(selected);
}

double QCPAbstractItem_SelectTest(const QCPAbstractItem* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpabstractitem = dynamic_cast<const VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        return vqcpabstractitem->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPAbstractItem*)self)->selectTest(*pos, onlySelectable, details);
    }
}

libqt_list /* of QCPItemPosition* */ QCPAbstractItem_Positions(const QCPAbstractItem* self) {
    QList<QCPItemPosition*> _ret = self->positions();
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPItemPosition** _arr = static_cast<QCPItemPosition**>(malloc(sizeof(QCPItemPosition*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

libqt_list /* of QCPItemAnchor* */ QCPAbstractItem_Anchors(const QCPAbstractItem* self) {
    QList<QCPItemAnchor*> _ret = self->anchors();
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPItemAnchor** _arr = static_cast<QCPItemAnchor**>(malloc(sizeof(QCPItemAnchor*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

QCPItemPosition* QCPAbstractItem_Position(const QCPAbstractItem* self, const libqt_string name) {
    QString name_QString = QString::fromUtf8(name.data, name.len);
    return self->position(name_QString);
}

QCPItemAnchor* QCPAbstractItem_Anchor(const QCPAbstractItem* self, const libqt_string name) {
    QString name_QString = QString::fromUtf8(name.data, name.len);
    return self->anchor(name_QString);
}

bool QCPAbstractItem_HasAnchor(const QCPAbstractItem* self, const libqt_string name) {
    QString name_QString = QString::fromUtf8(name.data, name.len);
    return self->hasAnchor(name_QString);
}

void QCPAbstractItem_SelectionChanged(QCPAbstractItem* self, bool selected) {
    self->selectionChanged(selected);
}

void QCPAbstractItem_Connect_SelectionChanged(QCPAbstractItem* self, intptr_t slot) {
    void (*slotFunc)(QCPAbstractItem*, bool) = reinterpret_cast<void (*)(QCPAbstractItem*, bool)>(slot);
    QCPAbstractItem::connect(self, &QCPAbstractItem::selectionChanged, [self, slotFunc](bool selected) {
        bool sigval1 = selected;
        slotFunc(self, sigval1);
    });
}

void QCPAbstractItem_SelectableChanged(QCPAbstractItem* self, bool selectable) {
    self->selectableChanged(selectable);
}

void QCPAbstractItem_Connect_SelectableChanged(QCPAbstractItem* self, intptr_t slot) {
    void (*slotFunc)(QCPAbstractItem*, bool) = reinterpret_cast<void (*)(QCPAbstractItem*, bool)>(slot);
    QCPAbstractItem::connect(self, &QCPAbstractItem::selectableChanged, [self, slotFunc](bool selectable) {
        bool sigval1 = selectable;
        slotFunc(self, sigval1);
    });
}

int QCPAbstractItem_SelectionCategory(const QCPAbstractItem* self) {
    auto* vqcpabstractitem = dynamic_cast<const VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        return static_cast<int>(vqcpabstractitem->selectionCategory());
    }
    return {};
}

QRect* QCPAbstractItem_ClipRect(const QCPAbstractItem* self) {
    auto* vqcpabstractitem = dynamic_cast<const VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        return new QRect(vqcpabstractitem->clipRect());
    }
    return {};
}

void QCPAbstractItem_ApplyDefaultAntialiasingHint(const QCPAbstractItem* self, QCPPainter* painter) {
    auto* vqcpabstractitem = dynamic_cast<const VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->applyDefaultAntialiasingHint(painter);
    }
}

void QCPAbstractItem_Draw(QCPAbstractItem* self, QCPPainter* painter) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->draw(painter);
    }
}

void QCPAbstractItem_SelectEvent(QCPAbstractItem* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

void QCPAbstractItem_DeselectEvent(QCPAbstractItem* self, bool* selectionStateChanged) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->deselectEvent(selectionStateChanged);
    }
}

QPointF* QCPAbstractItem_AnchorPixelPosition(const QCPAbstractItem* self, int anchorId) {
    auto* vqcpabstractitem = dynamic_cast<const VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        return new QPointF(vqcpabstractitem->anchorPixelPosition(static_cast<int>(anchorId)));
    }
    return {};
}

libqt_string QCPAbstractItem_Tr2(const char* s, const char* c) {
    QString _ret = QCPAbstractItem::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPAbstractItem_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPAbstractItem::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPAbstractItem_QBaseMetacall(QCPAbstractItem* self, int param1, int param2, void** param3) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_Metacall_IsBase(true);
        return vqcpabstractitem->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPAbstractItem::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnMetacall(QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_Metacall_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
double QCPAbstractItem_QBaseSelectTest(const QCPAbstractItem* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_SelectTest_IsBase(true);
        return vqcpabstractitem->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPAbstractItem*)self)->selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnSelectTest(const QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_SelectTest_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
int QCPAbstractItem_QBaseSelectionCategory(const QCPAbstractItem* self) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcpabstractitem->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPAbstractItem*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnSelectionCategory(const QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_SelectionCategory_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_SelectionCategory_Callback>(slot));
    }
}

// Base class handler implementation
QRect* QCPAbstractItem_QBaseClipRect(const QCPAbstractItem* self) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_ClipRect_IsBase(true);
        return new QRect(vqcpabstractitem->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnClipRect(const QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_ClipRect_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_ClipRect_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAbstractItem_QBaseApplyDefaultAntialiasingHint(const QCPAbstractItem* self, QCPPainter* painter) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcpabstractitem->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPAbstractItem*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnApplyDefaultAntialiasingHint(const QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAbstractItem_QBaseDraw(QCPAbstractItem* self, QCPPainter* painter) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_Draw_IsBase(true);
        vqcpabstractitem->draw(painter);
    } else {
        ((VirtualQCPAbstractItem*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnDraw(QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_Draw_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_Draw_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAbstractItem_QBaseSelectEvent(QCPAbstractItem* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_SelectEvent_IsBase(true);
        vqcpabstractitem->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPAbstractItem*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnSelectEvent(QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_SelectEvent_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_SelectEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAbstractItem_QBaseDeselectEvent(QCPAbstractItem* self, bool* selectionStateChanged) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_DeselectEvent_IsBase(true);
        vqcpabstractitem->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPAbstractItem*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnDeselectEvent(QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_DeselectEvent_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_DeselectEvent_Callback>(slot));
    }
}

// Base class handler implementation
QPointF* QCPAbstractItem_QBaseAnchorPixelPosition(const QCPAbstractItem* self, int anchorId) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_AnchorPixelPosition_IsBase(true);
        return new QPointF(vqcpabstractitem->anchorPixelPosition(static_cast<int>(anchorId)));
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnAnchorPixelPosition(const QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_AnchorPixelPosition_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_AnchorPixelPosition_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractItem_ParentPlotInitialized(QCPAbstractItem* self, QCustomPlot* parentPlot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPAbstractItem*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPAbstractItem_QBaseParentPlotInitialized(QCPAbstractItem* self, QCustomPlot* parentPlot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_ParentPlotInitialized_IsBase(true);
        vqcpabstractitem->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPAbstractItem*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnParentPlotInitialized(QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractItem_MousePressEvent(QCPAbstractItem* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPAbstractItem*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPAbstractItem_QBaseMousePressEvent(QCPAbstractItem* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_MousePressEvent_IsBase(true);
        vqcpabstractitem->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPAbstractItem*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnMousePressEvent(QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_MousePressEvent_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractItem_MouseMoveEvent(QCPAbstractItem* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPAbstractItem*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPAbstractItem_QBaseMouseMoveEvent(QCPAbstractItem* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_MouseMoveEvent_IsBase(true);
        vqcpabstractitem->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPAbstractItem*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnMouseMoveEvent(QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractItem_MouseReleaseEvent(QCPAbstractItem* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPAbstractItem*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPAbstractItem_QBaseMouseReleaseEvent(QCPAbstractItem* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_MouseReleaseEvent_IsBase(true);
        vqcpabstractitem->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPAbstractItem*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnMouseReleaseEvent(QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractItem_MouseDoubleClickEvent(QCPAbstractItem* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPAbstractItem*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPAbstractItem_QBaseMouseDoubleClickEvent(QCPAbstractItem* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_MouseDoubleClickEvent_IsBase(true);
        vqcpabstractitem->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPAbstractItem*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnMouseDoubleClickEvent(QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractItem_WheelEvent(QCPAbstractItem* self, QWheelEvent* event) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->wheelEvent(event);
    } else {
        ((VirtualQCPAbstractItem*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPAbstractItem_QBaseWheelEvent(QCPAbstractItem* self, QWheelEvent* event) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_WheelEvent_IsBase(true);
        vqcpabstractitem->wheelEvent(event);
    } else {
        ((VirtualQCPAbstractItem*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnWheelEvent(QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_WheelEvent_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPAbstractItem_Event(QCPAbstractItem* self, QEvent* event) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        return vqcpabstractitem->event(event);
    } else {
        return self->QCPAbstractItem::event(event);
    }
}

// Base class handler implementation
bool QCPAbstractItem_QBaseEvent(QCPAbstractItem* self, QEvent* event) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_Event_IsBase(true);
        return vqcpabstractitem->event(event);
    } else {
        return self->QCPAbstractItem::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnEvent(QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_Event_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPAbstractItem_EventFilter(QCPAbstractItem* self, QObject* watched, QEvent* event) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        return vqcpabstractitem->eventFilter(watched, event);
    } else {
        return self->QCPAbstractItem::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPAbstractItem_QBaseEventFilter(QCPAbstractItem* self, QObject* watched, QEvent* event) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_EventFilter_IsBase(true);
        return vqcpabstractitem->eventFilter(watched, event);
    } else {
        return self->QCPAbstractItem::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnEventFilter(QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_EventFilter_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractItem_TimerEvent(QCPAbstractItem* self, QTimerEvent* event) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->timerEvent(event);
    } else {
        ((VirtualQCPAbstractItem*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPAbstractItem_QBaseTimerEvent(QCPAbstractItem* self, QTimerEvent* event) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_TimerEvent_IsBase(true);
        vqcpabstractitem->timerEvent(event);
    } else {
        ((VirtualQCPAbstractItem*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnTimerEvent(QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_TimerEvent_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractItem_ChildEvent(QCPAbstractItem* self, QChildEvent* event) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->childEvent(event);
    } else {
        ((VirtualQCPAbstractItem*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPAbstractItem_QBaseChildEvent(QCPAbstractItem* self, QChildEvent* event) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_ChildEvent_IsBase(true);
        vqcpabstractitem->childEvent(event);
    } else {
        ((VirtualQCPAbstractItem*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnChildEvent(QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_ChildEvent_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractItem_CustomEvent(QCPAbstractItem* self, QEvent* event) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->customEvent(event);
    } else {
        ((VirtualQCPAbstractItem*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPAbstractItem_QBaseCustomEvent(QCPAbstractItem* self, QEvent* event) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_CustomEvent_IsBase(true);
        vqcpabstractitem->customEvent(event);
    } else {
        ((VirtualQCPAbstractItem*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnCustomEvent(QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_CustomEvent_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractItem_ConnectNotify(QCPAbstractItem* self, const QMetaMethod* signal) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->connectNotify(*signal);
    } else {
        ((VirtualQCPAbstractItem*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPAbstractItem_QBaseConnectNotify(QCPAbstractItem* self, const QMetaMethod* signal) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_ConnectNotify_IsBase(true);
        vqcpabstractitem->connectNotify(*signal);
    } else {
        ((VirtualQCPAbstractItem*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnConnectNotify(QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_ConnectNotify_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractItem_DisconnectNotify(QCPAbstractItem* self, const QMetaMethod* signal) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->disconnectNotify(*signal);
    } else {
        ((VirtualQCPAbstractItem*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPAbstractItem_QBaseDisconnectNotify(QCPAbstractItem* self, const QMetaMethod* signal) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_DisconnectNotify_IsBase(true);
        vqcpabstractitem->disconnectNotify(*signal);
    } else {
        ((VirtualQCPAbstractItem*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnDisconnectNotify(QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPAbstractItem_RectDistance(const QCPAbstractItem* self, const QRectF* rect, const QPointF* pos, bool filledRect) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        return vqcpabstractitem->rectDistance(*rect, *pos, filledRect);
    } else {
        return ((VirtualQCPAbstractItem*)self)->rectDistance(*rect, *pos, filledRect);
    }
}

// Base class handler implementation
double QCPAbstractItem_QBaseRectDistance(const QCPAbstractItem* self, const QRectF* rect, const QPointF* pos, bool filledRect) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_RectDistance_IsBase(true);
        return vqcpabstractitem->rectDistance(*rect, *pos, filledRect);
    } else {
        return ((VirtualQCPAbstractItem*)self)->rectDistance(*rect, *pos, filledRect);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnRectDistance(const QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_RectDistance_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_RectDistance_Callback>(slot));
    }
}

// Derived class handler implementation
QCPItemPosition* QCPAbstractItem_CreatePosition(QCPAbstractItem* self, const libqt_string name) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        return vqcpabstractitem->createPosition(name_QString);
    } else {
        return ((VirtualQCPAbstractItem*)self)->createPosition(name_QString);
    }
}

// Base class handler implementation
QCPItemPosition* QCPAbstractItem_QBaseCreatePosition(QCPAbstractItem* self, const libqt_string name) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_CreatePosition_IsBase(true);
        return vqcpabstractitem->createPosition(name_QString);
    } else {
        return ((VirtualQCPAbstractItem*)self)->createPosition(name_QString);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnCreatePosition(QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_CreatePosition_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_CreatePosition_Callback>(slot));
    }
}

// Derived class handler implementation
QCPItemAnchor* QCPAbstractItem_CreateAnchor(QCPAbstractItem* self, const libqt_string name, int anchorId) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        return vqcpabstractitem->createAnchor(name_QString, static_cast<int>(anchorId));
    } else {
        return ((VirtualQCPAbstractItem*)self)->createAnchor(name_QString, static_cast<int>(anchorId));
    }
}

// Base class handler implementation
QCPItemAnchor* QCPAbstractItem_QBaseCreateAnchor(QCPAbstractItem* self, const libqt_string name, int anchorId) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_CreateAnchor_IsBase(true);
        return vqcpabstractitem->createAnchor(name_QString, static_cast<int>(anchorId));
    } else {
        return ((VirtualQCPAbstractItem*)self)->createAnchor(name_QString, static_cast<int>(anchorId));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnCreateAnchor(QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_CreateAnchor_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_CreateAnchor_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractItem_InitializeParentPlot(QCPAbstractItem* self, QCustomPlot* parentPlot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPAbstractItem*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPAbstractItem_QBaseInitializeParentPlot(QCPAbstractItem* self, QCustomPlot* parentPlot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_InitializeParentPlot_IsBase(true);
        vqcpabstractitem->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPAbstractItem*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnInitializeParentPlot(QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractItem_SetParentLayerable(QCPAbstractItem* self, QCPLayerable* parentLayerable) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPAbstractItem*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPAbstractItem_QBaseSetParentLayerable(QCPAbstractItem* self, QCPLayerable* parentLayerable) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_SetParentLayerable_IsBase(true);
        vqcpabstractitem->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPAbstractItem*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnSetParentLayerable(QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPAbstractItem_MoveToLayer(QCPAbstractItem* self, QCPLayer* layer, bool prepend) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        return vqcpabstractitem->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPAbstractItem*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPAbstractItem_QBaseMoveToLayer(QCPAbstractItem* self, QCPLayer* layer, bool prepend) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_MoveToLayer_IsBase(true);
        return vqcpabstractitem->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPAbstractItem*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnMoveToLayer(QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = dynamic_cast<VirtualQCPAbstractItem*>(self);
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_MoveToLayer_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractItem_ApplyAntialiasingHint(const QCPAbstractItem* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPAbstractItem*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPAbstractItem_QBaseApplyAntialiasingHint(const QCPAbstractItem* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_ApplyAntialiasingHint_IsBase(true);
        vqcpabstractitem->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPAbstractItem*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnApplyAntialiasingHint(const QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPAbstractItem_Sender(const QCPAbstractItem* self) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        return vqcpabstractitem->sender();
    } else {
        return ((VirtualQCPAbstractItem*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPAbstractItem_QBaseSender(const QCPAbstractItem* self) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_Sender_IsBase(true);
        return vqcpabstractitem->sender();
    } else {
        return ((VirtualQCPAbstractItem*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnSender(const QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_Sender_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPAbstractItem_SenderSignalIndex(const QCPAbstractItem* self) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        return vqcpabstractitem->senderSignalIndex();
    } else {
        return ((VirtualQCPAbstractItem*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPAbstractItem_QBaseSenderSignalIndex(const QCPAbstractItem* self) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_SenderSignalIndex_IsBase(true);
        return vqcpabstractitem->senderSignalIndex();
    } else {
        return ((VirtualQCPAbstractItem*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnSenderSignalIndex(const QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPAbstractItem_Receivers(const QCPAbstractItem* self, const char* signal) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        return vqcpabstractitem->receivers(signal);
    } else {
        return ((VirtualQCPAbstractItem*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPAbstractItem_QBaseReceivers(const QCPAbstractItem* self, const char* signal) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_Receivers_IsBase(true);
        return vqcpabstractitem->receivers(signal);
    } else {
        return ((VirtualQCPAbstractItem*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnReceivers(const QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_Receivers_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPAbstractItem_IsSignalConnected(const QCPAbstractItem* self, const QMetaMethod* signal) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        return vqcpabstractitem->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPAbstractItem*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPAbstractItem_QBaseIsSignalConnected(const QCPAbstractItem* self, const QMetaMethod* signal) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_IsSignalConnected_IsBase(true);
        return vqcpabstractitem->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPAbstractItem*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractItem_OnIsSignalConnected(const QCPAbstractItem* self, intptr_t slot) {
    auto* vqcpabstractitem = const_cast<VirtualQCPAbstractItem*>(dynamic_cast<const VirtualQCPAbstractItem*>(self));
    if (vqcpabstractitem && vqcpabstractitem->isVirtualQCPAbstractItem) {
        vqcpabstractitem->setQCPAbstractItem_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPAbstractItem::QCPAbstractItem_IsSignalConnected_Callback>(slot));
    }
}

void QCPAbstractItem_Delete(QCPAbstractItem* self) {
    delete self;
}

QCustomPlot* QCustomPlot_new(QWidget* parent) {
    return new VirtualQCustomPlot(parent);
}

QCustomPlot* QCustomPlot_new2() {
    return new VirtualQCustomPlot();
}

QMetaObject* QCustomPlot_MetaObject(const QCustomPlot* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCustomPlot_Metacast(QCustomPlot* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCustomPlot_Metacall(QCustomPlot* self, int param1, int param2, void** param3) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCustomPlot*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCustomPlot_Tr(const char* s) {
    QString _ret = QCustomPlot::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

QRect* QCustomPlot_Viewport(const QCustomPlot* self) {
    return new QRect(self->viewport());
}

double QCustomPlot_BufferDevicePixelRatio(const QCustomPlot* self) {
    return self->bufferDevicePixelRatio();
}

QPixmap* QCustomPlot_Background(const QCustomPlot* self) {
    return new QPixmap(self->background());
}

bool QCustomPlot_BackgroundScaled(const QCustomPlot* self) {
    return self->backgroundScaled();
}

int QCustomPlot_BackgroundScaledMode(const QCustomPlot* self) {
    return static_cast<int>(self->backgroundScaledMode());
}

QCPLayoutGrid* QCustomPlot_PlotLayout(const QCustomPlot* self) {
    return self->plotLayout();
}

int QCustomPlot_AntialiasedElements(const QCustomPlot* self) {
    return static_cast<int>(self->antialiasedElements());
}

int QCustomPlot_NotAntialiasedElements(const QCustomPlot* self) {
    return static_cast<int>(self->notAntialiasedElements());
}

bool QCustomPlot_AutoAddPlottableToLegend(const QCustomPlot* self) {
    return self->autoAddPlottableToLegend();
}

int QCustomPlot_Interactions(const QCustomPlot* self) {
    return static_cast<int>(self->interactions());
}

int QCustomPlot_SelectionTolerance(const QCustomPlot* self) {
    return self->selectionTolerance();
}

bool QCustomPlot_NoAntialiasingOnDrag(const QCustomPlot* self) {
    return self->noAntialiasingOnDrag();
}

int QCustomPlot_PlottingHints(const QCustomPlot* self) {
    return static_cast<int>(self->plottingHints());
}

int QCustomPlot_MultiSelectModifier(const QCustomPlot* self) {
    return static_cast<int>(self->multiSelectModifier());
}

int QCustomPlot_SelectionRectMode(const QCustomPlot* self) {
    return static_cast<int>(self->selectionRectMode());
}

QCPSelectionRect* QCustomPlot_SelectionRect(const QCustomPlot* self) {
    return self->selectionRect();
}

bool QCustomPlot_OpenGl(const QCustomPlot* self) {
    return self->openGl();
}

void QCustomPlot_SetViewport(QCustomPlot* self, const QRect* rect) {
    self->setViewport(*rect);
}

void QCustomPlot_SetBufferDevicePixelRatio(QCustomPlot* self, double ratio) {
    self->setBufferDevicePixelRatio(static_cast<double>(ratio));
}

void QCustomPlot_SetBackground(QCustomPlot* self, const QPixmap* pm) {
    self->setBackground(*pm);
}

void QCustomPlot_SetBackground2(QCustomPlot* self, const QPixmap* pm, bool scaled) {
    self->setBackground(*pm, scaled);
}

void QCustomPlot_SetBackground3(QCustomPlot* self, const QBrush* brush) {
    self->setBackground(*brush);
}

void QCustomPlot_SetBackgroundScaled(QCustomPlot* self, bool scaled) {
    self->setBackgroundScaled(scaled);
}

void QCustomPlot_SetBackgroundScaledMode(QCustomPlot* self, int mode) {
    self->setBackgroundScaledMode(static_cast<Qt::AspectRatioMode>(mode));
}

void QCustomPlot_SetAntialiasedElements(QCustomPlot* self, const int* antialiasedElements) {
    self->setAntialiasedElements((const QCP::AntialiasedElements&)(*antialiasedElements));
}

void QCustomPlot_SetAntialiasedElement(QCustomPlot* self, int antialiasedElement) {
    self->setAntialiasedElement(static_cast<QCP::AntialiasedElement>(antialiasedElement));
}

void QCustomPlot_SetNotAntialiasedElements(QCustomPlot* self, const int* notAntialiasedElements) {
    self->setNotAntialiasedElements((const QCP::AntialiasedElements&)(*notAntialiasedElements));
}

void QCustomPlot_SetNotAntialiasedElement(QCustomPlot* self, int notAntialiasedElement) {
    self->setNotAntialiasedElement(static_cast<QCP::AntialiasedElement>(notAntialiasedElement));
}

void QCustomPlot_SetAutoAddPlottableToLegend(QCustomPlot* self, bool on) {
    self->setAutoAddPlottableToLegend(on);
}

void QCustomPlot_SetInteractions(QCustomPlot* self, const int* interactions) {
    self->setInteractions((const QCP::Interactions&)(*interactions));
}

void QCustomPlot_SetInteraction(QCustomPlot* self, const int* interaction) {
    self->setInteraction((const QCP::Interaction&)(*interaction));
}

void QCustomPlot_SetSelectionTolerance(QCustomPlot* self, int pixels) {
    self->setSelectionTolerance(static_cast<int>(pixels));
}

void QCustomPlot_SetNoAntialiasingOnDrag(QCustomPlot* self, bool enabled) {
    self->setNoAntialiasingOnDrag(enabled);
}

void QCustomPlot_SetPlottingHints(QCustomPlot* self, const int* hints) {
    self->setPlottingHints((const QCP::PlottingHints&)(*hints));
}

void QCustomPlot_SetPlottingHint(QCustomPlot* self, int hint) {
    self->setPlottingHint(static_cast<QCP::PlottingHint>(hint));
}

void QCustomPlot_SetMultiSelectModifier(QCustomPlot* self, int modifier) {
    self->setMultiSelectModifier(static_cast<Qt::KeyboardModifier>(modifier));
}

void QCustomPlot_SetSelectionRectMode(QCustomPlot* self, int mode) {
    self->setSelectionRectMode(static_cast<QCP::SelectionRectMode>(mode));
}

void QCustomPlot_SetSelectionRect(QCustomPlot* self, QCPSelectionRect* selectionRect) {
    self->setSelectionRect(selectionRect);
}

void QCustomPlot_SetOpenGl(QCustomPlot* self, bool enabled) {
    self->setOpenGl(enabled);
}

QCPAbstractPlottable* QCustomPlot_Plottable(QCustomPlot* self, int index) {
    return self->plottable(static_cast<int>(index));
}

QCPAbstractPlottable* QCustomPlot_Plottable2(QCustomPlot* self) {
    return self->plottable();
}

bool QCustomPlot_RemovePlottable(QCustomPlot* self, QCPAbstractPlottable* plottable) {
    return self->removePlottable(plottable);
}

bool QCustomPlot_RemovePlottable2(QCustomPlot* self, int index) {
    return self->removePlottable(static_cast<int>(index));
}

int QCustomPlot_ClearPlottables(QCustomPlot* self) {
    return self->clearPlottables();
}

int QCustomPlot_PlottableCount(const QCustomPlot* self) {
    return self->plottableCount();
}

libqt_list /* of QCPAbstractPlottable* */ QCustomPlot_SelectedPlottables(const QCustomPlot* self) {
    QList<QCPAbstractPlottable*> _ret = self->selectedPlottables();
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPAbstractPlottable** _arr = static_cast<QCPAbstractPlottable**>(malloc(sizeof(QCPAbstractPlottable*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

QCPAbstractPlottable* QCustomPlot_PlottableAt(const QCustomPlot* self, const QPointF* pos) {
    return self->plottableAt(*pos);
}

bool QCustomPlot_HasPlottable(const QCustomPlot* self, QCPAbstractPlottable* plottable) {
    return self->hasPlottable(plottable);
}

QCPGraph* QCustomPlot_Graph(const QCustomPlot* self, int index) {
    return self->graph(static_cast<int>(index));
}

QCPGraph* QCustomPlot_Graph2(const QCustomPlot* self) {
    return self->graph();
}

QCPGraph* QCustomPlot_AddGraph(QCustomPlot* self) {
    return self->addGraph();
}

bool QCustomPlot_RemoveGraph(QCustomPlot* self, QCPGraph* graph) {
    return self->removeGraph(graph);
}

bool QCustomPlot_RemoveGraph2(QCustomPlot* self, int index) {
    return self->removeGraph(static_cast<int>(index));
}

int QCustomPlot_ClearGraphs(QCustomPlot* self) {
    return self->clearGraphs();
}

int QCustomPlot_GraphCount(const QCustomPlot* self) {
    return self->graphCount();
}

libqt_list /* of QCPGraph* */ QCustomPlot_SelectedGraphs(const QCustomPlot* self) {
    QList<QCPGraph*> _ret = self->selectedGraphs();
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPGraph** _arr = static_cast<QCPGraph**>(malloc(sizeof(QCPGraph*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

QCPAbstractItem* QCustomPlot_Item(const QCustomPlot* self, int index) {
    return self->item(static_cast<int>(index));
}

QCPAbstractItem* QCustomPlot_Item2(const QCustomPlot* self) {
    return self->item();
}

bool QCustomPlot_RemoveItem(QCustomPlot* self, QCPAbstractItem* item) {
    return self->removeItem(item);
}

bool QCustomPlot_RemoveItem2(QCustomPlot* self, int index) {
    return self->removeItem(static_cast<int>(index));
}

int QCustomPlot_ClearItems(QCustomPlot* self) {
    return self->clearItems();
}

int QCustomPlot_ItemCount(const QCustomPlot* self) {
    return self->itemCount();
}

libqt_list /* of QCPAbstractItem* */ QCustomPlot_SelectedItems(const QCustomPlot* self) {
    QList<QCPAbstractItem*> _ret = self->selectedItems();
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPAbstractItem** _arr = static_cast<QCPAbstractItem**>(malloc(sizeof(QCPAbstractItem*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

QCPAbstractItem* QCustomPlot_ItemAt(const QCustomPlot* self, const QPointF* pos) {
    return self->itemAt(*pos);
}

bool QCustomPlot_HasItem(const QCustomPlot* self, QCPAbstractItem* item) {
    return self->hasItem(item);
}

QCPLayer* QCustomPlot_Layer(const QCustomPlot* self, const libqt_string name) {
    QString name_QString = QString::fromUtf8(name.data, name.len);
    return self->layer(name_QString);
}

QCPLayer* QCustomPlot_Layer2(const QCustomPlot* self, int index) {
    return self->layer(static_cast<int>(index));
}

QCPLayer* QCustomPlot_CurrentLayer(const QCustomPlot* self) {
    return self->currentLayer();
}

bool QCustomPlot_SetCurrentLayer(QCustomPlot* self, const libqt_string name) {
    QString name_QString = QString::fromUtf8(name.data, name.len);
    return self->setCurrentLayer(name_QString);
}

bool QCustomPlot_SetCurrentLayer2(QCustomPlot* self, QCPLayer* layer) {
    return self->setCurrentLayer(layer);
}

int QCustomPlot_LayerCount(const QCustomPlot* self) {
    return self->layerCount();
}

bool QCustomPlot_AddLayer(QCustomPlot* self, const libqt_string name) {
    QString name_QString = QString::fromUtf8(name.data, name.len);
    return self->addLayer(name_QString);
}

bool QCustomPlot_RemoveLayer(QCustomPlot* self, QCPLayer* layer) {
    return self->removeLayer(layer);
}

bool QCustomPlot_MoveLayer(QCustomPlot* self, QCPLayer* layer, QCPLayer* otherLayer) {
    return self->moveLayer(layer, otherLayer);
}

int QCustomPlot_AxisRectCount(const QCustomPlot* self) {
    return self->axisRectCount();
}

QCPAxisRect* QCustomPlot_AxisRect(const QCustomPlot* self) {
    return self->axisRect();
}

libqt_list /* of QCPAxisRect* */ QCustomPlot_AxisRects(const QCustomPlot* self) {
    QList<QCPAxisRect*> _ret = self->axisRects();
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPAxisRect** _arr = static_cast<QCPAxisRect**>(malloc(sizeof(QCPAxisRect*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

QCPLayoutElement* QCustomPlot_LayoutElementAt(const QCustomPlot* self, const QPointF* pos) {
    return self->layoutElementAt(*pos);
}

QCPAxisRect* QCustomPlot_AxisRectAt(const QCustomPlot* self, const QPointF* pos) {
    return self->axisRectAt(*pos);
}

void QCustomPlot_RescaleAxes(QCustomPlot* self) {
    self->rescaleAxes();
}

libqt_list /* of QCPAxis* */ QCustomPlot_SelectedAxes(const QCustomPlot* self) {
    QList<QCPAxis*> _ret = self->selectedAxes();
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPAxis** _arr = static_cast<QCPAxis**>(malloc(sizeof(QCPAxis*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

libqt_list /* of QCPLegend* */ QCustomPlot_SelectedLegends(const QCustomPlot* self) {
    QList<QCPLegend*> _ret = self->selectedLegends();
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPLegend** _arr = static_cast<QCPLegend**>(malloc(sizeof(QCPLegend*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

void QCustomPlot_DeselectAll(QCustomPlot* self) {
    self->deselectAll();
}

bool QCustomPlot_SavePdf(QCustomPlot* self, const libqt_string fileName) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->savePdf(fileName_QString);
}

bool QCustomPlot_SavePng(QCustomPlot* self, const libqt_string fileName) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->savePng(fileName_QString);
}

bool QCustomPlot_SaveJpg(QCustomPlot* self, const libqt_string fileName) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->saveJpg(fileName_QString);
}

bool QCustomPlot_SaveBmp(QCustomPlot* self, const libqt_string fileName) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->saveBmp(fileName_QString);
}

bool QCustomPlot_SaveRastered(QCustomPlot* self, const libqt_string fileName, int width, int height, double scale, const char* format) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->saveRastered(fileName_QString, static_cast<int>(width), static_cast<int>(height), static_cast<double>(scale), format);
}

QPixmap* QCustomPlot_ToPixmap(QCustomPlot* self) {
    return new QPixmap(self->toPixmap());
}

void QCustomPlot_ToPainter(QCustomPlot* self, QCPPainter* painter) {
    self->toPainter(painter);
}

void QCustomPlot_Replot(QCustomPlot* self) {
    self->replot();
}

double QCustomPlot_ReplotTime(const QCustomPlot* self) {
    return self->replotTime();
}

QCPAxis* QCustomPlot_XAxis(const QCustomPlot* self) {
    return self->xAxis;
}

void QCustomPlot_SetXAxis(QCustomPlot* self, QCPAxis* xAxis) {
    self->xAxis = xAxis;
}

QCPAxis* QCustomPlot_YAxis(const QCustomPlot* self) {
    return self->yAxis;
}

void QCustomPlot_SetYAxis(QCustomPlot* self, QCPAxis* yAxis) {
    self->yAxis = yAxis;
}

QCPAxis* QCustomPlot_XAxis2(const QCustomPlot* self) {
    return self->xAxis2;
}

void QCustomPlot_SetXAxis2(QCustomPlot* self, QCPAxis* xAxis2) {
    self->xAxis2 = xAxis2;
}

QCPAxis* QCustomPlot_YAxis2(const QCustomPlot* self) {
    return self->yAxis2;
}

void QCustomPlot_SetYAxis2(QCustomPlot* self, QCPAxis* yAxis2) {
    self->yAxis2 = yAxis2;
}

QCPLegend* QCustomPlot_Legend(const QCustomPlot* self) {
    return self->legend;
}

void QCustomPlot_SetLegend(QCustomPlot* self, QCPLegend* legend) {
    self->legend = legend;
}

void QCustomPlot_MouseDoubleClick(QCustomPlot* self, QMouseEvent* event) {
    self->mouseDoubleClick(event);
}

void QCustomPlot_Connect_MouseDoubleClick(QCustomPlot* self, intptr_t slot) {
    void (*slotFunc)(QCustomPlot*, QMouseEvent*) = reinterpret_cast<void (*)(QCustomPlot*, QMouseEvent*)>(slot);
    QCustomPlot::connect(self, &QCustomPlot::mouseDoubleClick, [self, slotFunc](QMouseEvent* event) {
        QMouseEvent* sigval1 = event;
        slotFunc(self, sigval1);
    });
}

void QCustomPlot_MousePress(QCustomPlot* self, QMouseEvent* event) {
    self->mousePress(event);
}

void QCustomPlot_Connect_MousePress(QCustomPlot* self, intptr_t slot) {
    void (*slotFunc)(QCustomPlot*, QMouseEvent*) = reinterpret_cast<void (*)(QCustomPlot*, QMouseEvent*)>(slot);
    QCustomPlot::connect(self, &QCustomPlot::mousePress, [self, slotFunc](QMouseEvent* event) {
        QMouseEvent* sigval1 = event;
        slotFunc(self, sigval1);
    });
}

void QCustomPlot_MouseMove(QCustomPlot* self, QMouseEvent* event) {
    self->mouseMove(event);
}

void QCustomPlot_Connect_MouseMove(QCustomPlot* self, intptr_t slot) {
    void (*slotFunc)(QCustomPlot*, QMouseEvent*) = reinterpret_cast<void (*)(QCustomPlot*, QMouseEvent*)>(slot);
    QCustomPlot::connect(self, &QCustomPlot::mouseMove, [self, slotFunc](QMouseEvent* event) {
        QMouseEvent* sigval1 = event;
        slotFunc(self, sigval1);
    });
}

void QCustomPlot_MouseRelease(QCustomPlot* self, QMouseEvent* event) {
    self->mouseRelease(event);
}

void QCustomPlot_Connect_MouseRelease(QCustomPlot* self, intptr_t slot) {
    void (*slotFunc)(QCustomPlot*, QMouseEvent*) = reinterpret_cast<void (*)(QCustomPlot*, QMouseEvent*)>(slot);
    QCustomPlot::connect(self, &QCustomPlot::mouseRelease, [self, slotFunc](QMouseEvent* event) {
        QMouseEvent* sigval1 = event;
        slotFunc(self, sigval1);
    });
}

void QCustomPlot_MouseWheel(QCustomPlot* self, QWheelEvent* event) {
    self->mouseWheel(event);
}

void QCustomPlot_Connect_MouseWheel(QCustomPlot* self, intptr_t slot) {
    void (*slotFunc)(QCustomPlot*, QWheelEvent*) = reinterpret_cast<void (*)(QCustomPlot*, QWheelEvent*)>(slot);
    QCustomPlot::connect(self, &QCustomPlot::mouseWheel, [self, slotFunc](QWheelEvent* event) {
        QWheelEvent* sigval1 = event;
        slotFunc(self, sigval1);
    });
}

void QCustomPlot_PlottableClick(QCustomPlot* self, QCPAbstractPlottable* plottable, int dataIndex, QMouseEvent* event) {
    self->plottableClick(plottable, static_cast<int>(dataIndex), event);
}

void QCustomPlot_Connect_PlottableClick(QCustomPlot* self, intptr_t slot) {
    void (*slotFunc)(QCustomPlot*, QCPAbstractPlottable*, int, QMouseEvent*) = reinterpret_cast<void (*)(QCustomPlot*, QCPAbstractPlottable*, int, QMouseEvent*)>(slot);
    QCustomPlot::connect(self, &QCustomPlot::plottableClick, [self, slotFunc](QCPAbstractPlottable* plottable, int dataIndex, QMouseEvent* event) {
        QCPAbstractPlottable* sigval1 = plottable;
        int sigval2 = dataIndex;
        QMouseEvent* sigval3 = event;
        slotFunc(self, sigval1, sigval2, sigval3);
    });
}

void QCustomPlot_PlottableDoubleClick(QCustomPlot* self, QCPAbstractPlottable* plottable, int dataIndex, QMouseEvent* event) {
    self->plottableDoubleClick(plottable, static_cast<int>(dataIndex), event);
}

void QCustomPlot_Connect_PlottableDoubleClick(QCustomPlot* self, intptr_t slot) {
    void (*slotFunc)(QCustomPlot*, QCPAbstractPlottable*, int, QMouseEvent*) = reinterpret_cast<void (*)(QCustomPlot*, QCPAbstractPlottable*, int, QMouseEvent*)>(slot);
    QCustomPlot::connect(self, &QCustomPlot::plottableDoubleClick, [self, slotFunc](QCPAbstractPlottable* plottable, int dataIndex, QMouseEvent* event) {
        QCPAbstractPlottable* sigval1 = plottable;
        int sigval2 = dataIndex;
        QMouseEvent* sigval3 = event;
        slotFunc(self, sigval1, sigval2, sigval3);
    });
}

void QCustomPlot_ItemClick(QCustomPlot* self, QCPAbstractItem* item, QMouseEvent* event) {
    self->itemClick(item, event);
}

void QCustomPlot_Connect_ItemClick(QCustomPlot* self, intptr_t slot) {
    void (*slotFunc)(QCustomPlot*, QCPAbstractItem*, QMouseEvent*) = reinterpret_cast<void (*)(QCustomPlot*, QCPAbstractItem*, QMouseEvent*)>(slot);
    QCustomPlot::connect(self, &QCustomPlot::itemClick, [self, slotFunc](QCPAbstractItem* item, QMouseEvent* event) {
        QCPAbstractItem* sigval1 = item;
        QMouseEvent* sigval2 = event;
        slotFunc(self, sigval1, sigval2);
    });
}

void QCustomPlot_ItemDoubleClick(QCustomPlot* self, QCPAbstractItem* item, QMouseEvent* event) {
    self->itemDoubleClick(item, event);
}

void QCustomPlot_Connect_ItemDoubleClick(QCustomPlot* self, intptr_t slot) {
    void (*slotFunc)(QCustomPlot*, QCPAbstractItem*, QMouseEvent*) = reinterpret_cast<void (*)(QCustomPlot*, QCPAbstractItem*, QMouseEvent*)>(slot);
    QCustomPlot::connect(self, &QCustomPlot::itemDoubleClick, [self, slotFunc](QCPAbstractItem* item, QMouseEvent* event) {
        QCPAbstractItem* sigval1 = item;
        QMouseEvent* sigval2 = event;
        slotFunc(self, sigval1, sigval2);
    });
}

void QCustomPlot_AxisClick(QCustomPlot* self, QCPAxis* axis, int part, QMouseEvent* event) {
    self->axisClick(axis, static_cast<QCPAxis::SelectablePart>(part), event);
}

void QCustomPlot_Connect_AxisClick(QCustomPlot* self, intptr_t slot) {
    void (*slotFunc)(QCustomPlot*, QCPAxis*, int, QMouseEvent*) = reinterpret_cast<void (*)(QCustomPlot*, QCPAxis*, int, QMouseEvent*)>(slot);
    QCustomPlot::connect(self, &QCustomPlot::axisClick, [self, slotFunc](QCPAxis* axis, QCPAxis::SelectablePart part, QMouseEvent* event) {
        QCPAxis* sigval1 = axis;
        int sigval2 = static_cast<int>(part);
        QMouseEvent* sigval3 = event;
        slotFunc(self, sigval1, sigval2, sigval3);
    });
}

void QCustomPlot_AxisDoubleClick(QCustomPlot* self, QCPAxis* axis, int part, QMouseEvent* event) {
    self->axisDoubleClick(axis, static_cast<QCPAxis::SelectablePart>(part), event);
}

void QCustomPlot_Connect_AxisDoubleClick(QCustomPlot* self, intptr_t slot) {
    void (*slotFunc)(QCustomPlot*, QCPAxis*, int, QMouseEvent*) = reinterpret_cast<void (*)(QCustomPlot*, QCPAxis*, int, QMouseEvent*)>(slot);
    QCustomPlot::connect(self, &QCustomPlot::axisDoubleClick, [self, slotFunc](QCPAxis* axis, QCPAxis::SelectablePart part, QMouseEvent* event) {
        QCPAxis* sigval1 = axis;
        int sigval2 = static_cast<int>(part);
        QMouseEvent* sigval3 = event;
        slotFunc(self, sigval1, sigval2, sigval3);
    });
}

void QCustomPlot_LegendClick(QCustomPlot* self, QCPLegend* legend, QCPAbstractLegendItem* item, QMouseEvent* event) {
    self->legendClick(legend, item, event);
}

void QCustomPlot_Connect_LegendClick(QCustomPlot* self, intptr_t slot) {
    void (*slotFunc)(QCustomPlot*, QCPLegend*, QCPAbstractLegendItem*, QMouseEvent*) = reinterpret_cast<void (*)(QCustomPlot*, QCPLegend*, QCPAbstractLegendItem*, QMouseEvent*)>(slot);
    QCustomPlot::connect(self, &QCustomPlot::legendClick, [self, slotFunc](QCPLegend* legend, QCPAbstractLegendItem* item, QMouseEvent* event) {
        QCPLegend* sigval1 = legend;
        QCPAbstractLegendItem* sigval2 = item;
        QMouseEvent* sigval3 = event;
        slotFunc(self, sigval1, sigval2, sigval3);
    });
}

void QCustomPlot_LegendDoubleClick(QCustomPlot* self, QCPLegend* legend, QCPAbstractLegendItem* item, QMouseEvent* event) {
    self->legendDoubleClick(legend, item, event);
}

void QCustomPlot_Connect_LegendDoubleClick(QCustomPlot* self, intptr_t slot) {
    void (*slotFunc)(QCustomPlot*, QCPLegend*, QCPAbstractLegendItem*, QMouseEvent*) = reinterpret_cast<void (*)(QCustomPlot*, QCPLegend*, QCPAbstractLegendItem*, QMouseEvent*)>(slot);
    QCustomPlot::connect(self, &QCustomPlot::legendDoubleClick, [self, slotFunc](QCPLegend* legend, QCPAbstractLegendItem* item, QMouseEvent* event) {
        QCPLegend* sigval1 = legend;
        QCPAbstractLegendItem* sigval2 = item;
        QMouseEvent* sigval3 = event;
        slotFunc(self, sigval1, sigval2, sigval3);
    });
}

void QCustomPlot_SelectionChangedByUser(QCustomPlot* self) {
    self->selectionChangedByUser();
}

void QCustomPlot_Connect_SelectionChangedByUser(QCustomPlot* self, intptr_t slot) {
    void (*slotFunc)(QCustomPlot*) = reinterpret_cast<void (*)(QCustomPlot*)>(slot);
    QCustomPlot::connect(self, &QCustomPlot::selectionChangedByUser, [self, slotFunc]() {
        slotFunc(self);
    });
}

void QCustomPlot_BeforeReplot(QCustomPlot* self) {
    self->beforeReplot();
}

void QCustomPlot_Connect_BeforeReplot(QCustomPlot* self, intptr_t slot) {
    void (*slotFunc)(QCustomPlot*) = reinterpret_cast<void (*)(QCustomPlot*)>(slot);
    QCustomPlot::connect(self, &QCustomPlot::beforeReplot, [self, slotFunc]() {
        slotFunc(self);
    });
}

void QCustomPlot_AfterLayout(QCustomPlot* self) {
    self->afterLayout();
}

void QCustomPlot_Connect_AfterLayout(QCustomPlot* self, intptr_t slot) {
    void (*slotFunc)(QCustomPlot*) = reinterpret_cast<void (*)(QCustomPlot*)>(slot);
    QCustomPlot::connect(self, &QCustomPlot::afterLayout, [self, slotFunc]() {
        slotFunc(self);
    });
}

void QCustomPlot_AfterReplot(QCustomPlot* self) {
    self->afterReplot();
}

void QCustomPlot_Connect_AfterReplot(QCustomPlot* self, intptr_t slot) {
    void (*slotFunc)(QCustomPlot*) = reinterpret_cast<void (*)(QCustomPlot*)>(slot);
    QCustomPlot::connect(self, &QCustomPlot::afterReplot, [self, slotFunc]() {
        slotFunc(self);
    });
}

QSize* QCustomPlot_MinimumSizeHint(const QCustomPlot* self) {
    auto* vqcustomplot = dynamic_cast<const VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return new QSize(vqcustomplot->minimumSizeHint());
    }
    return {};
}

QSize* QCustomPlot_SizeHint(const QCustomPlot* self) {
    auto* vqcustomplot = dynamic_cast<const VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return new QSize(vqcustomplot->sizeHint());
    }
    return {};
}

void QCustomPlot_PaintEvent(QCustomPlot* self, QPaintEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->paintEvent(event);
    }
}

void QCustomPlot_ResizeEvent(QCustomPlot* self, QResizeEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->resizeEvent(event);
    }
}

void QCustomPlot_MouseDoubleClickEvent(QCustomPlot* self, QMouseEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->mouseDoubleClickEvent(event);
    }
}

void QCustomPlot_MousePressEvent(QCustomPlot* self, QMouseEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->mousePressEvent(event);
    }
}

void QCustomPlot_MouseMoveEvent(QCustomPlot* self, QMouseEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->mouseMoveEvent(event);
    }
}

void QCustomPlot_MouseReleaseEvent(QCustomPlot* self, QMouseEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->mouseReleaseEvent(event);
    }
}

void QCustomPlot_WheelEvent(QCustomPlot* self, QWheelEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->wheelEvent(event);
    }
}

void QCustomPlot_Draw(QCustomPlot* self, QCPPainter* painter) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->draw(painter);
    }
}

void QCustomPlot_UpdateLayout(QCustomPlot* self) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->updateLayout();
    }
}

void QCustomPlot_AxisRemoved(QCustomPlot* self, QCPAxis* axis) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->axisRemoved(axis);
    }
}

void QCustomPlot_LegendRemoved(QCustomPlot* self, QCPLegend* legend) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->legendRemoved(legend);
    }
}

void QCustomPlot_ProcessRectSelection(QCustomPlot* self, QRect* rect, QMouseEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->processRectSelection(*rect, event);
    }
}

void QCustomPlot_ProcessRectZoom(QCustomPlot* self, QRect* rect, QMouseEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->processRectZoom(*rect, event);
    }
}

void QCustomPlot_ProcessPointSelection(QCustomPlot* self, QMouseEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->processPointSelection(event);
    }
}

libqt_string QCustomPlot_Tr2(const char* s, const char* c) {
    QString _ret = QCustomPlot::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCustomPlot_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCustomPlot::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

void QCustomPlot_SetBackground32(QCustomPlot* self, const QPixmap* pm, bool scaled, int mode) {
    self->setBackground(*pm, scaled, static_cast<Qt::AspectRatioMode>(mode));
}

void QCustomPlot_SetAntialiasedElement2(QCustomPlot* self, int antialiasedElement, bool enabled) {
    self->setAntialiasedElement(static_cast<QCP::AntialiasedElement>(antialiasedElement), enabled);
}

void QCustomPlot_SetNotAntialiasedElement2(QCustomPlot* self, int notAntialiasedElement, bool enabled) {
    self->setNotAntialiasedElement(static_cast<QCP::AntialiasedElement>(notAntialiasedElement), enabled);
}

void QCustomPlot_SetInteraction2(QCustomPlot* self, const int* interaction, bool enabled) {
    self->setInteraction((const QCP::Interaction&)(*interaction), enabled);
}

void QCustomPlot_SetPlottingHint2(QCustomPlot* self, int hint, bool enabled) {
    self->setPlottingHint(static_cast<QCP::PlottingHint>(hint), enabled);
}

void QCustomPlot_SetOpenGl2(QCustomPlot* self, bool enabled, int multisampling) {
    self->setOpenGl(enabled, static_cast<int>(multisampling));
}

QCPAbstractPlottable* QCustomPlot_PlottableAt2(const QCustomPlot* self, const QPointF* pos, bool onlySelectable) {
    return self->plottableAt(*pos, onlySelectable);
}

QCPAbstractPlottable* QCustomPlot_PlottableAt3(const QCustomPlot* self, const QPointF* pos, bool onlySelectable, int* dataIndex) {
    return self->plottableAt(*pos, onlySelectable, static_cast<int*>(dataIndex));
}

QCPGraph* QCustomPlot_AddGraph1(QCustomPlot* self, QCPAxis* keyAxis) {
    return self->addGraph(keyAxis);
}

QCPGraph* QCustomPlot_AddGraph2(QCustomPlot* self, QCPAxis* keyAxis, QCPAxis* valueAxis) {
    return self->addGraph(keyAxis, valueAxis);
}

QCPAbstractItem* QCustomPlot_ItemAt2(const QCustomPlot* self, const QPointF* pos, bool onlySelectable) {
    return self->itemAt(*pos, onlySelectable);
}

bool QCustomPlot_AddLayer2(QCustomPlot* self, const libqt_string name, QCPLayer* otherLayer) {
    QString name_QString = QString::fromUtf8(name.data, name.len);
    return self->addLayer(name_QString, otherLayer);
}

bool QCustomPlot_AddLayer3(QCustomPlot* self, const libqt_string name, QCPLayer* otherLayer, int insertMode) {
    QString name_QString = QString::fromUtf8(name.data, name.len);
    return self->addLayer(name_QString, otherLayer, static_cast<QCustomPlot::LayerInsertMode>(insertMode));
}

bool QCustomPlot_MoveLayer3(QCustomPlot* self, QCPLayer* layer, QCPLayer* otherLayer, int insertMode) {
    return self->moveLayer(layer, otherLayer, static_cast<QCustomPlot::LayerInsertMode>(insertMode));
}

QCPAxisRect* QCustomPlot_AxisRect1(const QCustomPlot* self, int index) {
    return self->axisRect(static_cast<int>(index));
}

void QCustomPlot_RescaleAxes1(QCustomPlot* self, bool onlyVisiblePlottables) {
    self->rescaleAxes(onlyVisiblePlottables);
}

bool QCustomPlot_SavePdf2(QCustomPlot* self, const libqt_string fileName, int width) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->savePdf(fileName_QString, static_cast<int>(width));
}

bool QCustomPlot_SavePdf3(QCustomPlot* self, const libqt_string fileName, int width, int height) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->savePdf(fileName_QString, static_cast<int>(width), static_cast<int>(height));
}

bool QCustomPlot_SavePdf4(QCustomPlot* self, const libqt_string fileName, int width, int height, int exportPen) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->savePdf(fileName_QString, static_cast<int>(width), static_cast<int>(height), static_cast<QCP::ExportPen>(exportPen));
}

bool QCustomPlot_SavePdf5(QCustomPlot* self, const libqt_string fileName, int width, int height, int exportPen, const libqt_string pdfCreator) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    QString pdfCreator_QString = QString::fromUtf8(pdfCreator.data, pdfCreator.len);
    return self->savePdf(fileName_QString, static_cast<int>(width), static_cast<int>(height), static_cast<QCP::ExportPen>(exportPen), pdfCreator_QString);
}

bool QCustomPlot_SavePdf6(QCustomPlot* self, const libqt_string fileName, int width, int height, int exportPen, const libqt_string pdfCreator, const libqt_string pdfTitle) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    QString pdfCreator_QString = QString::fromUtf8(pdfCreator.data, pdfCreator.len);
    QString pdfTitle_QString = QString::fromUtf8(pdfTitle.data, pdfTitle.len);
    return self->savePdf(fileName_QString, static_cast<int>(width), static_cast<int>(height), static_cast<QCP::ExportPen>(exportPen), pdfCreator_QString, pdfTitle_QString);
}

bool QCustomPlot_SavePng2(QCustomPlot* self, const libqt_string fileName, int width) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->savePng(fileName_QString, static_cast<int>(width));
}

bool QCustomPlot_SavePng3(QCustomPlot* self, const libqt_string fileName, int width, int height) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->savePng(fileName_QString, static_cast<int>(width), static_cast<int>(height));
}

bool QCustomPlot_SavePng4(QCustomPlot* self, const libqt_string fileName, int width, int height, double scale) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->savePng(fileName_QString, static_cast<int>(width), static_cast<int>(height), static_cast<double>(scale));
}

bool QCustomPlot_SavePng5(QCustomPlot* self, const libqt_string fileName, int width, int height, double scale, int quality) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->savePng(fileName_QString, static_cast<int>(width), static_cast<int>(height), static_cast<double>(scale), static_cast<int>(quality));
}

bool QCustomPlot_SavePng6(QCustomPlot* self, const libqt_string fileName, int width, int height, double scale, int quality, int resolution) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->savePng(fileName_QString, static_cast<int>(width), static_cast<int>(height), static_cast<double>(scale), static_cast<int>(quality), static_cast<int>(resolution));
}

bool QCustomPlot_SavePng7(QCustomPlot* self, const libqt_string fileName, int width, int height, double scale, int quality, int resolution, int resolutionUnit) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->savePng(fileName_QString, static_cast<int>(width), static_cast<int>(height), static_cast<double>(scale), static_cast<int>(quality), static_cast<int>(resolution), static_cast<QCP::ResolutionUnit>(resolutionUnit));
}

bool QCustomPlot_SaveJpg2(QCustomPlot* self, const libqt_string fileName, int width) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->saveJpg(fileName_QString, static_cast<int>(width));
}

bool QCustomPlot_SaveJpg3(QCustomPlot* self, const libqt_string fileName, int width, int height) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->saveJpg(fileName_QString, static_cast<int>(width), static_cast<int>(height));
}

bool QCustomPlot_SaveJpg4(QCustomPlot* self, const libqt_string fileName, int width, int height, double scale) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->saveJpg(fileName_QString, static_cast<int>(width), static_cast<int>(height), static_cast<double>(scale));
}

bool QCustomPlot_SaveJpg5(QCustomPlot* self, const libqt_string fileName, int width, int height, double scale, int quality) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->saveJpg(fileName_QString, static_cast<int>(width), static_cast<int>(height), static_cast<double>(scale), static_cast<int>(quality));
}

bool QCustomPlot_SaveJpg6(QCustomPlot* self, const libqt_string fileName, int width, int height, double scale, int quality, int resolution) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->saveJpg(fileName_QString, static_cast<int>(width), static_cast<int>(height), static_cast<double>(scale), static_cast<int>(quality), static_cast<int>(resolution));
}

bool QCustomPlot_SaveJpg7(QCustomPlot* self, const libqt_string fileName, int width, int height, double scale, int quality, int resolution, int resolutionUnit) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->saveJpg(fileName_QString, static_cast<int>(width), static_cast<int>(height), static_cast<double>(scale), static_cast<int>(quality), static_cast<int>(resolution), static_cast<QCP::ResolutionUnit>(resolutionUnit));
}

bool QCustomPlot_SaveBmp2(QCustomPlot* self, const libqt_string fileName, int width) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->saveBmp(fileName_QString, static_cast<int>(width));
}

bool QCustomPlot_SaveBmp3(QCustomPlot* self, const libqt_string fileName, int width, int height) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->saveBmp(fileName_QString, static_cast<int>(width), static_cast<int>(height));
}

bool QCustomPlot_SaveBmp4(QCustomPlot* self, const libqt_string fileName, int width, int height, double scale) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->saveBmp(fileName_QString, static_cast<int>(width), static_cast<int>(height), static_cast<double>(scale));
}

bool QCustomPlot_SaveBmp5(QCustomPlot* self, const libqt_string fileName, int width, int height, double scale, int resolution) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->saveBmp(fileName_QString, static_cast<int>(width), static_cast<int>(height), static_cast<double>(scale), static_cast<int>(resolution));
}

bool QCustomPlot_SaveBmp6(QCustomPlot* self, const libqt_string fileName, int width, int height, double scale, int resolution, int resolutionUnit) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->saveBmp(fileName_QString, static_cast<int>(width), static_cast<int>(height), static_cast<double>(scale), static_cast<int>(resolution), static_cast<QCP::ResolutionUnit>(resolutionUnit));
}

bool QCustomPlot_SaveRastered6(QCustomPlot* self, const libqt_string fileName, int width, int height, double scale, const char* format, int quality) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->saveRastered(fileName_QString, static_cast<int>(width), static_cast<int>(height), static_cast<double>(scale), format, static_cast<int>(quality));
}

bool QCustomPlot_SaveRastered7(QCustomPlot* self, const libqt_string fileName, int width, int height, double scale, const char* format, int quality, int resolution) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->saveRastered(fileName_QString, static_cast<int>(width), static_cast<int>(height), static_cast<double>(scale), format, static_cast<int>(quality), static_cast<int>(resolution));
}

bool QCustomPlot_SaveRastered8(QCustomPlot* self, const libqt_string fileName, int width, int height, double scale, const char* format, int quality, int resolution, int resolutionUnit) {
    QString fileName_QString = QString::fromUtf8(fileName.data, fileName.len);
    return self->saveRastered(fileName_QString, static_cast<int>(width), static_cast<int>(height), static_cast<double>(scale), format, static_cast<int>(quality), static_cast<int>(resolution), static_cast<QCP::ResolutionUnit>(resolutionUnit));
}

QPixmap* QCustomPlot_ToPixmap1(QCustomPlot* self, int width) {
    return new QPixmap(self->toPixmap(static_cast<int>(width)));
}

QPixmap* QCustomPlot_ToPixmap2(QCustomPlot* self, int width, int height) {
    return new QPixmap(self->toPixmap(static_cast<int>(width), static_cast<int>(height)));
}

QPixmap* QCustomPlot_ToPixmap3(QCustomPlot* self, int width, int height, double scale) {
    return new QPixmap(self->toPixmap(static_cast<int>(width), static_cast<int>(height), static_cast<double>(scale)));
}

void QCustomPlot_ToPainter2(QCustomPlot* self, QCPPainter* painter, int width) {
    self->toPainter(painter, static_cast<int>(width));
}

void QCustomPlot_ToPainter3(QCustomPlot* self, QCPPainter* painter, int width, int height) {
    self->toPainter(painter, static_cast<int>(width), static_cast<int>(height));
}

void QCustomPlot_Replot1(QCustomPlot* self, int refreshPriority) {
    self->replot(static_cast<QCustomPlot::RefreshPriority>(refreshPriority));
}

double QCustomPlot_ReplotTime1(const QCustomPlot* self, bool average) {
    return self->replotTime(average);
}

// Base class handler implementation
int QCustomPlot_QBaseMetacall(QCustomPlot* self, int param1, int param2, void** param3) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_Metacall_IsBase(true);
        return vqcustomplot->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCustomPlot::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnMetacall(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_Metacall_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
QSize* QCustomPlot_QBaseMinimumSizeHint(const QCustomPlot* self) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_MinimumSizeHint_IsBase(true);
        return new QSize(vqcustomplot->minimumSizeHint());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnMinimumSizeHint(const QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_MinimumSizeHint_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_MinimumSizeHint_Callback>(slot));
    }
}

// Base class handler implementation
QSize* QCustomPlot_QBaseSizeHint(const QCustomPlot* self) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_SizeHint_IsBase(true);
        return new QSize(vqcustomplot->sizeHint());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnSizeHint(const QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_SizeHint_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_SizeHint_Callback>(slot));
    }
}

// Base class handler implementation
void QCustomPlot_QBasePaintEvent(QCustomPlot* self, QPaintEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_PaintEvent_IsBase(true);
        vqcustomplot->paintEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->paintEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnPaintEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_PaintEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_PaintEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCustomPlot_QBaseResizeEvent(QCustomPlot* self, QResizeEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_ResizeEvent_IsBase(true);
        vqcustomplot->resizeEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->resizeEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnResizeEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_ResizeEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_ResizeEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCustomPlot_QBaseMouseDoubleClickEvent(QCustomPlot* self, QMouseEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_MouseDoubleClickEvent_IsBase(true);
        vqcustomplot->mouseDoubleClickEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->mouseDoubleClickEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnMouseDoubleClickEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCustomPlot_QBaseMousePressEvent(QCustomPlot* self, QMouseEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_MousePressEvent_IsBase(true);
        vqcustomplot->mousePressEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->mousePressEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnMousePressEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_MousePressEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_MousePressEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCustomPlot_QBaseMouseMoveEvent(QCustomPlot* self, QMouseEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_MouseMoveEvent_IsBase(true);
        vqcustomplot->mouseMoveEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->mouseMoveEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnMouseMoveEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_MouseMoveEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCustomPlot_QBaseMouseReleaseEvent(QCustomPlot* self, QMouseEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_MouseReleaseEvent_IsBase(true);
        vqcustomplot->mouseReleaseEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->mouseReleaseEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnMouseReleaseEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_MouseReleaseEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCustomPlot_QBaseWheelEvent(QCustomPlot* self, QWheelEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_WheelEvent_IsBase(true);
        vqcustomplot->wheelEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnWheelEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_WheelEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_WheelEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCustomPlot_QBaseDraw(QCustomPlot* self, QCPPainter* painter) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_Draw_IsBase(true);
        vqcustomplot->draw(painter);
    } else {
        ((VirtualQCustomPlot*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnDraw(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_Draw_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_Draw_Callback>(slot));
    }
}

// Base class handler implementation
void QCustomPlot_QBaseUpdateLayout(QCustomPlot* self) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_UpdateLayout_IsBase(true);
        vqcustomplot->updateLayout();
    } else {
        ((VirtualQCustomPlot*)self)->updateLayout();
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnUpdateLayout(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_UpdateLayout_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_UpdateLayout_Callback>(slot));
    }
}

// Base class handler implementation
void QCustomPlot_QBaseAxisRemoved(QCustomPlot* self, QCPAxis* axis) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_AxisRemoved_IsBase(true);
        vqcustomplot->axisRemoved(axis);
    } else {
        ((VirtualQCustomPlot*)self)->axisRemoved(axis);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnAxisRemoved(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_AxisRemoved_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_AxisRemoved_Callback>(slot));
    }
}

// Base class handler implementation
void QCustomPlot_QBaseLegendRemoved(QCustomPlot* self, QCPLegend* legend) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_LegendRemoved_IsBase(true);
        vqcustomplot->legendRemoved(legend);
    } else {
        ((VirtualQCustomPlot*)self)->legendRemoved(legend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnLegendRemoved(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_LegendRemoved_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_LegendRemoved_Callback>(slot));
    }
}

// Base class handler implementation
void QCustomPlot_QBaseProcessRectSelection(QCustomPlot* self, QRect* rect, QMouseEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_ProcessRectSelection_IsBase(true);
        vqcustomplot->processRectSelection(*rect, event);
    } else {
        ((VirtualQCustomPlot*)self)->processRectSelection(*rect, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnProcessRectSelection(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_ProcessRectSelection_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_ProcessRectSelection_Callback>(slot));
    }
}

// Base class handler implementation
void QCustomPlot_QBaseProcessRectZoom(QCustomPlot* self, QRect* rect, QMouseEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_ProcessRectZoom_IsBase(true);
        vqcustomplot->processRectZoom(*rect, event);
    } else {
        ((VirtualQCustomPlot*)self)->processRectZoom(*rect, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnProcessRectZoom(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_ProcessRectZoom_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_ProcessRectZoom_Callback>(slot));
    }
}

// Base class handler implementation
void QCustomPlot_QBaseProcessPointSelection(QCustomPlot* self, QMouseEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_ProcessPointSelection_IsBase(true);
        vqcustomplot->processPointSelection(event);
    } else {
        ((VirtualQCustomPlot*)self)->processPointSelection(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnProcessPointSelection(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_ProcessPointSelection_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_ProcessPointSelection_Callback>(slot));
    }
}

// Derived class handler implementation
int QCustomPlot_DevType(const QCustomPlot* self) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->devType();
    } else {
        return self->QCustomPlot::devType();
    }
}

// Base class handler implementation
int QCustomPlot_QBaseDevType(const QCustomPlot* self) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_DevType_IsBase(true);
        return vqcustomplot->devType();
    } else {
        return self->QCustomPlot::devType();
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnDevType(const QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_DevType_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_DevType_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_SetVisible(QCustomPlot* self, bool visible) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setVisible(visible);
    } else {
        self->QCustomPlot::setVisible(visible);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseSetVisible(QCustomPlot* self, bool visible) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_SetVisible_IsBase(true);
        vqcustomplot->setVisible(visible);
    } else {
        self->QCustomPlot::setVisible(visible);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnSetVisible(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_SetVisible_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_SetVisible_Callback>(slot));
    }
}

// Derived class handler implementation
int QCustomPlot_HeightForWidth(const QCustomPlot* self, int param1) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->heightForWidth(static_cast<int>(param1));
    } else {
        return self->QCustomPlot::heightForWidth(static_cast<int>(param1));
    }
}

// Base class handler implementation
int QCustomPlot_QBaseHeightForWidth(const QCustomPlot* self, int param1) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_HeightForWidth_IsBase(true);
        return vqcustomplot->heightForWidth(static_cast<int>(param1));
    } else {
        return self->QCustomPlot::heightForWidth(static_cast<int>(param1));
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnHeightForWidth(const QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_HeightForWidth_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_HeightForWidth_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCustomPlot_HasHeightForWidth(const QCustomPlot* self) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->hasHeightForWidth();
    } else {
        return self->QCustomPlot::hasHeightForWidth();
    }
}

// Base class handler implementation
bool QCustomPlot_QBaseHasHeightForWidth(const QCustomPlot* self) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_HasHeightForWidth_IsBase(true);
        return vqcustomplot->hasHeightForWidth();
    } else {
        return self->QCustomPlot::hasHeightForWidth();
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnHasHeightForWidth(const QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_HasHeightForWidth_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_HasHeightForWidth_Callback>(slot));
    }
}

// Derived class handler implementation
QPaintEngine* QCustomPlot_PaintEngine(const QCustomPlot* self) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->paintEngine();
    } else {
        return self->QCustomPlot::paintEngine();
    }
}

// Base class handler implementation
QPaintEngine* QCustomPlot_QBasePaintEngine(const QCustomPlot* self) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_PaintEngine_IsBase(true);
        return vqcustomplot->paintEngine();
    } else {
        return self->QCustomPlot::paintEngine();
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnPaintEngine(const QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_PaintEngine_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_PaintEngine_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCustomPlot_Event(QCustomPlot* self, QEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->event(event);
    } else {
        return ((VirtualQCustomPlot*)self)->event(event);
    }
}

// Base class handler implementation
bool QCustomPlot_QBaseEvent(QCustomPlot* self, QEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_Event_IsBase(true);
        return vqcustomplot->event(event);
    } else {
        return ((VirtualQCustomPlot*)self)->event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_Event_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_Event_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_KeyPressEvent(QCustomPlot* self, QKeyEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->keyPressEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->keyPressEvent(event);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseKeyPressEvent(QCustomPlot* self, QKeyEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_KeyPressEvent_IsBase(true);
        vqcustomplot->keyPressEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->keyPressEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnKeyPressEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_KeyPressEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_KeyPressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_KeyReleaseEvent(QCustomPlot* self, QKeyEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->keyReleaseEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->keyReleaseEvent(event);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseKeyReleaseEvent(QCustomPlot* self, QKeyEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_KeyReleaseEvent_IsBase(true);
        vqcustomplot->keyReleaseEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->keyReleaseEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnKeyReleaseEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_KeyReleaseEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_KeyReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_FocusInEvent(QCustomPlot* self, QFocusEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->focusInEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->focusInEvent(event);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseFocusInEvent(QCustomPlot* self, QFocusEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_FocusInEvent_IsBase(true);
        vqcustomplot->focusInEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->focusInEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnFocusInEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_FocusInEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_FocusInEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_FocusOutEvent(QCustomPlot* self, QFocusEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->focusOutEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->focusOutEvent(event);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseFocusOutEvent(QCustomPlot* self, QFocusEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_FocusOutEvent_IsBase(true);
        vqcustomplot->focusOutEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->focusOutEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnFocusOutEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_FocusOutEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_FocusOutEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_EnterEvent(QCustomPlot* self, QEnterEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->enterEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->enterEvent(event);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseEnterEvent(QCustomPlot* self, QEnterEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_EnterEvent_IsBase(true);
        vqcustomplot->enterEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->enterEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnEnterEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_EnterEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_EnterEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_LeaveEvent(QCustomPlot* self, QEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->leaveEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->leaveEvent(event);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseLeaveEvent(QCustomPlot* self, QEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_LeaveEvent_IsBase(true);
        vqcustomplot->leaveEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->leaveEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnLeaveEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_LeaveEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_LeaveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_MoveEvent(QCustomPlot* self, QMoveEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->moveEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->moveEvent(event);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseMoveEvent(QCustomPlot* self, QMoveEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_MoveEvent_IsBase(true);
        vqcustomplot->moveEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->moveEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnMoveEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_MoveEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_MoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_CloseEvent(QCustomPlot* self, QCloseEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->closeEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->closeEvent(event);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseCloseEvent(QCustomPlot* self, QCloseEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_CloseEvent_IsBase(true);
        vqcustomplot->closeEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->closeEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnCloseEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_CloseEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_CloseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_ContextMenuEvent(QCustomPlot* self, QContextMenuEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->contextMenuEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->contextMenuEvent(event);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseContextMenuEvent(QCustomPlot* self, QContextMenuEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_ContextMenuEvent_IsBase(true);
        vqcustomplot->contextMenuEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->contextMenuEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnContextMenuEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_ContextMenuEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_ContextMenuEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_TabletEvent(QCustomPlot* self, QTabletEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->tabletEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->tabletEvent(event);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseTabletEvent(QCustomPlot* self, QTabletEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_TabletEvent_IsBase(true);
        vqcustomplot->tabletEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->tabletEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnTabletEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_TabletEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_TabletEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_ActionEvent(QCustomPlot* self, QActionEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->actionEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->actionEvent(event);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseActionEvent(QCustomPlot* self, QActionEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_ActionEvent_IsBase(true);
        vqcustomplot->actionEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->actionEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnActionEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_ActionEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_ActionEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_DragEnterEvent(QCustomPlot* self, QDragEnterEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->dragEnterEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->dragEnterEvent(event);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseDragEnterEvent(QCustomPlot* self, QDragEnterEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_DragEnterEvent_IsBase(true);
        vqcustomplot->dragEnterEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->dragEnterEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnDragEnterEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_DragEnterEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_DragEnterEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_DragMoveEvent(QCustomPlot* self, QDragMoveEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->dragMoveEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->dragMoveEvent(event);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseDragMoveEvent(QCustomPlot* self, QDragMoveEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_DragMoveEvent_IsBase(true);
        vqcustomplot->dragMoveEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->dragMoveEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnDragMoveEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_DragMoveEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_DragMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_DragLeaveEvent(QCustomPlot* self, QDragLeaveEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->dragLeaveEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->dragLeaveEvent(event);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseDragLeaveEvent(QCustomPlot* self, QDragLeaveEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_DragLeaveEvent_IsBase(true);
        vqcustomplot->dragLeaveEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->dragLeaveEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnDragLeaveEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_DragLeaveEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_DragLeaveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_DropEvent(QCustomPlot* self, QDropEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->dropEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->dropEvent(event);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseDropEvent(QCustomPlot* self, QDropEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_DropEvent_IsBase(true);
        vqcustomplot->dropEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->dropEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnDropEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_DropEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_DropEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_ShowEvent(QCustomPlot* self, QShowEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->showEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->showEvent(event);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseShowEvent(QCustomPlot* self, QShowEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_ShowEvent_IsBase(true);
        vqcustomplot->showEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->showEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnShowEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_ShowEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_ShowEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_HideEvent(QCustomPlot* self, QHideEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->hideEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->hideEvent(event);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseHideEvent(QCustomPlot* self, QHideEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_HideEvent_IsBase(true);
        vqcustomplot->hideEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->hideEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnHideEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_HideEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_HideEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCustomPlot_NativeEvent(QCustomPlot* self, const libqt_string eventType, void* message, intptr_t* result) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    QByteArray eventType_QByteArray(eventType.data, eventType.len);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->nativeEvent(eventType_QByteArray, message, (qintptr*)(result));
    } else {
        return ((VirtualQCustomPlot*)self)->nativeEvent(eventType_QByteArray, message, (qintptr*)(result));
    }
}

// Base class handler implementation
bool QCustomPlot_QBaseNativeEvent(QCustomPlot* self, const libqt_string eventType, void* message, intptr_t* result) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    QByteArray eventType_QByteArray(eventType.data, eventType.len);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_NativeEvent_IsBase(true);
        return vqcustomplot->nativeEvent(eventType_QByteArray, message, (qintptr*)(result));
    } else {
        return ((VirtualQCustomPlot*)self)->nativeEvent(eventType_QByteArray, message, (qintptr*)(result));
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnNativeEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_NativeEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_NativeEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_ChangeEvent(QCustomPlot* self, QEvent* param1) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->changeEvent(param1);
    } else {
        ((VirtualQCustomPlot*)self)->changeEvent(param1);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseChangeEvent(QCustomPlot* self, QEvent* param1) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_ChangeEvent_IsBase(true);
        vqcustomplot->changeEvent(param1);
    } else {
        ((VirtualQCustomPlot*)self)->changeEvent(param1);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnChangeEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_ChangeEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_ChangeEvent_Callback>(slot));
    }
}

// Derived class handler implementation
int QCustomPlot_Metric(const QCustomPlot* self, int param1) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->metric(static_cast<QPaintDevice::PaintDeviceMetric>(param1));
    } else {
        return ((VirtualQCustomPlot*)self)->metric(static_cast<QPaintDevice::PaintDeviceMetric>(param1));
    }
}

// Base class handler implementation
int QCustomPlot_QBaseMetric(const QCustomPlot* self, int param1) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_Metric_IsBase(true);
        return vqcustomplot->metric(static_cast<QPaintDevice::PaintDeviceMetric>(param1));
    } else {
        return ((VirtualQCustomPlot*)self)->metric(static_cast<QPaintDevice::PaintDeviceMetric>(param1));
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnMetric(const QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_Metric_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_Metric_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_InitPainter(const QCustomPlot* self, QPainter* painter) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->initPainter(painter);
    } else {
        ((VirtualQCustomPlot*)self)->initPainter(painter);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseInitPainter(const QCustomPlot* self, QPainter* painter) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_InitPainter_IsBase(true);
        vqcustomplot->initPainter(painter);
    } else {
        ((VirtualQCustomPlot*)self)->initPainter(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnInitPainter(const QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_InitPainter_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_InitPainter_Callback>(slot));
    }
}

// Derived class handler implementation
QPaintDevice* QCustomPlot_Redirected(const QCustomPlot* self, QPoint* offset) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->redirected(offset);
    } else {
        return ((VirtualQCustomPlot*)self)->redirected(offset);
    }
}

// Base class handler implementation
QPaintDevice* QCustomPlot_QBaseRedirected(const QCustomPlot* self, QPoint* offset) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_Redirected_IsBase(true);
        return vqcustomplot->redirected(offset);
    } else {
        return ((VirtualQCustomPlot*)self)->redirected(offset);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnRedirected(const QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_Redirected_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_Redirected_Callback>(slot));
    }
}

// Derived class handler implementation
QPainter* QCustomPlot_SharedPainter(const QCustomPlot* self) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->sharedPainter();
    } else {
        return ((VirtualQCustomPlot*)self)->sharedPainter();
    }
}

// Base class handler implementation
QPainter* QCustomPlot_QBaseSharedPainter(const QCustomPlot* self) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_SharedPainter_IsBase(true);
        return vqcustomplot->sharedPainter();
    } else {
        return ((VirtualQCustomPlot*)self)->sharedPainter();
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnSharedPainter(const QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_SharedPainter_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_SharedPainter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_InputMethodEvent(QCustomPlot* self, QInputMethodEvent* param1) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->inputMethodEvent(param1);
    } else {
        ((VirtualQCustomPlot*)self)->inputMethodEvent(param1);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseInputMethodEvent(QCustomPlot* self, QInputMethodEvent* param1) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_InputMethodEvent_IsBase(true);
        vqcustomplot->inputMethodEvent(param1);
    } else {
        ((VirtualQCustomPlot*)self)->inputMethodEvent(param1);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnInputMethodEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_InputMethodEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_InputMethodEvent_Callback>(slot));
    }
}

// Derived class handler implementation
QVariant* QCustomPlot_InputMethodQuery(const QCustomPlot* self, int param1) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return new QVariant(vqcustomplot->inputMethodQuery(static_cast<Qt::InputMethodQuery>(param1)));
    } else {
        return new QVariant(((VirtualQCustomPlot*)self)->inputMethodQuery(static_cast<Qt::InputMethodQuery>(param1)));
    }
}

// Base class handler implementation
QVariant* QCustomPlot_QBaseInputMethodQuery(const QCustomPlot* self, int param1) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_InputMethodQuery_IsBase(true);
        return new QVariant(vqcustomplot->inputMethodQuery(static_cast<Qt::InputMethodQuery>(param1)));
    } else {
        return new QVariant(((VirtualQCustomPlot*)self)->inputMethodQuery(static_cast<Qt::InputMethodQuery>(param1)));
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnInputMethodQuery(const QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_InputMethodQuery_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_InputMethodQuery_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCustomPlot_FocusNextPrevChild(QCustomPlot* self, bool next) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->focusNextPrevChild(next);
    } else {
        return ((VirtualQCustomPlot*)self)->focusNextPrevChild(next);
    }
}

// Base class handler implementation
bool QCustomPlot_QBaseFocusNextPrevChild(QCustomPlot* self, bool next) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_FocusNextPrevChild_IsBase(true);
        return vqcustomplot->focusNextPrevChild(next);
    } else {
        return ((VirtualQCustomPlot*)self)->focusNextPrevChild(next);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnFocusNextPrevChild(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_FocusNextPrevChild_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_FocusNextPrevChild_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCustomPlot_EventFilter(QCustomPlot* self, QObject* watched, QEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->eventFilter(watched, event);
    } else {
        return self->QCustomPlot::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCustomPlot_QBaseEventFilter(QCustomPlot* self, QObject* watched, QEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_EventFilter_IsBase(true);
        return vqcustomplot->eventFilter(watched, event);
    } else {
        return self->QCustomPlot::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnEventFilter(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_EventFilter_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_TimerEvent(QCustomPlot* self, QTimerEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->timerEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseTimerEvent(QCustomPlot* self, QTimerEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_TimerEvent_IsBase(true);
        vqcustomplot->timerEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnTimerEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_TimerEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_ChildEvent(QCustomPlot* self, QChildEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->childEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseChildEvent(QCustomPlot* self, QChildEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_ChildEvent_IsBase(true);
        vqcustomplot->childEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnChildEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_ChildEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_CustomEvent(QCustomPlot* self, QEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->customEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseCustomEvent(QCustomPlot* self, QEvent* event) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_CustomEvent_IsBase(true);
        vqcustomplot->customEvent(event);
    } else {
        ((VirtualQCustomPlot*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnCustomEvent(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_CustomEvent_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_ConnectNotify(QCustomPlot* self, const QMetaMethod* signal) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->connectNotify(*signal);
    } else {
        ((VirtualQCustomPlot*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseConnectNotify(QCustomPlot* self, const QMetaMethod* signal) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_ConnectNotify_IsBase(true);
        vqcustomplot->connectNotify(*signal);
    } else {
        ((VirtualQCustomPlot*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnConnectNotify(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_ConnectNotify_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_DisconnectNotify(QCustomPlot* self, const QMetaMethod* signal) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->disconnectNotify(*signal);
    } else {
        ((VirtualQCustomPlot*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseDisconnectNotify(QCustomPlot* self, const QMetaMethod* signal) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_DisconnectNotify_IsBase(true);
        vqcustomplot->disconnectNotify(*signal);
    } else {
        ((VirtualQCustomPlot*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnDisconnectNotify(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_DisconnectNotify_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCustomPlot_RegisterPlottable(QCustomPlot* self, QCPAbstractPlottable* plottable) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->registerPlottable(plottable);
    } else {
        return ((VirtualQCustomPlot*)self)->registerPlottable(plottable);
    }
}

// Base class handler implementation
bool QCustomPlot_QBaseRegisterPlottable(QCustomPlot* self, QCPAbstractPlottable* plottable) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_RegisterPlottable_IsBase(true);
        return vqcustomplot->registerPlottable(plottable);
    } else {
        return ((VirtualQCustomPlot*)self)->registerPlottable(plottable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnRegisterPlottable(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_RegisterPlottable_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_RegisterPlottable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCustomPlot_RegisterGraph(QCustomPlot* self, QCPGraph* graph) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->registerGraph(graph);
    } else {
        return ((VirtualQCustomPlot*)self)->registerGraph(graph);
    }
}

// Base class handler implementation
bool QCustomPlot_QBaseRegisterGraph(QCustomPlot* self, QCPGraph* graph) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_RegisterGraph_IsBase(true);
        return vqcustomplot->registerGraph(graph);
    } else {
        return ((VirtualQCustomPlot*)self)->registerGraph(graph);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnRegisterGraph(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_RegisterGraph_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_RegisterGraph_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCustomPlot_RegisterItem(QCustomPlot* self, QCPAbstractItem* item) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->registerItem(item);
    } else {
        return ((VirtualQCustomPlot*)self)->registerItem(item);
    }
}

// Base class handler implementation
bool QCustomPlot_QBaseRegisterItem(QCustomPlot* self, QCPAbstractItem* item) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_RegisterItem_IsBase(true);
        return vqcustomplot->registerItem(item);
    } else {
        return ((VirtualQCustomPlot*)self)->registerItem(item);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnRegisterItem(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_RegisterItem_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_RegisterItem_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_UpdateLayerIndices(const QCustomPlot* self) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->updateLayerIndices();
    } else {
        ((VirtualQCustomPlot*)self)->updateLayerIndices();
    }
}

// Base class handler implementation
void QCustomPlot_QBaseUpdateLayerIndices(const QCustomPlot* self) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_UpdateLayerIndices_IsBase(true);
        vqcustomplot->updateLayerIndices();
    } else {
        ((VirtualQCustomPlot*)self)->updateLayerIndices();
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnUpdateLayerIndices(const QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_UpdateLayerIndices_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_UpdateLayerIndices_Callback>(slot));
    }
}

// Derived class handler implementation
QCPLayerable* QCustomPlot_LayerableAt(const QCustomPlot* self, const QPointF* pos, bool onlySelectable) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->layerableAt(*pos, onlySelectable);
    } else {
        return ((VirtualQCustomPlot*)self)->layerableAt(*pos, onlySelectable);
    }
}

// Base class handler implementation
QCPLayerable* QCustomPlot_QBaseLayerableAt(const QCustomPlot* self, const QPointF* pos, bool onlySelectable) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_LayerableAt_IsBase(true);
        return vqcustomplot->layerableAt(*pos, onlySelectable);
    } else {
        return ((VirtualQCustomPlot*)self)->layerableAt(*pos, onlySelectable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnLayerableAt(const QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_LayerableAt_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_LayerableAt_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of QCPLayerable* */ QCustomPlot_LayerableListAt(const QCustomPlot* self, const QPointF* pos, bool onlySelectable) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        QList<QCPLayerable*> _ret = vqcustomplot->layerableListAt(*pos, onlySelectable);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayerable** _arr = static_cast<QCPLayerable**>(malloc(sizeof(QCPLayerable*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayerable*> _ret = ((VirtualQCustomPlot*)self)->layerableListAt(*pos, onlySelectable);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayerable** _arr = static_cast<QCPLayerable**>(malloc(sizeof(QCPLayerable*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of QCPLayerable* */ QCustomPlot_QBaseLayerableListAt(const QCustomPlot* self, const QPointF* pos, bool onlySelectable) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_LayerableListAt_IsBase(true);
        QList<QCPLayerable*> _ret = vqcustomplot->layerableListAt(*pos, onlySelectable);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayerable** _arr = static_cast<QCPLayerable**>(malloc(sizeof(QCPLayerable*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayerable*> _ret = ((VirtualQCustomPlot*)self)->layerableListAt(*pos, onlySelectable);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayerable** _arr = static_cast<QCPLayerable**>(malloc(sizeof(QCPLayerable*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnLayerableListAt(const QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_LayerableListAt_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_LayerableListAt_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_DrawBackground(QCustomPlot* self, QCPPainter* painter) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->drawBackground(painter);
    } else {
        ((VirtualQCustomPlot*)self)->drawBackground(painter);
    }
}

// Base class handler implementation
void QCustomPlot_QBaseDrawBackground(QCustomPlot* self, QCPPainter* painter) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_DrawBackground_IsBase(true);
        vqcustomplot->drawBackground(painter);
    } else {
        ((VirtualQCustomPlot*)self)->drawBackground(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnDrawBackground(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_DrawBackground_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_DrawBackground_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_SetupPaintBuffers(QCustomPlot* self) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setupPaintBuffers();
    } else {
        ((VirtualQCustomPlot*)self)->setupPaintBuffers();
    }
}

// Base class handler implementation
void QCustomPlot_QBaseSetupPaintBuffers(QCustomPlot* self) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_SetupPaintBuffers_IsBase(true);
        vqcustomplot->setupPaintBuffers();
    } else {
        ((VirtualQCustomPlot*)self)->setupPaintBuffers();
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnSetupPaintBuffers(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_SetupPaintBuffers_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_SetupPaintBuffers_Callback>(slot));
    }
}

// Derived class handler implementation
QCPAbstractPaintBuffer* QCustomPlot_CreatePaintBuffer(QCustomPlot* self) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->createPaintBuffer();
    } else {
        return ((VirtualQCustomPlot*)self)->createPaintBuffer();
    }
}

// Base class handler implementation
QCPAbstractPaintBuffer* QCustomPlot_QBaseCreatePaintBuffer(QCustomPlot* self) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_CreatePaintBuffer_IsBase(true);
        return vqcustomplot->createPaintBuffer();
    } else {
        return ((VirtualQCustomPlot*)self)->createPaintBuffer();
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnCreatePaintBuffer(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_CreatePaintBuffer_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_CreatePaintBuffer_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCustomPlot_HasInvalidatedPaintBuffers(QCustomPlot* self) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->hasInvalidatedPaintBuffers();
    } else {
        return ((VirtualQCustomPlot*)self)->hasInvalidatedPaintBuffers();
    }
}

// Base class handler implementation
bool QCustomPlot_QBaseHasInvalidatedPaintBuffers(QCustomPlot* self) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_HasInvalidatedPaintBuffers_IsBase(true);
        return vqcustomplot->hasInvalidatedPaintBuffers();
    } else {
        return ((VirtualQCustomPlot*)self)->hasInvalidatedPaintBuffers();
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnHasInvalidatedPaintBuffers(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_HasInvalidatedPaintBuffers_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_HasInvalidatedPaintBuffers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCustomPlot_SetupOpenGl(QCustomPlot* self) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->setupOpenGl();
    } else {
        return ((VirtualQCustomPlot*)self)->setupOpenGl();
    }
}

// Base class handler implementation
bool QCustomPlot_QBaseSetupOpenGl(QCustomPlot* self) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_SetupOpenGl_IsBase(true);
        return vqcustomplot->setupOpenGl();
    } else {
        return ((VirtualQCustomPlot*)self)->setupOpenGl();
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnSetupOpenGl(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_SetupOpenGl_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_SetupOpenGl_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_FreeOpenGl(QCustomPlot* self) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->freeOpenGl();
    } else {
        ((VirtualQCustomPlot*)self)->freeOpenGl();
    }
}

// Base class handler implementation
void QCustomPlot_QBaseFreeOpenGl(QCustomPlot* self) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_FreeOpenGl_IsBase(true);
        vqcustomplot->freeOpenGl();
    } else {
        ((VirtualQCustomPlot*)self)->freeOpenGl();
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnFreeOpenGl(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_FreeOpenGl_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_FreeOpenGl_Callback>(slot));
    }
}

// Derived class handler implementation
QCPLayerable* QCustomPlot_LayerableAt3(const QCustomPlot* self, const QPointF* pos, bool onlySelectable, QVariant* selectionDetails) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->layerableAt(*pos, onlySelectable, selectionDetails);
    } else {
        return ((VirtualQCustomPlot*)self)->layerableAt(*pos, onlySelectable, selectionDetails);
    }
}

// Base class handler implementation
QCPLayerable* QCustomPlot_QBaseLayerableAt3(const QCustomPlot* self, const QPointF* pos, bool onlySelectable, QVariant* selectionDetails) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_LayerableAt3_IsBase(true);
        return vqcustomplot->layerableAt(*pos, onlySelectable, selectionDetails);
    } else {
        return ((VirtualQCustomPlot*)self)->layerableAt(*pos, onlySelectable, selectionDetails);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnLayerableAt3(const QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_LayerableAt3_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_LayerableAt3_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of QCPLayerable* */ QCustomPlot_LayerableListAt3(const QCustomPlot* self, const QPointF* pos, bool onlySelectable, libqt_list /* of QVariant* */ selectionDetails) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    QList<QVariant> selectionDetails_QList;
    selectionDetails_QList.reserve(selectionDetails.len);
    QVariant** selectionDetails_arr = static_cast<QVariant**>(selectionDetails.data);
    for (size_t i = 0; i < selectionDetails.len; ++i) {
        selectionDetails_QList.push_back(*(selectionDetails_arr[i]));
    }
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        QList<QCPLayerable*> _ret = vqcustomplot->layerableListAt(*pos, onlySelectable, &selectionDetails_QList);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayerable** _arr = static_cast<QCPLayerable**>(malloc(sizeof(QCPLayerable*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayerable*> _ret = ((VirtualQCustomPlot*)self)->layerableListAt(*pos, onlySelectable, &selectionDetails_QList);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayerable** _arr = static_cast<QCPLayerable**>(malloc(sizeof(QCPLayerable*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of QCPLayerable* */ QCustomPlot_QBaseLayerableListAt3(const QCustomPlot* self, const QPointF* pos, bool onlySelectable, libqt_list /* of QVariant* */ selectionDetails) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    QList<QVariant> selectionDetails_QList;
    selectionDetails_QList.reserve(selectionDetails.len);
    QVariant** selectionDetails_arr = static_cast<QVariant**>(selectionDetails.data);
    for (size_t i = 0; i < selectionDetails.len; ++i) {
        selectionDetails_QList.push_back(*(selectionDetails_arr[i]));
    }
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_LayerableListAt3_IsBase(true);
        QList<QCPLayerable*> _ret = vqcustomplot->layerableListAt(*pos, onlySelectable, &selectionDetails_QList);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayerable** _arr = static_cast<QCPLayerable**>(malloc(sizeof(QCPLayerable*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayerable*> _ret = ((VirtualQCustomPlot*)self)->layerableListAt(*pos, onlySelectable, &selectionDetails_QList);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayerable** _arr = static_cast<QCPLayerable**>(malloc(sizeof(QCPLayerable*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnLayerableListAt3(const QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_LayerableListAt3_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_LayerableListAt3_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_UpdateMicroFocus(QCustomPlot* self) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->updateMicroFocus();
    } else {
        ((VirtualQCustomPlot*)self)->updateMicroFocus();
    }
}

// Base class handler implementation
void QCustomPlot_QBaseUpdateMicroFocus(QCustomPlot* self) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_UpdateMicroFocus_IsBase(true);
        vqcustomplot->updateMicroFocus();
    } else {
        ((VirtualQCustomPlot*)self)->updateMicroFocus();
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnUpdateMicroFocus(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_UpdateMicroFocus_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_UpdateMicroFocus_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_Create(QCustomPlot* self) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->create();
    } else {
        ((VirtualQCustomPlot*)self)->create();
    }
}

// Base class handler implementation
void QCustomPlot_QBaseCreate(QCustomPlot* self) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_Create_IsBase(true);
        vqcustomplot->create();
    } else {
        ((VirtualQCustomPlot*)self)->create();
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnCreate(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_Create_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_Create_Callback>(slot));
    }
}

// Derived class handler implementation
void QCustomPlot_Destroy(QCustomPlot* self) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->destroy();
    } else {
        ((VirtualQCustomPlot*)self)->destroy();
    }
}

// Base class handler implementation
void QCustomPlot_QBaseDestroy(QCustomPlot* self) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_Destroy_IsBase(true);
        vqcustomplot->destroy();
    } else {
        ((VirtualQCustomPlot*)self)->destroy();
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnDestroy(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_Destroy_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_Destroy_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCustomPlot_FocusNextChild(QCustomPlot* self) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->focusNextChild();
    } else {
        return ((VirtualQCustomPlot*)self)->focusNextChild();
    }
}

// Base class handler implementation
bool QCustomPlot_QBaseFocusNextChild(QCustomPlot* self) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_FocusNextChild_IsBase(true);
        return vqcustomplot->focusNextChild();
    } else {
        return ((VirtualQCustomPlot*)self)->focusNextChild();
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnFocusNextChild(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_FocusNextChild_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_FocusNextChild_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCustomPlot_FocusPreviousChild(QCustomPlot* self) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->focusPreviousChild();
    } else {
        return ((VirtualQCustomPlot*)self)->focusPreviousChild();
    }
}

// Base class handler implementation
bool QCustomPlot_QBaseFocusPreviousChild(QCustomPlot* self) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_FocusPreviousChild_IsBase(true);
        return vqcustomplot->focusPreviousChild();
    } else {
        return ((VirtualQCustomPlot*)self)->focusPreviousChild();
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnFocusPreviousChild(QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = dynamic_cast<VirtualQCustomPlot*>(self);
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_FocusPreviousChild_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_FocusPreviousChild_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCustomPlot_Sender(const QCustomPlot* self) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->sender();
    } else {
        return ((VirtualQCustomPlot*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCustomPlot_QBaseSender(const QCustomPlot* self) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_Sender_IsBase(true);
        return vqcustomplot->sender();
    } else {
        return ((VirtualQCustomPlot*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnSender(const QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_Sender_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCustomPlot_SenderSignalIndex(const QCustomPlot* self) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->senderSignalIndex();
    } else {
        return ((VirtualQCustomPlot*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCustomPlot_QBaseSenderSignalIndex(const QCustomPlot* self) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_SenderSignalIndex_IsBase(true);
        return vqcustomplot->senderSignalIndex();
    } else {
        return ((VirtualQCustomPlot*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnSenderSignalIndex(const QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCustomPlot_Receivers(const QCustomPlot* self, const char* signal) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->receivers(signal);
    } else {
        return ((VirtualQCustomPlot*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCustomPlot_QBaseReceivers(const QCustomPlot* self, const char* signal) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_Receivers_IsBase(true);
        return vqcustomplot->receivers(signal);
    } else {
        return ((VirtualQCustomPlot*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnReceivers(const QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_Receivers_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCustomPlot_IsSignalConnected(const QCustomPlot* self, const QMetaMethod* signal) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->isSignalConnected(*signal);
    } else {
        return ((VirtualQCustomPlot*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCustomPlot_QBaseIsSignalConnected(const QCustomPlot* self, const QMetaMethod* signal) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_IsSignalConnected_IsBase(true);
        return vqcustomplot->isSignalConnected(*signal);
    } else {
        return ((VirtualQCustomPlot*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnIsSignalConnected(const QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_IsSignalConnected_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_IsSignalConnected_Callback>(slot));
    }
}

// Derived class handler implementation
double QCustomPlot_GetDecodedMetricF(const QCustomPlot* self, int metricA, int metricB) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        return vqcustomplot->getDecodedMetricF(static_cast<QPaintDevice::PaintDeviceMetric>(metricA), static_cast<QPaintDevice::PaintDeviceMetric>(metricB));
    } else {
        return ((VirtualQCustomPlot*)self)->getDecodedMetricF(static_cast<QPaintDevice::PaintDeviceMetric>(metricA), static_cast<QPaintDevice::PaintDeviceMetric>(metricB));
    }
}

// Base class handler implementation
double QCustomPlot_QBaseGetDecodedMetricF(const QCustomPlot* self, int metricA, int metricB) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_GetDecodedMetricF_IsBase(true);
        return vqcustomplot->getDecodedMetricF(static_cast<QPaintDevice::PaintDeviceMetric>(metricA), static_cast<QPaintDevice::PaintDeviceMetric>(metricB));
    } else {
        return ((VirtualQCustomPlot*)self)->getDecodedMetricF(static_cast<QPaintDevice::PaintDeviceMetric>(metricA), static_cast<QPaintDevice::PaintDeviceMetric>(metricB));
    }
}

// Auxiliary method to allow providing re-implementation
void QCustomPlot_OnGetDecodedMetricF(const QCustomPlot* self, intptr_t slot) {
    auto* vqcustomplot = const_cast<VirtualQCustomPlot*>(dynamic_cast<const VirtualQCustomPlot*>(self));
    if (vqcustomplot && vqcustomplot->isVirtualQCustomPlot) {
        vqcustomplot->setQCustomPlot_GetDecodedMetricF_Callback(reinterpret_cast<VirtualQCustomPlot::QCustomPlot_GetDecodedMetricF_Callback>(slot));
    }
}

void QCustomPlot_Delete(QCustomPlot* self) {
    delete self;
}

int QCPPlottableInterface1D_DataCount(const QCPPlottableInterface1D* self) {
    return self->dataCount();
}

double QCPPlottableInterface1D_DataMainKey(const QCPPlottableInterface1D* self, int index) {
    return self->dataMainKey(static_cast<int>(index));
}

double QCPPlottableInterface1D_DataSortKey(const QCPPlottableInterface1D* self, int index) {
    return self->dataSortKey(static_cast<int>(index));
}

double QCPPlottableInterface1D_DataMainValue(const QCPPlottableInterface1D* self, int index) {
    return self->dataMainValue(static_cast<int>(index));
}

QCPRange* QCPPlottableInterface1D_DataValueRange(const QCPPlottableInterface1D* self, int index) {
    return new QCPRange(self->dataValueRange(static_cast<int>(index)));
}

QPointF* QCPPlottableInterface1D_DataPixelPosition(const QCPPlottableInterface1D* self, int index) {
    return new QPointF(self->dataPixelPosition(static_cast<int>(index)));
}

bool QCPPlottableInterface1D_SortKeyIsMainKey(const QCPPlottableInterface1D* self) {
    return self->sortKeyIsMainKey();
}

QCPDataSelection* QCPPlottableInterface1D_SelectTestRect(const QCPPlottableInterface1D* self, const QRectF* rect, bool onlySelectable) {
    return new QCPDataSelection(self->selectTestRect(*rect, onlySelectable));
}

int QCPPlottableInterface1D_FindBegin(const QCPPlottableInterface1D* self, double sortKey, bool expandedRange) {
    return self->findBegin(static_cast<double>(sortKey), expandedRange);
}

int QCPPlottableInterface1D_FindEnd(const QCPPlottableInterface1D* self, double sortKey, bool expandedRange) {
    return self->findEnd(static_cast<double>(sortKey), expandedRange);
}

void QCPPlottableInterface1D_OperatorAssign(QCPPlottableInterface1D* self, const QCPPlottableInterface1D* param1) {
    self->operator=(*param1);
}

void QCPPlottableInterface1D_Delete(QCPPlottableInterface1D* self) {
    delete self;
}

QCPColorGradient* QCPColorGradient_new() {
    return new QCPColorGradient();
}

QCPColorGradient* QCPColorGradient_new2(int preset) {
    return new QCPColorGradient(static_cast<QCPColorGradient::GradientPreset>(preset));
}

QCPColorGradient* QCPColorGradient_new3(const QCPColorGradient* param1) {
    return new QCPColorGradient(*param1);
}

bool QCPColorGradient_OperatorEqual(const QCPColorGradient* self, const QCPColorGradient* other) {
    return (*self == *other);
}

bool QCPColorGradient_OperatorNotEqual(const QCPColorGradient* self, const QCPColorGradient* other) {
    return (*self != *other);
}

int QCPColorGradient_LevelCount(const QCPColorGradient* self) {
    return self->levelCount();
}

libqt_map /* of double to QColor* */ QCPColorGradient_ColorStops(const QCPColorGradient* self) {
    QMap<double, QColor> _ret = self->colorStops();
    // Convert QMap<> from C++ memory to manually-managed C memory
    double* _karr = static_cast<double*>(malloc(sizeof(double) * _ret.size()));
    QColor** _varr = static_cast<QColor**>(malloc(sizeof(QColor*) * _ret.size()));
    int _ctr = 0;
    for (auto _itr = _ret.keyValueBegin(); _itr != _ret.keyValueEnd(); ++_itr) {
        _karr[_ctr] = _itr->first;
        _varr[_ctr] = new QColor(_itr->second);
        _ctr++;
    }
    libqt_map _out;
    _out.len = _ret.size();
    _out.keys = static_cast<void*>(_karr);
    _out.values = static_cast<void*>(_varr);
    return _out;
}

int QCPColorGradient_ColorInterpolation(const QCPColorGradient* self) {
    return static_cast<int>(self->colorInterpolation());
}

int QCPColorGradient_NanHandling(const QCPColorGradient* self) {
    return static_cast<int>(self->nanHandling());
}

QColor* QCPColorGradient_NanColor(const QCPColorGradient* self) {
    return new QColor(self->nanColor());
}

bool QCPColorGradient_Periodic(const QCPColorGradient* self) {
    return self->periodic();
}

void QCPColorGradient_SetLevelCount(QCPColorGradient* self, int n) {
    self->setLevelCount(static_cast<int>(n));
}

void QCPColorGradient_SetColorStops(QCPColorGradient* self, const libqt_map /* of double to QColor* */ colorStops) {
    QMap<double, QColor> colorStops_QMap;
    double* colorStops_karr = static_cast<double*>(colorStops.keys);
    QColor** colorStops_varr = static_cast<QColor**>(colorStops.values);
    for (size_t i = 0; i < colorStops.len; ++i) {
        colorStops_QMap[static_cast<double>(colorStops_karr[i])] = *(colorStops_varr[i]);
    }
    self->setColorStops(colorStops_QMap);
}

void QCPColorGradient_SetColorStopAt(QCPColorGradient* self, double position, const QColor* color) {
    self->setColorStopAt(static_cast<double>(position), *color);
}

void QCPColorGradient_SetColorInterpolation(QCPColorGradient* self, int interpolation) {
    self->setColorInterpolation(static_cast<QCPColorGradient::ColorInterpolation>(interpolation));
}

void QCPColorGradient_SetNanHandling(QCPColorGradient* self, int handling) {
    self->setNanHandling(static_cast<QCPColorGradient::NanHandling>(handling));
}

void QCPColorGradient_SetNanColor(QCPColorGradient* self, const QColor* color) {
    self->setNanColor(*color);
}

void QCPColorGradient_SetPeriodic(QCPColorGradient* self, bool enabled) {
    self->setPeriodic(enabled);
}

void QCPColorGradient_Colorize(QCPColorGradient* self, const double* data, const QCPRange* range, unsigned int* scanLine, int n) {
    self->colorize(static_cast<const double*>(data), *range, static_cast<QRgb*>(scanLine), static_cast<int>(n));
}

void QCPColorGradient_Colorize2(QCPColorGradient* self, const double* data, const unsigned char* alpha, const QCPRange* range, unsigned int* scanLine, int n) {
    self->colorize(static_cast<const double*>(data), static_cast<const unsigned char*>(alpha), *range, static_cast<QRgb*>(scanLine), static_cast<int>(n));
}

unsigned int QCPColorGradient_Color(QCPColorGradient* self, double position, const QCPRange* range) {
    return static_cast<unsigned int>(self->color(static_cast<double>(position), *range));
}

void QCPColorGradient_LoadPreset(QCPColorGradient* self, int preset) {
    self->loadPreset(static_cast<QCPColorGradient::GradientPreset>(preset));
}

void QCPColorGradient_ClearColorStops(QCPColorGradient* self) {
    self->clearColorStops();
}

QCPColorGradient* QCPColorGradient_Inverted(const QCPColorGradient* self) {
    return new QCPColorGradient(self->inverted());
}

void QCPColorGradient_Colorize5(QCPColorGradient* self, const double* data, const QCPRange* range, unsigned int* scanLine, int n, int dataIndexFactor) {
    self->colorize(static_cast<const double*>(data), *range, static_cast<QRgb*>(scanLine), static_cast<int>(n), static_cast<int>(dataIndexFactor));
}

void QCPColorGradient_Colorize6(QCPColorGradient* self, const double* data, const QCPRange* range, unsigned int* scanLine, int n, int dataIndexFactor, bool logarithmic) {
    self->colorize(static_cast<const double*>(data), *range, static_cast<QRgb*>(scanLine), static_cast<int>(n), static_cast<int>(dataIndexFactor), logarithmic);
}

void QCPColorGradient_Colorize62(QCPColorGradient* self, const double* data, const unsigned char* alpha, const QCPRange* range, unsigned int* scanLine, int n, int dataIndexFactor) {
    self->colorize(static_cast<const double*>(data), static_cast<const unsigned char*>(alpha), *range, static_cast<QRgb*>(scanLine), static_cast<int>(n), static_cast<int>(dataIndexFactor));
}

void QCPColorGradient_Colorize7(QCPColorGradient* self, const double* data, const unsigned char* alpha, const QCPRange* range, unsigned int* scanLine, int n, int dataIndexFactor, bool logarithmic) {
    self->colorize(static_cast<const double*>(data), static_cast<const unsigned char*>(alpha), *range, static_cast<QRgb*>(scanLine), static_cast<int>(n), static_cast<int>(dataIndexFactor), logarithmic);
}

unsigned int QCPColorGradient_Color3(QCPColorGradient* self, double position, const QCPRange* range, bool logarithmic) {
    return static_cast<unsigned int>(self->color(static_cast<double>(position), *range, logarithmic));
}

void QCPColorGradient_Delete(QCPColorGradient* self) {
    delete self;
}

QCPSelectionDecoratorBracket* QCPSelectionDecoratorBracket_new() {
    return new VirtualQCPSelectionDecoratorBracket();
}

QPen* QCPSelectionDecoratorBracket_BracketPen(const QCPSelectionDecoratorBracket* self) {
    return new QPen(self->bracketPen());
}

QBrush* QCPSelectionDecoratorBracket_BracketBrush(const QCPSelectionDecoratorBracket* self) {
    return new QBrush(self->bracketBrush());
}

int QCPSelectionDecoratorBracket_BracketWidth(const QCPSelectionDecoratorBracket* self) {
    return self->bracketWidth();
}

int QCPSelectionDecoratorBracket_BracketHeight(const QCPSelectionDecoratorBracket* self) {
    return self->bracketHeight();
}

int QCPSelectionDecoratorBracket_BracketStyle(const QCPSelectionDecoratorBracket* self) {
    return static_cast<int>(self->bracketStyle());
}

bool QCPSelectionDecoratorBracket_TangentToData(const QCPSelectionDecoratorBracket* self) {
    return self->tangentToData();
}

int QCPSelectionDecoratorBracket_TangentAverage(const QCPSelectionDecoratorBracket* self) {
    return self->tangentAverage();
}

void QCPSelectionDecoratorBracket_SetBracketPen(QCPSelectionDecoratorBracket* self, const QPen* pen) {
    self->setBracketPen(*pen);
}

void QCPSelectionDecoratorBracket_SetBracketBrush(QCPSelectionDecoratorBracket* self, const QBrush* brush) {
    self->setBracketBrush(*brush);
}

void QCPSelectionDecoratorBracket_SetBracketWidth(QCPSelectionDecoratorBracket* self, int width) {
    self->setBracketWidth(static_cast<int>(width));
}

void QCPSelectionDecoratorBracket_SetBracketHeight(QCPSelectionDecoratorBracket* self, int height) {
    self->setBracketHeight(static_cast<int>(height));
}

void QCPSelectionDecoratorBracket_SetBracketStyle(QCPSelectionDecoratorBracket* self, int style) {
    self->setBracketStyle(static_cast<QCPSelectionDecoratorBracket::BracketStyle>(style));
}

void QCPSelectionDecoratorBracket_SetTangentToData(QCPSelectionDecoratorBracket* self, bool enabled) {
    self->setTangentToData(enabled);
}

void QCPSelectionDecoratorBracket_SetTangentAverage(QCPSelectionDecoratorBracket* self, int pointCount) {
    self->setTangentAverage(static_cast<int>(pointCount));
}

void QCPSelectionDecoratorBracket_DrawBracket(const QCPSelectionDecoratorBracket* self, QCPPainter* painter, int direction) {
    auto* vqcpselectiondecoratorbracket = dynamic_cast<const VirtualQCPSelectionDecoratorBracket*>(self);
    if (vqcpselectiondecoratorbracket && vqcpselectiondecoratorbracket->isVirtualQCPSelectionDecoratorBracket) {
        self->drawBracket(painter, static_cast<int>(direction));
    } else {
        ((VirtualQCPSelectionDecoratorBracket*)self)->drawBracket(painter, static_cast<int>(direction));
    }
}

void QCPSelectionDecoratorBracket_DrawDecoration(QCPSelectionDecoratorBracket* self, QCPPainter* painter, QCPDataSelection* selection) {
    auto* vqcpselectiondecoratorbracket = dynamic_cast<VirtualQCPSelectionDecoratorBracket*>(self);
    if (vqcpselectiondecoratorbracket && vqcpselectiondecoratorbracket->isVirtualQCPSelectionDecoratorBracket) {
        self->drawDecoration(painter, *selection);
    } else {
        ((VirtualQCPSelectionDecoratorBracket*)self)->drawDecoration(painter, *selection);
    }
}

// Base class handler implementation
void QCPSelectionDecoratorBracket_QBaseDrawBracket(const QCPSelectionDecoratorBracket* self, QCPPainter* painter, int direction) {
    auto* vqcpselectiondecoratorbracket = const_cast<VirtualQCPSelectionDecoratorBracket*>(dynamic_cast<const VirtualQCPSelectionDecoratorBracket*>(self));
    if (vqcpselectiondecoratorbracket && vqcpselectiondecoratorbracket->isVirtualQCPSelectionDecoratorBracket) {
        vqcpselectiondecoratorbracket->setQCPSelectionDecoratorBracket_DrawBracket_IsBase(true);
        vqcpselectiondecoratorbracket->drawBracket(painter, static_cast<int>(direction));
    } else {
        self->QCPSelectionDecoratorBracket::drawBracket(painter, static_cast<int>(direction));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionDecoratorBracket_OnDrawBracket(const QCPSelectionDecoratorBracket* self, intptr_t slot) {
    auto* vqcpselectiondecoratorbracket = const_cast<VirtualQCPSelectionDecoratorBracket*>(dynamic_cast<const VirtualQCPSelectionDecoratorBracket*>(self));
    if (vqcpselectiondecoratorbracket && vqcpselectiondecoratorbracket->isVirtualQCPSelectionDecoratorBracket) {
        vqcpselectiondecoratorbracket->setQCPSelectionDecoratorBracket_DrawBracket_Callback(reinterpret_cast<VirtualQCPSelectionDecoratorBracket::QCPSelectionDecoratorBracket_DrawBracket_Callback>(slot));
    }
}

// Base class handler implementation
void QCPSelectionDecoratorBracket_QBaseDrawDecoration(QCPSelectionDecoratorBracket* self, QCPPainter* painter, QCPDataSelection* selection) {
    auto* vqcpselectiondecoratorbracket = dynamic_cast<VirtualQCPSelectionDecoratorBracket*>(self);
    if (vqcpselectiondecoratorbracket && vqcpselectiondecoratorbracket->isVirtualQCPSelectionDecoratorBracket) {
        vqcpselectiondecoratorbracket->setQCPSelectionDecoratorBracket_DrawDecoration_IsBase(true);
        vqcpselectiondecoratorbracket->drawDecoration(painter, *selection);
    } else {
        self->QCPSelectionDecoratorBracket::drawDecoration(painter, *selection);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionDecoratorBracket_OnDrawDecoration(QCPSelectionDecoratorBracket* self, intptr_t slot) {
    auto* vqcpselectiondecoratorbracket = dynamic_cast<VirtualQCPSelectionDecoratorBracket*>(self);
    if (vqcpselectiondecoratorbracket && vqcpselectiondecoratorbracket->isVirtualQCPSelectionDecoratorBracket) {
        vqcpselectiondecoratorbracket->setQCPSelectionDecoratorBracket_DrawDecoration_Callback(reinterpret_cast<VirtualQCPSelectionDecoratorBracket::QCPSelectionDecoratorBracket_DrawDecoration_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPSelectionDecoratorBracket_CopyFrom(QCPSelectionDecoratorBracket* self, const QCPSelectionDecorator* other) {
    auto* vqcpselectiondecoratorbracket = dynamic_cast<VirtualQCPSelectionDecoratorBracket*>(self);
    if (vqcpselectiondecoratorbracket && vqcpselectiondecoratorbracket->isVirtualQCPSelectionDecoratorBracket) {
        vqcpselectiondecoratorbracket->copyFrom(other);
    } else {
        self->QCPSelectionDecoratorBracket::copyFrom(other);
    }
}

// Base class handler implementation
void QCPSelectionDecoratorBracket_QBaseCopyFrom(QCPSelectionDecoratorBracket* self, const QCPSelectionDecorator* other) {
    auto* vqcpselectiondecoratorbracket = dynamic_cast<VirtualQCPSelectionDecoratorBracket*>(self);
    if (vqcpselectiondecoratorbracket && vqcpselectiondecoratorbracket->isVirtualQCPSelectionDecoratorBracket) {
        vqcpselectiondecoratorbracket->setQCPSelectionDecoratorBracket_CopyFrom_IsBase(true);
        vqcpselectiondecoratorbracket->copyFrom(other);
    } else {
        self->QCPSelectionDecoratorBracket::copyFrom(other);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionDecoratorBracket_OnCopyFrom(QCPSelectionDecoratorBracket* self, intptr_t slot) {
    auto* vqcpselectiondecoratorbracket = dynamic_cast<VirtualQCPSelectionDecoratorBracket*>(self);
    if (vqcpselectiondecoratorbracket && vqcpselectiondecoratorbracket->isVirtualQCPSelectionDecoratorBracket) {
        vqcpselectiondecoratorbracket->setQCPSelectionDecoratorBracket_CopyFrom_Callback(reinterpret_cast<VirtualQCPSelectionDecoratorBracket::QCPSelectionDecoratorBracket_CopyFrom_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPSelectionDecoratorBracket_RegisterWithPlottable(QCPSelectionDecoratorBracket* self, QCPAbstractPlottable* plottable) {
    auto* vqcpselectiondecoratorbracket = dynamic_cast<VirtualQCPSelectionDecoratorBracket*>(self);
    if (vqcpselectiondecoratorbracket && vqcpselectiondecoratorbracket->isVirtualQCPSelectionDecoratorBracket) {
        return vqcpselectiondecoratorbracket->registerWithPlottable(plottable);
    } else {
        return ((VirtualQCPSelectionDecoratorBracket*)self)->registerWithPlottable(plottable);
    }
}

// Base class handler implementation
bool QCPSelectionDecoratorBracket_QBaseRegisterWithPlottable(QCPSelectionDecoratorBracket* self, QCPAbstractPlottable* plottable) {
    auto* vqcpselectiondecoratorbracket = dynamic_cast<VirtualQCPSelectionDecoratorBracket*>(self);
    if (vqcpselectiondecoratorbracket && vqcpselectiondecoratorbracket->isVirtualQCPSelectionDecoratorBracket) {
        vqcpselectiondecoratorbracket->setQCPSelectionDecoratorBracket_RegisterWithPlottable_IsBase(true);
        return vqcpselectiondecoratorbracket->registerWithPlottable(plottable);
    } else {
        return ((VirtualQCPSelectionDecoratorBracket*)self)->registerWithPlottable(plottable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionDecoratorBracket_OnRegisterWithPlottable(QCPSelectionDecoratorBracket* self, intptr_t slot) {
    auto* vqcpselectiondecoratorbracket = dynamic_cast<VirtualQCPSelectionDecoratorBracket*>(self);
    if (vqcpselectiondecoratorbracket && vqcpselectiondecoratorbracket->isVirtualQCPSelectionDecoratorBracket) {
        vqcpselectiondecoratorbracket->setQCPSelectionDecoratorBracket_RegisterWithPlottable_Callback(reinterpret_cast<VirtualQCPSelectionDecoratorBracket::QCPSelectionDecoratorBracket_RegisterWithPlottable_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPSelectionDecoratorBracket_GetTangentAngle(const QCPSelectionDecoratorBracket* self, const QCPPlottableInterface1D* interface1d, int dataIndex, int direction) {
    auto* vqcpselectiondecoratorbracket = const_cast<VirtualQCPSelectionDecoratorBracket*>(dynamic_cast<const VirtualQCPSelectionDecoratorBracket*>(self));
    if (vqcpselectiondecoratorbracket && vqcpselectiondecoratorbracket->isVirtualQCPSelectionDecoratorBracket) {
        return vqcpselectiondecoratorbracket->getTangentAngle(interface1d, static_cast<int>(dataIndex), static_cast<int>(direction));
    } else {
        return ((VirtualQCPSelectionDecoratorBracket*)self)->getTangentAngle(interface1d, static_cast<int>(dataIndex), static_cast<int>(direction));
    }
}

// Base class handler implementation
double QCPSelectionDecoratorBracket_QBaseGetTangentAngle(const QCPSelectionDecoratorBracket* self, const QCPPlottableInterface1D* interface1d, int dataIndex, int direction) {
    auto* vqcpselectiondecoratorbracket = const_cast<VirtualQCPSelectionDecoratorBracket*>(dynamic_cast<const VirtualQCPSelectionDecoratorBracket*>(self));
    if (vqcpselectiondecoratorbracket && vqcpselectiondecoratorbracket->isVirtualQCPSelectionDecoratorBracket) {
        vqcpselectiondecoratorbracket->setQCPSelectionDecoratorBracket_GetTangentAngle_IsBase(true);
        return vqcpselectiondecoratorbracket->getTangentAngle(interface1d, static_cast<int>(dataIndex), static_cast<int>(direction));
    } else {
        return ((VirtualQCPSelectionDecoratorBracket*)self)->getTangentAngle(interface1d, static_cast<int>(dataIndex), static_cast<int>(direction));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionDecoratorBracket_OnGetTangentAngle(const QCPSelectionDecoratorBracket* self, intptr_t slot) {
    auto* vqcpselectiondecoratorbracket = const_cast<VirtualQCPSelectionDecoratorBracket*>(dynamic_cast<const VirtualQCPSelectionDecoratorBracket*>(self));
    if (vqcpselectiondecoratorbracket && vqcpselectiondecoratorbracket->isVirtualQCPSelectionDecoratorBracket) {
        vqcpselectiondecoratorbracket->setQCPSelectionDecoratorBracket_GetTangentAngle_Callback(reinterpret_cast<VirtualQCPSelectionDecoratorBracket::QCPSelectionDecoratorBracket_GetTangentAngle_Callback>(slot));
    }
}

// Derived class handler implementation
QPointF* QCPSelectionDecoratorBracket_GetPixelCoordinates(const QCPSelectionDecoratorBracket* self, const QCPPlottableInterface1D* interface1d, int dataIndex) {
    auto* vqcpselectiondecoratorbracket = const_cast<VirtualQCPSelectionDecoratorBracket*>(dynamic_cast<const VirtualQCPSelectionDecoratorBracket*>(self));
    if (vqcpselectiondecoratorbracket && vqcpselectiondecoratorbracket->isVirtualQCPSelectionDecoratorBracket) {
        return new QPointF(vqcpselectiondecoratorbracket->getPixelCoordinates(interface1d, static_cast<int>(dataIndex)));
    }
    return {};
}

// Base class handler implementation
QPointF* QCPSelectionDecoratorBracket_QBaseGetPixelCoordinates(const QCPSelectionDecoratorBracket* self, const QCPPlottableInterface1D* interface1d, int dataIndex) {
    auto* vqcpselectiondecoratorbracket = const_cast<VirtualQCPSelectionDecoratorBracket*>(dynamic_cast<const VirtualQCPSelectionDecoratorBracket*>(self));
    if (vqcpselectiondecoratorbracket && vqcpselectiondecoratorbracket->isVirtualQCPSelectionDecoratorBracket) {
        vqcpselectiondecoratorbracket->setQCPSelectionDecoratorBracket_GetPixelCoordinates_IsBase(true);
        return new QPointF(vqcpselectiondecoratorbracket->getPixelCoordinates(interface1d, static_cast<int>(dataIndex)));
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPSelectionDecoratorBracket_OnGetPixelCoordinates(const QCPSelectionDecoratorBracket* self, intptr_t slot) {
    auto* vqcpselectiondecoratorbracket = const_cast<VirtualQCPSelectionDecoratorBracket*>(dynamic_cast<const VirtualQCPSelectionDecoratorBracket*>(self));
    if (vqcpselectiondecoratorbracket && vqcpselectiondecoratorbracket->isVirtualQCPSelectionDecoratorBracket) {
        vqcpselectiondecoratorbracket->setQCPSelectionDecoratorBracket_GetPixelCoordinates_Callback(reinterpret_cast<VirtualQCPSelectionDecoratorBracket::QCPSelectionDecoratorBracket_GetPixelCoordinates_Callback>(slot));
    }
}

void QCPSelectionDecoratorBracket_Delete(QCPSelectionDecoratorBracket* self) {
    delete self;
}

QCPAxisRect* QCPAxisRect_new(QCustomPlot* parentPlot) {
    return new VirtualQCPAxisRect(parentPlot);
}

QCPAxisRect* QCPAxisRect_new2(QCustomPlot* parentPlot, bool setupDefaultAxes) {
    return new VirtualQCPAxisRect(parentPlot, setupDefaultAxes);
}

QMetaObject* QCPAxisRect_MetaObject(const QCPAxisRect* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPAxisRect_Metacast(QCPAxisRect* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPAxisRect_Metacall(QCPAxisRect* self, int param1, int param2, void** param3) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPAxisRect*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPAxisRect_Tr(const char* s) {
    QString _ret = QCPAxisRect::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

QPixmap* QCPAxisRect_Background(const QCPAxisRect* self) {
    return new QPixmap(self->background());
}

QBrush* QCPAxisRect_BackgroundBrush(const QCPAxisRect* self) {
    return new QBrush(self->backgroundBrush());
}

bool QCPAxisRect_BackgroundScaled(const QCPAxisRect* self) {
    return self->backgroundScaled();
}

int QCPAxisRect_BackgroundScaledMode(const QCPAxisRect* self) {
    return static_cast<int>(self->backgroundScaledMode());
}

int QCPAxisRect_RangeDrag(const QCPAxisRect* self) {
    return static_cast<int>(self->rangeDrag());
}

int QCPAxisRect_RangeZoom(const QCPAxisRect* self) {
    return static_cast<int>(self->rangeZoom());
}

QCPAxis* QCPAxisRect_RangeDragAxis(QCPAxisRect* self, int orientation) {
    return self->rangeDragAxis(static_cast<Qt::Orientation>(orientation));
}

QCPAxis* QCPAxisRect_RangeZoomAxis(QCPAxisRect* self, int orientation) {
    return self->rangeZoomAxis(static_cast<Qt::Orientation>(orientation));
}

libqt_list /* of QCPAxis* */ QCPAxisRect_RangeDragAxes(QCPAxisRect* self, int orientation) {
    QList<QCPAxis*> _ret = self->rangeDragAxes(static_cast<Qt::Orientation>(orientation));
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPAxis** _arr = static_cast<QCPAxis**>(malloc(sizeof(QCPAxis*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

libqt_list /* of QCPAxis* */ QCPAxisRect_RangeZoomAxes(QCPAxisRect* self, int orientation) {
    QList<QCPAxis*> _ret = self->rangeZoomAxes(static_cast<Qt::Orientation>(orientation));
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPAxis** _arr = static_cast<QCPAxis**>(malloc(sizeof(QCPAxis*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

double QCPAxisRect_RangeZoomFactor(QCPAxisRect* self, int orientation) {
    return self->rangeZoomFactor(static_cast<Qt::Orientation>(orientation));
}

void QCPAxisRect_SetBackground(QCPAxisRect* self, const QPixmap* pm) {
    self->setBackground(*pm);
}

void QCPAxisRect_SetBackground2(QCPAxisRect* self, const QPixmap* pm, bool scaled) {
    self->setBackground(*pm, scaled);
}

void QCPAxisRect_SetBackground3(QCPAxisRect* self, const QBrush* brush) {
    self->setBackground(*brush);
}

void QCPAxisRect_SetBackgroundScaled(QCPAxisRect* self, bool scaled) {
    self->setBackgroundScaled(scaled);
}

void QCPAxisRect_SetBackgroundScaledMode(QCPAxisRect* self, int mode) {
    self->setBackgroundScaledMode(static_cast<Qt::AspectRatioMode>(mode));
}

void QCPAxisRect_SetRangeDrag(QCPAxisRect* self, int orientations) {
    self->setRangeDrag(static_cast<Qt::Orientations>(orientations));
}

void QCPAxisRect_SetRangeZoom(QCPAxisRect* self, int orientations) {
    self->setRangeZoom(static_cast<Qt::Orientations>(orientations));
}

void QCPAxisRect_SetRangeDragAxes(QCPAxisRect* self, QCPAxis* horizontal, QCPAxis* vertical) {
    self->setRangeDragAxes(horizontal, vertical);
}

void QCPAxisRect_SetRangeDragAxes2(QCPAxisRect* self, libqt_list /* of QCPAxis* */ axes) {
    QList<QCPAxis*> axes_QList;
    axes_QList.reserve(axes.len);
    QCPAxis** axes_arr = static_cast<QCPAxis**>(axes.data);
    for (size_t i = 0; i < axes.len; ++i) {
        axes_QList.push_back(axes_arr[i]);
    }
    self->setRangeDragAxes(axes_QList);
}

void QCPAxisRect_SetRangeDragAxes3(QCPAxisRect* self, libqt_list /* of QCPAxis* */ horizontal, libqt_list /* of QCPAxis* */ vertical) {
    QList<QCPAxis*> horizontal_QList;
    horizontal_QList.reserve(horizontal.len);
    QCPAxis** horizontal_arr = static_cast<QCPAxis**>(horizontal.data);
    for (size_t i = 0; i < horizontal.len; ++i) {
        horizontal_QList.push_back(horizontal_arr[i]);
    }
    QList<QCPAxis*> vertical_QList;
    vertical_QList.reserve(vertical.len);
    QCPAxis** vertical_arr = static_cast<QCPAxis**>(vertical.data);
    for (size_t i = 0; i < vertical.len; ++i) {
        vertical_QList.push_back(vertical_arr[i]);
    }
    self->setRangeDragAxes(horizontal_QList, vertical_QList);
}

void QCPAxisRect_SetRangeZoomAxes(QCPAxisRect* self, QCPAxis* horizontal, QCPAxis* vertical) {
    self->setRangeZoomAxes(horizontal, vertical);
}

void QCPAxisRect_SetRangeZoomAxes2(QCPAxisRect* self, libqt_list /* of QCPAxis* */ axes) {
    QList<QCPAxis*> axes_QList;
    axes_QList.reserve(axes.len);
    QCPAxis** axes_arr = static_cast<QCPAxis**>(axes.data);
    for (size_t i = 0; i < axes.len; ++i) {
        axes_QList.push_back(axes_arr[i]);
    }
    self->setRangeZoomAxes(axes_QList);
}

void QCPAxisRect_SetRangeZoomAxes3(QCPAxisRect* self, libqt_list /* of QCPAxis* */ horizontal, libqt_list /* of QCPAxis* */ vertical) {
    QList<QCPAxis*> horizontal_QList;
    horizontal_QList.reserve(horizontal.len);
    QCPAxis** horizontal_arr = static_cast<QCPAxis**>(horizontal.data);
    for (size_t i = 0; i < horizontal.len; ++i) {
        horizontal_QList.push_back(horizontal_arr[i]);
    }
    QList<QCPAxis*> vertical_QList;
    vertical_QList.reserve(vertical.len);
    QCPAxis** vertical_arr = static_cast<QCPAxis**>(vertical.data);
    for (size_t i = 0; i < vertical.len; ++i) {
        vertical_QList.push_back(vertical_arr[i]);
    }
    self->setRangeZoomAxes(horizontal_QList, vertical_QList);
}

void QCPAxisRect_SetRangeZoomFactor(QCPAxisRect* self, double horizontalFactor, double verticalFactor) {
    self->setRangeZoomFactor(static_cast<double>(horizontalFactor), static_cast<double>(verticalFactor));
}

void QCPAxisRect_SetRangeZoomFactor2(QCPAxisRect* self, double factor) {
    self->setRangeZoomFactor(static_cast<double>(factor));
}

int QCPAxisRect_AxisCount(const QCPAxisRect* self, int typeVal) {
    return self->axisCount(static_cast<QCPAxis::AxisType>(typeVal));
}

QCPAxis* QCPAxisRect_Axis(const QCPAxisRect* self, int typeVal) {
    return self->axis(static_cast<QCPAxis::AxisType>(typeVal));
}

libqt_list /* of QCPAxis* */ QCPAxisRect_Axes(const QCPAxisRect* self, int types) {
    QList<QCPAxis*> _ret = self->axes(static_cast<QCPAxis::AxisTypes>(types));
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPAxis** _arr = static_cast<QCPAxis**>(malloc(sizeof(QCPAxis*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

libqt_list /* of QCPAxis* */ QCPAxisRect_Axes2(const QCPAxisRect* self) {
    QList<QCPAxis*> _ret = self->axes();
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPAxis** _arr = static_cast<QCPAxis**>(malloc(sizeof(QCPAxis*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

QCPAxis* QCPAxisRect_AddAxis(QCPAxisRect* self, int typeVal) {
    return self->addAxis(static_cast<QCPAxis::AxisType>(typeVal));
}

libqt_list /* of QCPAxis* */ QCPAxisRect_AddAxes(QCPAxisRect* self, int types) {
    QList<QCPAxis*> _ret = self->addAxes(static_cast<QCPAxis::AxisTypes>(types));
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPAxis** _arr = static_cast<QCPAxis**>(malloc(sizeof(QCPAxis*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

bool QCPAxisRect_RemoveAxis(QCPAxisRect* self, QCPAxis* axis) {
    return self->removeAxis(axis);
}

QCPLayoutInset* QCPAxisRect_InsetLayout(const QCPAxisRect* self) {
    return self->insetLayout();
}

void QCPAxisRect_Zoom(QCPAxisRect* self, const QRectF* pixelRect) {
    self->zoom(*pixelRect);
}

void QCPAxisRect_Zoom2(QCPAxisRect* self, const QRectF* pixelRect, const libqt_list /* of QCPAxis* */ affectedAxes) {
    QList<QCPAxis*> affectedAxes_QList;
    affectedAxes_QList.reserve(affectedAxes.len);
    QCPAxis** affectedAxes_arr = static_cast<QCPAxis**>(affectedAxes.data);
    for (size_t i = 0; i < affectedAxes.len; ++i) {
        affectedAxes_QList.push_back(affectedAxes_arr[i]);
    }
    self->zoom(*pixelRect, affectedAxes_QList);
}

void QCPAxisRect_SetupFullAxesBox(QCPAxisRect* self) {
    self->setupFullAxesBox();
}

libqt_list /* of QCPAbstractPlottable* */ QCPAxisRect_Plottables(const QCPAxisRect* self) {
    QList<QCPAbstractPlottable*> _ret = self->plottables();
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPAbstractPlottable** _arr = static_cast<QCPAbstractPlottable**>(malloc(sizeof(QCPAbstractPlottable*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

libqt_list /* of QCPGraph* */ QCPAxisRect_Graphs(const QCPAxisRect* self) {
    QList<QCPGraph*> _ret = self->graphs();
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPGraph** _arr = static_cast<QCPGraph**>(malloc(sizeof(QCPGraph*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

libqt_list /* of QCPAbstractItem* */ QCPAxisRect_Items(const QCPAxisRect* self) {
    QList<QCPAbstractItem*> _ret = self->items();
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPAbstractItem** _arr = static_cast<QCPAbstractItem**>(malloc(sizeof(QCPAbstractItem*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

int QCPAxisRect_Left(const QCPAxisRect* self) {
    return self->left();
}

int QCPAxisRect_Right(const QCPAxisRect* self) {
    return self->right();
}

int QCPAxisRect_Top(const QCPAxisRect* self) {
    return self->top();
}

int QCPAxisRect_Bottom(const QCPAxisRect* self) {
    return self->bottom();
}

int QCPAxisRect_Width(const QCPAxisRect* self) {
    return self->width();
}

int QCPAxisRect_Height(const QCPAxisRect* self) {
    return self->height();
}

QSize* QCPAxisRect_Size(const QCPAxisRect* self) {
    return new QSize(self->size());
}

QPoint* QCPAxisRect_TopLeft(const QCPAxisRect* self) {
    return new QPoint(self->topLeft());
}

QPoint* QCPAxisRect_TopRight(const QCPAxisRect* self) {
    return new QPoint(self->topRight());
}

QPoint* QCPAxisRect_BottomLeft(const QCPAxisRect* self) {
    return new QPoint(self->bottomLeft());
}

QPoint* QCPAxisRect_BottomRight(const QCPAxisRect* self) {
    return new QPoint(self->bottomRight());
}

QPoint* QCPAxisRect_Center(const QCPAxisRect* self) {
    return new QPoint(self->center());
}

void QCPAxisRect_Update(QCPAxisRect* self, int phase) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        self->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    } else {
        ((VirtualQCPAxisRect*)self)->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    }
}

libqt_list /* of QCPLayoutElement* */ QCPAxisRect_Elements(const QCPAxisRect* self, bool recursive) {
    auto* vqcpaxisrect = dynamic_cast<const VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        QList<QCPLayoutElement*> _ret = self->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayoutElement*> _ret = ((VirtualQCPAxisRect*)self)->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

void QCPAxisRect_ApplyDefaultAntialiasingHint(const QCPAxisRect* self, QCPPainter* painter) {
    auto* vqcpaxisrect = dynamic_cast<const VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->applyDefaultAntialiasingHint(painter);
    }
}

void QCPAxisRect_Draw(QCPAxisRect* self, QCPPainter* painter) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->draw(painter);
    }
}

int QCPAxisRect_CalculateAutoMargin(QCPAxisRect* self, int side) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        return vqcpaxisrect->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    }
    return {};
}

void QCPAxisRect_LayoutChanged(QCPAxisRect* self) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->layoutChanged();
    }
}

void QCPAxisRect_MousePressEvent(QCPAxisRect* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->mousePressEvent(event, *details);
    }
}

void QCPAxisRect_MouseMoveEvent(QCPAxisRect* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->mouseMoveEvent(event, *startPos);
    }
}

void QCPAxisRect_MouseReleaseEvent(QCPAxisRect* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->mouseReleaseEvent(event, *startPos);
    }
}

void QCPAxisRect_WheelEvent(QCPAxisRect* self, QWheelEvent* event) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->wheelEvent(event);
    }
}

libqt_string QCPAxisRect_Tr2(const char* s, const char* c) {
    QString _ret = QCPAxisRect::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPAxisRect_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPAxisRect::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

void QCPAxisRect_SetBackground32(QCPAxisRect* self, const QPixmap* pm, bool scaled, int mode) {
    self->setBackground(*pm, scaled, static_cast<Qt::AspectRatioMode>(mode));
}

QCPAxis* QCPAxisRect_Axis2(const QCPAxisRect* self, int typeVal, int index) {
    return self->axis(static_cast<QCPAxis::AxisType>(typeVal), static_cast<int>(index));
}

QCPAxis* QCPAxisRect_AddAxis2(QCPAxisRect* self, int typeVal, QCPAxis* axis) {
    return self->addAxis(static_cast<QCPAxis::AxisType>(typeVal), axis);
}

void QCPAxisRect_SetupFullAxesBox1(QCPAxisRect* self, bool connectRanges) {
    self->setupFullAxesBox(connectRanges);
}

// Base class handler implementation
int QCPAxisRect_QBaseMetacall(QCPAxisRect* self, int param1, int param2, void** param3) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_Metacall_IsBase(true);
        return vqcpaxisrect->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPAxisRect::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnMetacall(QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_Metacall_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAxisRect_QBaseUpdate(QCPAxisRect* self, int phase) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_Update_IsBase(true);
        vqcpaxisrect->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    } else {
        self->QCPAxisRect::update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnUpdate(QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_Update_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_Update_Callback>(slot));
    }
}

// Base class handler implementation
libqt_list /* of QCPLayoutElement* */ QCPAxisRect_QBaseElements(const QCPAxisRect* self, bool recursive) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_Elements_IsBase(true);
        QList<QCPLayoutElement*> _ret = vqcpaxisrect->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayoutElement*> _ret = self->QCPAxisRect::elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnElements(const QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_Elements_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_Elements_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAxisRect_QBaseApplyDefaultAntialiasingHint(const QCPAxisRect* self, QCPPainter* painter) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcpaxisrect->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPAxisRect*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnApplyDefaultAntialiasingHint(const QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAxisRect_QBaseDraw(QCPAxisRect* self, QCPPainter* painter) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_Draw_IsBase(true);
        vqcpaxisrect->draw(painter);
    } else {
        ((VirtualQCPAxisRect*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnDraw(QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_Draw_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_Draw_Callback>(slot));
    }
}

// Base class handler implementation
int QCPAxisRect_QBaseCalculateAutoMargin(QCPAxisRect* self, int side) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_CalculateAutoMargin_IsBase(true);
        return vqcpaxisrect->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    } else {
        return ((VirtualQCPAxisRect*)self)->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnCalculateAutoMargin(QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_CalculateAutoMargin_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_CalculateAutoMargin_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAxisRect_QBaseLayoutChanged(QCPAxisRect* self) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_LayoutChanged_IsBase(true);
        vqcpaxisrect->layoutChanged();
    } else {
        ((VirtualQCPAxisRect*)self)->layoutChanged();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnLayoutChanged(QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_LayoutChanged_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_LayoutChanged_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAxisRect_QBaseMousePressEvent(QCPAxisRect* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_MousePressEvent_IsBase(true);
        vqcpaxisrect->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPAxisRect*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnMousePressEvent(QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_MousePressEvent_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_MousePressEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAxisRect_QBaseMouseMoveEvent(QCPAxisRect* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_MouseMoveEvent_IsBase(true);
        vqcpaxisrect->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPAxisRect*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnMouseMoveEvent(QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_MouseMoveEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAxisRect_QBaseMouseReleaseEvent(QCPAxisRect* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_MouseReleaseEvent_IsBase(true);
        vqcpaxisrect->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPAxisRect*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnMouseReleaseEvent(QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_MouseReleaseEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAxisRect_QBaseWheelEvent(QCPAxisRect* self, QWheelEvent* event) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_WheelEvent_IsBase(true);
        vqcpaxisrect->wheelEvent(event);
    } else {
        ((VirtualQCPAxisRect*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnWheelEvent(QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_WheelEvent_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
QSize* QCPAxisRect_MinimumOuterSizeHint(const QCPAxisRect* self) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        return new QSize(vqcpaxisrect->minimumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPAxisRect*)self)->minimumOuterSizeHint());
    }
}

// Base class handler implementation
QSize* QCPAxisRect_QBaseMinimumOuterSizeHint(const QCPAxisRect* self) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_MinimumOuterSizeHint_IsBase(true);
        return new QSize(vqcpaxisrect->minimumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPAxisRect*)self)->minimumOuterSizeHint());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnMinimumOuterSizeHint(const QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_MinimumOuterSizeHint_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_MinimumOuterSizeHint_Callback>(slot));
    }
}

// Derived class handler implementation
QSize* QCPAxisRect_MaximumOuterSizeHint(const QCPAxisRect* self) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        return new QSize(vqcpaxisrect->maximumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPAxisRect*)self)->maximumOuterSizeHint());
    }
}

// Base class handler implementation
QSize* QCPAxisRect_QBaseMaximumOuterSizeHint(const QCPAxisRect* self) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_MaximumOuterSizeHint_IsBase(true);
        return new QSize(vqcpaxisrect->maximumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPAxisRect*)self)->maximumOuterSizeHint());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnMaximumOuterSizeHint(const QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_MaximumOuterSizeHint_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_MaximumOuterSizeHint_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPAxisRect_SelectTest(const QCPAxisRect* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        return vqcpaxisrect->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPAxisRect::selectTest(*pos, onlySelectable, details);
    }
}

// Base class handler implementation
double QCPAxisRect_QBaseSelectTest(const QCPAxisRect* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_SelectTest_IsBase(true);
        return vqcpaxisrect->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPAxisRect::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnSelectTest(const QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_SelectTest_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_SelectTest_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisRect_ParentPlotInitialized(QCPAxisRect* self, QCustomPlot* parentPlot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPAxisRect*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPAxisRect_QBaseParentPlotInitialized(QCPAxisRect* self, QCustomPlot* parentPlot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_ParentPlotInitialized_IsBase(true);
        vqcpaxisrect->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPAxisRect*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnParentPlotInitialized(QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPAxisRect_SelectionCategory(const QCPAxisRect* self) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        return static_cast<int>(vqcpaxisrect->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPAxisRect*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPAxisRect_QBaseSelectionCategory(const QCPAxisRect* self) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcpaxisrect->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPAxisRect*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnSelectionCategory(const QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_SelectionCategory_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPAxisRect_ClipRect(const QCPAxisRect* self) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        return new QRect(vqcpaxisrect->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPAxisRect_QBaseClipRect(const QCPAxisRect* self) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_ClipRect_IsBase(true);
        return new QRect(vqcpaxisrect->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnClipRect(const QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_ClipRect_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisRect_SelectEvent(QCPAxisRect* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPAxisRect*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPAxisRect_QBaseSelectEvent(QCPAxisRect* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_SelectEvent_IsBase(true);
        vqcpaxisrect->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPAxisRect*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnSelectEvent(QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_SelectEvent_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisRect_DeselectEvent(QCPAxisRect* self, bool* selectionStateChanged) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPAxisRect*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPAxisRect_QBaseDeselectEvent(QCPAxisRect* self, bool* selectionStateChanged) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_DeselectEvent_IsBase(true);
        vqcpaxisrect->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPAxisRect*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnDeselectEvent(QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_DeselectEvent_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisRect_MouseDoubleClickEvent(QCPAxisRect* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPAxisRect*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPAxisRect_QBaseMouseDoubleClickEvent(QCPAxisRect* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_MouseDoubleClickEvent_IsBase(true);
        vqcpaxisrect->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPAxisRect*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnMouseDoubleClickEvent(QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPAxisRect_Event(QCPAxisRect* self, QEvent* event) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        return vqcpaxisrect->event(event);
    } else {
        return self->QCPAxisRect::event(event);
    }
}

// Base class handler implementation
bool QCPAxisRect_QBaseEvent(QCPAxisRect* self, QEvent* event) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_Event_IsBase(true);
        return vqcpaxisrect->event(event);
    } else {
        return self->QCPAxisRect::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnEvent(QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_Event_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPAxisRect_EventFilter(QCPAxisRect* self, QObject* watched, QEvent* event) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        return vqcpaxisrect->eventFilter(watched, event);
    } else {
        return self->QCPAxisRect::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPAxisRect_QBaseEventFilter(QCPAxisRect* self, QObject* watched, QEvent* event) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_EventFilter_IsBase(true);
        return vqcpaxisrect->eventFilter(watched, event);
    } else {
        return self->QCPAxisRect::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnEventFilter(QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_EventFilter_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisRect_TimerEvent(QCPAxisRect* self, QTimerEvent* event) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->timerEvent(event);
    } else {
        ((VirtualQCPAxisRect*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPAxisRect_QBaseTimerEvent(QCPAxisRect* self, QTimerEvent* event) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_TimerEvent_IsBase(true);
        vqcpaxisrect->timerEvent(event);
    } else {
        ((VirtualQCPAxisRect*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnTimerEvent(QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_TimerEvent_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisRect_ChildEvent(QCPAxisRect* self, QChildEvent* event) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->childEvent(event);
    } else {
        ((VirtualQCPAxisRect*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPAxisRect_QBaseChildEvent(QCPAxisRect* self, QChildEvent* event) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_ChildEvent_IsBase(true);
        vqcpaxisrect->childEvent(event);
    } else {
        ((VirtualQCPAxisRect*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnChildEvent(QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_ChildEvent_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisRect_CustomEvent(QCPAxisRect* self, QEvent* event) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->customEvent(event);
    } else {
        ((VirtualQCPAxisRect*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPAxisRect_QBaseCustomEvent(QCPAxisRect* self, QEvent* event) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_CustomEvent_IsBase(true);
        vqcpaxisrect->customEvent(event);
    } else {
        ((VirtualQCPAxisRect*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnCustomEvent(QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_CustomEvent_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisRect_ConnectNotify(QCPAxisRect* self, const QMetaMethod* signal) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->connectNotify(*signal);
    } else {
        ((VirtualQCPAxisRect*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPAxisRect_QBaseConnectNotify(QCPAxisRect* self, const QMetaMethod* signal) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_ConnectNotify_IsBase(true);
        vqcpaxisrect->connectNotify(*signal);
    } else {
        ((VirtualQCPAxisRect*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnConnectNotify(QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_ConnectNotify_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisRect_DisconnectNotify(QCPAxisRect* self, const QMetaMethod* signal) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->disconnectNotify(*signal);
    } else {
        ((VirtualQCPAxisRect*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPAxisRect_QBaseDisconnectNotify(QCPAxisRect* self, const QMetaMethod* signal) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_DisconnectNotify_IsBase(true);
        vqcpaxisrect->disconnectNotify(*signal);
    } else {
        ((VirtualQCPAxisRect*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnDisconnectNotify(QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisRect_DrawBackground(QCPAxisRect* self, QCPPainter* painter) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->drawBackground(painter);
    } else {
        ((VirtualQCPAxisRect*)self)->drawBackground(painter);
    }
}

// Base class handler implementation
void QCPAxisRect_QBaseDrawBackground(QCPAxisRect* self, QCPPainter* painter) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_DrawBackground_IsBase(true);
        vqcpaxisrect->drawBackground(painter);
    } else {
        ((VirtualQCPAxisRect*)self)->drawBackground(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnDrawBackground(QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_DrawBackground_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_DrawBackground_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisRect_UpdateAxesOffset(QCPAxisRect* self, int typeVal) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->updateAxesOffset(static_cast<QCPAxis::AxisType>(typeVal));
    } else {
        ((VirtualQCPAxisRect*)self)->updateAxesOffset(static_cast<QCPAxis::AxisType>(typeVal));
    }
}

// Base class handler implementation
void QCPAxisRect_QBaseUpdateAxesOffset(QCPAxisRect* self, int typeVal) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_UpdateAxesOffset_IsBase(true);
        vqcpaxisrect->updateAxesOffset(static_cast<QCPAxis::AxisType>(typeVal));
    } else {
        ((VirtualQCPAxisRect*)self)->updateAxesOffset(static_cast<QCPAxis::AxisType>(typeVal));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnUpdateAxesOffset(QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_UpdateAxesOffset_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_UpdateAxesOffset_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisRect_InitializeParentPlot(QCPAxisRect* self, QCustomPlot* parentPlot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPAxisRect*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPAxisRect_QBaseInitializeParentPlot(QCPAxisRect* self, QCustomPlot* parentPlot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_InitializeParentPlot_IsBase(true);
        vqcpaxisrect->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPAxisRect*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnInitializeParentPlot(QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisRect_SetParentLayerable(QCPAxisRect* self, QCPLayerable* parentLayerable) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPAxisRect*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPAxisRect_QBaseSetParentLayerable(QCPAxisRect* self, QCPLayerable* parentLayerable) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_SetParentLayerable_IsBase(true);
        vqcpaxisrect->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPAxisRect*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnSetParentLayerable(QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPAxisRect_MoveToLayer(QCPAxisRect* self, QCPLayer* layer, bool prepend) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        return vqcpaxisrect->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPAxisRect*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPAxisRect_QBaseMoveToLayer(QCPAxisRect* self, QCPLayer* layer, bool prepend) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_MoveToLayer_IsBase(true);
        return vqcpaxisrect->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPAxisRect*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnMoveToLayer(QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = dynamic_cast<VirtualQCPAxisRect*>(self);
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_MoveToLayer_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAxisRect_ApplyAntialiasingHint(const QCPAxisRect* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPAxisRect*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPAxisRect_QBaseApplyAntialiasingHint(const QCPAxisRect* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_ApplyAntialiasingHint_IsBase(true);
        vqcpaxisrect->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPAxisRect*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnApplyAntialiasingHint(const QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPAxisRect_Sender(const QCPAxisRect* self) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        return vqcpaxisrect->sender();
    } else {
        return ((VirtualQCPAxisRect*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPAxisRect_QBaseSender(const QCPAxisRect* self) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_Sender_IsBase(true);
        return vqcpaxisrect->sender();
    } else {
        return ((VirtualQCPAxisRect*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnSender(const QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_Sender_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPAxisRect_SenderSignalIndex(const QCPAxisRect* self) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        return vqcpaxisrect->senderSignalIndex();
    } else {
        return ((VirtualQCPAxisRect*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPAxisRect_QBaseSenderSignalIndex(const QCPAxisRect* self) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_SenderSignalIndex_IsBase(true);
        return vqcpaxisrect->senderSignalIndex();
    } else {
        return ((VirtualQCPAxisRect*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnSenderSignalIndex(const QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPAxisRect_Receivers(const QCPAxisRect* self, const char* signal) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        return vqcpaxisrect->receivers(signal);
    } else {
        return ((VirtualQCPAxisRect*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPAxisRect_QBaseReceivers(const QCPAxisRect* self, const char* signal) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_Receivers_IsBase(true);
        return vqcpaxisrect->receivers(signal);
    } else {
        return ((VirtualQCPAxisRect*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnReceivers(const QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_Receivers_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPAxisRect_IsSignalConnected(const QCPAxisRect* self, const QMetaMethod* signal) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        return vqcpaxisrect->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPAxisRect*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPAxisRect_QBaseIsSignalConnected(const QCPAxisRect* self, const QMetaMethod* signal) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_IsSignalConnected_IsBase(true);
        return vqcpaxisrect->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPAxisRect*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAxisRect_OnIsSignalConnected(const QCPAxisRect* self, intptr_t slot) {
    auto* vqcpaxisrect = const_cast<VirtualQCPAxisRect*>(dynamic_cast<const VirtualQCPAxisRect*>(self));
    if (vqcpaxisrect && vqcpaxisrect->isVirtualQCPAxisRect) {
        vqcpaxisrect->setQCPAxisRect_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPAxisRect::QCPAxisRect_IsSignalConnected_Callback>(slot));
    }
}

void QCPAxisRect_Delete(QCPAxisRect* self) {
    delete self;
}

QCPAbstractLegendItem* QCPAbstractLegendItem_new(QCPLegend* parent) {
    return new VirtualQCPAbstractLegendItem(parent);
}

QMetaObject* QCPAbstractLegendItem_MetaObject(const QCPAbstractLegendItem* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPAbstractLegendItem_Metacast(QCPAbstractLegendItem* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPAbstractLegendItem_Metacall(QCPAbstractLegendItem* self, int param1, int param2, void** param3) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPAbstractLegendItem*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPAbstractLegendItem_Tr(const char* s) {
    QString _ret = QCPAbstractLegendItem::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

QCPLegend* QCPAbstractLegendItem_ParentLegend(const QCPAbstractLegendItem* self) {
    return self->parentLegend();
}

QFont* QCPAbstractLegendItem_Font(const QCPAbstractLegendItem* self) {
    return new QFont(self->font());
}

QColor* QCPAbstractLegendItem_TextColor(const QCPAbstractLegendItem* self) {
    return new QColor(self->textColor());
}

QFont* QCPAbstractLegendItem_SelectedFont(const QCPAbstractLegendItem* self) {
    return new QFont(self->selectedFont());
}

QColor* QCPAbstractLegendItem_SelectedTextColor(const QCPAbstractLegendItem* self) {
    return new QColor(self->selectedTextColor());
}

bool QCPAbstractLegendItem_Selectable(const QCPAbstractLegendItem* self) {
    return self->selectable();
}

bool QCPAbstractLegendItem_Selected(const QCPAbstractLegendItem* self) {
    return self->selected();
}

void QCPAbstractLegendItem_SetFont(QCPAbstractLegendItem* self, const QFont* font) {
    self->setFont(*font);
}

void QCPAbstractLegendItem_SetTextColor(QCPAbstractLegendItem* self, const QColor* color) {
    self->setTextColor(*color);
}

void QCPAbstractLegendItem_SetSelectedFont(QCPAbstractLegendItem* self, const QFont* font) {
    self->setSelectedFont(*font);
}

void QCPAbstractLegendItem_SetSelectedTextColor(QCPAbstractLegendItem* self, const QColor* color) {
    self->setSelectedTextColor(*color);
}

void QCPAbstractLegendItem_SetSelectable(QCPAbstractLegendItem* self, bool selectable) {
    self->setSelectable(selectable);
}

void QCPAbstractLegendItem_SetSelected(QCPAbstractLegendItem* self, bool selected) {
    self->setSelected(selected);
}

double QCPAbstractLegendItem_SelectTest(const QCPAbstractLegendItem* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpabstractlegenditem = dynamic_cast<const VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPAbstractLegendItem*)self)->selectTest(*pos, onlySelectable, details);
    }
}

void QCPAbstractLegendItem_SelectionChanged(QCPAbstractLegendItem* self, bool selected) {
    self->selectionChanged(selected);
}

void QCPAbstractLegendItem_Connect_SelectionChanged(QCPAbstractLegendItem* self, intptr_t slot) {
    void (*slotFunc)(QCPAbstractLegendItem*, bool) = reinterpret_cast<void (*)(QCPAbstractLegendItem*, bool)>(slot);
    QCPAbstractLegendItem::connect(self, &QCPAbstractLegendItem::selectionChanged, [self, slotFunc](bool selected) {
        bool sigval1 = selected;
        slotFunc(self, sigval1);
    });
}

void QCPAbstractLegendItem_SelectableChanged(QCPAbstractLegendItem* self, bool selectable) {
    self->selectableChanged(selectable);
}

void QCPAbstractLegendItem_Connect_SelectableChanged(QCPAbstractLegendItem* self, intptr_t slot) {
    void (*slotFunc)(QCPAbstractLegendItem*, bool) = reinterpret_cast<void (*)(QCPAbstractLegendItem*, bool)>(slot);
    QCPAbstractLegendItem::connect(self, &QCPAbstractLegendItem::selectableChanged, [self, slotFunc](bool selectable) {
        bool sigval1 = selectable;
        slotFunc(self, sigval1);
    });
}

int QCPAbstractLegendItem_SelectionCategory(const QCPAbstractLegendItem* self) {
    auto* vqcpabstractlegenditem = dynamic_cast<const VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        return static_cast<int>(vqcpabstractlegenditem->selectionCategory());
    }
    return {};
}

void QCPAbstractLegendItem_ApplyDefaultAntialiasingHint(const QCPAbstractLegendItem* self, QCPPainter* painter) {
    auto* vqcpabstractlegenditem = dynamic_cast<const VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->applyDefaultAntialiasingHint(painter);
    }
}

QRect* QCPAbstractLegendItem_ClipRect(const QCPAbstractLegendItem* self) {
    auto* vqcpabstractlegenditem = dynamic_cast<const VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        return new QRect(vqcpabstractlegenditem->clipRect());
    }
    return {};
}

void QCPAbstractLegendItem_Draw(QCPAbstractLegendItem* self, QCPPainter* painter) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->draw(painter);
    }
}

void QCPAbstractLegendItem_SelectEvent(QCPAbstractLegendItem* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

void QCPAbstractLegendItem_DeselectEvent(QCPAbstractLegendItem* self, bool* selectionStateChanged) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->deselectEvent(selectionStateChanged);
    }
}

libqt_string QCPAbstractLegendItem_Tr2(const char* s, const char* c) {
    QString _ret = QCPAbstractLegendItem::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPAbstractLegendItem_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPAbstractLegendItem::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPAbstractLegendItem_QBaseMetacall(QCPAbstractLegendItem* self, int param1, int param2, void** param3) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_Metacall_IsBase(true);
        return vqcpabstractlegenditem->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPAbstractLegendItem::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnMetacall(QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_Metacall_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
double QCPAbstractLegendItem_QBaseSelectTest(const QCPAbstractLegendItem* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_SelectTest_IsBase(true);
        return vqcpabstractlegenditem->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPAbstractLegendItem::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnSelectTest(const QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_SelectTest_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
int QCPAbstractLegendItem_QBaseSelectionCategory(const QCPAbstractLegendItem* self) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcpabstractlegenditem->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPAbstractLegendItem*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnSelectionCategory(const QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_SelectionCategory_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_SelectionCategory_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAbstractLegendItem_QBaseApplyDefaultAntialiasingHint(const QCPAbstractLegendItem* self, QCPPainter* painter) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcpabstractlegenditem->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnApplyDefaultAntialiasingHint(const QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Base class handler implementation
QRect* QCPAbstractLegendItem_QBaseClipRect(const QCPAbstractLegendItem* self) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_ClipRect_IsBase(true);
        return new QRect(vqcpabstractlegenditem->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnClipRect(const QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_ClipRect_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_ClipRect_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAbstractLegendItem_QBaseDraw(QCPAbstractLegendItem* self, QCPPainter* painter) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_Draw_IsBase(true);
        vqcpabstractlegenditem->draw(painter);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnDraw(QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_Draw_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_Draw_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAbstractLegendItem_QBaseSelectEvent(QCPAbstractLegendItem* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_SelectEvent_IsBase(true);
        vqcpabstractlegenditem->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnSelectEvent(QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_SelectEvent_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_SelectEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPAbstractLegendItem_QBaseDeselectEvent(QCPAbstractLegendItem* self, bool* selectionStateChanged) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_DeselectEvent_IsBase(true);
        vqcpabstractlegenditem->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnDeselectEvent(QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_DeselectEvent_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractLegendItem_Update(QCPAbstractLegendItem* self, int phase) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    } else {
        self->QCPAbstractLegendItem::update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    }
}

// Base class handler implementation
void QCPAbstractLegendItem_QBaseUpdate(QCPAbstractLegendItem* self, int phase) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_Update_IsBase(true);
        vqcpabstractlegenditem->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    } else {
        self->QCPAbstractLegendItem::update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnUpdate(QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_Update_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_Update_Callback>(slot));
    }
}

// Derived class handler implementation
QSize* QCPAbstractLegendItem_MinimumOuterSizeHint(const QCPAbstractLegendItem* self) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        return new QSize(vqcpabstractlegenditem->minimumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPAbstractLegendItem*)self)->minimumOuterSizeHint());
    }
}

// Base class handler implementation
QSize* QCPAbstractLegendItem_QBaseMinimumOuterSizeHint(const QCPAbstractLegendItem* self) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_MinimumOuterSizeHint_IsBase(true);
        return new QSize(vqcpabstractlegenditem->minimumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPAbstractLegendItem*)self)->minimumOuterSizeHint());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnMinimumOuterSizeHint(const QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_MinimumOuterSizeHint_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_MinimumOuterSizeHint_Callback>(slot));
    }
}

// Derived class handler implementation
QSize* QCPAbstractLegendItem_MaximumOuterSizeHint(const QCPAbstractLegendItem* self) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        return new QSize(vqcpabstractlegenditem->maximumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPAbstractLegendItem*)self)->maximumOuterSizeHint());
    }
}

// Base class handler implementation
QSize* QCPAbstractLegendItem_QBaseMaximumOuterSizeHint(const QCPAbstractLegendItem* self) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_MaximumOuterSizeHint_IsBase(true);
        return new QSize(vqcpabstractlegenditem->maximumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPAbstractLegendItem*)self)->maximumOuterSizeHint());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnMaximumOuterSizeHint(const QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_MaximumOuterSizeHint_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_MaximumOuterSizeHint_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of QCPLayoutElement* */ QCPAbstractLegendItem_Elements(const QCPAbstractLegendItem* self, bool recursive) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        QList<QCPLayoutElement*> _ret = vqcpabstractlegenditem->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayoutElement*> _ret = self->QCPAbstractLegendItem::elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of QCPLayoutElement* */ QCPAbstractLegendItem_QBaseElements(const QCPAbstractLegendItem* self, bool recursive) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_Elements_IsBase(true);
        QList<QCPLayoutElement*> _ret = vqcpabstractlegenditem->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayoutElement*> _ret = self->QCPAbstractLegendItem::elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnElements(const QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_Elements_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_Elements_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPAbstractLegendItem_CalculateAutoMargin(QCPAbstractLegendItem* self, int side) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        return vqcpabstractlegenditem->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    } else {
        return ((VirtualQCPAbstractLegendItem*)self)->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    }
}

// Base class handler implementation
int QCPAbstractLegendItem_QBaseCalculateAutoMargin(QCPAbstractLegendItem* self, int side) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_CalculateAutoMargin_IsBase(true);
        return vqcpabstractlegenditem->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    } else {
        return ((VirtualQCPAbstractLegendItem*)self)->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnCalculateAutoMargin(QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_CalculateAutoMargin_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_CalculateAutoMargin_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractLegendItem_LayoutChanged(QCPAbstractLegendItem* self) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->layoutChanged();
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->layoutChanged();
    }
}

// Base class handler implementation
void QCPAbstractLegendItem_QBaseLayoutChanged(QCPAbstractLegendItem* self) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_LayoutChanged_IsBase(true);
        vqcpabstractlegenditem->layoutChanged();
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->layoutChanged();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnLayoutChanged(QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_LayoutChanged_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_LayoutChanged_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractLegendItem_ParentPlotInitialized(QCPAbstractLegendItem* self, QCustomPlot* parentPlot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPAbstractLegendItem_QBaseParentPlotInitialized(QCPAbstractLegendItem* self, QCustomPlot* parentPlot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_ParentPlotInitialized_IsBase(true);
        vqcpabstractlegenditem->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnParentPlotInitialized(QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractLegendItem_MousePressEvent(QCPAbstractLegendItem* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPAbstractLegendItem_QBaseMousePressEvent(QCPAbstractLegendItem* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_MousePressEvent_IsBase(true);
        vqcpabstractlegenditem->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnMousePressEvent(QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_MousePressEvent_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractLegendItem_MouseMoveEvent(QCPAbstractLegendItem* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPAbstractLegendItem_QBaseMouseMoveEvent(QCPAbstractLegendItem* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_MouseMoveEvent_IsBase(true);
        vqcpabstractlegenditem->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnMouseMoveEvent(QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractLegendItem_MouseReleaseEvent(QCPAbstractLegendItem* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPAbstractLegendItem_QBaseMouseReleaseEvent(QCPAbstractLegendItem* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_MouseReleaseEvent_IsBase(true);
        vqcpabstractlegenditem->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnMouseReleaseEvent(QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractLegendItem_MouseDoubleClickEvent(QCPAbstractLegendItem* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPAbstractLegendItem_QBaseMouseDoubleClickEvent(QCPAbstractLegendItem* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_MouseDoubleClickEvent_IsBase(true);
        vqcpabstractlegenditem->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnMouseDoubleClickEvent(QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractLegendItem_WheelEvent(QCPAbstractLegendItem* self, QWheelEvent* event) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->wheelEvent(event);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPAbstractLegendItem_QBaseWheelEvent(QCPAbstractLegendItem* self, QWheelEvent* event) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_WheelEvent_IsBase(true);
        vqcpabstractlegenditem->wheelEvent(event);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnWheelEvent(QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_WheelEvent_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPAbstractLegendItem_Event(QCPAbstractLegendItem* self, QEvent* event) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        return vqcpabstractlegenditem->event(event);
    } else {
        return self->QCPAbstractLegendItem::event(event);
    }
}

// Base class handler implementation
bool QCPAbstractLegendItem_QBaseEvent(QCPAbstractLegendItem* self, QEvent* event) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_Event_IsBase(true);
        return vqcpabstractlegenditem->event(event);
    } else {
        return self->QCPAbstractLegendItem::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnEvent(QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_Event_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPAbstractLegendItem_EventFilter(QCPAbstractLegendItem* self, QObject* watched, QEvent* event) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        return vqcpabstractlegenditem->eventFilter(watched, event);
    } else {
        return self->QCPAbstractLegendItem::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPAbstractLegendItem_QBaseEventFilter(QCPAbstractLegendItem* self, QObject* watched, QEvent* event) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_EventFilter_IsBase(true);
        return vqcpabstractlegenditem->eventFilter(watched, event);
    } else {
        return self->QCPAbstractLegendItem::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnEventFilter(QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_EventFilter_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractLegendItem_TimerEvent(QCPAbstractLegendItem* self, QTimerEvent* event) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->timerEvent(event);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPAbstractLegendItem_QBaseTimerEvent(QCPAbstractLegendItem* self, QTimerEvent* event) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_TimerEvent_IsBase(true);
        vqcpabstractlegenditem->timerEvent(event);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnTimerEvent(QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_TimerEvent_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractLegendItem_ChildEvent(QCPAbstractLegendItem* self, QChildEvent* event) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->childEvent(event);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPAbstractLegendItem_QBaseChildEvent(QCPAbstractLegendItem* self, QChildEvent* event) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_ChildEvent_IsBase(true);
        vqcpabstractlegenditem->childEvent(event);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnChildEvent(QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_ChildEvent_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractLegendItem_CustomEvent(QCPAbstractLegendItem* self, QEvent* event) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->customEvent(event);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPAbstractLegendItem_QBaseCustomEvent(QCPAbstractLegendItem* self, QEvent* event) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_CustomEvent_IsBase(true);
        vqcpabstractlegenditem->customEvent(event);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnCustomEvent(QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_CustomEvent_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractLegendItem_ConnectNotify(QCPAbstractLegendItem* self, const QMetaMethod* signal) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->connectNotify(*signal);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPAbstractLegendItem_QBaseConnectNotify(QCPAbstractLegendItem* self, const QMetaMethod* signal) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_ConnectNotify_IsBase(true);
        vqcpabstractlegenditem->connectNotify(*signal);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnConnectNotify(QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_ConnectNotify_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractLegendItem_DisconnectNotify(QCPAbstractLegendItem* self, const QMetaMethod* signal) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->disconnectNotify(*signal);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPAbstractLegendItem_QBaseDisconnectNotify(QCPAbstractLegendItem* self, const QMetaMethod* signal) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_DisconnectNotify_IsBase(true);
        vqcpabstractlegenditem->disconnectNotify(*signal);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnDisconnectNotify(QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractLegendItem_InitializeParentPlot(QCPAbstractLegendItem* self, QCustomPlot* parentPlot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPAbstractLegendItem_QBaseInitializeParentPlot(QCPAbstractLegendItem* self, QCustomPlot* parentPlot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_InitializeParentPlot_IsBase(true);
        vqcpabstractlegenditem->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnInitializeParentPlot(QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractLegendItem_SetParentLayerable(QCPAbstractLegendItem* self, QCPLayerable* parentLayerable) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPAbstractLegendItem_QBaseSetParentLayerable(QCPAbstractLegendItem* self, QCPLayerable* parentLayerable) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_SetParentLayerable_IsBase(true);
        vqcpabstractlegenditem->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnSetParentLayerable(QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPAbstractLegendItem_MoveToLayer(QCPAbstractLegendItem* self, QCPLayer* layer, bool prepend) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        return vqcpabstractlegenditem->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPAbstractLegendItem*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPAbstractLegendItem_QBaseMoveToLayer(QCPAbstractLegendItem* self, QCPLayer* layer, bool prepend) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_MoveToLayer_IsBase(true);
        return vqcpabstractlegenditem->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPAbstractLegendItem*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnMoveToLayer(QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = dynamic_cast<VirtualQCPAbstractLegendItem*>(self);
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_MoveToLayer_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPAbstractLegendItem_ApplyAntialiasingHint(const QCPAbstractLegendItem* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPAbstractLegendItem_QBaseApplyAntialiasingHint(const QCPAbstractLegendItem* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_ApplyAntialiasingHint_IsBase(true);
        vqcpabstractlegenditem->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPAbstractLegendItem*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnApplyAntialiasingHint(const QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPAbstractLegendItem_Sender(const QCPAbstractLegendItem* self) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        return vqcpabstractlegenditem->sender();
    } else {
        return ((VirtualQCPAbstractLegendItem*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPAbstractLegendItem_QBaseSender(const QCPAbstractLegendItem* self) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_Sender_IsBase(true);
        return vqcpabstractlegenditem->sender();
    } else {
        return ((VirtualQCPAbstractLegendItem*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnSender(const QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_Sender_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPAbstractLegendItem_SenderSignalIndex(const QCPAbstractLegendItem* self) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        return vqcpabstractlegenditem->senderSignalIndex();
    } else {
        return ((VirtualQCPAbstractLegendItem*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPAbstractLegendItem_QBaseSenderSignalIndex(const QCPAbstractLegendItem* self) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_SenderSignalIndex_IsBase(true);
        return vqcpabstractlegenditem->senderSignalIndex();
    } else {
        return ((VirtualQCPAbstractLegendItem*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnSenderSignalIndex(const QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPAbstractLegendItem_Receivers(const QCPAbstractLegendItem* self, const char* signal) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        return vqcpabstractlegenditem->receivers(signal);
    } else {
        return ((VirtualQCPAbstractLegendItem*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPAbstractLegendItem_QBaseReceivers(const QCPAbstractLegendItem* self, const char* signal) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_Receivers_IsBase(true);
        return vqcpabstractlegenditem->receivers(signal);
    } else {
        return ((VirtualQCPAbstractLegendItem*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnReceivers(const QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_Receivers_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPAbstractLegendItem_IsSignalConnected(const QCPAbstractLegendItem* self, const QMetaMethod* signal) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        return vqcpabstractlegenditem->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPAbstractLegendItem*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPAbstractLegendItem_QBaseIsSignalConnected(const QCPAbstractLegendItem* self, const QMetaMethod* signal) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_IsSignalConnected_IsBase(true);
        return vqcpabstractlegenditem->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPAbstractLegendItem*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPAbstractLegendItem_OnIsSignalConnected(const QCPAbstractLegendItem* self, intptr_t slot) {
    auto* vqcpabstractlegenditem = const_cast<VirtualQCPAbstractLegendItem*>(dynamic_cast<const VirtualQCPAbstractLegendItem*>(self));
    if (vqcpabstractlegenditem && vqcpabstractlegenditem->isVirtualQCPAbstractLegendItem) {
        vqcpabstractlegenditem->setQCPAbstractLegendItem_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPAbstractLegendItem::QCPAbstractLegendItem_IsSignalConnected_Callback>(slot));
    }
}

void QCPAbstractLegendItem_Delete(QCPAbstractLegendItem* self) {
    delete self;
}

QCPPlottableLegendItem* QCPPlottableLegendItem_new(QCPLegend* parent, QCPAbstractPlottable* plottable) {
    return new VirtualQCPPlottableLegendItem(parent, plottable);
}

QMetaObject* QCPPlottableLegendItem_MetaObject(const QCPPlottableLegendItem* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPPlottableLegendItem_Metacast(QCPPlottableLegendItem* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPPlottableLegendItem_Metacall(QCPPlottableLegendItem* self, int param1, int param2, void** param3) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPPlottableLegendItem*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPPlottableLegendItem_Tr(const char* s) {
    QString _ret = QCPPlottableLegendItem::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

QCPAbstractPlottable* QCPPlottableLegendItem_Plottable(QCPPlottableLegendItem* self) {
    return self->plottable();
}

void QCPPlottableLegendItem_Draw(QCPPlottableLegendItem* self, QCPPainter* painter) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->draw(painter);
    }
}

QSize* QCPPlottableLegendItem_MinimumOuterSizeHint(const QCPPlottableLegendItem* self) {
    auto* vqcpplottablelegenditem = dynamic_cast<const VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        return new QSize(vqcpplottablelegenditem->minimumOuterSizeHint());
    }
    return {};
}

libqt_string QCPPlottableLegendItem_Tr2(const char* s, const char* c) {
    QString _ret = QCPPlottableLegendItem::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPPlottableLegendItem_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPPlottableLegendItem::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPPlottableLegendItem_QBaseMetacall(QCPPlottableLegendItem* self, int param1, int param2, void** param3) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_Metacall_IsBase(true);
        return vqcpplottablelegenditem->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPPlottableLegendItem::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnMetacall(QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_Metacall_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPlottableLegendItem_QBaseDraw(QCPPlottableLegendItem* self, QCPPainter* painter) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_Draw_IsBase(true);
        vqcpplottablelegenditem->draw(painter);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnDraw(QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_Draw_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_Draw_Callback>(slot));
    }
}

// Base class handler implementation
QSize* QCPPlottableLegendItem_QBaseMinimumOuterSizeHint(const QCPPlottableLegendItem* self) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_MinimumOuterSizeHint_IsBase(true);
        return new QSize(vqcpplottablelegenditem->minimumOuterSizeHint());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnMinimumOuterSizeHint(const QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_MinimumOuterSizeHint_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_MinimumOuterSizeHint_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPPlottableLegendItem_SelectTest(const QCPPlottableLegendItem* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        return vqcpplottablelegenditem->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPPlottableLegendItem::selectTest(*pos, onlySelectable, details);
    }
}

// Base class handler implementation
double QCPPlottableLegendItem_QBaseSelectTest(const QCPPlottableLegendItem* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_SelectTest_IsBase(true);
        return vqcpplottablelegenditem->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPPlottableLegendItem::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnSelectTest(const QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_SelectTest_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_SelectTest_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPPlottableLegendItem_SelectionCategory(const QCPPlottableLegendItem* self) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        return static_cast<int>(vqcpplottablelegenditem->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPPlottableLegendItem*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPPlottableLegendItem_QBaseSelectionCategory(const QCPPlottableLegendItem* self) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcpplottablelegenditem->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPPlottableLegendItem*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnSelectionCategory(const QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_SelectionCategory_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPlottableLegendItem_ApplyDefaultAntialiasingHint(const QCPPlottableLegendItem* self, QCPPainter* painter) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPPlottableLegendItem_QBaseApplyDefaultAntialiasingHint(const QCPPlottableLegendItem* self, QCPPainter* painter) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcpplottablelegenditem->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnApplyDefaultAntialiasingHint(const QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPPlottableLegendItem_ClipRect(const QCPPlottableLegendItem* self) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        return new QRect(vqcpplottablelegenditem->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPPlottableLegendItem_QBaseClipRect(const QCPPlottableLegendItem* self) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_ClipRect_IsBase(true);
        return new QRect(vqcpplottablelegenditem->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnClipRect(const QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_ClipRect_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPlottableLegendItem_SelectEvent(QCPPlottableLegendItem* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPPlottableLegendItem_QBaseSelectEvent(QCPPlottableLegendItem* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_SelectEvent_IsBase(true);
        vqcpplottablelegenditem->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnSelectEvent(QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_SelectEvent_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPlottableLegendItem_DeselectEvent(QCPPlottableLegendItem* self, bool* selectionStateChanged) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPPlottableLegendItem_QBaseDeselectEvent(QCPPlottableLegendItem* self, bool* selectionStateChanged) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_DeselectEvent_IsBase(true);
        vqcpplottablelegenditem->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnDeselectEvent(QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_DeselectEvent_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPlottableLegendItem_Update(QCPPlottableLegendItem* self, int phase) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    } else {
        self->QCPPlottableLegendItem::update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    }
}

// Base class handler implementation
void QCPPlottableLegendItem_QBaseUpdate(QCPPlottableLegendItem* self, int phase) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_Update_IsBase(true);
        vqcpplottablelegenditem->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    } else {
        self->QCPPlottableLegendItem::update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnUpdate(QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_Update_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_Update_Callback>(slot));
    }
}

// Derived class handler implementation
QSize* QCPPlottableLegendItem_MaximumOuterSizeHint(const QCPPlottableLegendItem* self) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        return new QSize(vqcpplottablelegenditem->maximumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPPlottableLegendItem*)self)->maximumOuterSizeHint());
    }
}

// Base class handler implementation
QSize* QCPPlottableLegendItem_QBaseMaximumOuterSizeHint(const QCPPlottableLegendItem* self) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_MaximumOuterSizeHint_IsBase(true);
        return new QSize(vqcpplottablelegenditem->maximumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPPlottableLegendItem*)self)->maximumOuterSizeHint());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnMaximumOuterSizeHint(const QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_MaximumOuterSizeHint_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_MaximumOuterSizeHint_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of QCPLayoutElement* */ QCPPlottableLegendItem_Elements(const QCPPlottableLegendItem* self, bool recursive) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        QList<QCPLayoutElement*> _ret = vqcpplottablelegenditem->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayoutElement*> _ret = self->QCPPlottableLegendItem::elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of QCPLayoutElement* */ QCPPlottableLegendItem_QBaseElements(const QCPPlottableLegendItem* self, bool recursive) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_Elements_IsBase(true);
        QList<QCPLayoutElement*> _ret = vqcpplottablelegenditem->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayoutElement*> _ret = self->QCPPlottableLegendItem::elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnElements(const QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_Elements_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_Elements_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPPlottableLegendItem_CalculateAutoMargin(QCPPlottableLegendItem* self, int side) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        return vqcpplottablelegenditem->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    } else {
        return ((VirtualQCPPlottableLegendItem*)self)->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    }
}

// Base class handler implementation
int QCPPlottableLegendItem_QBaseCalculateAutoMargin(QCPPlottableLegendItem* self, int side) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_CalculateAutoMargin_IsBase(true);
        return vqcpplottablelegenditem->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    } else {
        return ((VirtualQCPPlottableLegendItem*)self)->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnCalculateAutoMargin(QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_CalculateAutoMargin_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_CalculateAutoMargin_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPlottableLegendItem_LayoutChanged(QCPPlottableLegendItem* self) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->layoutChanged();
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->layoutChanged();
    }
}

// Base class handler implementation
void QCPPlottableLegendItem_QBaseLayoutChanged(QCPPlottableLegendItem* self) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_LayoutChanged_IsBase(true);
        vqcpplottablelegenditem->layoutChanged();
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->layoutChanged();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnLayoutChanged(QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_LayoutChanged_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_LayoutChanged_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPlottableLegendItem_ParentPlotInitialized(QCPPlottableLegendItem* self, QCustomPlot* parentPlot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPPlottableLegendItem_QBaseParentPlotInitialized(QCPPlottableLegendItem* self, QCustomPlot* parentPlot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_ParentPlotInitialized_IsBase(true);
        vqcpplottablelegenditem->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnParentPlotInitialized(QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPlottableLegendItem_MousePressEvent(QCPPlottableLegendItem* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPPlottableLegendItem_QBaseMousePressEvent(QCPPlottableLegendItem* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_MousePressEvent_IsBase(true);
        vqcpplottablelegenditem->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnMousePressEvent(QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_MousePressEvent_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPlottableLegendItem_MouseMoveEvent(QCPPlottableLegendItem* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPPlottableLegendItem_QBaseMouseMoveEvent(QCPPlottableLegendItem* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_MouseMoveEvent_IsBase(true);
        vqcpplottablelegenditem->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnMouseMoveEvent(QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPlottableLegendItem_MouseReleaseEvent(QCPPlottableLegendItem* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPPlottableLegendItem_QBaseMouseReleaseEvent(QCPPlottableLegendItem* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_MouseReleaseEvent_IsBase(true);
        vqcpplottablelegenditem->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnMouseReleaseEvent(QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPlottableLegendItem_MouseDoubleClickEvent(QCPPlottableLegendItem* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPPlottableLegendItem_QBaseMouseDoubleClickEvent(QCPPlottableLegendItem* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_MouseDoubleClickEvent_IsBase(true);
        vqcpplottablelegenditem->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnMouseDoubleClickEvent(QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPlottableLegendItem_WheelEvent(QCPPlottableLegendItem* self, QWheelEvent* event) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->wheelEvent(event);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPPlottableLegendItem_QBaseWheelEvent(QCPPlottableLegendItem* self, QWheelEvent* event) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_WheelEvent_IsBase(true);
        vqcpplottablelegenditem->wheelEvent(event);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnWheelEvent(QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_WheelEvent_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPPlottableLegendItem_Event(QCPPlottableLegendItem* self, QEvent* event) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        return vqcpplottablelegenditem->event(event);
    } else {
        return self->QCPPlottableLegendItem::event(event);
    }
}

// Base class handler implementation
bool QCPPlottableLegendItem_QBaseEvent(QCPPlottableLegendItem* self, QEvent* event) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_Event_IsBase(true);
        return vqcpplottablelegenditem->event(event);
    } else {
        return self->QCPPlottableLegendItem::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnEvent(QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_Event_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPPlottableLegendItem_EventFilter(QCPPlottableLegendItem* self, QObject* watched, QEvent* event) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        return vqcpplottablelegenditem->eventFilter(watched, event);
    } else {
        return self->QCPPlottableLegendItem::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPPlottableLegendItem_QBaseEventFilter(QCPPlottableLegendItem* self, QObject* watched, QEvent* event) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_EventFilter_IsBase(true);
        return vqcpplottablelegenditem->eventFilter(watched, event);
    } else {
        return self->QCPPlottableLegendItem::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnEventFilter(QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_EventFilter_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPlottableLegendItem_TimerEvent(QCPPlottableLegendItem* self, QTimerEvent* event) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->timerEvent(event);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPPlottableLegendItem_QBaseTimerEvent(QCPPlottableLegendItem* self, QTimerEvent* event) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_TimerEvent_IsBase(true);
        vqcpplottablelegenditem->timerEvent(event);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnTimerEvent(QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_TimerEvent_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPlottableLegendItem_ChildEvent(QCPPlottableLegendItem* self, QChildEvent* event) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->childEvent(event);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPPlottableLegendItem_QBaseChildEvent(QCPPlottableLegendItem* self, QChildEvent* event) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_ChildEvent_IsBase(true);
        vqcpplottablelegenditem->childEvent(event);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnChildEvent(QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_ChildEvent_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPlottableLegendItem_CustomEvent(QCPPlottableLegendItem* self, QEvent* event) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->customEvent(event);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPPlottableLegendItem_QBaseCustomEvent(QCPPlottableLegendItem* self, QEvent* event) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_CustomEvent_IsBase(true);
        vqcpplottablelegenditem->customEvent(event);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnCustomEvent(QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_CustomEvent_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPlottableLegendItem_ConnectNotify(QCPPlottableLegendItem* self, const QMetaMethod* signal) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->connectNotify(*signal);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPPlottableLegendItem_QBaseConnectNotify(QCPPlottableLegendItem* self, const QMetaMethod* signal) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_ConnectNotify_IsBase(true);
        vqcpplottablelegenditem->connectNotify(*signal);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnConnectNotify(QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_ConnectNotify_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPlottableLegendItem_DisconnectNotify(QCPPlottableLegendItem* self, const QMetaMethod* signal) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->disconnectNotify(*signal);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPPlottableLegendItem_QBaseDisconnectNotify(QCPPlottableLegendItem* self, const QMetaMethod* signal) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_DisconnectNotify_IsBase(true);
        vqcpplottablelegenditem->disconnectNotify(*signal);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnDisconnectNotify(QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
QPen* QCPPlottableLegendItem_GetIconBorderPen(const QCPPlottableLegendItem* self) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        return new QPen(vqcpplottablelegenditem->getIconBorderPen());
    }
    return {};
}

// Base class handler implementation
QPen* QCPPlottableLegendItem_QBaseGetIconBorderPen(const QCPPlottableLegendItem* self) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_GetIconBorderPen_IsBase(true);
        return new QPen(vqcpplottablelegenditem->getIconBorderPen());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnGetIconBorderPen(const QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_GetIconBorderPen_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_GetIconBorderPen_Callback>(slot));
    }
}

// Derived class handler implementation
QColor* QCPPlottableLegendItem_GetTextColor(const QCPPlottableLegendItem* self) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        return new QColor(vqcpplottablelegenditem->getTextColor());
    }
    return {};
}

// Base class handler implementation
QColor* QCPPlottableLegendItem_QBaseGetTextColor(const QCPPlottableLegendItem* self) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_GetTextColor_IsBase(true);
        return new QColor(vqcpplottablelegenditem->getTextColor());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnGetTextColor(const QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_GetTextColor_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_GetTextColor_Callback>(slot));
    }
}

// Derived class handler implementation
QFont* QCPPlottableLegendItem_GetFont(const QCPPlottableLegendItem* self) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        return new QFont(vqcpplottablelegenditem->getFont());
    }
    return {};
}

// Base class handler implementation
QFont* QCPPlottableLegendItem_QBaseGetFont(const QCPPlottableLegendItem* self) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_GetFont_IsBase(true);
        return new QFont(vqcpplottablelegenditem->getFont());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnGetFont(const QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_GetFont_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_GetFont_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPlottableLegendItem_InitializeParentPlot(QCPPlottableLegendItem* self, QCustomPlot* parentPlot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPPlottableLegendItem_QBaseInitializeParentPlot(QCPPlottableLegendItem* self, QCustomPlot* parentPlot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_InitializeParentPlot_IsBase(true);
        vqcpplottablelegenditem->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnInitializeParentPlot(QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPlottableLegendItem_SetParentLayerable(QCPPlottableLegendItem* self, QCPLayerable* parentLayerable) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPPlottableLegendItem_QBaseSetParentLayerable(QCPPlottableLegendItem* self, QCPLayerable* parentLayerable) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_SetParentLayerable_IsBase(true);
        vqcpplottablelegenditem->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnSetParentLayerable(QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPPlottableLegendItem_MoveToLayer(QCPPlottableLegendItem* self, QCPLayer* layer, bool prepend) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        return vqcpplottablelegenditem->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPPlottableLegendItem*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPPlottableLegendItem_QBaseMoveToLayer(QCPPlottableLegendItem* self, QCPLayer* layer, bool prepend) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_MoveToLayer_IsBase(true);
        return vqcpplottablelegenditem->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPPlottableLegendItem*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnMoveToLayer(QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = dynamic_cast<VirtualQCPPlottableLegendItem*>(self);
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_MoveToLayer_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPlottableLegendItem_ApplyAntialiasingHint(const QCPPlottableLegendItem* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPPlottableLegendItem_QBaseApplyAntialiasingHint(const QCPPlottableLegendItem* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_ApplyAntialiasingHint_IsBase(true);
        vqcpplottablelegenditem->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPPlottableLegendItem*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnApplyAntialiasingHint(const QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPPlottableLegendItem_Sender(const QCPPlottableLegendItem* self) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        return vqcpplottablelegenditem->sender();
    } else {
        return ((VirtualQCPPlottableLegendItem*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPPlottableLegendItem_QBaseSender(const QCPPlottableLegendItem* self) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_Sender_IsBase(true);
        return vqcpplottablelegenditem->sender();
    } else {
        return ((VirtualQCPPlottableLegendItem*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnSender(const QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_Sender_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPPlottableLegendItem_SenderSignalIndex(const QCPPlottableLegendItem* self) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        return vqcpplottablelegenditem->senderSignalIndex();
    } else {
        return ((VirtualQCPPlottableLegendItem*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPPlottableLegendItem_QBaseSenderSignalIndex(const QCPPlottableLegendItem* self) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_SenderSignalIndex_IsBase(true);
        return vqcpplottablelegenditem->senderSignalIndex();
    } else {
        return ((VirtualQCPPlottableLegendItem*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnSenderSignalIndex(const QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPPlottableLegendItem_Receivers(const QCPPlottableLegendItem* self, const char* signal) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        return vqcpplottablelegenditem->receivers(signal);
    } else {
        return ((VirtualQCPPlottableLegendItem*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPPlottableLegendItem_QBaseReceivers(const QCPPlottableLegendItem* self, const char* signal) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_Receivers_IsBase(true);
        return vqcpplottablelegenditem->receivers(signal);
    } else {
        return ((VirtualQCPPlottableLegendItem*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnReceivers(const QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_Receivers_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPPlottableLegendItem_IsSignalConnected(const QCPPlottableLegendItem* self, const QMetaMethod* signal) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        return vqcpplottablelegenditem->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPPlottableLegendItem*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPPlottableLegendItem_QBaseIsSignalConnected(const QCPPlottableLegendItem* self, const QMetaMethod* signal) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_IsSignalConnected_IsBase(true);
        return vqcpplottablelegenditem->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPPlottableLegendItem*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPlottableLegendItem_OnIsSignalConnected(const QCPPlottableLegendItem* self, intptr_t slot) {
    auto* vqcpplottablelegenditem = const_cast<VirtualQCPPlottableLegendItem*>(dynamic_cast<const VirtualQCPPlottableLegendItem*>(self));
    if (vqcpplottablelegenditem && vqcpplottablelegenditem->isVirtualQCPPlottableLegendItem) {
        vqcpplottablelegenditem->setQCPPlottableLegendItem_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPPlottableLegendItem::QCPPlottableLegendItem_IsSignalConnected_Callback>(slot));
    }
}

void QCPPlottableLegendItem_Delete(QCPPlottableLegendItem* self) {
    delete self;
}

QCPLegend* QCPLegend_new() {
    return new VirtualQCPLegend();
}

QMetaObject* QCPLegend_MetaObject(const QCPLegend* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPLegend_Metacast(QCPLegend* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPLegend_Metacall(QCPLegend* self, int param1, int param2, void** param3) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPLegend*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPLegend_Tr(const char* s) {
    QString _ret = QCPLegend::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

QPen* QCPLegend_BorderPen(const QCPLegend* self) {
    return new QPen(self->borderPen());
}

QBrush* QCPLegend_Brush(const QCPLegend* self) {
    return new QBrush(self->brush());
}

QFont* QCPLegend_Font(const QCPLegend* self) {
    return new QFont(self->font());
}

QColor* QCPLegend_TextColor(const QCPLegend* self) {
    return new QColor(self->textColor());
}

QSize* QCPLegend_IconSize(const QCPLegend* self) {
    return new QSize(self->iconSize());
}

int QCPLegend_IconTextPadding(const QCPLegend* self) {
    return self->iconTextPadding();
}

QPen* QCPLegend_IconBorderPen(const QCPLegend* self) {
    return new QPen(self->iconBorderPen());
}

int QCPLegend_SelectableParts(const QCPLegend* self) {
    return static_cast<int>(self->selectableParts());
}

int QCPLegend_SelectedParts(const QCPLegend* self) {
    return static_cast<int>(self->selectedParts());
}

QPen* QCPLegend_SelectedBorderPen(const QCPLegend* self) {
    return new QPen(self->selectedBorderPen());
}

QPen* QCPLegend_SelectedIconBorderPen(const QCPLegend* self) {
    return new QPen(self->selectedIconBorderPen());
}

QBrush* QCPLegend_SelectedBrush(const QCPLegend* self) {
    return new QBrush(self->selectedBrush());
}

QFont* QCPLegend_SelectedFont(const QCPLegend* self) {
    return new QFont(self->selectedFont());
}

QColor* QCPLegend_SelectedTextColor(const QCPLegend* self) {
    return new QColor(self->selectedTextColor());
}

void QCPLegend_SetBorderPen(QCPLegend* self, const QPen* pen) {
    self->setBorderPen(*pen);
}

void QCPLegend_SetBrush(QCPLegend* self, const QBrush* brush) {
    self->setBrush(*brush);
}

void QCPLegend_SetFont(QCPLegend* self, const QFont* font) {
    self->setFont(*font);
}

void QCPLegend_SetTextColor(QCPLegend* self, const QColor* color) {
    self->setTextColor(*color);
}

void QCPLegend_SetIconSize(QCPLegend* self, const QSize* size) {
    self->setIconSize(*size);
}

void QCPLegend_SetIconSize2(QCPLegend* self, int width, int height) {
    self->setIconSize(static_cast<int>(width), static_cast<int>(height));
}

void QCPLegend_SetIconTextPadding(QCPLegend* self, int padding) {
    self->setIconTextPadding(static_cast<int>(padding));
}

void QCPLegend_SetIconBorderPen(QCPLegend* self, const QPen* pen) {
    self->setIconBorderPen(*pen);
}

void QCPLegend_SetSelectableParts(QCPLegend* self, const int* selectableParts) {
    self->setSelectableParts((const QCPLegend::SelectableParts&)(*selectableParts));
}

void QCPLegend_SetSelectedParts(QCPLegend* self, const int* selectedParts) {
    self->setSelectedParts((const QCPLegend::SelectableParts&)(*selectedParts));
}

void QCPLegend_SetSelectedBorderPen(QCPLegend* self, const QPen* pen) {
    self->setSelectedBorderPen(*pen);
}

void QCPLegend_SetSelectedIconBorderPen(QCPLegend* self, const QPen* pen) {
    self->setSelectedIconBorderPen(*pen);
}

void QCPLegend_SetSelectedBrush(QCPLegend* self, const QBrush* brush) {
    self->setSelectedBrush(*brush);
}

void QCPLegend_SetSelectedFont(QCPLegend* self, const QFont* font) {
    self->setSelectedFont(*font);
}

void QCPLegend_SetSelectedTextColor(QCPLegend* self, const QColor* color) {
    self->setSelectedTextColor(*color);
}

double QCPLegend_SelectTest(const QCPLegend* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcplegend = dynamic_cast<const VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPLegend*)self)->selectTest(*pos, onlySelectable, details);
    }
}

QCPAbstractLegendItem* QCPLegend_Item(const QCPLegend* self, int index) {
    return self->item(static_cast<int>(index));
}

QCPPlottableLegendItem* QCPLegend_ItemWithPlottable(const QCPLegend* self, const QCPAbstractPlottable* plottable) {
    return self->itemWithPlottable(plottable);
}

int QCPLegend_ItemCount(const QCPLegend* self) {
    return self->itemCount();
}

bool QCPLegend_HasItem(const QCPLegend* self, QCPAbstractLegendItem* item) {
    return self->hasItem(item);
}

bool QCPLegend_HasItemWithPlottable(const QCPLegend* self, const QCPAbstractPlottable* plottable) {
    return self->hasItemWithPlottable(plottable);
}

bool QCPLegend_AddItem(QCPLegend* self, QCPAbstractLegendItem* item) {
    return self->addItem(item);
}

bool QCPLegend_RemoveItem(QCPLegend* self, int index) {
    return self->removeItem(static_cast<int>(index));
}

bool QCPLegend_RemoveItem2(QCPLegend* self, QCPAbstractLegendItem* item) {
    return self->removeItem(item);
}

void QCPLegend_ClearItems(QCPLegend* self) {
    self->clearItems();
}

libqt_list /* of QCPAbstractLegendItem* */ QCPLegend_SelectedItems(const QCPLegend* self) {
    QList<QCPAbstractLegendItem*> _ret = self->selectedItems();
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPAbstractLegendItem** _arr = static_cast<QCPAbstractLegendItem**>(malloc(sizeof(QCPAbstractLegendItem*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

void QCPLegend_SelectionChanged(QCPLegend* self, int parts) {
    self->selectionChanged(static_cast<QCPLegend::SelectableParts>(parts));
}

void QCPLegend_Connect_SelectionChanged(QCPLegend* self, intptr_t slot) {
    void (*slotFunc)(QCPLegend*, int) = reinterpret_cast<void (*)(QCPLegend*, int)>(slot);
    QCPLegend::connect(self, &QCPLegend::selectionChanged, [self, slotFunc](QCPLegend::SelectableParts parts) {
        int sigval1 = static_cast<int>(parts);
        slotFunc(self, sigval1);
    });
}

void QCPLegend_SelectableChanged(QCPLegend* self, int parts) {
    self->selectableChanged(static_cast<QCPLegend::SelectableParts>(parts));
}

void QCPLegend_Connect_SelectableChanged(QCPLegend* self, intptr_t slot) {
    void (*slotFunc)(QCPLegend*, int) = reinterpret_cast<void (*)(QCPLegend*, int)>(slot);
    QCPLegend::connect(self, &QCPLegend::selectableChanged, [self, slotFunc](QCPLegend::SelectableParts parts) {
        int sigval1 = static_cast<int>(parts);
        slotFunc(self, sigval1);
    });
}

void QCPLegend_ParentPlotInitialized(QCPLegend* self, QCustomPlot* parentPlot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->parentPlotInitialized(parentPlot);
    }
}

int QCPLegend_SelectionCategory(const QCPLegend* self) {
    auto* vqcplegend = dynamic_cast<const VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        return static_cast<int>(vqcplegend->selectionCategory());
    }
    return {};
}

void QCPLegend_ApplyDefaultAntialiasingHint(const QCPLegend* self, QCPPainter* painter) {
    auto* vqcplegend = dynamic_cast<const VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->applyDefaultAntialiasingHint(painter);
    }
}

void QCPLegend_Draw(QCPLegend* self, QCPPainter* painter) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->draw(painter);
    }
}

void QCPLegend_SelectEvent(QCPLegend* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

void QCPLegend_DeselectEvent(QCPLegend* self, bool* selectionStateChanged) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->deselectEvent(selectionStateChanged);
    }
}

libqt_string QCPLegend_Tr2(const char* s, const char* c) {
    QString _ret = QCPLegend::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPLegend_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPLegend::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPLegend_QBaseMetacall(QCPLegend* self, int param1, int param2, void** param3) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_Metacall_IsBase(true);
        return vqcplegend->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPLegend::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnMetacall(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_Metacall_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
double QCPLegend_QBaseSelectTest(const QCPLegend* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_SelectTest_IsBase(true);
        return vqcplegend->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPLegend::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnSelectTest(const QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_SelectTest_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLegend_QBaseParentPlotInitialized(QCPLegend* self, QCustomPlot* parentPlot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_ParentPlotInitialized_IsBase(true);
        vqcplegend->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPLegend*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnParentPlotInitialized(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_ParentPlotInitialized_Callback>(slot));
    }
}

// Base class handler implementation
int QCPLegend_QBaseSelectionCategory(const QCPLegend* self) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcplegend->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPLegend*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnSelectionCategory(const QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_SelectionCategory_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_SelectionCategory_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLegend_QBaseApplyDefaultAntialiasingHint(const QCPLegend* self, QCPPainter* painter) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcplegend->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPLegend*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnApplyDefaultAntialiasingHint(const QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLegend_QBaseDraw(QCPLegend* self, QCPPainter* painter) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_Draw_IsBase(true);
        vqcplegend->draw(painter);
    } else {
        ((VirtualQCPLegend*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnDraw(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_Draw_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_Draw_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLegend_QBaseSelectEvent(QCPLegend* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_SelectEvent_IsBase(true);
        vqcplegend->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPLegend*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnSelectEvent(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_SelectEvent_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_SelectEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPLegend_QBaseDeselectEvent(QCPLegend* self, bool* selectionStateChanged) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_DeselectEvent_IsBase(true);
        vqcplegend->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPLegend*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnDeselectEvent(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_DeselectEvent_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLegend_UpdateLayout(QCPLegend* self) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->updateLayout();
    } else {
        self->QCPLegend::updateLayout();
    }
}

// Base class handler implementation
void QCPLegend_QBaseUpdateLayout(QCPLegend* self) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_UpdateLayout_IsBase(true);
        vqcplegend->updateLayout();
    } else {
        self->QCPLegend::updateLayout();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnUpdateLayout(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_UpdateLayout_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_UpdateLayout_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPLegend_ElementCount(const QCPLegend* self) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        return vqcplegend->elementCount();
    } else {
        return self->QCPLegend::elementCount();
    }
}

// Base class handler implementation
int QCPLegend_QBaseElementCount(const QCPLegend* self) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_ElementCount_IsBase(true);
        return vqcplegend->elementCount();
    } else {
        return self->QCPLegend::elementCount();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnElementCount(const QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_ElementCount_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_ElementCount_Callback>(slot));
    }
}

// Derived class handler implementation
QCPLayoutElement* QCPLegend_ElementAt(const QCPLegend* self, int index) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        return vqcplegend->elementAt(static_cast<int>(index));
    } else {
        return self->QCPLegend::elementAt(static_cast<int>(index));
    }
}

// Base class handler implementation
QCPLayoutElement* QCPLegend_QBaseElementAt(const QCPLegend* self, int index) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_ElementAt_IsBase(true);
        return vqcplegend->elementAt(static_cast<int>(index));
    } else {
        return self->QCPLegend::elementAt(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnElementAt(const QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_ElementAt_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_ElementAt_Callback>(slot));
    }
}

// Derived class handler implementation
QCPLayoutElement* QCPLegend_TakeAt(QCPLegend* self, int index) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        return vqcplegend->takeAt(static_cast<int>(index));
    } else {
        return self->QCPLegend::takeAt(static_cast<int>(index));
    }
}

// Base class handler implementation
QCPLayoutElement* QCPLegend_QBaseTakeAt(QCPLegend* self, int index) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_TakeAt_IsBase(true);
        return vqcplegend->takeAt(static_cast<int>(index));
    } else {
        return self->QCPLegend::takeAt(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnTakeAt(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_TakeAt_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_TakeAt_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLegend_Take(QCPLegend* self, QCPLayoutElement* element) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        return vqcplegend->take(element);
    } else {
        return self->QCPLegend::take(element);
    }
}

// Base class handler implementation
bool QCPLegend_QBaseTake(QCPLegend* self, QCPLayoutElement* element) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_Take_IsBase(true);
        return vqcplegend->take(element);
    } else {
        return self->QCPLegend::take(element);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnTake(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_Take_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_Take_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of QCPLayoutElement* */ QCPLegend_Elements(const QCPLegend* self, bool recursive) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        QList<QCPLayoutElement*> _ret = vqcplegend->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayoutElement*> _ret = self->QCPLegend::elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of QCPLayoutElement* */ QCPLegend_QBaseElements(const QCPLegend* self, bool recursive) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_Elements_IsBase(true);
        QList<QCPLayoutElement*> _ret = vqcplegend->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayoutElement*> _ret = self->QCPLegend::elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnElements(const QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_Elements_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_Elements_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLegend_Simplify(QCPLegend* self) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->simplify();
    } else {
        self->QCPLegend::simplify();
    }
}

// Base class handler implementation
void QCPLegend_QBaseSimplify(QCPLegend* self) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_Simplify_IsBase(true);
        vqcplegend->simplify();
    } else {
        self->QCPLegend::simplify();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnSimplify(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_Simplify_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_Simplify_Callback>(slot));
    }
}

// Derived class handler implementation
QSize* QCPLegend_MinimumOuterSizeHint(const QCPLegend* self) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        return new QSize(vqcplegend->minimumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPLegend*)self)->minimumOuterSizeHint());
    }
}

// Base class handler implementation
QSize* QCPLegend_QBaseMinimumOuterSizeHint(const QCPLegend* self) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_MinimumOuterSizeHint_IsBase(true);
        return new QSize(vqcplegend->minimumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPLegend*)self)->minimumOuterSizeHint());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnMinimumOuterSizeHint(const QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_MinimumOuterSizeHint_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_MinimumOuterSizeHint_Callback>(slot));
    }
}

// Derived class handler implementation
QSize* QCPLegend_MaximumOuterSizeHint(const QCPLegend* self) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        return new QSize(vqcplegend->maximumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPLegend*)self)->maximumOuterSizeHint());
    }
}

// Base class handler implementation
QSize* QCPLegend_QBaseMaximumOuterSizeHint(const QCPLegend* self) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_MaximumOuterSizeHint_IsBase(true);
        return new QSize(vqcplegend->maximumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPLegend*)self)->maximumOuterSizeHint());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnMaximumOuterSizeHint(const QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_MaximumOuterSizeHint_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_MaximumOuterSizeHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLegend_Update(QCPLegend* self, int phase) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    } else {
        self->QCPLegend::update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    }
}

// Base class handler implementation
void QCPLegend_QBaseUpdate(QCPLegend* self, int phase) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_Update_IsBase(true);
        vqcplegend->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    } else {
        self->QCPLegend::update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnUpdate(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_Update_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_Update_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPLegend_CalculateAutoMargin(QCPLegend* self, int side) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        return vqcplegend->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    } else {
        return ((VirtualQCPLegend*)self)->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    }
}

// Base class handler implementation
int QCPLegend_QBaseCalculateAutoMargin(QCPLegend* self, int side) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_CalculateAutoMargin_IsBase(true);
        return vqcplegend->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    } else {
        return ((VirtualQCPLegend*)self)->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnCalculateAutoMargin(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_CalculateAutoMargin_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_CalculateAutoMargin_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLegend_LayoutChanged(QCPLegend* self) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->layoutChanged();
    } else {
        ((VirtualQCPLegend*)self)->layoutChanged();
    }
}

// Base class handler implementation
void QCPLegend_QBaseLayoutChanged(QCPLegend* self) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_LayoutChanged_IsBase(true);
        vqcplegend->layoutChanged();
    } else {
        ((VirtualQCPLegend*)self)->layoutChanged();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnLayoutChanged(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_LayoutChanged_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_LayoutChanged_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPLegend_ClipRect(const QCPLegend* self) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        return new QRect(vqcplegend->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPLegend_QBaseClipRect(const QCPLegend* self) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_ClipRect_IsBase(true);
        return new QRect(vqcplegend->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnClipRect(const QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_ClipRect_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLegend_MousePressEvent(QCPLegend* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPLegend*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPLegend_QBaseMousePressEvent(QCPLegend* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_MousePressEvent_IsBase(true);
        vqcplegend->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPLegend*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnMousePressEvent(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_MousePressEvent_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLegend_MouseMoveEvent(QCPLegend* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPLegend*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPLegend_QBaseMouseMoveEvent(QCPLegend* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_MouseMoveEvent_IsBase(true);
        vqcplegend->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPLegend*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnMouseMoveEvent(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLegend_MouseReleaseEvent(QCPLegend* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPLegend*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPLegend_QBaseMouseReleaseEvent(QCPLegend* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_MouseReleaseEvent_IsBase(true);
        vqcplegend->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPLegend*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnMouseReleaseEvent(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLegend_MouseDoubleClickEvent(QCPLegend* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPLegend*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPLegend_QBaseMouseDoubleClickEvent(QCPLegend* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_MouseDoubleClickEvent_IsBase(true);
        vqcplegend->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPLegend*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnMouseDoubleClickEvent(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLegend_WheelEvent(QCPLegend* self, QWheelEvent* event) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->wheelEvent(event);
    } else {
        ((VirtualQCPLegend*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPLegend_QBaseWheelEvent(QCPLegend* self, QWheelEvent* event) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_WheelEvent_IsBase(true);
        vqcplegend->wheelEvent(event);
    } else {
        ((VirtualQCPLegend*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnWheelEvent(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_WheelEvent_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLegend_Event(QCPLegend* self, QEvent* event) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        return vqcplegend->event(event);
    } else {
        return self->QCPLegend::event(event);
    }
}

// Base class handler implementation
bool QCPLegend_QBaseEvent(QCPLegend* self, QEvent* event) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_Event_IsBase(true);
        return vqcplegend->event(event);
    } else {
        return self->QCPLegend::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnEvent(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_Event_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLegend_EventFilter(QCPLegend* self, QObject* watched, QEvent* event) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        return vqcplegend->eventFilter(watched, event);
    } else {
        return self->QCPLegend::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPLegend_QBaseEventFilter(QCPLegend* self, QObject* watched, QEvent* event) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_EventFilter_IsBase(true);
        return vqcplegend->eventFilter(watched, event);
    } else {
        return self->QCPLegend::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnEventFilter(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_EventFilter_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLegend_TimerEvent(QCPLegend* self, QTimerEvent* event) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->timerEvent(event);
    } else {
        ((VirtualQCPLegend*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPLegend_QBaseTimerEvent(QCPLegend* self, QTimerEvent* event) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_TimerEvent_IsBase(true);
        vqcplegend->timerEvent(event);
    } else {
        ((VirtualQCPLegend*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnTimerEvent(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_TimerEvent_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLegend_ChildEvent(QCPLegend* self, QChildEvent* event) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->childEvent(event);
    } else {
        ((VirtualQCPLegend*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPLegend_QBaseChildEvent(QCPLegend* self, QChildEvent* event) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_ChildEvent_IsBase(true);
        vqcplegend->childEvent(event);
    } else {
        ((VirtualQCPLegend*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnChildEvent(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_ChildEvent_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLegend_CustomEvent(QCPLegend* self, QEvent* event) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->customEvent(event);
    } else {
        ((VirtualQCPLegend*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPLegend_QBaseCustomEvent(QCPLegend* self, QEvent* event) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_CustomEvent_IsBase(true);
        vqcplegend->customEvent(event);
    } else {
        ((VirtualQCPLegend*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnCustomEvent(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_CustomEvent_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLegend_ConnectNotify(QCPLegend* self, const QMetaMethod* signal) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->connectNotify(*signal);
    } else {
        ((VirtualQCPLegend*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPLegend_QBaseConnectNotify(QCPLegend* self, const QMetaMethod* signal) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_ConnectNotify_IsBase(true);
        vqcplegend->connectNotify(*signal);
    } else {
        ((VirtualQCPLegend*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnConnectNotify(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_ConnectNotify_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLegend_DisconnectNotify(QCPLegend* self, const QMetaMethod* signal) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->disconnectNotify(*signal);
    } else {
        ((VirtualQCPLegend*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPLegend_QBaseDisconnectNotify(QCPLegend* self, const QMetaMethod* signal) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_DisconnectNotify_IsBase(true);
        vqcplegend->disconnectNotify(*signal);
    } else {
        ((VirtualQCPLegend*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnDisconnectNotify(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
QPen* QCPLegend_GetBorderPen(const QCPLegend* self) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        return new QPen(vqcplegend->getBorderPen());
    }
    return {};
}

// Base class handler implementation
QPen* QCPLegend_QBaseGetBorderPen(const QCPLegend* self) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_GetBorderPen_IsBase(true);
        return new QPen(vqcplegend->getBorderPen());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnGetBorderPen(const QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_GetBorderPen_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_GetBorderPen_Callback>(slot));
    }
}

// Derived class handler implementation
QBrush* QCPLegend_GetBrush(const QCPLegend* self) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        return new QBrush(vqcplegend->getBrush());
    }
    return {};
}

// Base class handler implementation
QBrush* QCPLegend_QBaseGetBrush(const QCPLegend* self) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_GetBrush_IsBase(true);
        return new QBrush(vqcplegend->getBrush());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnGetBrush(const QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_GetBrush_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_GetBrush_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLegend_GetMinimumRowColSizes(const QCPLegend* self, libqt_list /* of int */ minColWidths, libqt_list /* of int */ minRowHeights) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    QVector<int> minColWidths_QVector;
    minColWidths_QVector.reserve(minColWidths.len);
    int* minColWidths_arr = static_cast<int*>(minColWidths.data);
    for (size_t i = 0; i < minColWidths.len; ++i) {
        minColWidths_QVector.push_back(static_cast<int>(minColWidths_arr[i]));
    }
    QVector<int> minRowHeights_QVector;
    minRowHeights_QVector.reserve(minRowHeights.len);
    int* minRowHeights_arr = static_cast<int*>(minRowHeights.data);
    for (size_t i = 0; i < minRowHeights.len; ++i) {
        minRowHeights_QVector.push_back(static_cast<int>(minRowHeights_arr[i]));
    }
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->getMinimumRowColSizes(&minColWidths_QVector, &minRowHeights_QVector);
    } else {
        ((VirtualQCPLegend*)self)->getMinimumRowColSizes(&minColWidths_QVector, &minRowHeights_QVector);
    }
}

// Base class handler implementation
void QCPLegend_QBaseGetMinimumRowColSizes(const QCPLegend* self, libqt_list /* of int */ minColWidths, libqt_list /* of int */ minRowHeights) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    QVector<int> minColWidths_QVector;
    minColWidths_QVector.reserve(minColWidths.len);
    int* minColWidths_arr = static_cast<int*>(minColWidths.data);
    for (size_t i = 0; i < minColWidths.len; ++i) {
        minColWidths_QVector.push_back(static_cast<int>(minColWidths_arr[i]));
    }
    QVector<int> minRowHeights_QVector;
    minRowHeights_QVector.reserve(minRowHeights.len);
    int* minRowHeights_arr = static_cast<int*>(minRowHeights.data);
    for (size_t i = 0; i < minRowHeights.len; ++i) {
        minRowHeights_QVector.push_back(static_cast<int>(minRowHeights_arr[i]));
    }
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_GetMinimumRowColSizes_IsBase(true);
        vqcplegend->getMinimumRowColSizes(&minColWidths_QVector, &minRowHeights_QVector);
    } else {
        ((VirtualQCPLegend*)self)->getMinimumRowColSizes(&minColWidths_QVector, &minRowHeights_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnGetMinimumRowColSizes(const QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_GetMinimumRowColSizes_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_GetMinimumRowColSizes_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLegend_GetMaximumRowColSizes(const QCPLegend* self, libqt_list /* of int */ maxColWidths, libqt_list /* of int */ maxRowHeights) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    QVector<int> maxColWidths_QVector;
    maxColWidths_QVector.reserve(maxColWidths.len);
    int* maxColWidths_arr = static_cast<int*>(maxColWidths.data);
    for (size_t i = 0; i < maxColWidths.len; ++i) {
        maxColWidths_QVector.push_back(static_cast<int>(maxColWidths_arr[i]));
    }
    QVector<int> maxRowHeights_QVector;
    maxRowHeights_QVector.reserve(maxRowHeights.len);
    int* maxRowHeights_arr = static_cast<int*>(maxRowHeights.data);
    for (size_t i = 0; i < maxRowHeights.len; ++i) {
        maxRowHeights_QVector.push_back(static_cast<int>(maxRowHeights_arr[i]));
    }
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->getMaximumRowColSizes(&maxColWidths_QVector, &maxRowHeights_QVector);
    } else {
        ((VirtualQCPLegend*)self)->getMaximumRowColSizes(&maxColWidths_QVector, &maxRowHeights_QVector);
    }
}

// Base class handler implementation
void QCPLegend_QBaseGetMaximumRowColSizes(const QCPLegend* self, libqt_list /* of int */ maxColWidths, libqt_list /* of int */ maxRowHeights) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    QVector<int> maxColWidths_QVector;
    maxColWidths_QVector.reserve(maxColWidths.len);
    int* maxColWidths_arr = static_cast<int*>(maxColWidths.data);
    for (size_t i = 0; i < maxColWidths.len; ++i) {
        maxColWidths_QVector.push_back(static_cast<int>(maxColWidths_arr[i]));
    }
    QVector<int> maxRowHeights_QVector;
    maxRowHeights_QVector.reserve(maxRowHeights.len);
    int* maxRowHeights_arr = static_cast<int*>(maxRowHeights.data);
    for (size_t i = 0; i < maxRowHeights.len; ++i) {
        maxRowHeights_QVector.push_back(static_cast<int>(maxRowHeights_arr[i]));
    }
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_GetMaximumRowColSizes_IsBase(true);
        vqcplegend->getMaximumRowColSizes(&maxColWidths_QVector, &maxRowHeights_QVector);
    } else {
        ((VirtualQCPLegend*)self)->getMaximumRowColSizes(&maxColWidths_QVector, &maxRowHeights_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnGetMaximumRowColSizes(const QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_GetMaximumRowColSizes_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_GetMaximumRowColSizes_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLegend_SizeConstraintsChanged(const QCPLegend* self) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->sizeConstraintsChanged();
    } else {
        ((VirtualQCPLegend*)self)->sizeConstraintsChanged();
    }
}

// Base class handler implementation
void QCPLegend_QBaseSizeConstraintsChanged(const QCPLegend* self) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_SizeConstraintsChanged_IsBase(true);
        vqcplegend->sizeConstraintsChanged();
    } else {
        ((VirtualQCPLegend*)self)->sizeConstraintsChanged();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnSizeConstraintsChanged(const QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_SizeConstraintsChanged_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_SizeConstraintsChanged_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLegend_AdoptElement(QCPLegend* self, QCPLayoutElement* el) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->adoptElement(el);
    } else {
        ((VirtualQCPLegend*)self)->adoptElement(el);
    }
}

// Base class handler implementation
void QCPLegend_QBaseAdoptElement(QCPLegend* self, QCPLayoutElement* el) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_AdoptElement_IsBase(true);
        vqcplegend->adoptElement(el);
    } else {
        ((VirtualQCPLegend*)self)->adoptElement(el);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnAdoptElement(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_AdoptElement_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_AdoptElement_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLegend_ReleaseElement(QCPLegend* self, QCPLayoutElement* el) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->releaseElement(el);
    } else {
        ((VirtualQCPLegend*)self)->releaseElement(el);
    }
}

// Base class handler implementation
void QCPLegend_QBaseReleaseElement(QCPLegend* self, QCPLayoutElement* el) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_ReleaseElement_IsBase(true);
        vqcplegend->releaseElement(el);
    } else {
        ((VirtualQCPLegend*)self)->releaseElement(el);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnReleaseElement(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_ReleaseElement_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_ReleaseElement_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of int */ QCPLegend_GetSectionSizes(const QCPLegend* self, libqt_list /* of int */ maxSizes, libqt_list /* of int */ minSizes, libqt_list /* of double */ stretchFactors, int totalSize) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    QVector<int> maxSizes_QVector;
    maxSizes_QVector.reserve(maxSizes.len);
    int* maxSizes_arr = static_cast<int*>(maxSizes.data);
    for (size_t i = 0; i < maxSizes.len; ++i) {
        maxSizes_QVector.push_back(static_cast<int>(maxSizes_arr[i]));
    }
    QVector<int> minSizes_QVector;
    minSizes_QVector.reserve(minSizes.len);
    int* minSizes_arr = static_cast<int*>(minSizes.data);
    for (size_t i = 0; i < minSizes.len; ++i) {
        minSizes_QVector.push_back(static_cast<int>(minSizes_arr[i]));
    }
    QVector<double> stretchFactors_QVector;
    stretchFactors_QVector.reserve(stretchFactors.len);
    double* stretchFactors_arr = static_cast<double*>(stretchFactors.data);
    for (size_t i = 0; i < stretchFactors.len; ++i) {
        stretchFactors_QVector.push_back(static_cast<double>(stretchFactors_arr[i]));
    }
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        QVector<int> _ret = vqcplegend->getSectionSizes(maxSizes_QVector, minSizes_QVector, stretchFactors_QVector, static_cast<int>(totalSize));
        // Convert QVector<> from C++ memory to manually-managed C memory
        int* _arr = static_cast<int*>(malloc(sizeof(int) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<int> _ret = ((VirtualQCPLegend*)self)->getSectionSizes(maxSizes_QVector, minSizes_QVector, stretchFactors_QVector, static_cast<int>(totalSize));
        // Convert QVector<> from C++ memory to manually-managed C memory
        int* _arr = static_cast<int*>(malloc(sizeof(int) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of int */ QCPLegend_QBaseGetSectionSizes(const QCPLegend* self, libqt_list /* of int */ maxSizes, libqt_list /* of int */ minSizes, libqt_list /* of double */ stretchFactors, int totalSize) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    QVector<int> maxSizes_QVector;
    maxSizes_QVector.reserve(maxSizes.len);
    int* maxSizes_arr = static_cast<int*>(maxSizes.data);
    for (size_t i = 0; i < maxSizes.len; ++i) {
        maxSizes_QVector.push_back(static_cast<int>(maxSizes_arr[i]));
    }
    QVector<int> minSizes_QVector;
    minSizes_QVector.reserve(minSizes.len);
    int* minSizes_arr = static_cast<int*>(minSizes.data);
    for (size_t i = 0; i < minSizes.len; ++i) {
        minSizes_QVector.push_back(static_cast<int>(minSizes_arr[i]));
    }
    QVector<double> stretchFactors_QVector;
    stretchFactors_QVector.reserve(stretchFactors.len);
    double* stretchFactors_arr = static_cast<double*>(stretchFactors.data);
    for (size_t i = 0; i < stretchFactors.len; ++i) {
        stretchFactors_QVector.push_back(static_cast<double>(stretchFactors_arr[i]));
    }
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_GetSectionSizes_IsBase(true);
        QVector<int> _ret = vqcplegend->getSectionSizes(maxSizes_QVector, minSizes_QVector, stretchFactors_QVector, static_cast<int>(totalSize));
        // Convert QVector<> from C++ memory to manually-managed C memory
        int* _arr = static_cast<int*>(malloc(sizeof(int) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<int> _ret = ((VirtualQCPLegend*)self)->getSectionSizes(maxSizes_QVector, minSizes_QVector, stretchFactors_QVector, static_cast<int>(totalSize));
        // Convert QVector<> from C++ memory to manually-managed C memory
        int* _arr = static_cast<int*>(malloc(sizeof(int) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnGetSectionSizes(const QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_GetSectionSizes_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_GetSectionSizes_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLegend_InitializeParentPlot(QCPLegend* self, QCustomPlot* parentPlot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPLegend*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPLegend_QBaseInitializeParentPlot(QCPLegend* self, QCustomPlot* parentPlot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_InitializeParentPlot_IsBase(true);
        vqcplegend->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPLegend*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnInitializeParentPlot(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLegend_SetParentLayerable(QCPLegend* self, QCPLayerable* parentLayerable) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPLegend*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPLegend_QBaseSetParentLayerable(QCPLegend* self, QCPLayerable* parentLayerable) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_SetParentLayerable_IsBase(true);
        vqcplegend->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPLegend*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnSetParentLayerable(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLegend_MoveToLayer(QCPLegend* self, QCPLayer* layer, bool prepend) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        return vqcplegend->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPLegend*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPLegend_QBaseMoveToLayer(QCPLegend* self, QCPLayer* layer, bool prepend) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_MoveToLayer_IsBase(true);
        return vqcplegend->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPLegend*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnMoveToLayer(QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = dynamic_cast<VirtualQCPLegend*>(self);
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_MoveToLayer_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPLegend_ApplyAntialiasingHint(const QCPLegend* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPLegend*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPLegend_QBaseApplyAntialiasingHint(const QCPLegend* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_ApplyAntialiasingHint_IsBase(true);
        vqcplegend->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPLegend*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnApplyAntialiasingHint(const QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPLegend_Sender(const QCPLegend* self) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        return vqcplegend->sender();
    } else {
        return ((VirtualQCPLegend*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPLegend_QBaseSender(const QCPLegend* self) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_Sender_IsBase(true);
        return vqcplegend->sender();
    } else {
        return ((VirtualQCPLegend*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnSender(const QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_Sender_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPLegend_SenderSignalIndex(const QCPLegend* self) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        return vqcplegend->senderSignalIndex();
    } else {
        return ((VirtualQCPLegend*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPLegend_QBaseSenderSignalIndex(const QCPLegend* self) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_SenderSignalIndex_IsBase(true);
        return vqcplegend->senderSignalIndex();
    } else {
        return ((VirtualQCPLegend*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnSenderSignalIndex(const QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPLegend_Receivers(const QCPLegend* self, const char* signal) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        return vqcplegend->receivers(signal);
    } else {
        return ((VirtualQCPLegend*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPLegend_QBaseReceivers(const QCPLegend* self, const char* signal) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_Receivers_IsBase(true);
        return vqcplegend->receivers(signal);
    } else {
        return ((VirtualQCPLegend*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnReceivers(const QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_Receivers_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPLegend_IsSignalConnected(const QCPLegend* self, const QMetaMethod* signal) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        return vqcplegend->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPLegend*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPLegend_QBaseIsSignalConnected(const QCPLegend* self, const QMetaMethod* signal) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_IsSignalConnected_IsBase(true);
        return vqcplegend->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPLegend*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPLegend_OnIsSignalConnected(const QCPLegend* self, intptr_t slot) {
    auto* vqcplegend = const_cast<VirtualQCPLegend*>(dynamic_cast<const VirtualQCPLegend*>(self));
    if (vqcplegend && vqcplegend->isVirtualQCPLegend) {
        vqcplegend->setQCPLegend_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPLegend::QCPLegend_IsSignalConnected_Callback>(slot));
    }
}

void QCPLegend_Delete(QCPLegend* self) {
    delete self;
}

QCPTextElement* QCPTextElement_new(QCustomPlot* parentPlot) {
    return new VirtualQCPTextElement(parentPlot);
}

QCPTextElement* QCPTextElement_new2(QCustomPlot* parentPlot, const libqt_string text) {
    QString text_QString = QString::fromUtf8(text.data, text.len);
    return new VirtualQCPTextElement(parentPlot, text_QString);
}

QCPTextElement* QCPTextElement_new3(QCustomPlot* parentPlot, const libqt_string text, double pointSize) {
    QString text_QString = QString::fromUtf8(text.data, text.len);
    return new VirtualQCPTextElement(parentPlot, text_QString, static_cast<double>(pointSize));
}

QCPTextElement* QCPTextElement_new4(QCustomPlot* parentPlot, const libqt_string text, const libqt_string fontFamily, double pointSize) {
    QString text_QString = QString::fromUtf8(text.data, text.len);
    QString fontFamily_QString = QString::fromUtf8(fontFamily.data, fontFamily.len);
    return new VirtualQCPTextElement(parentPlot, text_QString, fontFamily_QString, static_cast<double>(pointSize));
}

QCPTextElement* QCPTextElement_new5(QCustomPlot* parentPlot, const libqt_string text, const QFont* font) {
    QString text_QString = QString::fromUtf8(text.data, text.len);
    return new VirtualQCPTextElement(parentPlot, text_QString, *font);
}

QMetaObject* QCPTextElement_MetaObject(const QCPTextElement* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPTextElement_Metacast(QCPTextElement* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPTextElement_Metacall(QCPTextElement* self, int param1, int param2, void** param3) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPTextElement*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPTextElement_Tr(const char* s) {
    QString _ret = QCPTextElement::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPTextElement_Text(const QCPTextElement* self) {
    QString _ret = self->text();
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

int QCPTextElement_TextFlags(const QCPTextElement* self) {
    return self->textFlags();
}

QFont* QCPTextElement_Font(const QCPTextElement* self) {
    return new QFont(self->font());
}

QColor* QCPTextElement_TextColor(const QCPTextElement* self) {
    return new QColor(self->textColor());
}

QFont* QCPTextElement_SelectedFont(const QCPTextElement* self) {
    return new QFont(self->selectedFont());
}

QColor* QCPTextElement_SelectedTextColor(const QCPTextElement* self) {
    return new QColor(self->selectedTextColor());
}

bool QCPTextElement_Selectable(const QCPTextElement* self) {
    return self->selectable();
}

bool QCPTextElement_Selected(const QCPTextElement* self) {
    return self->selected();
}

void QCPTextElement_SetText(QCPTextElement* self, const libqt_string text) {
    QString text_QString = QString::fromUtf8(text.data, text.len);
    self->setText(text_QString);
}

void QCPTextElement_SetTextFlags(QCPTextElement* self, int flags) {
    self->setTextFlags(static_cast<int>(flags));
}

void QCPTextElement_SetFont(QCPTextElement* self, const QFont* font) {
    self->setFont(*font);
}

void QCPTextElement_SetTextColor(QCPTextElement* self, const QColor* color) {
    self->setTextColor(*color);
}

void QCPTextElement_SetSelectedFont(QCPTextElement* self, const QFont* font) {
    self->setSelectedFont(*font);
}

void QCPTextElement_SetSelectedTextColor(QCPTextElement* self, const QColor* color) {
    self->setSelectedTextColor(*color);
}

void QCPTextElement_SetSelectable(QCPTextElement* self, bool selectable) {
    self->setSelectable(selectable);
}

void QCPTextElement_SetSelected(QCPTextElement* self, bool selected) {
    self->setSelected(selected);
}

double QCPTextElement_SelectTest(const QCPTextElement* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcptextelement = dynamic_cast<const VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPTextElement*)self)->selectTest(*pos, onlySelectable, details);
    }
}

void QCPTextElement_MousePressEvent(QCPTextElement* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        self->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPTextElement*)self)->mousePressEvent(event, *details);
    }
}

void QCPTextElement_MouseReleaseEvent(QCPTextElement* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        self->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPTextElement*)self)->mouseReleaseEvent(event, *startPos);
    }
}

void QCPTextElement_MouseDoubleClickEvent(QCPTextElement* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        self->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPTextElement*)self)->mouseDoubleClickEvent(event, *details);
    }
}

void QCPTextElement_SelectionChanged(QCPTextElement* self, bool selected) {
    self->selectionChanged(selected);
}

void QCPTextElement_Connect_SelectionChanged(QCPTextElement* self, intptr_t slot) {
    void (*slotFunc)(QCPTextElement*, bool) = reinterpret_cast<void (*)(QCPTextElement*, bool)>(slot);
    QCPTextElement::connect(self, &QCPTextElement::selectionChanged, [self, slotFunc](bool selected) {
        bool sigval1 = selected;
        slotFunc(self, sigval1);
    });
}

void QCPTextElement_SelectableChanged(QCPTextElement* self, bool selectable) {
    self->selectableChanged(selectable);
}

void QCPTextElement_Connect_SelectableChanged(QCPTextElement* self, intptr_t slot) {
    void (*slotFunc)(QCPTextElement*, bool) = reinterpret_cast<void (*)(QCPTextElement*, bool)>(slot);
    QCPTextElement::connect(self, &QCPTextElement::selectableChanged, [self, slotFunc](bool selectable) {
        bool sigval1 = selectable;
        slotFunc(self, sigval1);
    });
}

void QCPTextElement_Clicked(QCPTextElement* self, QMouseEvent* event) {
    self->clicked(event);
}

void QCPTextElement_Connect_Clicked(QCPTextElement* self, intptr_t slot) {
    void (*slotFunc)(QCPTextElement*, QMouseEvent*) = reinterpret_cast<void (*)(QCPTextElement*, QMouseEvent*)>(slot);
    QCPTextElement::connect(self, &QCPTextElement::clicked, [self, slotFunc](QMouseEvent* event) {
        QMouseEvent* sigval1 = event;
        slotFunc(self, sigval1);
    });
}

void QCPTextElement_DoubleClicked(QCPTextElement* self, QMouseEvent* event) {
    self->doubleClicked(event);
}

void QCPTextElement_Connect_DoubleClicked(QCPTextElement* self, intptr_t slot) {
    void (*slotFunc)(QCPTextElement*, QMouseEvent*) = reinterpret_cast<void (*)(QCPTextElement*, QMouseEvent*)>(slot);
    QCPTextElement::connect(self, &QCPTextElement::doubleClicked, [self, slotFunc](QMouseEvent* event) {
        QMouseEvent* sigval1 = event;
        slotFunc(self, sigval1);
    });
}

void QCPTextElement_ApplyDefaultAntialiasingHint(const QCPTextElement* self, QCPPainter* painter) {
    auto* vqcptextelement = dynamic_cast<const VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->applyDefaultAntialiasingHint(painter);
    }
}

void QCPTextElement_Draw(QCPTextElement* self, QCPPainter* painter) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->draw(painter);
    }
}

QSize* QCPTextElement_MinimumOuterSizeHint(const QCPTextElement* self) {
    auto* vqcptextelement = dynamic_cast<const VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        return new QSize(vqcptextelement->minimumOuterSizeHint());
    }
    return {};
}

QSize* QCPTextElement_MaximumOuterSizeHint(const QCPTextElement* self) {
    auto* vqcptextelement = dynamic_cast<const VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        return new QSize(vqcptextelement->maximumOuterSizeHint());
    }
    return {};
}

void QCPTextElement_SelectEvent(QCPTextElement* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

void QCPTextElement_DeselectEvent(QCPTextElement* self, bool* selectionStateChanged) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->deselectEvent(selectionStateChanged);
    }
}

libqt_string QCPTextElement_Tr2(const char* s, const char* c) {
    QString _ret = QCPTextElement::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPTextElement_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPTextElement::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPTextElement_QBaseMetacall(QCPTextElement* self, int param1, int param2, void** param3) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_Metacall_IsBase(true);
        return vqcptextelement->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPTextElement::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnMetacall(QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_Metacall_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
double QCPTextElement_QBaseSelectTest(const QCPTextElement* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_SelectTest_IsBase(true);
        return vqcptextelement->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPTextElement::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnSelectTest(const QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_SelectTest_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
void QCPTextElement_QBaseMousePressEvent(QCPTextElement* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_MousePressEvent_IsBase(true);
        vqcptextelement->mousePressEvent(event, *details);
    } else {
        self->QCPTextElement::mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnMousePressEvent(QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_MousePressEvent_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_MousePressEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPTextElement_QBaseMouseReleaseEvent(QCPTextElement* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_MouseReleaseEvent_IsBase(true);
        vqcptextelement->mouseReleaseEvent(event, *startPos);
    } else {
        self->QCPTextElement::mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnMouseReleaseEvent(QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_MouseReleaseEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPTextElement_QBaseMouseDoubleClickEvent(QCPTextElement* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_MouseDoubleClickEvent_IsBase(true);
        vqcptextelement->mouseDoubleClickEvent(event, *details);
    } else {
        self->QCPTextElement::mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnMouseDoubleClickEvent(QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPTextElement_QBaseApplyDefaultAntialiasingHint(const QCPTextElement* self, QCPPainter* painter) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcptextelement->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPTextElement*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnApplyDefaultAntialiasingHint(const QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Base class handler implementation
void QCPTextElement_QBaseDraw(QCPTextElement* self, QCPPainter* painter) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_Draw_IsBase(true);
        vqcptextelement->draw(painter);
    } else {
        ((VirtualQCPTextElement*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnDraw(QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_Draw_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_Draw_Callback>(slot));
    }
}

// Base class handler implementation
QSize* QCPTextElement_QBaseMinimumOuterSizeHint(const QCPTextElement* self) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_MinimumOuterSizeHint_IsBase(true);
        return new QSize(vqcptextelement->minimumOuterSizeHint());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnMinimumOuterSizeHint(const QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_MinimumOuterSizeHint_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_MinimumOuterSizeHint_Callback>(slot));
    }
}

// Base class handler implementation
QSize* QCPTextElement_QBaseMaximumOuterSizeHint(const QCPTextElement* self) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_MaximumOuterSizeHint_IsBase(true);
        return new QSize(vqcptextelement->maximumOuterSizeHint());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnMaximumOuterSizeHint(const QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_MaximumOuterSizeHint_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_MaximumOuterSizeHint_Callback>(slot));
    }
}

// Base class handler implementation
void QCPTextElement_QBaseSelectEvent(QCPTextElement* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_SelectEvent_IsBase(true);
        vqcptextelement->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPTextElement*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnSelectEvent(QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_SelectEvent_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_SelectEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPTextElement_QBaseDeselectEvent(QCPTextElement* self, bool* selectionStateChanged) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_DeselectEvent_IsBase(true);
        vqcptextelement->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPTextElement*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnDeselectEvent(QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_DeselectEvent_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPTextElement_Update(QCPTextElement* self, int phase) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    } else {
        self->QCPTextElement::update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    }
}

// Base class handler implementation
void QCPTextElement_QBaseUpdate(QCPTextElement* self, int phase) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_Update_IsBase(true);
        vqcptextelement->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    } else {
        self->QCPTextElement::update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnUpdate(QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_Update_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_Update_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of QCPLayoutElement* */ QCPTextElement_Elements(const QCPTextElement* self, bool recursive) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        QList<QCPLayoutElement*> _ret = vqcptextelement->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayoutElement*> _ret = self->QCPTextElement::elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of QCPLayoutElement* */ QCPTextElement_QBaseElements(const QCPTextElement* self, bool recursive) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_Elements_IsBase(true);
        QList<QCPLayoutElement*> _ret = vqcptextelement->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayoutElement*> _ret = self->QCPTextElement::elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnElements(const QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_Elements_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_Elements_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPTextElement_CalculateAutoMargin(QCPTextElement* self, int side) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        return vqcptextelement->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    } else {
        return ((VirtualQCPTextElement*)self)->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    }
}

// Base class handler implementation
int QCPTextElement_QBaseCalculateAutoMargin(QCPTextElement* self, int side) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_CalculateAutoMargin_IsBase(true);
        return vqcptextelement->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    } else {
        return ((VirtualQCPTextElement*)self)->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnCalculateAutoMargin(QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_CalculateAutoMargin_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_CalculateAutoMargin_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPTextElement_LayoutChanged(QCPTextElement* self) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->layoutChanged();
    } else {
        ((VirtualQCPTextElement*)self)->layoutChanged();
    }
}

// Base class handler implementation
void QCPTextElement_QBaseLayoutChanged(QCPTextElement* self) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_LayoutChanged_IsBase(true);
        vqcptextelement->layoutChanged();
    } else {
        ((VirtualQCPTextElement*)self)->layoutChanged();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnLayoutChanged(QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_LayoutChanged_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_LayoutChanged_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPTextElement_ParentPlotInitialized(QCPTextElement* self, QCustomPlot* parentPlot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPTextElement*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPTextElement_QBaseParentPlotInitialized(QCPTextElement* self, QCustomPlot* parentPlot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_ParentPlotInitialized_IsBase(true);
        vqcptextelement->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPTextElement*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnParentPlotInitialized(QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPTextElement_SelectionCategory(const QCPTextElement* self) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        return static_cast<int>(vqcptextelement->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPTextElement*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPTextElement_QBaseSelectionCategory(const QCPTextElement* self) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcptextelement->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPTextElement*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnSelectionCategory(const QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_SelectionCategory_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPTextElement_ClipRect(const QCPTextElement* self) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        return new QRect(vqcptextelement->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPTextElement_QBaseClipRect(const QCPTextElement* self) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_ClipRect_IsBase(true);
        return new QRect(vqcptextelement->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnClipRect(const QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_ClipRect_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPTextElement_MouseMoveEvent(QCPTextElement* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPTextElement*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPTextElement_QBaseMouseMoveEvent(QCPTextElement* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_MouseMoveEvent_IsBase(true);
        vqcptextelement->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPTextElement*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnMouseMoveEvent(QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPTextElement_WheelEvent(QCPTextElement* self, QWheelEvent* event) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->wheelEvent(event);
    } else {
        ((VirtualQCPTextElement*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPTextElement_QBaseWheelEvent(QCPTextElement* self, QWheelEvent* event) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_WheelEvent_IsBase(true);
        vqcptextelement->wheelEvent(event);
    } else {
        ((VirtualQCPTextElement*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnWheelEvent(QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_WheelEvent_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPTextElement_Event(QCPTextElement* self, QEvent* event) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        return vqcptextelement->event(event);
    } else {
        return self->QCPTextElement::event(event);
    }
}

// Base class handler implementation
bool QCPTextElement_QBaseEvent(QCPTextElement* self, QEvent* event) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_Event_IsBase(true);
        return vqcptextelement->event(event);
    } else {
        return self->QCPTextElement::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnEvent(QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_Event_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPTextElement_EventFilter(QCPTextElement* self, QObject* watched, QEvent* event) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        return vqcptextelement->eventFilter(watched, event);
    } else {
        return self->QCPTextElement::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPTextElement_QBaseEventFilter(QCPTextElement* self, QObject* watched, QEvent* event) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_EventFilter_IsBase(true);
        return vqcptextelement->eventFilter(watched, event);
    } else {
        return self->QCPTextElement::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnEventFilter(QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_EventFilter_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPTextElement_TimerEvent(QCPTextElement* self, QTimerEvent* event) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->timerEvent(event);
    } else {
        ((VirtualQCPTextElement*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPTextElement_QBaseTimerEvent(QCPTextElement* self, QTimerEvent* event) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_TimerEvent_IsBase(true);
        vqcptextelement->timerEvent(event);
    } else {
        ((VirtualQCPTextElement*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnTimerEvent(QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_TimerEvent_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPTextElement_ChildEvent(QCPTextElement* self, QChildEvent* event) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->childEvent(event);
    } else {
        ((VirtualQCPTextElement*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPTextElement_QBaseChildEvent(QCPTextElement* self, QChildEvent* event) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_ChildEvent_IsBase(true);
        vqcptextelement->childEvent(event);
    } else {
        ((VirtualQCPTextElement*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnChildEvent(QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_ChildEvent_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPTextElement_CustomEvent(QCPTextElement* self, QEvent* event) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->customEvent(event);
    } else {
        ((VirtualQCPTextElement*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPTextElement_QBaseCustomEvent(QCPTextElement* self, QEvent* event) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_CustomEvent_IsBase(true);
        vqcptextelement->customEvent(event);
    } else {
        ((VirtualQCPTextElement*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnCustomEvent(QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_CustomEvent_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPTextElement_ConnectNotify(QCPTextElement* self, const QMetaMethod* signal) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->connectNotify(*signal);
    } else {
        ((VirtualQCPTextElement*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPTextElement_QBaseConnectNotify(QCPTextElement* self, const QMetaMethod* signal) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_ConnectNotify_IsBase(true);
        vqcptextelement->connectNotify(*signal);
    } else {
        ((VirtualQCPTextElement*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnConnectNotify(QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_ConnectNotify_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPTextElement_DisconnectNotify(QCPTextElement* self, const QMetaMethod* signal) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->disconnectNotify(*signal);
    } else {
        ((VirtualQCPTextElement*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPTextElement_QBaseDisconnectNotify(QCPTextElement* self, const QMetaMethod* signal) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_DisconnectNotify_IsBase(true);
        vqcptextelement->disconnectNotify(*signal);
    } else {
        ((VirtualQCPTextElement*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnDisconnectNotify(QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
QFont* QCPTextElement_MainFont(const QCPTextElement* self) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        return new QFont(vqcptextelement->mainFont());
    }
    return {};
}

// Base class handler implementation
QFont* QCPTextElement_QBaseMainFont(const QCPTextElement* self) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_MainFont_IsBase(true);
        return new QFont(vqcptextelement->mainFont());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnMainFont(const QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_MainFont_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_MainFont_Callback>(slot));
    }
}

// Derived class handler implementation
QColor* QCPTextElement_MainTextColor(const QCPTextElement* self) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        return new QColor(vqcptextelement->mainTextColor());
    }
    return {};
}

// Base class handler implementation
QColor* QCPTextElement_QBaseMainTextColor(const QCPTextElement* self) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_MainTextColor_IsBase(true);
        return new QColor(vqcptextelement->mainTextColor());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnMainTextColor(const QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_MainTextColor_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_MainTextColor_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPTextElement_InitializeParentPlot(QCPTextElement* self, QCustomPlot* parentPlot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPTextElement*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPTextElement_QBaseInitializeParentPlot(QCPTextElement* self, QCustomPlot* parentPlot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_InitializeParentPlot_IsBase(true);
        vqcptextelement->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPTextElement*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnInitializeParentPlot(QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPTextElement_SetParentLayerable(QCPTextElement* self, QCPLayerable* parentLayerable) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPTextElement*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPTextElement_QBaseSetParentLayerable(QCPTextElement* self, QCPLayerable* parentLayerable) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_SetParentLayerable_IsBase(true);
        vqcptextelement->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPTextElement*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnSetParentLayerable(QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPTextElement_MoveToLayer(QCPTextElement* self, QCPLayer* layer, bool prepend) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        return vqcptextelement->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPTextElement*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPTextElement_QBaseMoveToLayer(QCPTextElement* self, QCPLayer* layer, bool prepend) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_MoveToLayer_IsBase(true);
        return vqcptextelement->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPTextElement*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnMoveToLayer(QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = dynamic_cast<VirtualQCPTextElement*>(self);
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_MoveToLayer_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPTextElement_ApplyAntialiasingHint(const QCPTextElement* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPTextElement*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPTextElement_QBaseApplyAntialiasingHint(const QCPTextElement* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_ApplyAntialiasingHint_IsBase(true);
        vqcptextelement->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPTextElement*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnApplyAntialiasingHint(const QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPTextElement_Sender(const QCPTextElement* self) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        return vqcptextelement->sender();
    } else {
        return ((VirtualQCPTextElement*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPTextElement_QBaseSender(const QCPTextElement* self) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_Sender_IsBase(true);
        return vqcptextelement->sender();
    } else {
        return ((VirtualQCPTextElement*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnSender(const QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_Sender_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPTextElement_SenderSignalIndex(const QCPTextElement* self) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        return vqcptextelement->senderSignalIndex();
    } else {
        return ((VirtualQCPTextElement*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPTextElement_QBaseSenderSignalIndex(const QCPTextElement* self) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_SenderSignalIndex_IsBase(true);
        return vqcptextelement->senderSignalIndex();
    } else {
        return ((VirtualQCPTextElement*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnSenderSignalIndex(const QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPTextElement_Receivers(const QCPTextElement* self, const char* signal) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        return vqcptextelement->receivers(signal);
    } else {
        return ((VirtualQCPTextElement*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPTextElement_QBaseReceivers(const QCPTextElement* self, const char* signal) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_Receivers_IsBase(true);
        return vqcptextelement->receivers(signal);
    } else {
        return ((VirtualQCPTextElement*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnReceivers(const QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_Receivers_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPTextElement_IsSignalConnected(const QCPTextElement* self, const QMetaMethod* signal) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        return vqcptextelement->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPTextElement*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPTextElement_QBaseIsSignalConnected(const QCPTextElement* self, const QMetaMethod* signal) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_IsSignalConnected_IsBase(true);
        return vqcptextelement->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPTextElement*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPTextElement_OnIsSignalConnected(const QCPTextElement* self, intptr_t slot) {
    auto* vqcptextelement = const_cast<VirtualQCPTextElement*>(dynamic_cast<const VirtualQCPTextElement*>(self));
    if (vqcptextelement && vqcptextelement->isVirtualQCPTextElement) {
        vqcptextelement->setQCPTextElement_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPTextElement::QCPTextElement_IsSignalConnected_Callback>(slot));
    }
}

void QCPTextElement_Delete(QCPTextElement* self) {
    delete self;
}

QCPColorScale* QCPColorScale_new(QCustomPlot* parentPlot) {
    return new VirtualQCPColorScale(parentPlot);
}

QMetaObject* QCPColorScale_MetaObject(const QCPColorScale* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPColorScale_Metacast(QCPColorScale* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPColorScale_Metacall(QCPColorScale* self, int param1, int param2, void** param3) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPColorScale*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPColorScale_Tr(const char* s) {
    QString _ret = QCPColorScale::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

QCPAxis* QCPColorScale_Axis(const QCPColorScale* self) {
    return self->axis();
}

int QCPColorScale_Type(const QCPColorScale* self) {
    return static_cast<int>(self->type());
}

QCPRange* QCPColorScale_DataRange(const QCPColorScale* self) {
    return new QCPRange(self->dataRange());
}

int QCPColorScale_DataScaleType(const QCPColorScale* self) {
    return static_cast<int>(self->dataScaleType());
}

QCPColorGradient* QCPColorScale_Gradient(const QCPColorScale* self) {
    return new QCPColorGradient(self->gradient());
}

libqt_string QCPColorScale_Label(const QCPColorScale* self) {
    QString _ret = self->label();
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

int QCPColorScale_BarWidth(const QCPColorScale* self) {
    return self->barWidth();
}

bool QCPColorScale_RangeDrag(const QCPColorScale* self) {
    return self->rangeDrag();
}

bool QCPColorScale_RangeZoom(const QCPColorScale* self) {
    return self->rangeZoom();
}

void QCPColorScale_SetType(QCPColorScale* self, int typeVal) {
    self->setType(static_cast<QCPAxis::AxisType>(typeVal));
}

void QCPColorScale_SetDataRange(QCPColorScale* self, const QCPRange* dataRange) {
    self->setDataRange(*dataRange);
}

void QCPColorScale_SetDataScaleType(QCPColorScale* self, int scaleType) {
    self->setDataScaleType(static_cast<QCPAxis::ScaleType>(scaleType));
}

void QCPColorScale_SetGradient(QCPColorScale* self, const QCPColorGradient* gradient) {
    self->setGradient(*gradient);
}

void QCPColorScale_SetLabel(QCPColorScale* self, const libqt_string str) {
    QString str_QString = QString::fromUtf8(str.data, str.len);
    self->setLabel(str_QString);
}

void QCPColorScale_SetBarWidth(QCPColorScale* self, int width) {
    self->setBarWidth(static_cast<int>(width));
}

void QCPColorScale_SetRangeDrag(QCPColorScale* self, bool enabled) {
    self->setRangeDrag(enabled);
}

void QCPColorScale_SetRangeZoom(QCPColorScale* self, bool enabled) {
    self->setRangeZoom(enabled);
}

libqt_list /* of QCPColorMap* */ QCPColorScale_ColorMaps(const QCPColorScale* self) {
    QList<QCPColorMap*> _ret = self->colorMaps();
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPColorMap** _arr = static_cast<QCPColorMap**>(malloc(sizeof(QCPColorMap*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

void QCPColorScale_RescaleDataRange(QCPColorScale* self, bool onlyVisibleMaps) {
    self->rescaleDataRange(onlyVisibleMaps);
}

void QCPColorScale_Update(QCPColorScale* self, int phase) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        self->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    } else {
        ((VirtualQCPColorScale*)self)->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    }
}

void QCPColorScale_DataRangeChanged(QCPColorScale* self, const QCPRange* newRange) {
    self->dataRangeChanged(*newRange);
}

void QCPColorScale_Connect_DataRangeChanged(QCPColorScale* self, intptr_t slot) {
    void (*slotFunc)(QCPColorScale*, QCPRange*) = reinterpret_cast<void (*)(QCPColorScale*, QCPRange*)>(slot);
    QCPColorScale::connect(self, &QCPColorScale::dataRangeChanged, [self, slotFunc](const QCPRange& newRange) {
        const QCPRange& newRange_ret = newRange;
        // Cast returned reference into pointer
        QCPRange* sigval1 = const_cast<QCPRange*>(&newRange_ret);
        slotFunc(self, sigval1);
    });
}

void QCPColorScale_DataScaleTypeChanged(QCPColorScale* self, int scaleType) {
    self->dataScaleTypeChanged(static_cast<QCPAxis::ScaleType>(scaleType));
}

void QCPColorScale_Connect_DataScaleTypeChanged(QCPColorScale* self, intptr_t slot) {
    void (*slotFunc)(QCPColorScale*, int) = reinterpret_cast<void (*)(QCPColorScale*, int)>(slot);
    QCPColorScale::connect(self, &QCPColorScale::dataScaleTypeChanged, [self, slotFunc](QCPAxis::ScaleType scaleType) {
        int sigval1 = static_cast<int>(scaleType);
        slotFunc(self, sigval1);
    });
}

void QCPColorScale_GradientChanged(QCPColorScale* self, const QCPColorGradient* newGradient) {
    self->gradientChanged(*newGradient);
}

void QCPColorScale_Connect_GradientChanged(QCPColorScale* self, intptr_t slot) {
    void (*slotFunc)(QCPColorScale*, QCPColorGradient*) = reinterpret_cast<void (*)(QCPColorScale*, QCPColorGradient*)>(slot);
    QCPColorScale::connect(self, &QCPColorScale::gradientChanged, [self, slotFunc](const QCPColorGradient& newGradient) {
        const QCPColorGradient& newGradient_ret = newGradient;
        // Cast returned reference into pointer
        QCPColorGradient* sigval1 = const_cast<QCPColorGradient*>(&newGradient_ret);
        slotFunc(self, sigval1);
    });
}

void QCPColorScale_ApplyDefaultAntialiasingHint(const QCPColorScale* self, QCPPainter* painter) {
    auto* vqcpcolorscale = dynamic_cast<const VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->applyDefaultAntialiasingHint(painter);
    }
}

void QCPColorScale_MousePressEvent(QCPColorScale* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->mousePressEvent(event, *details);
    }
}

void QCPColorScale_MouseMoveEvent(QCPColorScale* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->mouseMoveEvent(event, *startPos);
    }
}

void QCPColorScale_MouseReleaseEvent(QCPColorScale* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->mouseReleaseEvent(event, *startPos);
    }
}

void QCPColorScale_WheelEvent(QCPColorScale* self, QWheelEvent* event) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->wheelEvent(event);
    }
}

libqt_string QCPColorScale_Tr2(const char* s, const char* c) {
    QString _ret = QCPColorScale::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPColorScale_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPColorScale::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPColorScale_QBaseMetacall(QCPColorScale* self, int param1, int param2, void** param3) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_Metacall_IsBase(true);
        return vqcpcolorscale->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPColorScale::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnMetacall(QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_Metacall_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
void QCPColorScale_QBaseUpdate(QCPColorScale* self, int phase) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_Update_IsBase(true);
        vqcpcolorscale->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    } else {
        self->QCPColorScale::update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnUpdate(QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_Update_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_Update_Callback>(slot));
    }
}

// Base class handler implementation
void QCPColorScale_QBaseApplyDefaultAntialiasingHint(const QCPColorScale* self, QCPPainter* painter) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcpcolorscale->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPColorScale*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnApplyDefaultAntialiasingHint(const QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Base class handler implementation
void QCPColorScale_QBaseMousePressEvent(QCPColorScale* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_MousePressEvent_IsBase(true);
        vqcpcolorscale->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPColorScale*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnMousePressEvent(QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_MousePressEvent_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_MousePressEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPColorScale_QBaseMouseMoveEvent(QCPColorScale* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_MouseMoveEvent_IsBase(true);
        vqcpcolorscale->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPColorScale*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnMouseMoveEvent(QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_MouseMoveEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPColorScale_QBaseMouseReleaseEvent(QCPColorScale* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_MouseReleaseEvent_IsBase(true);
        vqcpcolorscale->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPColorScale*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnMouseReleaseEvent(QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_MouseReleaseEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPColorScale_QBaseWheelEvent(QCPColorScale* self, QWheelEvent* event) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_WheelEvent_IsBase(true);
        vqcpcolorscale->wheelEvent(event);
    } else {
        ((VirtualQCPColorScale*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnWheelEvent(QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_WheelEvent_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
QSize* QCPColorScale_MinimumOuterSizeHint(const QCPColorScale* self) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        return new QSize(vqcpcolorscale->minimumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPColorScale*)self)->minimumOuterSizeHint());
    }
}

// Base class handler implementation
QSize* QCPColorScale_QBaseMinimumOuterSizeHint(const QCPColorScale* self) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_MinimumOuterSizeHint_IsBase(true);
        return new QSize(vqcpcolorscale->minimumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPColorScale*)self)->minimumOuterSizeHint());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnMinimumOuterSizeHint(const QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_MinimumOuterSizeHint_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_MinimumOuterSizeHint_Callback>(slot));
    }
}

// Derived class handler implementation
QSize* QCPColorScale_MaximumOuterSizeHint(const QCPColorScale* self) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        return new QSize(vqcpcolorscale->maximumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPColorScale*)self)->maximumOuterSizeHint());
    }
}

// Base class handler implementation
QSize* QCPColorScale_QBaseMaximumOuterSizeHint(const QCPColorScale* self) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_MaximumOuterSizeHint_IsBase(true);
        return new QSize(vqcpcolorscale->maximumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPColorScale*)self)->maximumOuterSizeHint());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnMaximumOuterSizeHint(const QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_MaximumOuterSizeHint_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_MaximumOuterSizeHint_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of QCPLayoutElement* */ QCPColorScale_Elements(const QCPColorScale* self, bool recursive) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        QList<QCPLayoutElement*> _ret = vqcpcolorscale->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayoutElement*> _ret = self->QCPColorScale::elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of QCPLayoutElement* */ QCPColorScale_QBaseElements(const QCPColorScale* self, bool recursive) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_Elements_IsBase(true);
        QList<QCPLayoutElement*> _ret = vqcpcolorscale->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayoutElement*> _ret = self->QCPColorScale::elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnElements(const QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_Elements_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_Elements_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPColorScale_SelectTest(const QCPColorScale* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        return vqcpcolorscale->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPColorScale::selectTest(*pos, onlySelectable, details);
    }
}

// Base class handler implementation
double QCPColorScale_QBaseSelectTest(const QCPColorScale* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_SelectTest_IsBase(true);
        return vqcpcolorscale->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPColorScale::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnSelectTest(const QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_SelectTest_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_SelectTest_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPColorScale_CalculateAutoMargin(QCPColorScale* self, int side) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        return vqcpcolorscale->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    } else {
        return ((VirtualQCPColorScale*)self)->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    }
}

// Base class handler implementation
int QCPColorScale_QBaseCalculateAutoMargin(QCPColorScale* self, int side) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_CalculateAutoMargin_IsBase(true);
        return vqcpcolorscale->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    } else {
        return ((VirtualQCPColorScale*)self)->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnCalculateAutoMargin(QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_CalculateAutoMargin_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_CalculateAutoMargin_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorScale_LayoutChanged(QCPColorScale* self) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->layoutChanged();
    } else {
        ((VirtualQCPColorScale*)self)->layoutChanged();
    }
}

// Base class handler implementation
void QCPColorScale_QBaseLayoutChanged(QCPColorScale* self) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_LayoutChanged_IsBase(true);
        vqcpcolorscale->layoutChanged();
    } else {
        ((VirtualQCPColorScale*)self)->layoutChanged();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnLayoutChanged(QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_LayoutChanged_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_LayoutChanged_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorScale_Draw(QCPColorScale* self, QCPPainter* painter) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->draw(painter);
    } else {
        ((VirtualQCPColorScale*)self)->draw(painter);
    }
}

// Base class handler implementation
void QCPColorScale_QBaseDraw(QCPColorScale* self, QCPPainter* painter) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_Draw_IsBase(true);
        vqcpcolorscale->draw(painter);
    } else {
        ((VirtualQCPColorScale*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnDraw(QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_Draw_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_Draw_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorScale_ParentPlotInitialized(QCPColorScale* self, QCustomPlot* parentPlot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPColorScale*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPColorScale_QBaseParentPlotInitialized(QCPColorScale* self, QCustomPlot* parentPlot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_ParentPlotInitialized_IsBase(true);
        vqcpcolorscale->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPColorScale*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnParentPlotInitialized(QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPColorScale_SelectionCategory(const QCPColorScale* self) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        return static_cast<int>(vqcpcolorscale->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPColorScale*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPColorScale_QBaseSelectionCategory(const QCPColorScale* self) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcpcolorscale->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPColorScale*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnSelectionCategory(const QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_SelectionCategory_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPColorScale_ClipRect(const QCPColorScale* self) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        return new QRect(vqcpcolorscale->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPColorScale_QBaseClipRect(const QCPColorScale* self) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_ClipRect_IsBase(true);
        return new QRect(vqcpcolorscale->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnClipRect(const QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_ClipRect_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorScale_SelectEvent(QCPColorScale* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPColorScale*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPColorScale_QBaseSelectEvent(QCPColorScale* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_SelectEvent_IsBase(true);
        vqcpcolorscale->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPColorScale*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnSelectEvent(QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_SelectEvent_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorScale_DeselectEvent(QCPColorScale* self, bool* selectionStateChanged) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPColorScale*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPColorScale_QBaseDeselectEvent(QCPColorScale* self, bool* selectionStateChanged) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_DeselectEvent_IsBase(true);
        vqcpcolorscale->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPColorScale*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnDeselectEvent(QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_DeselectEvent_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorScale_MouseDoubleClickEvent(QCPColorScale* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPColorScale*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPColorScale_QBaseMouseDoubleClickEvent(QCPColorScale* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_MouseDoubleClickEvent_IsBase(true);
        vqcpcolorscale->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPColorScale*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnMouseDoubleClickEvent(QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPColorScale_Event(QCPColorScale* self, QEvent* event) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        return vqcpcolorscale->event(event);
    } else {
        return self->QCPColorScale::event(event);
    }
}

// Base class handler implementation
bool QCPColorScale_QBaseEvent(QCPColorScale* self, QEvent* event) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_Event_IsBase(true);
        return vqcpcolorscale->event(event);
    } else {
        return self->QCPColorScale::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnEvent(QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_Event_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPColorScale_EventFilter(QCPColorScale* self, QObject* watched, QEvent* event) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        return vqcpcolorscale->eventFilter(watched, event);
    } else {
        return self->QCPColorScale::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPColorScale_QBaseEventFilter(QCPColorScale* self, QObject* watched, QEvent* event) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_EventFilter_IsBase(true);
        return vqcpcolorscale->eventFilter(watched, event);
    } else {
        return self->QCPColorScale::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnEventFilter(QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_EventFilter_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorScale_TimerEvent(QCPColorScale* self, QTimerEvent* event) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->timerEvent(event);
    } else {
        ((VirtualQCPColorScale*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPColorScale_QBaseTimerEvent(QCPColorScale* self, QTimerEvent* event) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_TimerEvent_IsBase(true);
        vqcpcolorscale->timerEvent(event);
    } else {
        ((VirtualQCPColorScale*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnTimerEvent(QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_TimerEvent_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorScale_ChildEvent(QCPColorScale* self, QChildEvent* event) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->childEvent(event);
    } else {
        ((VirtualQCPColorScale*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPColorScale_QBaseChildEvent(QCPColorScale* self, QChildEvent* event) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_ChildEvent_IsBase(true);
        vqcpcolorscale->childEvent(event);
    } else {
        ((VirtualQCPColorScale*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnChildEvent(QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_ChildEvent_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorScale_CustomEvent(QCPColorScale* self, QEvent* event) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->customEvent(event);
    } else {
        ((VirtualQCPColorScale*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPColorScale_QBaseCustomEvent(QCPColorScale* self, QEvent* event) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_CustomEvent_IsBase(true);
        vqcpcolorscale->customEvent(event);
    } else {
        ((VirtualQCPColorScale*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnCustomEvent(QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_CustomEvent_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorScale_ConnectNotify(QCPColorScale* self, const QMetaMethod* signal) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->connectNotify(*signal);
    } else {
        ((VirtualQCPColorScale*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPColorScale_QBaseConnectNotify(QCPColorScale* self, const QMetaMethod* signal) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_ConnectNotify_IsBase(true);
        vqcpcolorscale->connectNotify(*signal);
    } else {
        ((VirtualQCPColorScale*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnConnectNotify(QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_ConnectNotify_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorScale_DisconnectNotify(QCPColorScale* self, const QMetaMethod* signal) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->disconnectNotify(*signal);
    } else {
        ((VirtualQCPColorScale*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPColorScale_QBaseDisconnectNotify(QCPColorScale* self, const QMetaMethod* signal) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_DisconnectNotify_IsBase(true);
        vqcpcolorscale->disconnectNotify(*signal);
    } else {
        ((VirtualQCPColorScale*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnDisconnectNotify(QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorScale_InitializeParentPlot(QCPColorScale* self, QCustomPlot* parentPlot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPColorScale*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPColorScale_QBaseInitializeParentPlot(QCPColorScale* self, QCustomPlot* parentPlot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_InitializeParentPlot_IsBase(true);
        vqcpcolorscale->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPColorScale*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnInitializeParentPlot(QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorScale_SetParentLayerable(QCPColorScale* self, QCPLayerable* parentLayerable) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPColorScale*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPColorScale_QBaseSetParentLayerable(QCPColorScale* self, QCPLayerable* parentLayerable) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_SetParentLayerable_IsBase(true);
        vqcpcolorscale->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPColorScale*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnSetParentLayerable(QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPColorScale_MoveToLayer(QCPColorScale* self, QCPLayer* layer, bool prepend) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        return vqcpcolorscale->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPColorScale*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPColorScale_QBaseMoveToLayer(QCPColorScale* self, QCPLayer* layer, bool prepend) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_MoveToLayer_IsBase(true);
        return vqcpcolorscale->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPColorScale*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnMoveToLayer(QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = dynamic_cast<VirtualQCPColorScale*>(self);
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_MoveToLayer_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorScale_ApplyAntialiasingHint(const QCPColorScale* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPColorScale*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPColorScale_QBaseApplyAntialiasingHint(const QCPColorScale* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_ApplyAntialiasingHint_IsBase(true);
        vqcpcolorscale->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPColorScale*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnApplyAntialiasingHint(const QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPColorScale_Sender(const QCPColorScale* self) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        return vqcpcolorscale->sender();
    } else {
        return ((VirtualQCPColorScale*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPColorScale_QBaseSender(const QCPColorScale* self) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_Sender_IsBase(true);
        return vqcpcolorscale->sender();
    } else {
        return ((VirtualQCPColorScale*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnSender(const QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_Sender_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPColorScale_SenderSignalIndex(const QCPColorScale* self) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        return vqcpcolorscale->senderSignalIndex();
    } else {
        return ((VirtualQCPColorScale*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPColorScale_QBaseSenderSignalIndex(const QCPColorScale* self) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_SenderSignalIndex_IsBase(true);
        return vqcpcolorscale->senderSignalIndex();
    } else {
        return ((VirtualQCPColorScale*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnSenderSignalIndex(const QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPColorScale_Receivers(const QCPColorScale* self, const char* signal) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        return vqcpcolorscale->receivers(signal);
    } else {
        return ((VirtualQCPColorScale*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPColorScale_QBaseReceivers(const QCPColorScale* self, const char* signal) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_Receivers_IsBase(true);
        return vqcpcolorscale->receivers(signal);
    } else {
        return ((VirtualQCPColorScale*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnReceivers(const QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_Receivers_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPColorScale_IsSignalConnected(const QCPColorScale* self, const QMetaMethod* signal) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        return vqcpcolorscale->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPColorScale*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPColorScale_QBaseIsSignalConnected(const QCPColorScale* self, const QMetaMethod* signal) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_IsSignalConnected_IsBase(true);
        return vqcpcolorscale->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPColorScale*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorScale_OnIsSignalConnected(const QCPColorScale* self, intptr_t slot) {
    auto* vqcpcolorscale = const_cast<VirtualQCPColorScale*>(dynamic_cast<const VirtualQCPColorScale*>(self));
    if (vqcpcolorscale && vqcpcolorscale->isVirtualQCPColorScale) {
        vqcpcolorscale->setQCPColorScale_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPColorScale::QCPColorScale_IsSignalConnected_Callback>(slot));
    }
}

void QCPColorScale_Delete(QCPColorScale* self) {
    delete self;
}

QCPGraphData* QCPGraphData_new(const QCPGraphData* other) {
    return new QCPGraphData(*other);
}

QCPGraphData* QCPGraphData_new2(QCPGraphData* other) {
    return new QCPGraphData(std::move(*other));
}

QCPGraphData* QCPGraphData_new3() {
    return new QCPGraphData();
}

QCPGraphData* QCPGraphData_new4(double key, double value) {
    return new QCPGraphData(static_cast<double>(key), static_cast<double>(value));
}

QCPGraphData* QCPGraphData_new5(const QCPGraphData* param1) {
    return new QCPGraphData(*param1);
}

void QCPGraphData_CopyAssign(QCPGraphData* self, QCPGraphData* other) {
    *self = *other;
}

void QCPGraphData_MoveAssign(QCPGraphData* self, QCPGraphData* other) {
    *self = std::move(*other);
}

double QCPGraphData_SortKey(const QCPGraphData* self) {
    return self->sortKey();
}

QCPGraphData* QCPGraphData_FromSortKey(double sortKey) {
    return new QCPGraphData(QCPGraphData::fromSortKey(static_cast<double>(sortKey)));
}

bool QCPGraphData_SortKeyIsMainKey() {
    return QCPGraphData::sortKeyIsMainKey();
}

double QCPGraphData_MainKey(const QCPGraphData* self) {
    return self->mainKey();
}

double QCPGraphData_MainValue(const QCPGraphData* self) {
    return self->mainValue();
}

QCPRange* QCPGraphData_ValueRange(const QCPGraphData* self) {
    return new QCPRange(self->valueRange());
}

double QCPGraphData_Key(const QCPGraphData* self) {
    return self->key;
}

void QCPGraphData_SetKey(QCPGraphData* self, double key) {
    self->key = static_cast<double>(key);
}

double QCPGraphData_Value(const QCPGraphData* self) {
    return self->value;
}

void QCPGraphData_SetValue(QCPGraphData* self, double value) {
    self->value = static_cast<double>(value);
}

void QCPGraphData_Delete(QCPGraphData* self) {
    delete self;
}

QCPGraph* QCPGraph_new(QCPAxis* keyAxis, QCPAxis* valueAxis) {
    return new VirtualQCPGraph(keyAxis, valueAxis);
}

QMetaObject* QCPGraph_MetaObject(const QCPGraph* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPGraph_Metacast(QCPGraph* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPGraph_Metacall(QCPGraph* self, int param1, int param2, void** param3) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPGraph*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPGraph_Tr(const char* s) {
    QString _ret = QCPGraph::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

int QCPGraph_LineStyle(const QCPGraph* self) {
    return static_cast<int>(self->lineStyle());
}

QCPScatterStyle* QCPGraph_ScatterStyle(const QCPGraph* self) {
    return new QCPScatterStyle(self->scatterStyle());
}

int QCPGraph_ScatterSkip(const QCPGraph* self) {
    return self->scatterSkip();
}

QCPGraph* QCPGraph_ChannelFillGraph(const QCPGraph* self) {
    return self->channelFillGraph();
}

bool QCPGraph_AdaptiveSampling(const QCPGraph* self) {
    return self->adaptiveSampling();
}

void QCPGraph_SetData2(QCPGraph* self, const libqt_list /* of double */ keys, const libqt_list /* of double */ values) {
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> values_QVector;
    values_QVector.reserve(values.len);
    double* values_arr = static_cast<double*>(values.data);
    for (size_t i = 0; i < values.len; ++i) {
        values_QVector.push_back(static_cast<double>(values_arr[i]));
    }
    self->setData(keys_QVector, values_QVector);
}

void QCPGraph_SetLineStyle(QCPGraph* self, int ls) {
    self->setLineStyle(static_cast<QCPGraph::LineStyle>(ls));
}

void QCPGraph_SetScatterStyle(QCPGraph* self, const QCPScatterStyle* style) {
    self->setScatterStyle(*style);
}

void QCPGraph_SetScatterSkip(QCPGraph* self, int skip) {
    self->setScatterSkip(static_cast<int>(skip));
}

void QCPGraph_SetChannelFillGraph(QCPGraph* self, QCPGraph* targetGraph) {
    self->setChannelFillGraph(targetGraph);
}

void QCPGraph_SetAdaptiveSampling(QCPGraph* self, bool enabled) {
    self->setAdaptiveSampling(enabled);
}

void QCPGraph_AddData(QCPGraph* self, const libqt_list /* of double */ keys, const libqt_list /* of double */ values) {
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> values_QVector;
    values_QVector.reserve(values.len);
    double* values_arr = static_cast<double*>(values.data);
    for (size_t i = 0; i < values.len; ++i) {
        values_QVector.push_back(static_cast<double>(values_arr[i]));
    }
    self->addData(keys_QVector, values_QVector);
}

void QCPGraph_AddData2(QCPGraph* self, double key, double value) {
    self->addData(static_cast<double>(key), static_cast<double>(value));
}

double QCPGraph_SelectTest(const QCPGraph* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpgraph = dynamic_cast<const VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPGraph*)self)->selectTest(*pos, onlySelectable, details);
    }
}

QCPRange* QCPGraph_GetKeyRange(const QCPGraph* self, bool* foundRange, int inSignDomain) {
    auto* vqcpgraph = dynamic_cast<const VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return new QCPRange(self->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    } else {
        return new QCPRange(((VirtualQCPGraph*)self)->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    }
}

QCPRange* QCPGraph_GetValueRange(const QCPGraph* self, bool* foundRange, int inSignDomain, const QCPRange* inKeyRange) {
    auto* vqcpgraph = dynamic_cast<const VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return new QCPRange(self->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    } else {
        return new QCPRange(((VirtualQCPGraph*)self)->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    }
}

void QCPGraph_Draw(QCPGraph* self, QCPPainter* painter) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->draw(painter);
    }
}

void QCPGraph_DrawLegendIcon(const QCPGraph* self, QCPPainter* painter, const QRectF* rect) {
    auto* vqcpgraph = dynamic_cast<const VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->drawLegendIcon(painter, *rect);
    }
}

void QCPGraph_DrawFill(const QCPGraph* self, QCPPainter* painter, libqt_list /* of QPointF* */ lines) {
    QVector<QPointF> lines_QVector;
    lines_QVector.reserve(lines.len);
    QPointF** lines_arr = static_cast<QPointF**>(lines.data);
    for (size_t i = 0; i < lines.len; ++i) {
        lines_QVector.push_back(*(lines_arr[i]));
    }
    auto* vqcpgraph = dynamic_cast<const VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->drawFill(painter, &lines_QVector);
    }
}

void QCPGraph_DrawScatterPlot(const QCPGraph* self, QCPPainter* painter, const libqt_list /* of QPointF* */ scatters, const QCPScatterStyle* style) {
    QVector<QPointF> scatters_QVector;
    scatters_QVector.reserve(scatters.len);
    QPointF** scatters_arr = static_cast<QPointF**>(scatters.data);
    for (size_t i = 0; i < scatters.len; ++i) {
        scatters_QVector.push_back(*(scatters_arr[i]));
    }
    auto* vqcpgraph = dynamic_cast<const VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->drawScatterPlot(painter, scatters_QVector, *style);
    }
}

void QCPGraph_DrawLinePlot(const QCPGraph* self, QCPPainter* painter, const libqt_list /* of QPointF* */ lines) {
    QVector<QPointF> lines_QVector;
    lines_QVector.reserve(lines.len);
    QPointF** lines_arr = static_cast<QPointF**>(lines.data);
    for (size_t i = 0; i < lines.len; ++i) {
        lines_QVector.push_back(*(lines_arr[i]));
    }
    auto* vqcpgraph = dynamic_cast<const VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->drawLinePlot(painter, lines_QVector);
    }
}

void QCPGraph_DrawImpulsePlot(const QCPGraph* self, QCPPainter* painter, const libqt_list /* of QPointF* */ lines) {
    QVector<QPointF> lines_QVector;
    lines_QVector.reserve(lines.len);
    QPointF** lines_arr = static_cast<QPointF**>(lines.data);
    for (size_t i = 0; i < lines.len; ++i) {
        lines_QVector.push_back(*(lines_arr[i]));
    }
    auto* vqcpgraph = dynamic_cast<const VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->drawImpulsePlot(painter, lines_QVector);
    }
}

libqt_string QCPGraph_Tr2(const char* s, const char* c) {
    QString _ret = QCPGraph::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPGraph_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPGraph::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

void QCPGraph_SetData3(QCPGraph* self, const libqt_list /* of double */ keys, const libqt_list /* of double */ values, bool alreadySorted) {
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> values_QVector;
    values_QVector.reserve(values.len);
    double* values_arr = static_cast<double*>(values.data);
    for (size_t i = 0; i < values.len; ++i) {
        values_QVector.push_back(static_cast<double>(values_arr[i]));
    }
    self->setData(keys_QVector, values_QVector, alreadySorted);
}

void QCPGraph_AddData3(QCPGraph* self, const libqt_list /* of double */ keys, const libqt_list /* of double */ values, bool alreadySorted) {
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> values_QVector;
    values_QVector.reserve(values.len);
    double* values_arr = static_cast<double*>(values.data);
    for (size_t i = 0; i < values.len; ++i) {
        values_QVector.push_back(static_cast<double>(values_arr[i]));
    }
    self->addData(keys_QVector, values_QVector, alreadySorted);
}

// Base class handler implementation
int QCPGraph_QBaseMetacall(QCPGraph* self, int param1, int param2, void** param3) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_Metacall_IsBase(true);
        return vqcpgraph->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPGraph::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnMetacall(QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_Metacall_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
double QCPGraph_QBaseSelectTest(const QCPGraph* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_SelectTest_IsBase(true);
        return vqcpgraph->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPGraph::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnSelectTest(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_SelectTest_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
QCPRange* QCPGraph_QBaseGetKeyRange(const QCPGraph* self, bool* foundRange, int inSignDomain) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_GetKeyRange_IsBase(true);
        return new QCPRange(vqcpgraph->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    } else {
        return new QCPRange(((VirtualQCPGraph*)self)->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnGetKeyRange(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_GetKeyRange_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_GetKeyRange_Callback>(slot));
    }
}

// Base class handler implementation
QCPRange* QCPGraph_QBaseGetValueRange(const QCPGraph* self, bool* foundRange, int inSignDomain, const QCPRange* inKeyRange) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_GetValueRange_IsBase(true);
        return new QCPRange(vqcpgraph->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    } else {
        return new QCPRange(((VirtualQCPGraph*)self)->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnGetValueRange(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_GetValueRange_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_GetValueRange_Callback>(slot));
    }
}

// Base class handler implementation
void QCPGraph_QBaseDraw(QCPGraph* self, QCPPainter* painter) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_Draw_IsBase(true);
        vqcpgraph->draw(painter);
    } else {
        ((VirtualQCPGraph*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnDraw(QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_Draw_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_Draw_Callback>(slot));
    }
}

// Base class handler implementation
void QCPGraph_QBaseDrawLegendIcon(const QCPGraph* self, QCPPainter* painter, const QRectF* rect) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DrawLegendIcon_IsBase(true);
        vqcpgraph->drawLegendIcon(painter, *rect);
    } else {
        ((VirtualQCPGraph*)self)->drawLegendIcon(painter, *rect);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnDrawLegendIcon(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DrawLegendIcon_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_DrawLegendIcon_Callback>(slot));
    }
}

// Base class handler implementation
void QCPGraph_QBaseDrawFill(const QCPGraph* self, QCPPainter* painter, libqt_list /* of QPointF* */ lines) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QPointF> lines_QVector;
    lines_QVector.reserve(lines.len);
    QPointF** lines_arr = static_cast<QPointF**>(lines.data);
    for (size_t i = 0; i < lines.len; ++i) {
        lines_QVector.push_back(*(lines_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DrawFill_IsBase(true);
        vqcpgraph->drawFill(painter, &lines_QVector);
    } else {
        ((VirtualQCPGraph*)self)->drawFill(painter, &lines_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnDrawFill(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DrawFill_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_DrawFill_Callback>(slot));
    }
}

// Base class handler implementation
void QCPGraph_QBaseDrawScatterPlot(const QCPGraph* self, QCPPainter* painter, const libqt_list /* of QPointF* */ scatters, const QCPScatterStyle* style) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QPointF> scatters_QVector;
    scatters_QVector.reserve(scatters.len);
    QPointF** scatters_arr = static_cast<QPointF**>(scatters.data);
    for (size_t i = 0; i < scatters.len; ++i) {
        scatters_QVector.push_back(*(scatters_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DrawScatterPlot_IsBase(true);
        vqcpgraph->drawScatterPlot(painter, scatters_QVector, *style);
    } else {
        ((VirtualQCPGraph*)self)->drawScatterPlot(painter, scatters_QVector, *style);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnDrawScatterPlot(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DrawScatterPlot_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_DrawScatterPlot_Callback>(slot));
    }
}

// Base class handler implementation
void QCPGraph_QBaseDrawLinePlot(const QCPGraph* self, QCPPainter* painter, const libqt_list /* of QPointF* */ lines) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QPointF> lines_QVector;
    lines_QVector.reserve(lines.len);
    QPointF** lines_arr = static_cast<QPointF**>(lines.data);
    for (size_t i = 0; i < lines.len; ++i) {
        lines_QVector.push_back(*(lines_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DrawLinePlot_IsBase(true);
        vqcpgraph->drawLinePlot(painter, lines_QVector);
    } else {
        ((VirtualQCPGraph*)self)->drawLinePlot(painter, lines_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnDrawLinePlot(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DrawLinePlot_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_DrawLinePlot_Callback>(slot));
    }
}

// Base class handler implementation
void QCPGraph_QBaseDrawImpulsePlot(const QCPGraph* self, QCPPainter* painter, const libqt_list /* of QPointF* */ lines) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QPointF> lines_QVector;
    lines_QVector.reserve(lines.len);
    QPointF** lines_arr = static_cast<QPointF**>(lines.data);
    for (size_t i = 0; i < lines.len; ++i) {
        lines_QVector.push_back(*(lines_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DrawImpulsePlot_IsBase(true);
        vqcpgraph->drawImpulsePlot(painter, lines_QVector);
    } else {
        ((VirtualQCPGraph*)self)->drawImpulsePlot(painter, lines_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnDrawImpulsePlot(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DrawImpulsePlot_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_DrawImpulsePlot_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPGraph_DataCount(const QCPGraph* self) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return vqcpgraph->dataCount();
    } else {
        return ((VirtualQCPGraph*)self)->dataCount();
    }
}

// Base class handler implementation
int QCPGraph_QBaseDataCount(const QCPGraph* self) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DataCount_IsBase(true);
        return vqcpgraph->dataCount();
    } else {
        return ((VirtualQCPGraph*)self)->dataCount();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnDataCount(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DataCount_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_DataCount_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPGraph_DataMainKey(const QCPGraph* self, int index) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return vqcpgraph->dataMainKey(static_cast<int>(index));
    } else {
        return ((VirtualQCPGraph*)self)->dataMainKey(static_cast<int>(index));
    }
}

// Base class handler implementation
double QCPGraph_QBaseDataMainKey(const QCPGraph* self, int index) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DataMainKey_IsBase(true);
        return vqcpgraph->dataMainKey(static_cast<int>(index));
    } else {
        return ((VirtualQCPGraph*)self)->dataMainKey(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnDataMainKey(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DataMainKey_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_DataMainKey_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPGraph_DataSortKey(const QCPGraph* self, int index) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return vqcpgraph->dataSortKey(static_cast<int>(index));
    } else {
        return ((VirtualQCPGraph*)self)->dataSortKey(static_cast<int>(index));
    }
}

// Base class handler implementation
double QCPGraph_QBaseDataSortKey(const QCPGraph* self, int index) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DataSortKey_IsBase(true);
        return vqcpgraph->dataSortKey(static_cast<int>(index));
    } else {
        return ((VirtualQCPGraph*)self)->dataSortKey(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnDataSortKey(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DataSortKey_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_DataSortKey_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPGraph_DataMainValue(const QCPGraph* self, int index) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return vqcpgraph->dataMainValue(static_cast<int>(index));
    } else {
        return ((VirtualQCPGraph*)self)->dataMainValue(static_cast<int>(index));
    }
}

// Base class handler implementation
double QCPGraph_QBaseDataMainValue(const QCPGraph* self, int index) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DataMainValue_IsBase(true);
        return vqcpgraph->dataMainValue(static_cast<int>(index));
    } else {
        return ((VirtualQCPGraph*)self)->dataMainValue(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnDataMainValue(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DataMainValue_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_DataMainValue_Callback>(slot));
    }
}

// Derived class handler implementation
QCPRange* QCPGraph_DataValueRange(const QCPGraph* self, int index) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return new QCPRange(vqcpgraph->dataValueRange(static_cast<int>(index)));
    } else {
        return new QCPRange(((VirtualQCPGraph*)self)->dataValueRange(static_cast<int>(index)));
    }
}

// Base class handler implementation
QCPRange* QCPGraph_QBaseDataValueRange(const QCPGraph* self, int index) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DataValueRange_IsBase(true);
        return new QCPRange(vqcpgraph->dataValueRange(static_cast<int>(index)));
    } else {
        return new QCPRange(((VirtualQCPGraph*)self)->dataValueRange(static_cast<int>(index)));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnDataValueRange(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DataValueRange_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_DataValueRange_Callback>(slot));
    }
}

// Derived class handler implementation
QPointF* QCPGraph_DataPixelPosition(const QCPGraph* self, int index) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return new QPointF(vqcpgraph->dataPixelPosition(static_cast<int>(index)));
    } else {
        return new QPointF(((VirtualQCPGraph*)self)->dataPixelPosition(static_cast<int>(index)));
    }
}

// Base class handler implementation
QPointF* QCPGraph_QBaseDataPixelPosition(const QCPGraph* self, int index) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DataPixelPosition_IsBase(true);
        return new QPointF(vqcpgraph->dataPixelPosition(static_cast<int>(index)));
    } else {
        return new QPointF(((VirtualQCPGraph*)self)->dataPixelPosition(static_cast<int>(index)));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnDataPixelPosition(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DataPixelPosition_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_DataPixelPosition_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPGraph_SortKeyIsMainKey(const QCPGraph* self) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return vqcpgraph->sortKeyIsMainKey();
    } else {
        return ((VirtualQCPGraph*)self)->sortKeyIsMainKey();
    }
}

// Base class handler implementation
bool QCPGraph_QBaseSortKeyIsMainKey(const QCPGraph* self) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_SortKeyIsMainKey_IsBase(true);
        return vqcpgraph->sortKeyIsMainKey();
    } else {
        return ((VirtualQCPGraph*)self)->sortKeyIsMainKey();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnSortKeyIsMainKey(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_SortKeyIsMainKey_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_SortKeyIsMainKey_Callback>(slot));
    }
}

// Derived class handler implementation
QCPDataSelection* QCPGraph_SelectTestRect(const QCPGraph* self, const QRectF* rect, bool onlySelectable) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return new QCPDataSelection(vqcpgraph->selectTestRect(*rect, onlySelectable));
    } else {
        return new QCPDataSelection(((VirtualQCPGraph*)self)->selectTestRect(*rect, onlySelectable));
    }
}

// Base class handler implementation
QCPDataSelection* QCPGraph_QBaseSelectTestRect(const QCPGraph* self, const QRectF* rect, bool onlySelectable) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_SelectTestRect_IsBase(true);
        return new QCPDataSelection(vqcpgraph->selectTestRect(*rect, onlySelectable));
    } else {
        return new QCPDataSelection(((VirtualQCPGraph*)self)->selectTestRect(*rect, onlySelectable));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnSelectTestRect(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_SelectTestRect_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_SelectTestRect_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPGraph_FindBegin(const QCPGraph* self, double sortKey, bool expandedRange) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return vqcpgraph->findBegin(static_cast<double>(sortKey), expandedRange);
    } else {
        return ((VirtualQCPGraph*)self)->findBegin(static_cast<double>(sortKey), expandedRange);
    }
}

// Base class handler implementation
int QCPGraph_QBaseFindBegin(const QCPGraph* self, double sortKey, bool expandedRange) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_FindBegin_IsBase(true);
        return vqcpgraph->findBegin(static_cast<double>(sortKey), expandedRange);
    } else {
        return ((VirtualQCPGraph*)self)->findBegin(static_cast<double>(sortKey), expandedRange);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnFindBegin(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_FindBegin_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_FindBegin_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPGraph_FindEnd(const QCPGraph* self, double sortKey, bool expandedRange) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return vqcpgraph->findEnd(static_cast<double>(sortKey), expandedRange);
    } else {
        return ((VirtualQCPGraph*)self)->findEnd(static_cast<double>(sortKey), expandedRange);
    }
}

// Base class handler implementation
int QCPGraph_QBaseFindEnd(const QCPGraph* self, double sortKey, bool expandedRange) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_FindEnd_IsBase(true);
        return vqcpgraph->findEnd(static_cast<double>(sortKey), expandedRange);
    } else {
        return ((VirtualQCPGraph*)self)->findEnd(static_cast<double>(sortKey), expandedRange);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnFindEnd(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_FindEnd_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_FindEnd_Callback>(slot));
    }
}

// Derived class handler implementation
QCPPlottableInterface1D* QCPGraph_Interface1D(QCPGraph* self) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return vqcpgraph->interface1D();
    } else {
        return self->QCPGraph::interface1D();
    }
}

// Base class handler implementation
QCPPlottableInterface1D* QCPGraph_QBaseInterface1D(QCPGraph* self) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_Interface1D_IsBase(true);
        return vqcpgraph->interface1D();
    } else {
        return self->QCPGraph::interface1D();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnInterface1D(QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_Interface1D_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_Interface1D_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPGraph_ClipRect(const QCPGraph* self) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return new QRect(vqcpgraph->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPGraph_QBaseClipRect(const QCPGraph* self) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_ClipRect_IsBase(true);
        return new QRect(vqcpgraph->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnClipRect(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_ClipRect_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPGraph_SelectionCategory(const QCPGraph* self) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return static_cast<int>(vqcpgraph->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPGraph*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPGraph_QBaseSelectionCategory(const QCPGraph* self) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcpgraph->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPGraph*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnSelectionCategory(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_SelectionCategory_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGraph_ApplyDefaultAntialiasingHint(const QCPGraph* self, QCPPainter* painter) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPGraph*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPGraph_QBaseApplyDefaultAntialiasingHint(const QCPGraph* self, QCPPainter* painter) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcpgraph->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPGraph*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnApplyDefaultAntialiasingHint(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGraph_SelectEvent(QCPGraph* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPGraph*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPGraph_QBaseSelectEvent(QCPGraph* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_SelectEvent_IsBase(true);
        vqcpgraph->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPGraph*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnSelectEvent(QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_SelectEvent_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGraph_DeselectEvent(QCPGraph* self, bool* selectionStateChanged) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPGraph*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPGraph_QBaseDeselectEvent(QCPGraph* self, bool* selectionStateChanged) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DeselectEvent_IsBase(true);
        vqcpgraph->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPGraph*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnDeselectEvent(QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DeselectEvent_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGraph_ParentPlotInitialized(QCPGraph* self, QCustomPlot* parentPlot) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPGraph*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPGraph_QBaseParentPlotInitialized(QCPGraph* self, QCustomPlot* parentPlot) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_ParentPlotInitialized_IsBase(true);
        vqcpgraph->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPGraph*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnParentPlotInitialized(QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGraph_MousePressEvent(QCPGraph* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPGraph*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPGraph_QBaseMousePressEvent(QCPGraph* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_MousePressEvent_IsBase(true);
        vqcpgraph->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPGraph*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnMousePressEvent(QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_MousePressEvent_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGraph_MouseMoveEvent(QCPGraph* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPGraph*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPGraph_QBaseMouseMoveEvent(QCPGraph* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_MouseMoveEvent_IsBase(true);
        vqcpgraph->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPGraph*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnMouseMoveEvent(QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGraph_MouseReleaseEvent(QCPGraph* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPGraph*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPGraph_QBaseMouseReleaseEvent(QCPGraph* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_MouseReleaseEvent_IsBase(true);
        vqcpgraph->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPGraph*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnMouseReleaseEvent(QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGraph_MouseDoubleClickEvent(QCPGraph* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPGraph*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPGraph_QBaseMouseDoubleClickEvent(QCPGraph* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_MouseDoubleClickEvent_IsBase(true);
        vqcpgraph->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPGraph*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnMouseDoubleClickEvent(QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGraph_WheelEvent(QCPGraph* self, QWheelEvent* event) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->wheelEvent(event);
    } else {
        ((VirtualQCPGraph*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPGraph_QBaseWheelEvent(QCPGraph* self, QWheelEvent* event) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_WheelEvent_IsBase(true);
        vqcpgraph->wheelEvent(event);
    } else {
        ((VirtualQCPGraph*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnWheelEvent(QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_WheelEvent_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPGraph_Event(QCPGraph* self, QEvent* event) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return vqcpgraph->event(event);
    } else {
        return self->QCPGraph::event(event);
    }
}

// Base class handler implementation
bool QCPGraph_QBaseEvent(QCPGraph* self, QEvent* event) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_Event_IsBase(true);
        return vqcpgraph->event(event);
    } else {
        return self->QCPGraph::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnEvent(QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_Event_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPGraph_EventFilter(QCPGraph* self, QObject* watched, QEvent* event) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return vqcpgraph->eventFilter(watched, event);
    } else {
        return self->QCPGraph::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPGraph_QBaseEventFilter(QCPGraph* self, QObject* watched, QEvent* event) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_EventFilter_IsBase(true);
        return vqcpgraph->eventFilter(watched, event);
    } else {
        return self->QCPGraph::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnEventFilter(QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_EventFilter_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGraph_TimerEvent(QCPGraph* self, QTimerEvent* event) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->timerEvent(event);
    } else {
        ((VirtualQCPGraph*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPGraph_QBaseTimerEvent(QCPGraph* self, QTimerEvent* event) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_TimerEvent_IsBase(true);
        vqcpgraph->timerEvent(event);
    } else {
        ((VirtualQCPGraph*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnTimerEvent(QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_TimerEvent_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGraph_ChildEvent(QCPGraph* self, QChildEvent* event) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->childEvent(event);
    } else {
        ((VirtualQCPGraph*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPGraph_QBaseChildEvent(QCPGraph* self, QChildEvent* event) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_ChildEvent_IsBase(true);
        vqcpgraph->childEvent(event);
    } else {
        ((VirtualQCPGraph*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnChildEvent(QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_ChildEvent_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGraph_CustomEvent(QCPGraph* self, QEvent* event) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->customEvent(event);
    } else {
        ((VirtualQCPGraph*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPGraph_QBaseCustomEvent(QCPGraph* self, QEvent* event) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_CustomEvent_IsBase(true);
        vqcpgraph->customEvent(event);
    } else {
        ((VirtualQCPGraph*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnCustomEvent(QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_CustomEvent_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGraph_ConnectNotify(QCPGraph* self, const QMetaMethod* signal) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->connectNotify(*signal);
    } else {
        ((VirtualQCPGraph*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPGraph_QBaseConnectNotify(QCPGraph* self, const QMetaMethod* signal) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_ConnectNotify_IsBase(true);
        vqcpgraph->connectNotify(*signal);
    } else {
        ((VirtualQCPGraph*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnConnectNotify(QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_ConnectNotify_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGraph_DisconnectNotify(QCPGraph* self, const QMetaMethod* signal) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->disconnectNotify(*signal);
    } else {
        ((VirtualQCPGraph*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPGraph_QBaseDisconnectNotify(QCPGraph* self, const QMetaMethod* signal) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DisconnectNotify_IsBase(true);
        vqcpgraph->disconnectNotify(*signal);
    } else {
        ((VirtualQCPGraph*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnDisconnectNotify(QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGraph_GetLines(const QCPGraph* self, libqt_list /* of QPointF* */ lines, const QCPDataRange* dataRange) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QPointF> lines_QVector;
    lines_QVector.reserve(lines.len);
    QPointF** lines_arr = static_cast<QPointF**>(lines.data);
    for (size_t i = 0; i < lines.len; ++i) {
        lines_QVector.push_back(*(lines_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->getLines(&lines_QVector, *dataRange);
    } else {
        ((VirtualQCPGraph*)self)->getLines(&lines_QVector, *dataRange);
    }
}

// Base class handler implementation
void QCPGraph_QBaseGetLines(const QCPGraph* self, libqt_list /* of QPointF* */ lines, const QCPDataRange* dataRange) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QPointF> lines_QVector;
    lines_QVector.reserve(lines.len);
    QPointF** lines_arr = static_cast<QPointF**>(lines.data);
    for (size_t i = 0; i < lines.len; ++i) {
        lines_QVector.push_back(*(lines_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_GetLines_IsBase(true);
        vqcpgraph->getLines(&lines_QVector, *dataRange);
    } else {
        ((VirtualQCPGraph*)self)->getLines(&lines_QVector, *dataRange);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnGetLines(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_GetLines_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_GetLines_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGraph_GetScatters(const QCPGraph* self, libqt_list /* of QPointF* */ scatters, const QCPDataRange* dataRange) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QPointF> scatters_QVector;
    scatters_QVector.reserve(scatters.len);
    QPointF** scatters_arr = static_cast<QPointF**>(scatters.data);
    for (size_t i = 0; i < scatters.len; ++i) {
        scatters_QVector.push_back(*(scatters_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->getScatters(&scatters_QVector, *dataRange);
    } else {
        ((VirtualQCPGraph*)self)->getScatters(&scatters_QVector, *dataRange);
    }
}

// Base class handler implementation
void QCPGraph_QBaseGetScatters(const QCPGraph* self, libqt_list /* of QPointF* */ scatters, const QCPDataRange* dataRange) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QPointF> scatters_QVector;
    scatters_QVector.reserve(scatters.len);
    QPointF** scatters_arr = static_cast<QPointF**>(scatters.data);
    for (size_t i = 0; i < scatters.len; ++i) {
        scatters_QVector.push_back(*(scatters_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_GetScatters_IsBase(true);
        vqcpgraph->getScatters(&scatters_QVector, *dataRange);
    } else {
        ((VirtualQCPGraph*)self)->getScatters(&scatters_QVector, *dataRange);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnGetScatters(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_GetScatters_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_GetScatters_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of QPointF* */ QCPGraph_DataToLines(const QCPGraph* self, const libqt_list /* of QCPGraphData* */ data) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QCPGraphData> data_QVector;
    data_QVector.reserve(data.len);
    QCPGraphData** data_arr = static_cast<QCPGraphData**>(data.data);
    for (size_t i = 0; i < data.len; ++i) {
        data_QVector.push_back(*(data_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        QVector<QPointF> _ret = vqcpgraph->dataToLines(data_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QPointF> _ret = ((VirtualQCPGraph*)self)->dataToLines(data_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of QPointF* */ QCPGraph_QBaseDataToLines(const QCPGraph* self, const libqt_list /* of QCPGraphData* */ data) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QCPGraphData> data_QVector;
    data_QVector.reserve(data.len);
    QCPGraphData** data_arr = static_cast<QCPGraphData**>(data.data);
    for (size_t i = 0; i < data.len; ++i) {
        data_QVector.push_back(*(data_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DataToLines_IsBase(true);
        QVector<QPointF> _ret = vqcpgraph->dataToLines(data_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QPointF> _ret = ((VirtualQCPGraph*)self)->dataToLines(data_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnDataToLines(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DataToLines_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_DataToLines_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of QPointF* */ QCPGraph_DataToStepLeftLines(const QCPGraph* self, const libqt_list /* of QCPGraphData* */ data) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QCPGraphData> data_QVector;
    data_QVector.reserve(data.len);
    QCPGraphData** data_arr = static_cast<QCPGraphData**>(data.data);
    for (size_t i = 0; i < data.len; ++i) {
        data_QVector.push_back(*(data_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        QVector<QPointF> _ret = vqcpgraph->dataToStepLeftLines(data_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QPointF> _ret = ((VirtualQCPGraph*)self)->dataToStepLeftLines(data_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of QPointF* */ QCPGraph_QBaseDataToStepLeftLines(const QCPGraph* self, const libqt_list /* of QCPGraphData* */ data) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QCPGraphData> data_QVector;
    data_QVector.reserve(data.len);
    QCPGraphData** data_arr = static_cast<QCPGraphData**>(data.data);
    for (size_t i = 0; i < data.len; ++i) {
        data_QVector.push_back(*(data_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DataToStepLeftLines_IsBase(true);
        QVector<QPointF> _ret = vqcpgraph->dataToStepLeftLines(data_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QPointF> _ret = ((VirtualQCPGraph*)self)->dataToStepLeftLines(data_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnDataToStepLeftLines(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DataToStepLeftLines_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_DataToStepLeftLines_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of QPointF* */ QCPGraph_DataToStepRightLines(const QCPGraph* self, const libqt_list /* of QCPGraphData* */ data) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QCPGraphData> data_QVector;
    data_QVector.reserve(data.len);
    QCPGraphData** data_arr = static_cast<QCPGraphData**>(data.data);
    for (size_t i = 0; i < data.len; ++i) {
        data_QVector.push_back(*(data_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        QVector<QPointF> _ret = vqcpgraph->dataToStepRightLines(data_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QPointF> _ret = ((VirtualQCPGraph*)self)->dataToStepRightLines(data_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of QPointF* */ QCPGraph_QBaseDataToStepRightLines(const QCPGraph* self, const libqt_list /* of QCPGraphData* */ data) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QCPGraphData> data_QVector;
    data_QVector.reserve(data.len);
    QCPGraphData** data_arr = static_cast<QCPGraphData**>(data.data);
    for (size_t i = 0; i < data.len; ++i) {
        data_QVector.push_back(*(data_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DataToStepRightLines_IsBase(true);
        QVector<QPointF> _ret = vqcpgraph->dataToStepRightLines(data_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QPointF> _ret = ((VirtualQCPGraph*)self)->dataToStepRightLines(data_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnDataToStepRightLines(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DataToStepRightLines_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_DataToStepRightLines_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of QPointF* */ QCPGraph_DataToStepCenterLines(const QCPGraph* self, const libqt_list /* of QCPGraphData* */ data) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QCPGraphData> data_QVector;
    data_QVector.reserve(data.len);
    QCPGraphData** data_arr = static_cast<QCPGraphData**>(data.data);
    for (size_t i = 0; i < data.len; ++i) {
        data_QVector.push_back(*(data_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        QVector<QPointF> _ret = vqcpgraph->dataToStepCenterLines(data_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QPointF> _ret = ((VirtualQCPGraph*)self)->dataToStepCenterLines(data_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of QPointF* */ QCPGraph_QBaseDataToStepCenterLines(const QCPGraph* self, const libqt_list /* of QCPGraphData* */ data) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QCPGraphData> data_QVector;
    data_QVector.reserve(data.len);
    QCPGraphData** data_arr = static_cast<QCPGraphData**>(data.data);
    for (size_t i = 0; i < data.len; ++i) {
        data_QVector.push_back(*(data_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DataToStepCenterLines_IsBase(true);
        QVector<QPointF> _ret = vqcpgraph->dataToStepCenterLines(data_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QPointF> _ret = ((VirtualQCPGraph*)self)->dataToStepCenterLines(data_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnDataToStepCenterLines(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DataToStepCenterLines_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_DataToStepCenterLines_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of QPointF* */ QCPGraph_DataToImpulseLines(const QCPGraph* self, const libqt_list /* of QCPGraphData* */ data) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QCPGraphData> data_QVector;
    data_QVector.reserve(data.len);
    QCPGraphData** data_arr = static_cast<QCPGraphData**>(data.data);
    for (size_t i = 0; i < data.len; ++i) {
        data_QVector.push_back(*(data_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        QVector<QPointF> _ret = vqcpgraph->dataToImpulseLines(data_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QPointF> _ret = ((VirtualQCPGraph*)self)->dataToImpulseLines(data_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of QPointF* */ QCPGraph_QBaseDataToImpulseLines(const QCPGraph* self, const libqt_list /* of QCPGraphData* */ data) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QCPGraphData> data_QVector;
    data_QVector.reserve(data.len);
    QCPGraphData** data_arr = static_cast<QCPGraphData**>(data.data);
    for (size_t i = 0; i < data.len; ++i) {
        data_QVector.push_back(*(data_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DataToImpulseLines_IsBase(true);
        QVector<QPointF> _ret = vqcpgraph->dataToImpulseLines(data_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QPointF> _ret = ((VirtualQCPGraph*)self)->dataToImpulseLines(data_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnDataToImpulseLines(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_DataToImpulseLines_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_DataToImpulseLines_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of QCPDataRange* */ QCPGraph_GetNonNanSegments(const QCPGraph* self, const libqt_list /* of QPointF* */ lineData, int keyOrientation) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QPointF> lineData_QVector;
    lineData_QVector.reserve(lineData.len);
    QPointF** lineData_arr = static_cast<QPointF**>(lineData.data);
    for (size_t i = 0; i < lineData.len; ++i) {
        lineData_QVector.push_back(*(lineData_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        QVector<QCPDataRange> _ret = vqcpgraph->getNonNanSegments(&lineData_QVector, static_cast<Qt::Orientation>(keyOrientation));
        // Convert QVector<> from C++ memory to manually-managed C memory
        QCPDataRange** _arr = static_cast<QCPDataRange**>(malloc(sizeof(QCPDataRange*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QCPDataRange(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QCPDataRange> _ret = ((VirtualQCPGraph*)self)->getNonNanSegments(&lineData_QVector, static_cast<Qt::Orientation>(keyOrientation));
        // Convert QVector<> from C++ memory to manually-managed C memory
        QCPDataRange** _arr = static_cast<QCPDataRange**>(malloc(sizeof(QCPDataRange*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QCPDataRange(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of QCPDataRange* */ QCPGraph_QBaseGetNonNanSegments(const QCPGraph* self, const libqt_list /* of QPointF* */ lineData, int keyOrientation) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QPointF> lineData_QVector;
    lineData_QVector.reserve(lineData.len);
    QPointF** lineData_arr = static_cast<QPointF**>(lineData.data);
    for (size_t i = 0; i < lineData.len; ++i) {
        lineData_QVector.push_back(*(lineData_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_GetNonNanSegments_IsBase(true);
        QVector<QCPDataRange> _ret = vqcpgraph->getNonNanSegments(&lineData_QVector, static_cast<Qt::Orientation>(keyOrientation));
        // Convert QVector<> from C++ memory to manually-managed C memory
        QCPDataRange** _arr = static_cast<QCPDataRange**>(malloc(sizeof(QCPDataRange*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QCPDataRange(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QCPDataRange> _ret = ((VirtualQCPGraph*)self)->getNonNanSegments(&lineData_QVector, static_cast<Qt::Orientation>(keyOrientation));
        // Convert QVector<> from C++ memory to manually-managed C memory
        QCPDataRange** _arr = static_cast<QCPDataRange**>(malloc(sizeof(QCPDataRange*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QCPDataRange(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnGetNonNanSegments(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_GetNonNanSegments_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_GetNonNanSegments_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of libqt_pair  tuple of QCPDataRange* and QCPDataRange*  */ QCPGraph_GetOverlappingSegments(const QCPGraph* self, libqt_list /* of QCPDataRange* */ thisSegments, const libqt_list /* of QPointF* */ thisData, libqt_list /* of QCPDataRange* */ otherSegments, const libqt_list /* of QPointF* */ otherData) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QCPDataRange> thisSegments_QVector;
    thisSegments_QVector.reserve(thisSegments.len);
    QCPDataRange** thisSegments_arr = static_cast<QCPDataRange**>(thisSegments.data);
    for (size_t i = 0; i < thisSegments.len; ++i) {
        thisSegments_QVector.push_back(*(thisSegments_arr[i]));
    }
    QVector<QPointF> thisData_QVector;
    thisData_QVector.reserve(thisData.len);
    QPointF** thisData_arr = static_cast<QPointF**>(thisData.data);
    for (size_t i = 0; i < thisData.len; ++i) {
        thisData_QVector.push_back(*(thisData_arr[i]));
    }
    QVector<QCPDataRange> otherSegments_QVector;
    otherSegments_QVector.reserve(otherSegments.len);
    QCPDataRange** otherSegments_arr = static_cast<QCPDataRange**>(otherSegments.data);
    for (size_t i = 0; i < otherSegments.len; ++i) {
        otherSegments_QVector.push_back(*(otherSegments_arr[i]));
    }
    QVector<QPointF> otherData_QVector;
    otherData_QVector.reserve(otherData.len);
    QPointF** otherData_arr = static_cast<QPointF**>(otherData.data);
    for (size_t i = 0; i < otherData.len; ++i) {
        otherData_QVector.push_back(*(otherData_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        QVector<QPair<QCPDataRange, QCPDataRange>> _ret = vqcpgraph->getOverlappingSegments(thisSegments_QVector, &thisData_QVector, otherSegments_QVector, &otherData_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_pair /* tuple of QCPDataRange* and QCPDataRange* */* _arr = static_cast<libqt_pair /* tuple of QCPDataRange* and QCPDataRange* */*>(malloc(sizeof(libqt_pair /* tuple of QCPDataRange* and QCPDataRange* */) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QPair<QCPDataRange, QCPDataRange> _vv_ret = _ret[i];
            // Convert QPair<> from C++ memory to manually-managed C memory
            QCPDataRange** _vv_first = static_cast<QCPDataRange**>(malloc(sizeof(QCPDataRange*)));
            QCPDataRange** _vv_second = static_cast<QCPDataRange**>(malloc(sizeof(QCPDataRange*)));
            *_vv_first = new QCPDataRange(_vv_ret.first);
            *_vv_second = new QCPDataRange(_vv_ret.second);
            libqt_pair _vv_out;
            _vv_out.first = static_cast<void*>(_vv_first);
            _vv_out.second = static_cast<void*>(_vv_second);
            _arr[i] = _vv_out;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QPair<QCPDataRange, QCPDataRange>> _ret = ((VirtualQCPGraph*)self)->getOverlappingSegments(thisSegments_QVector, &thisData_QVector, otherSegments_QVector, &otherData_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_pair /* tuple of QCPDataRange* and QCPDataRange* */* _arr = static_cast<libqt_pair /* tuple of QCPDataRange* and QCPDataRange* */*>(malloc(sizeof(libqt_pair /* tuple of QCPDataRange* and QCPDataRange* */) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QPair<QCPDataRange, QCPDataRange> _vv_ret = _ret[i];
            // Convert QPair<> from C++ memory to manually-managed C memory
            QCPDataRange** _vv_first = static_cast<QCPDataRange**>(malloc(sizeof(QCPDataRange*)));
            QCPDataRange** _vv_second = static_cast<QCPDataRange**>(malloc(sizeof(QCPDataRange*)));
            *_vv_first = new QCPDataRange(_vv_ret.first);
            *_vv_second = new QCPDataRange(_vv_ret.second);
            libqt_pair _vv_out;
            _vv_out.first = static_cast<void*>(_vv_first);
            _vv_out.second = static_cast<void*>(_vv_second);
            _arr[i] = _vv_out;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of libqt_pair  tuple of QCPDataRange* and QCPDataRange*  */ QCPGraph_QBaseGetOverlappingSegments(const QCPGraph* self, libqt_list /* of QCPDataRange* */ thisSegments, const libqt_list /* of QPointF* */ thisData, libqt_list /* of QCPDataRange* */ otherSegments, const libqt_list /* of QPointF* */ otherData) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QCPDataRange> thisSegments_QVector;
    thisSegments_QVector.reserve(thisSegments.len);
    QCPDataRange** thisSegments_arr = static_cast<QCPDataRange**>(thisSegments.data);
    for (size_t i = 0; i < thisSegments.len; ++i) {
        thisSegments_QVector.push_back(*(thisSegments_arr[i]));
    }
    QVector<QPointF> thisData_QVector;
    thisData_QVector.reserve(thisData.len);
    QPointF** thisData_arr = static_cast<QPointF**>(thisData.data);
    for (size_t i = 0; i < thisData.len; ++i) {
        thisData_QVector.push_back(*(thisData_arr[i]));
    }
    QVector<QCPDataRange> otherSegments_QVector;
    otherSegments_QVector.reserve(otherSegments.len);
    QCPDataRange** otherSegments_arr = static_cast<QCPDataRange**>(otherSegments.data);
    for (size_t i = 0; i < otherSegments.len; ++i) {
        otherSegments_QVector.push_back(*(otherSegments_arr[i]));
    }
    QVector<QPointF> otherData_QVector;
    otherData_QVector.reserve(otherData.len);
    QPointF** otherData_arr = static_cast<QPointF**>(otherData.data);
    for (size_t i = 0; i < otherData.len; ++i) {
        otherData_QVector.push_back(*(otherData_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_GetOverlappingSegments_IsBase(true);
        QVector<QPair<QCPDataRange, QCPDataRange>> _ret = vqcpgraph->getOverlappingSegments(thisSegments_QVector, &thisData_QVector, otherSegments_QVector, &otherData_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_pair /* tuple of QCPDataRange* and QCPDataRange* */* _arr = static_cast<libqt_pair /* tuple of QCPDataRange* and QCPDataRange* */*>(malloc(sizeof(libqt_pair /* tuple of QCPDataRange* and QCPDataRange* */) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QPair<QCPDataRange, QCPDataRange> _vv_ret = _ret[i];
            // Convert QPair<> from C++ memory to manually-managed C memory
            QCPDataRange** _vv_first = static_cast<QCPDataRange**>(malloc(sizeof(QCPDataRange*)));
            QCPDataRange** _vv_second = static_cast<QCPDataRange**>(malloc(sizeof(QCPDataRange*)));
            *_vv_first = new QCPDataRange(_vv_ret.first);
            *_vv_second = new QCPDataRange(_vv_ret.second);
            libqt_pair _vv_out;
            _vv_out.first = static_cast<void*>(_vv_first);
            _vv_out.second = static_cast<void*>(_vv_second);
            _arr[i] = _vv_out;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QPair<QCPDataRange, QCPDataRange>> _ret = ((VirtualQCPGraph*)self)->getOverlappingSegments(thisSegments_QVector, &thisData_QVector, otherSegments_QVector, &otherData_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        libqt_pair /* tuple of QCPDataRange* and QCPDataRange* */* _arr = static_cast<libqt_pair /* tuple of QCPDataRange* and QCPDataRange* */*>(malloc(sizeof(libqt_pair /* tuple of QCPDataRange* and QCPDataRange* */) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            QPair<QCPDataRange, QCPDataRange> _vv_ret = _ret[i];
            // Convert QPair<> from C++ memory to manually-managed C memory
            QCPDataRange** _vv_first = static_cast<QCPDataRange**>(malloc(sizeof(QCPDataRange*)));
            QCPDataRange** _vv_second = static_cast<QCPDataRange**>(malloc(sizeof(QCPDataRange*)));
            *_vv_first = new QCPDataRange(_vv_ret.first);
            *_vv_second = new QCPDataRange(_vv_ret.second);
            libqt_pair _vv_out;
            _vv_out.first = static_cast<void*>(_vv_first);
            _vv_out.second = static_cast<void*>(_vv_second);
            _arr[i] = _vv_out;
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnGetOverlappingSegments(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_GetOverlappingSegments_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_GetOverlappingSegments_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPGraph_SegmentsIntersect(const QCPGraph* self, double aLower, double aUpper, double bLower, double bUpper, int* bPrecedence) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return vqcpgraph->segmentsIntersect(static_cast<double>(aLower), static_cast<double>(aUpper), static_cast<double>(bLower), static_cast<double>(bUpper), static_cast<int&>(*bPrecedence));
    } else {
        return ((VirtualQCPGraph*)self)->segmentsIntersect(static_cast<double>(aLower), static_cast<double>(aUpper), static_cast<double>(bLower), static_cast<double>(bUpper), static_cast<int&>(*bPrecedence));
    }
}

// Base class handler implementation
bool QCPGraph_QBaseSegmentsIntersect(const QCPGraph* self, double aLower, double aUpper, double bLower, double bUpper, int* bPrecedence) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_SegmentsIntersect_IsBase(true);
        return vqcpgraph->segmentsIntersect(static_cast<double>(aLower), static_cast<double>(aUpper), static_cast<double>(bLower), static_cast<double>(bUpper), static_cast<int&>(*bPrecedence));
    } else {
        return ((VirtualQCPGraph*)self)->segmentsIntersect(static_cast<double>(aLower), static_cast<double>(aUpper), static_cast<double>(bLower), static_cast<double>(bUpper), static_cast<int&>(*bPrecedence));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnSegmentsIntersect(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_SegmentsIntersect_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_SegmentsIntersect_Callback>(slot));
    }
}

// Derived class handler implementation
QPointF* QCPGraph_GetFillBasePoint(const QCPGraph* self, QPointF* matchingDataPoint) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return new QPointF(vqcpgraph->getFillBasePoint(*matchingDataPoint));
    }
    return {};
}

// Base class handler implementation
QPointF* QCPGraph_QBaseGetFillBasePoint(const QCPGraph* self, QPointF* matchingDataPoint) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_GetFillBasePoint_IsBase(true);
        return new QPointF(vqcpgraph->getFillBasePoint(*matchingDataPoint));
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnGetFillBasePoint(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_GetFillBasePoint_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_GetFillBasePoint_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPGraph_FindIndexBelowX(const QCPGraph* self, const libqt_list /* of QPointF* */ data, double x) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QPointF> data_QVector;
    data_QVector.reserve(data.len);
    QPointF** data_arr = static_cast<QPointF**>(data.data);
    for (size_t i = 0; i < data.len; ++i) {
        data_QVector.push_back(*(data_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return vqcpgraph->findIndexBelowX(&data_QVector, static_cast<double>(x));
    } else {
        return ((VirtualQCPGraph*)self)->findIndexBelowX(&data_QVector, static_cast<double>(x));
    }
}

// Base class handler implementation
int QCPGraph_QBaseFindIndexBelowX(const QCPGraph* self, const libqt_list /* of QPointF* */ data, double x) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QPointF> data_QVector;
    data_QVector.reserve(data.len);
    QPointF** data_arr = static_cast<QPointF**>(data.data);
    for (size_t i = 0; i < data.len; ++i) {
        data_QVector.push_back(*(data_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_FindIndexBelowX_IsBase(true);
        return vqcpgraph->findIndexBelowX(&data_QVector, static_cast<double>(x));
    } else {
        return ((VirtualQCPGraph*)self)->findIndexBelowX(&data_QVector, static_cast<double>(x));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnFindIndexBelowX(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_FindIndexBelowX_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_FindIndexBelowX_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPGraph_FindIndexAboveX(const QCPGraph* self, const libqt_list /* of QPointF* */ data, double x) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QPointF> data_QVector;
    data_QVector.reserve(data.len);
    QPointF** data_arr = static_cast<QPointF**>(data.data);
    for (size_t i = 0; i < data.len; ++i) {
        data_QVector.push_back(*(data_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return vqcpgraph->findIndexAboveX(&data_QVector, static_cast<double>(x));
    } else {
        return ((VirtualQCPGraph*)self)->findIndexAboveX(&data_QVector, static_cast<double>(x));
    }
}

// Base class handler implementation
int QCPGraph_QBaseFindIndexAboveX(const QCPGraph* self, const libqt_list /* of QPointF* */ data, double x) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QPointF> data_QVector;
    data_QVector.reserve(data.len);
    QPointF** data_arr = static_cast<QPointF**>(data.data);
    for (size_t i = 0; i < data.len; ++i) {
        data_QVector.push_back(*(data_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_FindIndexAboveX_IsBase(true);
        return vqcpgraph->findIndexAboveX(&data_QVector, static_cast<double>(x));
    } else {
        return ((VirtualQCPGraph*)self)->findIndexAboveX(&data_QVector, static_cast<double>(x));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnFindIndexAboveX(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_FindIndexAboveX_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_FindIndexAboveX_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPGraph_FindIndexBelowY(const QCPGraph* self, const libqt_list /* of QPointF* */ data, double y) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QPointF> data_QVector;
    data_QVector.reserve(data.len);
    QPointF** data_arr = static_cast<QPointF**>(data.data);
    for (size_t i = 0; i < data.len; ++i) {
        data_QVector.push_back(*(data_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return vqcpgraph->findIndexBelowY(&data_QVector, static_cast<double>(y));
    } else {
        return ((VirtualQCPGraph*)self)->findIndexBelowY(&data_QVector, static_cast<double>(y));
    }
}

// Base class handler implementation
int QCPGraph_QBaseFindIndexBelowY(const QCPGraph* self, const libqt_list /* of QPointF* */ data, double y) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QPointF> data_QVector;
    data_QVector.reserve(data.len);
    QPointF** data_arr = static_cast<QPointF**>(data.data);
    for (size_t i = 0; i < data.len; ++i) {
        data_QVector.push_back(*(data_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_FindIndexBelowY_IsBase(true);
        return vqcpgraph->findIndexBelowY(&data_QVector, static_cast<double>(y));
    } else {
        return ((VirtualQCPGraph*)self)->findIndexBelowY(&data_QVector, static_cast<double>(y));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnFindIndexBelowY(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_FindIndexBelowY_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_FindIndexBelowY_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPGraph_FindIndexAboveY(const QCPGraph* self, const libqt_list /* of QPointF* */ data, double y) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QPointF> data_QVector;
    data_QVector.reserve(data.len);
    QPointF** data_arr = static_cast<QPointF**>(data.data);
    for (size_t i = 0; i < data.len; ++i) {
        data_QVector.push_back(*(data_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return vqcpgraph->findIndexAboveY(&data_QVector, static_cast<double>(y));
    } else {
        return ((VirtualQCPGraph*)self)->findIndexAboveY(&data_QVector, static_cast<double>(y));
    }
}

// Base class handler implementation
int QCPGraph_QBaseFindIndexAboveY(const QCPGraph* self, const libqt_list /* of QPointF* */ data, double y) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    QVector<QPointF> data_QVector;
    data_QVector.reserve(data.len);
    QPointF** data_arr = static_cast<QPointF**>(data.data);
    for (size_t i = 0; i < data.len; ++i) {
        data_QVector.push_back(*(data_arr[i]));
    }
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_FindIndexAboveY_IsBase(true);
        return vqcpgraph->findIndexAboveY(&data_QVector, static_cast<double>(y));
    } else {
        return ((VirtualQCPGraph*)self)->findIndexAboveY(&data_QVector, static_cast<double>(y));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnFindIndexAboveY(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_FindIndexAboveY_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_FindIndexAboveY_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGraph_ApplyFillAntialiasingHint(const QCPGraph* self, QCPPainter* painter) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->applyFillAntialiasingHint(painter);
    } else {
        ((VirtualQCPGraph*)self)->applyFillAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPGraph_QBaseApplyFillAntialiasingHint(const QCPGraph* self, QCPPainter* painter) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_ApplyFillAntialiasingHint_IsBase(true);
        vqcpgraph->applyFillAntialiasingHint(painter);
    } else {
        ((VirtualQCPGraph*)self)->applyFillAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnApplyFillAntialiasingHint(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_ApplyFillAntialiasingHint_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_ApplyFillAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGraph_ApplyScattersAntialiasingHint(const QCPGraph* self, QCPPainter* painter) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->applyScattersAntialiasingHint(painter);
    } else {
        ((VirtualQCPGraph*)self)->applyScattersAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPGraph_QBaseApplyScattersAntialiasingHint(const QCPGraph* self, QCPPainter* painter) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_ApplyScattersAntialiasingHint_IsBase(true);
        vqcpgraph->applyScattersAntialiasingHint(painter);
    } else {
        ((VirtualQCPGraph*)self)->applyScattersAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnApplyScattersAntialiasingHint(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_ApplyScattersAntialiasingHint_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_ApplyScattersAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGraph_InitializeParentPlot(QCPGraph* self, QCustomPlot* parentPlot) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPGraph*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPGraph_QBaseInitializeParentPlot(QCPGraph* self, QCustomPlot* parentPlot) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_InitializeParentPlot_IsBase(true);
        vqcpgraph->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPGraph*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnInitializeParentPlot(QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGraph_SetParentLayerable(QCPGraph* self, QCPLayerable* parentLayerable) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPGraph*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPGraph_QBaseSetParentLayerable(QCPGraph* self, QCPLayerable* parentLayerable) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_SetParentLayerable_IsBase(true);
        vqcpgraph->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPGraph*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnSetParentLayerable(QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPGraph_MoveToLayer(QCPGraph* self, QCPLayer* layer, bool prepend) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return vqcpgraph->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPGraph*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPGraph_QBaseMoveToLayer(QCPGraph* self, QCPLayer* layer, bool prepend) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_MoveToLayer_IsBase(true);
        return vqcpgraph->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPGraph*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnMoveToLayer(QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = dynamic_cast<VirtualQCPGraph*>(self);
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_MoveToLayer_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPGraph_ApplyAntialiasingHint(const QCPGraph* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPGraph*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPGraph_QBaseApplyAntialiasingHint(const QCPGraph* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_ApplyAntialiasingHint_IsBase(true);
        vqcpgraph->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPGraph*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnApplyAntialiasingHint(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPGraph_Sender(const QCPGraph* self) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return vqcpgraph->sender();
    } else {
        return ((VirtualQCPGraph*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPGraph_QBaseSender(const QCPGraph* self) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_Sender_IsBase(true);
        return vqcpgraph->sender();
    } else {
        return ((VirtualQCPGraph*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnSender(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_Sender_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPGraph_SenderSignalIndex(const QCPGraph* self) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return vqcpgraph->senderSignalIndex();
    } else {
        return ((VirtualQCPGraph*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPGraph_QBaseSenderSignalIndex(const QCPGraph* self) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_SenderSignalIndex_IsBase(true);
        return vqcpgraph->senderSignalIndex();
    } else {
        return ((VirtualQCPGraph*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnSenderSignalIndex(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPGraph_Receivers(const QCPGraph* self, const char* signal) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return vqcpgraph->receivers(signal);
    } else {
        return ((VirtualQCPGraph*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPGraph_QBaseReceivers(const QCPGraph* self, const char* signal) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_Receivers_IsBase(true);
        return vqcpgraph->receivers(signal);
    } else {
        return ((VirtualQCPGraph*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnReceivers(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_Receivers_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPGraph_IsSignalConnected(const QCPGraph* self, const QMetaMethod* signal) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        return vqcpgraph->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPGraph*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPGraph_QBaseIsSignalConnected(const QCPGraph* self, const QMetaMethod* signal) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_IsSignalConnected_IsBase(true);
        return vqcpgraph->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPGraph*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPGraph_OnIsSignalConnected(const QCPGraph* self, intptr_t slot) {
    auto* vqcpgraph = const_cast<VirtualQCPGraph*>(dynamic_cast<const VirtualQCPGraph*>(self));
    if (vqcpgraph && vqcpgraph->isVirtualQCPGraph) {
        vqcpgraph->setQCPGraph_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPGraph::QCPGraph_IsSignalConnected_Callback>(slot));
    }
}

void QCPGraph_Delete(QCPGraph* self) {
    delete self;
}

QCPCurveData* QCPCurveData_new(const QCPCurveData* other) {
    return new QCPCurveData(*other);
}

QCPCurveData* QCPCurveData_new2(QCPCurveData* other) {
    return new QCPCurveData(std::move(*other));
}

QCPCurveData* QCPCurveData_new3() {
    return new QCPCurveData();
}

QCPCurveData* QCPCurveData_new4(double t, double key, double value) {
    return new QCPCurveData(static_cast<double>(t), static_cast<double>(key), static_cast<double>(value));
}

QCPCurveData* QCPCurveData_new5(const QCPCurveData* param1) {
    return new QCPCurveData(*param1);
}

void QCPCurveData_CopyAssign(QCPCurveData* self, QCPCurveData* other) {
    *self = *other;
}

void QCPCurveData_MoveAssign(QCPCurveData* self, QCPCurveData* other) {
    *self = std::move(*other);
}

double QCPCurveData_SortKey(const QCPCurveData* self) {
    return self->sortKey();
}

QCPCurveData* QCPCurveData_FromSortKey(double sortKey) {
    return new QCPCurveData(QCPCurveData::fromSortKey(static_cast<double>(sortKey)));
}

bool QCPCurveData_SortKeyIsMainKey() {
    return QCPCurveData::sortKeyIsMainKey();
}

double QCPCurveData_MainKey(const QCPCurveData* self) {
    return self->mainKey();
}

double QCPCurveData_MainValue(const QCPCurveData* self) {
    return self->mainValue();
}

QCPRange* QCPCurveData_ValueRange(const QCPCurveData* self) {
    return new QCPRange(self->valueRange());
}

double QCPCurveData_T(const QCPCurveData* self) {
    return self->t;
}

void QCPCurveData_SetT(QCPCurveData* self, double t) {
    self->t = static_cast<double>(t);
}

double QCPCurveData_Key(const QCPCurveData* self) {
    return self->key;
}

void QCPCurveData_SetKey(QCPCurveData* self, double key) {
    self->key = static_cast<double>(key);
}

double QCPCurveData_Value(const QCPCurveData* self) {
    return self->value;
}

void QCPCurveData_SetValue(QCPCurveData* self, double value) {
    self->value = static_cast<double>(value);
}

void QCPCurveData_Delete(QCPCurveData* self) {
    delete self;
}

QCPCurve* QCPCurve_new(QCPAxis* keyAxis, QCPAxis* valueAxis) {
    return new VirtualQCPCurve(keyAxis, valueAxis);
}

QMetaObject* QCPCurve_MetaObject(const QCPCurve* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPCurve_Metacast(QCPCurve* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPCurve_Metacall(QCPCurve* self, int param1, int param2, void** param3) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPCurve*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPCurve_Tr(const char* s) {
    QString _ret = QCPCurve::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

QCPScatterStyle* QCPCurve_ScatterStyle(const QCPCurve* self) {
    return new QCPScatterStyle(self->scatterStyle());
}

int QCPCurve_ScatterSkip(const QCPCurve* self) {
    return self->scatterSkip();
}

int QCPCurve_LineStyle(const QCPCurve* self) {
    return static_cast<int>(self->lineStyle());
}

void QCPCurve_SetData2(QCPCurve* self, const libqt_list /* of double */ t, const libqt_list /* of double */ keys, const libqt_list /* of double */ values) {
    QVector<double> t_QVector;
    t_QVector.reserve(t.len);
    double* t_arr = static_cast<double*>(t.data);
    for (size_t i = 0; i < t.len; ++i) {
        t_QVector.push_back(static_cast<double>(t_arr[i]));
    }
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> values_QVector;
    values_QVector.reserve(values.len);
    double* values_arr = static_cast<double*>(values.data);
    for (size_t i = 0; i < values.len; ++i) {
        values_QVector.push_back(static_cast<double>(values_arr[i]));
    }
    self->setData(t_QVector, keys_QVector, values_QVector);
}

void QCPCurve_SetData3(QCPCurve* self, const libqt_list /* of double */ keys, const libqt_list /* of double */ values) {
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> values_QVector;
    values_QVector.reserve(values.len);
    double* values_arr = static_cast<double*>(values.data);
    for (size_t i = 0; i < values.len; ++i) {
        values_QVector.push_back(static_cast<double>(values_arr[i]));
    }
    self->setData(keys_QVector, values_QVector);
}

void QCPCurve_SetScatterStyle(QCPCurve* self, const QCPScatterStyle* style) {
    self->setScatterStyle(*style);
}

void QCPCurve_SetScatterSkip(QCPCurve* self, int skip) {
    self->setScatterSkip(static_cast<int>(skip));
}

void QCPCurve_SetLineStyle(QCPCurve* self, int style) {
    self->setLineStyle(static_cast<QCPCurve::LineStyle>(style));
}

void QCPCurve_AddData(QCPCurve* self, const libqt_list /* of double */ t, const libqt_list /* of double */ keys, const libqt_list /* of double */ values) {
    QVector<double> t_QVector;
    t_QVector.reserve(t.len);
    double* t_arr = static_cast<double*>(t.data);
    for (size_t i = 0; i < t.len; ++i) {
        t_QVector.push_back(static_cast<double>(t_arr[i]));
    }
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> values_QVector;
    values_QVector.reserve(values.len);
    double* values_arr = static_cast<double*>(values.data);
    for (size_t i = 0; i < values.len; ++i) {
        values_QVector.push_back(static_cast<double>(values_arr[i]));
    }
    self->addData(t_QVector, keys_QVector, values_QVector);
}

void QCPCurve_AddData2(QCPCurve* self, const libqt_list /* of double */ keys, const libqt_list /* of double */ values) {
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> values_QVector;
    values_QVector.reserve(values.len);
    double* values_arr = static_cast<double*>(values.data);
    for (size_t i = 0; i < values.len; ++i) {
        values_QVector.push_back(static_cast<double>(values_arr[i]));
    }
    self->addData(keys_QVector, values_QVector);
}

void QCPCurve_AddData3(QCPCurve* self, double t, double key, double value) {
    self->addData(static_cast<double>(t), static_cast<double>(key), static_cast<double>(value));
}

void QCPCurve_AddData4(QCPCurve* self, double key, double value) {
    self->addData(static_cast<double>(key), static_cast<double>(value));
}

double QCPCurve_SelectTest(const QCPCurve* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpcurve = dynamic_cast<const VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPCurve*)self)->selectTest(*pos, onlySelectable, details);
    }
}

QCPRange* QCPCurve_GetKeyRange(const QCPCurve* self, bool* foundRange, int inSignDomain) {
    auto* vqcpcurve = dynamic_cast<const VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return new QCPRange(self->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    } else {
        return new QCPRange(((VirtualQCPCurve*)self)->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    }
}

QCPRange* QCPCurve_GetValueRange(const QCPCurve* self, bool* foundRange, int inSignDomain, const QCPRange* inKeyRange) {
    auto* vqcpcurve = dynamic_cast<const VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return new QCPRange(self->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    } else {
        return new QCPRange(((VirtualQCPCurve*)self)->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    }
}

void QCPCurve_Draw(QCPCurve* self, QCPPainter* painter) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->draw(painter);
    }
}

void QCPCurve_DrawLegendIcon(const QCPCurve* self, QCPPainter* painter, const QRectF* rect) {
    auto* vqcpcurve = dynamic_cast<const VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->drawLegendIcon(painter, *rect);
    }
}

void QCPCurve_DrawCurveLine(const QCPCurve* self, QCPPainter* painter, const libqt_list /* of QPointF* */ lines) {
    QVector<QPointF> lines_QVector;
    lines_QVector.reserve(lines.len);
    QPointF** lines_arr = static_cast<QPointF**>(lines.data);
    for (size_t i = 0; i < lines.len; ++i) {
        lines_QVector.push_back(*(lines_arr[i]));
    }
    auto* vqcpcurve = dynamic_cast<const VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->drawCurveLine(painter, lines_QVector);
    }
}

void QCPCurve_DrawScatterPlot(const QCPCurve* self, QCPPainter* painter, const libqt_list /* of QPointF* */ points, const QCPScatterStyle* style) {
    QVector<QPointF> points_QVector;
    points_QVector.reserve(points.len);
    QPointF** points_arr = static_cast<QPointF**>(points.data);
    for (size_t i = 0; i < points.len; ++i) {
        points_QVector.push_back(*(points_arr[i]));
    }
    auto* vqcpcurve = dynamic_cast<const VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->drawScatterPlot(painter, points_QVector, *style);
    }
}

libqt_string QCPCurve_Tr2(const char* s, const char* c) {
    QString _ret = QCPCurve::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPCurve_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPCurve::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

void QCPCurve_SetData4(QCPCurve* self, const libqt_list /* of double */ t, const libqt_list /* of double */ keys, const libqt_list /* of double */ values, bool alreadySorted) {
    QVector<double> t_QVector;
    t_QVector.reserve(t.len);
    double* t_arr = static_cast<double*>(t.data);
    for (size_t i = 0; i < t.len; ++i) {
        t_QVector.push_back(static_cast<double>(t_arr[i]));
    }
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> values_QVector;
    values_QVector.reserve(values.len);
    double* values_arr = static_cast<double*>(values.data);
    for (size_t i = 0; i < values.len; ++i) {
        values_QVector.push_back(static_cast<double>(values_arr[i]));
    }
    self->setData(t_QVector, keys_QVector, values_QVector, alreadySorted);
}

void QCPCurve_AddData42(QCPCurve* self, const libqt_list /* of double */ t, const libqt_list /* of double */ keys, const libqt_list /* of double */ values, bool alreadySorted) {
    QVector<double> t_QVector;
    t_QVector.reserve(t.len);
    double* t_arr = static_cast<double*>(t.data);
    for (size_t i = 0; i < t.len; ++i) {
        t_QVector.push_back(static_cast<double>(t_arr[i]));
    }
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> values_QVector;
    values_QVector.reserve(values.len);
    double* values_arr = static_cast<double*>(values.data);
    for (size_t i = 0; i < values.len; ++i) {
        values_QVector.push_back(static_cast<double>(values_arr[i]));
    }
    self->addData(t_QVector, keys_QVector, values_QVector, alreadySorted);
}

// Base class handler implementation
int QCPCurve_QBaseMetacall(QCPCurve* self, int param1, int param2, void** param3) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_Metacall_IsBase(true);
        return vqcpcurve->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPCurve::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnMetacall(QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_Metacall_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
double QCPCurve_QBaseSelectTest(const QCPCurve* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_SelectTest_IsBase(true);
        return vqcpcurve->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPCurve::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnSelectTest(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_SelectTest_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
QCPRange* QCPCurve_QBaseGetKeyRange(const QCPCurve* self, bool* foundRange, int inSignDomain) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_GetKeyRange_IsBase(true);
        return new QCPRange(vqcpcurve->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    } else {
        return new QCPRange(((VirtualQCPCurve*)self)->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnGetKeyRange(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_GetKeyRange_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_GetKeyRange_Callback>(slot));
    }
}

// Base class handler implementation
QCPRange* QCPCurve_QBaseGetValueRange(const QCPCurve* self, bool* foundRange, int inSignDomain, const QCPRange* inKeyRange) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_GetValueRange_IsBase(true);
        return new QCPRange(vqcpcurve->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    } else {
        return new QCPRange(((VirtualQCPCurve*)self)->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnGetValueRange(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_GetValueRange_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_GetValueRange_Callback>(slot));
    }
}

// Base class handler implementation
void QCPCurve_QBaseDraw(QCPCurve* self, QCPPainter* painter) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_Draw_IsBase(true);
        vqcpcurve->draw(painter);
    } else {
        ((VirtualQCPCurve*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnDraw(QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_Draw_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_Draw_Callback>(slot));
    }
}

// Base class handler implementation
void QCPCurve_QBaseDrawLegendIcon(const QCPCurve* self, QCPPainter* painter, const QRectF* rect) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_DrawLegendIcon_IsBase(true);
        vqcpcurve->drawLegendIcon(painter, *rect);
    } else {
        ((VirtualQCPCurve*)self)->drawLegendIcon(painter, *rect);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnDrawLegendIcon(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_DrawLegendIcon_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_DrawLegendIcon_Callback>(slot));
    }
}

// Base class handler implementation
void QCPCurve_QBaseDrawCurveLine(const QCPCurve* self, QCPPainter* painter, const libqt_list /* of QPointF* */ lines) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    QVector<QPointF> lines_QVector;
    lines_QVector.reserve(lines.len);
    QPointF** lines_arr = static_cast<QPointF**>(lines.data);
    for (size_t i = 0; i < lines.len; ++i) {
        lines_QVector.push_back(*(lines_arr[i]));
    }
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_DrawCurveLine_IsBase(true);
        vqcpcurve->drawCurveLine(painter, lines_QVector);
    } else {
        ((VirtualQCPCurve*)self)->drawCurveLine(painter, lines_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnDrawCurveLine(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_DrawCurveLine_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_DrawCurveLine_Callback>(slot));
    }
}

// Base class handler implementation
void QCPCurve_QBaseDrawScatterPlot(const QCPCurve* self, QCPPainter* painter, const libqt_list /* of QPointF* */ points, const QCPScatterStyle* style) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    QVector<QPointF> points_QVector;
    points_QVector.reserve(points.len);
    QPointF** points_arr = static_cast<QPointF**>(points.data);
    for (size_t i = 0; i < points.len; ++i) {
        points_QVector.push_back(*(points_arr[i]));
    }
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_DrawScatterPlot_IsBase(true);
        vqcpcurve->drawScatterPlot(painter, points_QVector, *style);
    } else {
        ((VirtualQCPCurve*)self)->drawScatterPlot(painter, points_QVector, *style);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnDrawScatterPlot(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_DrawScatterPlot_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_DrawScatterPlot_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPCurve_DataCount(const QCPCurve* self) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return vqcpcurve->dataCount();
    } else {
        return ((VirtualQCPCurve*)self)->dataCount();
    }
}

// Base class handler implementation
int QCPCurve_QBaseDataCount(const QCPCurve* self) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_DataCount_IsBase(true);
        return vqcpcurve->dataCount();
    } else {
        return ((VirtualQCPCurve*)self)->dataCount();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnDataCount(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_DataCount_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_DataCount_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPCurve_DataMainKey(const QCPCurve* self, int index) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return vqcpcurve->dataMainKey(static_cast<int>(index));
    } else {
        return ((VirtualQCPCurve*)self)->dataMainKey(static_cast<int>(index));
    }
}

// Base class handler implementation
double QCPCurve_QBaseDataMainKey(const QCPCurve* self, int index) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_DataMainKey_IsBase(true);
        return vqcpcurve->dataMainKey(static_cast<int>(index));
    } else {
        return ((VirtualQCPCurve*)self)->dataMainKey(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnDataMainKey(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_DataMainKey_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_DataMainKey_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPCurve_DataSortKey(const QCPCurve* self, int index) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return vqcpcurve->dataSortKey(static_cast<int>(index));
    } else {
        return ((VirtualQCPCurve*)self)->dataSortKey(static_cast<int>(index));
    }
}

// Base class handler implementation
double QCPCurve_QBaseDataSortKey(const QCPCurve* self, int index) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_DataSortKey_IsBase(true);
        return vqcpcurve->dataSortKey(static_cast<int>(index));
    } else {
        return ((VirtualQCPCurve*)self)->dataSortKey(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnDataSortKey(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_DataSortKey_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_DataSortKey_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPCurve_DataMainValue(const QCPCurve* self, int index) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return vqcpcurve->dataMainValue(static_cast<int>(index));
    } else {
        return ((VirtualQCPCurve*)self)->dataMainValue(static_cast<int>(index));
    }
}

// Base class handler implementation
double QCPCurve_QBaseDataMainValue(const QCPCurve* self, int index) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_DataMainValue_IsBase(true);
        return vqcpcurve->dataMainValue(static_cast<int>(index));
    } else {
        return ((VirtualQCPCurve*)self)->dataMainValue(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnDataMainValue(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_DataMainValue_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_DataMainValue_Callback>(slot));
    }
}

// Derived class handler implementation
QCPRange* QCPCurve_DataValueRange(const QCPCurve* self, int index) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return new QCPRange(vqcpcurve->dataValueRange(static_cast<int>(index)));
    } else {
        return new QCPRange(((VirtualQCPCurve*)self)->dataValueRange(static_cast<int>(index)));
    }
}

// Base class handler implementation
QCPRange* QCPCurve_QBaseDataValueRange(const QCPCurve* self, int index) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_DataValueRange_IsBase(true);
        return new QCPRange(vqcpcurve->dataValueRange(static_cast<int>(index)));
    } else {
        return new QCPRange(((VirtualQCPCurve*)self)->dataValueRange(static_cast<int>(index)));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnDataValueRange(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_DataValueRange_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_DataValueRange_Callback>(slot));
    }
}

// Derived class handler implementation
QPointF* QCPCurve_DataPixelPosition(const QCPCurve* self, int index) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return new QPointF(vqcpcurve->dataPixelPosition(static_cast<int>(index)));
    } else {
        return new QPointF(((VirtualQCPCurve*)self)->dataPixelPosition(static_cast<int>(index)));
    }
}

// Base class handler implementation
QPointF* QCPCurve_QBaseDataPixelPosition(const QCPCurve* self, int index) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_DataPixelPosition_IsBase(true);
        return new QPointF(vqcpcurve->dataPixelPosition(static_cast<int>(index)));
    } else {
        return new QPointF(((VirtualQCPCurve*)self)->dataPixelPosition(static_cast<int>(index)));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnDataPixelPosition(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_DataPixelPosition_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_DataPixelPosition_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPCurve_SortKeyIsMainKey(const QCPCurve* self) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return vqcpcurve->sortKeyIsMainKey();
    } else {
        return ((VirtualQCPCurve*)self)->sortKeyIsMainKey();
    }
}

// Base class handler implementation
bool QCPCurve_QBaseSortKeyIsMainKey(const QCPCurve* self) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_SortKeyIsMainKey_IsBase(true);
        return vqcpcurve->sortKeyIsMainKey();
    } else {
        return ((VirtualQCPCurve*)self)->sortKeyIsMainKey();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnSortKeyIsMainKey(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_SortKeyIsMainKey_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_SortKeyIsMainKey_Callback>(slot));
    }
}

// Derived class handler implementation
QCPDataSelection* QCPCurve_SelectTestRect(const QCPCurve* self, const QRectF* rect, bool onlySelectable) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return new QCPDataSelection(vqcpcurve->selectTestRect(*rect, onlySelectable));
    } else {
        return new QCPDataSelection(((VirtualQCPCurve*)self)->selectTestRect(*rect, onlySelectable));
    }
}

// Base class handler implementation
QCPDataSelection* QCPCurve_QBaseSelectTestRect(const QCPCurve* self, const QRectF* rect, bool onlySelectable) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_SelectTestRect_IsBase(true);
        return new QCPDataSelection(vqcpcurve->selectTestRect(*rect, onlySelectable));
    } else {
        return new QCPDataSelection(((VirtualQCPCurve*)self)->selectTestRect(*rect, onlySelectable));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnSelectTestRect(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_SelectTestRect_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_SelectTestRect_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPCurve_FindBegin(const QCPCurve* self, double sortKey, bool expandedRange) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return vqcpcurve->findBegin(static_cast<double>(sortKey), expandedRange);
    } else {
        return ((VirtualQCPCurve*)self)->findBegin(static_cast<double>(sortKey), expandedRange);
    }
}

// Base class handler implementation
int QCPCurve_QBaseFindBegin(const QCPCurve* self, double sortKey, bool expandedRange) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_FindBegin_IsBase(true);
        return vqcpcurve->findBegin(static_cast<double>(sortKey), expandedRange);
    } else {
        return ((VirtualQCPCurve*)self)->findBegin(static_cast<double>(sortKey), expandedRange);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnFindBegin(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_FindBegin_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_FindBegin_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPCurve_FindEnd(const QCPCurve* self, double sortKey, bool expandedRange) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return vqcpcurve->findEnd(static_cast<double>(sortKey), expandedRange);
    } else {
        return ((VirtualQCPCurve*)self)->findEnd(static_cast<double>(sortKey), expandedRange);
    }
}

// Base class handler implementation
int QCPCurve_QBaseFindEnd(const QCPCurve* self, double sortKey, bool expandedRange) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_FindEnd_IsBase(true);
        return vqcpcurve->findEnd(static_cast<double>(sortKey), expandedRange);
    } else {
        return ((VirtualQCPCurve*)self)->findEnd(static_cast<double>(sortKey), expandedRange);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnFindEnd(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_FindEnd_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_FindEnd_Callback>(slot));
    }
}

// Derived class handler implementation
QCPPlottableInterface1D* QCPCurve_Interface1D(QCPCurve* self) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return vqcpcurve->interface1D();
    } else {
        return self->QCPCurve::interface1D();
    }
}

// Base class handler implementation
QCPPlottableInterface1D* QCPCurve_QBaseInterface1D(QCPCurve* self) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_Interface1D_IsBase(true);
        return vqcpcurve->interface1D();
    } else {
        return self->QCPCurve::interface1D();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnInterface1D(QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_Interface1D_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_Interface1D_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPCurve_ClipRect(const QCPCurve* self) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return new QRect(vqcpcurve->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPCurve_QBaseClipRect(const QCPCurve* self) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_ClipRect_IsBase(true);
        return new QRect(vqcpcurve->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnClipRect(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_ClipRect_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPCurve_SelectionCategory(const QCPCurve* self) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return static_cast<int>(vqcpcurve->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPCurve*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPCurve_QBaseSelectionCategory(const QCPCurve* self) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcpcurve->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPCurve*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnSelectionCategory(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_SelectionCategory_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPCurve_ApplyDefaultAntialiasingHint(const QCPCurve* self, QCPPainter* painter) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPCurve*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPCurve_QBaseApplyDefaultAntialiasingHint(const QCPCurve* self, QCPPainter* painter) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcpcurve->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPCurve*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnApplyDefaultAntialiasingHint(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPCurve_SelectEvent(QCPCurve* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPCurve*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPCurve_QBaseSelectEvent(QCPCurve* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_SelectEvent_IsBase(true);
        vqcpcurve->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPCurve*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnSelectEvent(QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_SelectEvent_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPCurve_DeselectEvent(QCPCurve* self, bool* selectionStateChanged) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPCurve*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPCurve_QBaseDeselectEvent(QCPCurve* self, bool* selectionStateChanged) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_DeselectEvent_IsBase(true);
        vqcpcurve->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPCurve*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnDeselectEvent(QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_DeselectEvent_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPCurve_ParentPlotInitialized(QCPCurve* self, QCustomPlot* parentPlot) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPCurve*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPCurve_QBaseParentPlotInitialized(QCPCurve* self, QCustomPlot* parentPlot) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_ParentPlotInitialized_IsBase(true);
        vqcpcurve->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPCurve*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnParentPlotInitialized(QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPCurve_MousePressEvent(QCPCurve* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPCurve*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPCurve_QBaseMousePressEvent(QCPCurve* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_MousePressEvent_IsBase(true);
        vqcpcurve->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPCurve*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnMousePressEvent(QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_MousePressEvent_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPCurve_MouseMoveEvent(QCPCurve* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPCurve*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPCurve_QBaseMouseMoveEvent(QCPCurve* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_MouseMoveEvent_IsBase(true);
        vqcpcurve->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPCurve*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnMouseMoveEvent(QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPCurve_MouseReleaseEvent(QCPCurve* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPCurve*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPCurve_QBaseMouseReleaseEvent(QCPCurve* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_MouseReleaseEvent_IsBase(true);
        vqcpcurve->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPCurve*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnMouseReleaseEvent(QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPCurve_MouseDoubleClickEvent(QCPCurve* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPCurve*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPCurve_QBaseMouseDoubleClickEvent(QCPCurve* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_MouseDoubleClickEvent_IsBase(true);
        vqcpcurve->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPCurve*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnMouseDoubleClickEvent(QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPCurve_WheelEvent(QCPCurve* self, QWheelEvent* event) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->wheelEvent(event);
    } else {
        ((VirtualQCPCurve*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPCurve_QBaseWheelEvent(QCPCurve* self, QWheelEvent* event) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_WheelEvent_IsBase(true);
        vqcpcurve->wheelEvent(event);
    } else {
        ((VirtualQCPCurve*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnWheelEvent(QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_WheelEvent_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPCurve_Event(QCPCurve* self, QEvent* event) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return vqcpcurve->event(event);
    } else {
        return self->QCPCurve::event(event);
    }
}

// Base class handler implementation
bool QCPCurve_QBaseEvent(QCPCurve* self, QEvent* event) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_Event_IsBase(true);
        return vqcpcurve->event(event);
    } else {
        return self->QCPCurve::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnEvent(QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_Event_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPCurve_EventFilter(QCPCurve* self, QObject* watched, QEvent* event) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return vqcpcurve->eventFilter(watched, event);
    } else {
        return self->QCPCurve::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPCurve_QBaseEventFilter(QCPCurve* self, QObject* watched, QEvent* event) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_EventFilter_IsBase(true);
        return vqcpcurve->eventFilter(watched, event);
    } else {
        return self->QCPCurve::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnEventFilter(QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_EventFilter_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPCurve_TimerEvent(QCPCurve* self, QTimerEvent* event) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->timerEvent(event);
    } else {
        ((VirtualQCPCurve*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPCurve_QBaseTimerEvent(QCPCurve* self, QTimerEvent* event) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_TimerEvent_IsBase(true);
        vqcpcurve->timerEvent(event);
    } else {
        ((VirtualQCPCurve*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnTimerEvent(QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_TimerEvent_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPCurve_ChildEvent(QCPCurve* self, QChildEvent* event) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->childEvent(event);
    } else {
        ((VirtualQCPCurve*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPCurve_QBaseChildEvent(QCPCurve* self, QChildEvent* event) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_ChildEvent_IsBase(true);
        vqcpcurve->childEvent(event);
    } else {
        ((VirtualQCPCurve*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnChildEvent(QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_ChildEvent_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPCurve_CustomEvent(QCPCurve* self, QEvent* event) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->customEvent(event);
    } else {
        ((VirtualQCPCurve*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPCurve_QBaseCustomEvent(QCPCurve* self, QEvent* event) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_CustomEvent_IsBase(true);
        vqcpcurve->customEvent(event);
    } else {
        ((VirtualQCPCurve*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnCustomEvent(QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_CustomEvent_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPCurve_ConnectNotify(QCPCurve* self, const QMetaMethod* signal) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->connectNotify(*signal);
    } else {
        ((VirtualQCPCurve*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPCurve_QBaseConnectNotify(QCPCurve* self, const QMetaMethod* signal) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_ConnectNotify_IsBase(true);
        vqcpcurve->connectNotify(*signal);
    } else {
        ((VirtualQCPCurve*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnConnectNotify(QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_ConnectNotify_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPCurve_DisconnectNotify(QCPCurve* self, const QMetaMethod* signal) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->disconnectNotify(*signal);
    } else {
        ((VirtualQCPCurve*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPCurve_QBaseDisconnectNotify(QCPCurve* self, const QMetaMethod* signal) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_DisconnectNotify_IsBase(true);
        vqcpcurve->disconnectNotify(*signal);
    } else {
        ((VirtualQCPCurve*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnDisconnectNotify(QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPCurve_GetCurveLines(const QCPCurve* self, libqt_list /* of QPointF* */ lines, const QCPDataRange* dataRange, double penWidth) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    QVector<QPointF> lines_QVector;
    lines_QVector.reserve(lines.len);
    QPointF** lines_arr = static_cast<QPointF**>(lines.data);
    for (size_t i = 0; i < lines.len; ++i) {
        lines_QVector.push_back(*(lines_arr[i]));
    }
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->getCurveLines(&lines_QVector, *dataRange, static_cast<double>(penWidth));
    } else {
        ((VirtualQCPCurve*)self)->getCurveLines(&lines_QVector, *dataRange, static_cast<double>(penWidth));
    }
}

// Base class handler implementation
void QCPCurve_QBaseGetCurveLines(const QCPCurve* self, libqt_list /* of QPointF* */ lines, const QCPDataRange* dataRange, double penWidth) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    QVector<QPointF> lines_QVector;
    lines_QVector.reserve(lines.len);
    QPointF** lines_arr = static_cast<QPointF**>(lines.data);
    for (size_t i = 0; i < lines.len; ++i) {
        lines_QVector.push_back(*(lines_arr[i]));
    }
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_GetCurveLines_IsBase(true);
        vqcpcurve->getCurveLines(&lines_QVector, *dataRange, static_cast<double>(penWidth));
    } else {
        ((VirtualQCPCurve*)self)->getCurveLines(&lines_QVector, *dataRange, static_cast<double>(penWidth));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnGetCurveLines(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_GetCurveLines_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_GetCurveLines_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPCurve_GetScatters(const QCPCurve* self, libqt_list /* of QPointF* */ scatters, const QCPDataRange* dataRange, double scatterWidth) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    QVector<QPointF> scatters_QVector;
    scatters_QVector.reserve(scatters.len);
    QPointF** scatters_arr = static_cast<QPointF**>(scatters.data);
    for (size_t i = 0; i < scatters.len; ++i) {
        scatters_QVector.push_back(*(scatters_arr[i]));
    }
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->getScatters(&scatters_QVector, *dataRange, static_cast<double>(scatterWidth));
    } else {
        ((VirtualQCPCurve*)self)->getScatters(&scatters_QVector, *dataRange, static_cast<double>(scatterWidth));
    }
}

// Base class handler implementation
void QCPCurve_QBaseGetScatters(const QCPCurve* self, libqt_list /* of QPointF* */ scatters, const QCPDataRange* dataRange, double scatterWidth) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    QVector<QPointF> scatters_QVector;
    scatters_QVector.reserve(scatters.len);
    QPointF** scatters_arr = static_cast<QPointF**>(scatters.data);
    for (size_t i = 0; i < scatters.len; ++i) {
        scatters_QVector.push_back(*(scatters_arr[i]));
    }
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_GetScatters_IsBase(true);
        vqcpcurve->getScatters(&scatters_QVector, *dataRange, static_cast<double>(scatterWidth));
    } else {
        ((VirtualQCPCurve*)self)->getScatters(&scatters_QVector, *dataRange, static_cast<double>(scatterWidth));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnGetScatters(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_GetScatters_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_GetScatters_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPCurve_GetRegion(const QCPCurve* self, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return vqcpcurve->getRegion(static_cast<double>(key), static_cast<double>(value), static_cast<double>(keyMin), static_cast<double>(valueMax), static_cast<double>(keyMax), static_cast<double>(valueMin));
    } else {
        return ((VirtualQCPCurve*)self)->getRegion(static_cast<double>(key), static_cast<double>(value), static_cast<double>(keyMin), static_cast<double>(valueMax), static_cast<double>(keyMax), static_cast<double>(valueMin));
    }
}

// Base class handler implementation
int QCPCurve_QBaseGetRegion(const QCPCurve* self, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_GetRegion_IsBase(true);
        return vqcpcurve->getRegion(static_cast<double>(key), static_cast<double>(value), static_cast<double>(keyMin), static_cast<double>(valueMax), static_cast<double>(keyMax), static_cast<double>(valueMin));
    } else {
        return ((VirtualQCPCurve*)self)->getRegion(static_cast<double>(key), static_cast<double>(value), static_cast<double>(keyMin), static_cast<double>(valueMax), static_cast<double>(keyMax), static_cast<double>(valueMin));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnGetRegion(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_GetRegion_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_GetRegion_Callback>(slot));
    }
}

// Derived class handler implementation
QPointF* QCPCurve_GetOptimizedPoint(const QCPCurve* self, int otherRegion, double otherKey, double otherValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return new QPointF(vqcpcurve->getOptimizedPoint(static_cast<int>(otherRegion), static_cast<double>(otherKey), static_cast<double>(otherValue), static_cast<double>(key), static_cast<double>(value), static_cast<double>(keyMin), static_cast<double>(valueMax), static_cast<double>(keyMax), static_cast<double>(valueMin)));
    }
    return {};
}

// Base class handler implementation
QPointF* QCPCurve_QBaseGetOptimizedPoint(const QCPCurve* self, int otherRegion, double otherKey, double otherValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_GetOptimizedPoint_IsBase(true);
        return new QPointF(vqcpcurve->getOptimizedPoint(static_cast<int>(otherRegion), static_cast<double>(otherKey), static_cast<double>(otherValue), static_cast<double>(key), static_cast<double>(value), static_cast<double>(keyMin), static_cast<double>(valueMax), static_cast<double>(keyMax), static_cast<double>(valueMin)));
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnGetOptimizedPoint(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_GetOptimizedPoint_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_GetOptimizedPoint_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of QPointF* */ QCPCurve_GetOptimizedCornerPoints(const QCPCurve* self, int prevRegion, int currentRegion, double prevKey, double prevValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        QVector<QPointF> _ret = vqcpcurve->getOptimizedCornerPoints(static_cast<int>(prevRegion), static_cast<int>(currentRegion), static_cast<double>(prevKey), static_cast<double>(prevValue), static_cast<double>(key), static_cast<double>(value), static_cast<double>(keyMin), static_cast<double>(valueMax), static_cast<double>(keyMax), static_cast<double>(valueMin));
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QPointF> _ret = ((VirtualQCPCurve*)self)->getOptimizedCornerPoints(static_cast<int>(prevRegion), static_cast<int>(currentRegion), static_cast<double>(prevKey), static_cast<double>(prevValue), static_cast<double>(key), static_cast<double>(value), static_cast<double>(keyMin), static_cast<double>(valueMax), static_cast<double>(keyMax), static_cast<double>(valueMin));
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of QPointF* */ QCPCurve_QBaseGetOptimizedCornerPoints(const QCPCurve* self, int prevRegion, int currentRegion, double prevKey, double prevValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_GetOptimizedCornerPoints_IsBase(true);
        QVector<QPointF> _ret = vqcpcurve->getOptimizedCornerPoints(static_cast<int>(prevRegion), static_cast<int>(currentRegion), static_cast<double>(prevKey), static_cast<double>(prevValue), static_cast<double>(key), static_cast<double>(value), static_cast<double>(keyMin), static_cast<double>(valueMax), static_cast<double>(keyMax), static_cast<double>(valueMin));
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QPointF> _ret = ((VirtualQCPCurve*)self)->getOptimizedCornerPoints(static_cast<int>(prevRegion), static_cast<int>(currentRegion), static_cast<double>(prevKey), static_cast<double>(prevValue), static_cast<double>(key), static_cast<double>(value), static_cast<double>(keyMin), static_cast<double>(valueMax), static_cast<double>(keyMax), static_cast<double>(valueMin));
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnGetOptimizedCornerPoints(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_GetOptimizedCornerPoints_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_GetOptimizedCornerPoints_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPCurve_MayTraverse(const QCPCurve* self, int prevRegion, int currentRegion) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return vqcpcurve->mayTraverse(static_cast<int>(prevRegion), static_cast<int>(currentRegion));
    } else {
        return ((VirtualQCPCurve*)self)->mayTraverse(static_cast<int>(prevRegion), static_cast<int>(currentRegion));
    }
}

// Base class handler implementation
bool QCPCurve_QBaseMayTraverse(const QCPCurve* self, int prevRegion, int currentRegion) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_MayTraverse_IsBase(true);
        return vqcpcurve->mayTraverse(static_cast<int>(prevRegion), static_cast<int>(currentRegion));
    } else {
        return ((VirtualQCPCurve*)self)->mayTraverse(static_cast<int>(prevRegion), static_cast<int>(currentRegion));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnMayTraverse(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_MayTraverse_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_MayTraverse_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPCurve_GetTraverse(const QCPCurve* self, double prevKey, double prevValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin, QPointF* crossA, QPointF* crossB) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return vqcpcurve->getTraverse(static_cast<double>(prevKey), static_cast<double>(prevValue), static_cast<double>(key), static_cast<double>(value), static_cast<double>(keyMin), static_cast<double>(valueMax), static_cast<double>(keyMax), static_cast<double>(valueMin), *crossA, *crossB);
    } else {
        return ((VirtualQCPCurve*)self)->getTraverse(static_cast<double>(prevKey), static_cast<double>(prevValue), static_cast<double>(key), static_cast<double>(value), static_cast<double>(keyMin), static_cast<double>(valueMax), static_cast<double>(keyMax), static_cast<double>(valueMin), *crossA, *crossB);
    }
}

// Base class handler implementation
bool QCPCurve_QBaseGetTraverse(const QCPCurve* self, double prevKey, double prevValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin, QPointF* crossA, QPointF* crossB) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_GetTraverse_IsBase(true);
        return vqcpcurve->getTraverse(static_cast<double>(prevKey), static_cast<double>(prevValue), static_cast<double>(key), static_cast<double>(value), static_cast<double>(keyMin), static_cast<double>(valueMax), static_cast<double>(keyMax), static_cast<double>(valueMin), *crossA, *crossB);
    } else {
        return ((VirtualQCPCurve*)self)->getTraverse(static_cast<double>(prevKey), static_cast<double>(prevValue), static_cast<double>(key), static_cast<double>(value), static_cast<double>(keyMin), static_cast<double>(valueMax), static_cast<double>(keyMax), static_cast<double>(valueMin), *crossA, *crossB);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnGetTraverse(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_GetTraverse_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_GetTraverse_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPCurve_GetTraverseCornerPoints(const QCPCurve* self, int prevRegion, int currentRegion, double keyMin, double valueMax, double keyMax, double valueMin, libqt_list /* of QPointF* */ beforeTraverse, libqt_list /* of QPointF* */ afterTraverse) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    QVector<QPointF> beforeTraverse_QVector;
    beforeTraverse_QVector.reserve(beforeTraverse.len);
    QPointF** beforeTraverse_arr = static_cast<QPointF**>(beforeTraverse.data);
    for (size_t i = 0; i < beforeTraverse.len; ++i) {
        beforeTraverse_QVector.push_back(*(beforeTraverse_arr[i]));
    }
    QVector<QPointF> afterTraverse_QVector;
    afterTraverse_QVector.reserve(afterTraverse.len);
    QPointF** afterTraverse_arr = static_cast<QPointF**>(afterTraverse.data);
    for (size_t i = 0; i < afterTraverse.len; ++i) {
        afterTraverse_QVector.push_back(*(afterTraverse_arr[i]));
    }
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->getTraverseCornerPoints(static_cast<int>(prevRegion), static_cast<int>(currentRegion), static_cast<double>(keyMin), static_cast<double>(valueMax), static_cast<double>(keyMax), static_cast<double>(valueMin), beforeTraverse_QVector, afterTraverse_QVector);
    } else {
        ((VirtualQCPCurve*)self)->getTraverseCornerPoints(static_cast<int>(prevRegion), static_cast<int>(currentRegion), static_cast<double>(keyMin), static_cast<double>(valueMax), static_cast<double>(keyMax), static_cast<double>(valueMin), beforeTraverse_QVector, afterTraverse_QVector);
    }
}

// Base class handler implementation
void QCPCurve_QBaseGetTraverseCornerPoints(const QCPCurve* self, int prevRegion, int currentRegion, double keyMin, double valueMax, double keyMax, double valueMin, libqt_list /* of QPointF* */ beforeTraverse, libqt_list /* of QPointF* */ afterTraverse) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    QVector<QPointF> beforeTraverse_QVector;
    beforeTraverse_QVector.reserve(beforeTraverse.len);
    QPointF** beforeTraverse_arr = static_cast<QPointF**>(beforeTraverse.data);
    for (size_t i = 0; i < beforeTraverse.len; ++i) {
        beforeTraverse_QVector.push_back(*(beforeTraverse_arr[i]));
    }
    QVector<QPointF> afterTraverse_QVector;
    afterTraverse_QVector.reserve(afterTraverse.len);
    QPointF** afterTraverse_arr = static_cast<QPointF**>(afterTraverse.data);
    for (size_t i = 0; i < afterTraverse.len; ++i) {
        afterTraverse_QVector.push_back(*(afterTraverse_arr[i]));
    }
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_GetTraverseCornerPoints_IsBase(true);
        vqcpcurve->getTraverseCornerPoints(static_cast<int>(prevRegion), static_cast<int>(currentRegion), static_cast<double>(keyMin), static_cast<double>(valueMax), static_cast<double>(keyMax), static_cast<double>(valueMin), beforeTraverse_QVector, afterTraverse_QVector);
    } else {
        ((VirtualQCPCurve*)self)->getTraverseCornerPoints(static_cast<int>(prevRegion), static_cast<int>(currentRegion), static_cast<double>(keyMin), static_cast<double>(valueMax), static_cast<double>(keyMax), static_cast<double>(valueMin), beforeTraverse_QVector, afterTraverse_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnGetTraverseCornerPoints(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_GetTraverseCornerPoints_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_GetTraverseCornerPoints_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPCurve_ApplyFillAntialiasingHint(const QCPCurve* self, QCPPainter* painter) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->applyFillAntialiasingHint(painter);
    } else {
        ((VirtualQCPCurve*)self)->applyFillAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPCurve_QBaseApplyFillAntialiasingHint(const QCPCurve* self, QCPPainter* painter) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_ApplyFillAntialiasingHint_IsBase(true);
        vqcpcurve->applyFillAntialiasingHint(painter);
    } else {
        ((VirtualQCPCurve*)self)->applyFillAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnApplyFillAntialiasingHint(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_ApplyFillAntialiasingHint_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_ApplyFillAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPCurve_ApplyScattersAntialiasingHint(const QCPCurve* self, QCPPainter* painter) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->applyScattersAntialiasingHint(painter);
    } else {
        ((VirtualQCPCurve*)self)->applyScattersAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPCurve_QBaseApplyScattersAntialiasingHint(const QCPCurve* self, QCPPainter* painter) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_ApplyScattersAntialiasingHint_IsBase(true);
        vqcpcurve->applyScattersAntialiasingHint(painter);
    } else {
        ((VirtualQCPCurve*)self)->applyScattersAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnApplyScattersAntialiasingHint(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_ApplyScattersAntialiasingHint_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_ApplyScattersAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPCurve_InitializeParentPlot(QCPCurve* self, QCustomPlot* parentPlot) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPCurve*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPCurve_QBaseInitializeParentPlot(QCPCurve* self, QCustomPlot* parentPlot) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_InitializeParentPlot_IsBase(true);
        vqcpcurve->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPCurve*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnInitializeParentPlot(QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPCurve_SetParentLayerable(QCPCurve* self, QCPLayerable* parentLayerable) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPCurve*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPCurve_QBaseSetParentLayerable(QCPCurve* self, QCPLayerable* parentLayerable) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_SetParentLayerable_IsBase(true);
        vqcpcurve->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPCurve*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnSetParentLayerable(QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPCurve_MoveToLayer(QCPCurve* self, QCPLayer* layer, bool prepend) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return vqcpcurve->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPCurve*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPCurve_QBaseMoveToLayer(QCPCurve* self, QCPLayer* layer, bool prepend) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_MoveToLayer_IsBase(true);
        return vqcpcurve->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPCurve*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnMoveToLayer(QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = dynamic_cast<VirtualQCPCurve*>(self);
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_MoveToLayer_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPCurve_ApplyAntialiasingHint(const QCPCurve* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPCurve*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPCurve_QBaseApplyAntialiasingHint(const QCPCurve* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_ApplyAntialiasingHint_IsBase(true);
        vqcpcurve->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPCurve*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnApplyAntialiasingHint(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPCurve_Sender(const QCPCurve* self) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return vqcpcurve->sender();
    } else {
        return ((VirtualQCPCurve*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPCurve_QBaseSender(const QCPCurve* self) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_Sender_IsBase(true);
        return vqcpcurve->sender();
    } else {
        return ((VirtualQCPCurve*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnSender(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_Sender_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPCurve_SenderSignalIndex(const QCPCurve* self) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return vqcpcurve->senderSignalIndex();
    } else {
        return ((VirtualQCPCurve*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPCurve_QBaseSenderSignalIndex(const QCPCurve* self) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_SenderSignalIndex_IsBase(true);
        return vqcpcurve->senderSignalIndex();
    } else {
        return ((VirtualQCPCurve*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnSenderSignalIndex(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPCurve_Receivers(const QCPCurve* self, const char* signal) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return vqcpcurve->receivers(signal);
    } else {
        return ((VirtualQCPCurve*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPCurve_QBaseReceivers(const QCPCurve* self, const char* signal) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_Receivers_IsBase(true);
        return vqcpcurve->receivers(signal);
    } else {
        return ((VirtualQCPCurve*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnReceivers(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_Receivers_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPCurve_IsSignalConnected(const QCPCurve* self, const QMetaMethod* signal) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        return vqcpcurve->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPCurve*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPCurve_QBaseIsSignalConnected(const QCPCurve* self, const QMetaMethod* signal) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_IsSignalConnected_IsBase(true);
        return vqcpcurve->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPCurve*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPCurve_OnIsSignalConnected(const QCPCurve* self, intptr_t slot) {
    auto* vqcpcurve = const_cast<VirtualQCPCurve*>(dynamic_cast<const VirtualQCPCurve*>(self));
    if (vqcpcurve && vqcpcurve->isVirtualQCPCurve) {
        vqcpcurve->setQCPCurve_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPCurve::QCPCurve_IsSignalConnected_Callback>(slot));
    }
}

void QCPCurve_Delete(QCPCurve* self) {
    delete self;
}

QCPBarsGroup* QCPBarsGroup_new(QCustomPlot* parentPlot) {
    return new VirtualQCPBarsGroup(parentPlot);
}

QMetaObject* QCPBarsGroup_MetaObject(const QCPBarsGroup* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPBarsGroup_Metacast(QCPBarsGroup* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPBarsGroup_Metacall(QCPBarsGroup* self, int param1, int param2, void** param3) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPBarsGroup*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPBarsGroup_Tr(const char* s) {
    QString _ret = QCPBarsGroup::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

int QCPBarsGroup_SpacingType(const QCPBarsGroup* self) {
    return static_cast<int>(self->spacingType());
}

double QCPBarsGroup_Spacing(const QCPBarsGroup* self) {
    return self->spacing();
}

void QCPBarsGroup_SetSpacingType(QCPBarsGroup* self, int spacingType) {
    self->setSpacingType(static_cast<QCPBarsGroup::SpacingType>(spacingType));
}

void QCPBarsGroup_SetSpacing(QCPBarsGroup* self, double spacing) {
    self->setSpacing(static_cast<double>(spacing));
}

libqt_list /* of QCPBars* */ QCPBarsGroup_Bars(const QCPBarsGroup* self) {
    QList<QCPBars*> _ret = self->bars();
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPBars** _arr = static_cast<QCPBars**>(malloc(sizeof(QCPBars*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

QCPBars* QCPBarsGroup_Bars2(const QCPBarsGroup* self, int index) {
    return self->bars(static_cast<int>(index));
}

int QCPBarsGroup_Size(const QCPBarsGroup* self) {
    return self->size();
}

bool QCPBarsGroup_IsEmpty(const QCPBarsGroup* self) {
    return self->isEmpty();
}

void QCPBarsGroup_Clear(QCPBarsGroup* self) {
    self->clear();
}

bool QCPBarsGroup_Contains(const QCPBarsGroup* self, QCPBars* bars) {
    return self->contains(bars);
}

void QCPBarsGroup_Append(QCPBarsGroup* self, QCPBars* bars) {
    self->append(bars);
}

void QCPBarsGroup_Insert(QCPBarsGroup* self, int i, QCPBars* bars) {
    self->insert(static_cast<int>(i), bars);
}

void QCPBarsGroup_Remove(QCPBarsGroup* self, QCPBars* bars) {
    self->remove(bars);
}

libqt_string QCPBarsGroup_Tr2(const char* s, const char* c) {
    QString _ret = QCPBarsGroup::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPBarsGroup_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPBarsGroup::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPBarsGroup_QBaseMetacall(QCPBarsGroup* self, int param1, int param2, void** param3) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_Metacall_IsBase(true);
        return vqcpbarsgroup->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPBarsGroup::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBarsGroup_OnMetacall(QCPBarsGroup* self, intptr_t slot) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_Metacall_Callback(reinterpret_cast<VirtualQCPBarsGroup::QCPBarsGroup_Metacall_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPBarsGroup_Event(QCPBarsGroup* self, QEvent* event) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        return vqcpbarsgroup->event(event);
    } else {
        return self->QCPBarsGroup::event(event);
    }
}

// Base class handler implementation
bool QCPBarsGroup_QBaseEvent(QCPBarsGroup* self, QEvent* event) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_Event_IsBase(true);
        return vqcpbarsgroup->event(event);
    } else {
        return self->QCPBarsGroup::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBarsGroup_OnEvent(QCPBarsGroup* self, intptr_t slot) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_Event_Callback(reinterpret_cast<VirtualQCPBarsGroup::QCPBarsGroup_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPBarsGroup_EventFilter(QCPBarsGroup* self, QObject* watched, QEvent* event) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        return vqcpbarsgroup->eventFilter(watched, event);
    } else {
        return self->QCPBarsGroup::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPBarsGroup_QBaseEventFilter(QCPBarsGroup* self, QObject* watched, QEvent* event) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_EventFilter_IsBase(true);
        return vqcpbarsgroup->eventFilter(watched, event);
    } else {
        return self->QCPBarsGroup::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBarsGroup_OnEventFilter(QCPBarsGroup* self, intptr_t slot) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_EventFilter_Callback(reinterpret_cast<VirtualQCPBarsGroup::QCPBarsGroup_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBarsGroup_TimerEvent(QCPBarsGroup* self, QTimerEvent* event) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->timerEvent(event);
    } else {
        ((VirtualQCPBarsGroup*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPBarsGroup_QBaseTimerEvent(QCPBarsGroup* self, QTimerEvent* event) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_TimerEvent_IsBase(true);
        vqcpbarsgroup->timerEvent(event);
    } else {
        ((VirtualQCPBarsGroup*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBarsGroup_OnTimerEvent(QCPBarsGroup* self, intptr_t slot) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_TimerEvent_Callback(reinterpret_cast<VirtualQCPBarsGroup::QCPBarsGroup_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBarsGroup_ChildEvent(QCPBarsGroup* self, QChildEvent* event) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->childEvent(event);
    } else {
        ((VirtualQCPBarsGroup*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPBarsGroup_QBaseChildEvent(QCPBarsGroup* self, QChildEvent* event) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_ChildEvent_IsBase(true);
        vqcpbarsgroup->childEvent(event);
    } else {
        ((VirtualQCPBarsGroup*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBarsGroup_OnChildEvent(QCPBarsGroup* self, intptr_t slot) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_ChildEvent_Callback(reinterpret_cast<VirtualQCPBarsGroup::QCPBarsGroup_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBarsGroup_CustomEvent(QCPBarsGroup* self, QEvent* event) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->customEvent(event);
    } else {
        ((VirtualQCPBarsGroup*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPBarsGroup_QBaseCustomEvent(QCPBarsGroup* self, QEvent* event) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_CustomEvent_IsBase(true);
        vqcpbarsgroup->customEvent(event);
    } else {
        ((VirtualQCPBarsGroup*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBarsGroup_OnCustomEvent(QCPBarsGroup* self, intptr_t slot) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_CustomEvent_Callback(reinterpret_cast<VirtualQCPBarsGroup::QCPBarsGroup_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBarsGroup_ConnectNotify(QCPBarsGroup* self, const QMetaMethod* signal) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->connectNotify(*signal);
    } else {
        ((VirtualQCPBarsGroup*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPBarsGroup_QBaseConnectNotify(QCPBarsGroup* self, const QMetaMethod* signal) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_ConnectNotify_IsBase(true);
        vqcpbarsgroup->connectNotify(*signal);
    } else {
        ((VirtualQCPBarsGroup*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBarsGroup_OnConnectNotify(QCPBarsGroup* self, intptr_t slot) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_ConnectNotify_Callback(reinterpret_cast<VirtualQCPBarsGroup::QCPBarsGroup_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBarsGroup_DisconnectNotify(QCPBarsGroup* self, const QMetaMethod* signal) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->disconnectNotify(*signal);
    } else {
        ((VirtualQCPBarsGroup*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPBarsGroup_QBaseDisconnectNotify(QCPBarsGroup* self, const QMetaMethod* signal) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_DisconnectNotify_IsBase(true);
        vqcpbarsgroup->disconnectNotify(*signal);
    } else {
        ((VirtualQCPBarsGroup*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBarsGroup_OnDisconnectNotify(QCPBarsGroup* self, intptr_t slot) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPBarsGroup::QCPBarsGroup_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBarsGroup_RegisterBars(QCPBarsGroup* self, QCPBars* bars) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->registerBars(bars);
    } else {
        ((VirtualQCPBarsGroup*)self)->registerBars(bars);
    }
}

// Base class handler implementation
void QCPBarsGroup_QBaseRegisterBars(QCPBarsGroup* self, QCPBars* bars) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_RegisterBars_IsBase(true);
        vqcpbarsgroup->registerBars(bars);
    } else {
        ((VirtualQCPBarsGroup*)self)->registerBars(bars);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBarsGroup_OnRegisterBars(QCPBarsGroup* self, intptr_t slot) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_RegisterBars_Callback(reinterpret_cast<VirtualQCPBarsGroup::QCPBarsGroup_RegisterBars_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBarsGroup_UnregisterBars(QCPBarsGroup* self, QCPBars* bars) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->unregisterBars(bars);
    } else {
        ((VirtualQCPBarsGroup*)self)->unregisterBars(bars);
    }
}

// Base class handler implementation
void QCPBarsGroup_QBaseUnregisterBars(QCPBarsGroup* self, QCPBars* bars) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_UnregisterBars_IsBase(true);
        vqcpbarsgroup->unregisterBars(bars);
    } else {
        ((VirtualQCPBarsGroup*)self)->unregisterBars(bars);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBarsGroup_OnUnregisterBars(QCPBarsGroup* self, intptr_t slot) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_UnregisterBars_Callback(reinterpret_cast<VirtualQCPBarsGroup::QCPBarsGroup_UnregisterBars_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPBarsGroup_KeyPixelOffset(QCPBarsGroup* self, const QCPBars* bars, double keyCoord) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        return vqcpbarsgroup->keyPixelOffset(bars, static_cast<double>(keyCoord));
    } else {
        return ((VirtualQCPBarsGroup*)self)->keyPixelOffset(bars, static_cast<double>(keyCoord));
    }
}

// Base class handler implementation
double QCPBarsGroup_QBaseKeyPixelOffset(QCPBarsGroup* self, const QCPBars* bars, double keyCoord) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_KeyPixelOffset_IsBase(true);
        return vqcpbarsgroup->keyPixelOffset(bars, static_cast<double>(keyCoord));
    } else {
        return ((VirtualQCPBarsGroup*)self)->keyPixelOffset(bars, static_cast<double>(keyCoord));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBarsGroup_OnKeyPixelOffset(QCPBarsGroup* self, intptr_t slot) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_KeyPixelOffset_Callback(reinterpret_cast<VirtualQCPBarsGroup::QCPBarsGroup_KeyPixelOffset_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPBarsGroup_GetPixelSpacing(QCPBarsGroup* self, const QCPBars* bars, double keyCoord) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        return vqcpbarsgroup->getPixelSpacing(bars, static_cast<double>(keyCoord));
    } else {
        return ((VirtualQCPBarsGroup*)self)->getPixelSpacing(bars, static_cast<double>(keyCoord));
    }
}

// Base class handler implementation
double QCPBarsGroup_QBaseGetPixelSpacing(QCPBarsGroup* self, const QCPBars* bars, double keyCoord) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_GetPixelSpacing_IsBase(true);
        return vqcpbarsgroup->getPixelSpacing(bars, static_cast<double>(keyCoord));
    } else {
        return ((VirtualQCPBarsGroup*)self)->getPixelSpacing(bars, static_cast<double>(keyCoord));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBarsGroup_OnGetPixelSpacing(QCPBarsGroup* self, intptr_t slot) {
    auto* vqcpbarsgroup = dynamic_cast<VirtualQCPBarsGroup*>(self);
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_GetPixelSpacing_Callback(reinterpret_cast<VirtualQCPBarsGroup::QCPBarsGroup_GetPixelSpacing_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPBarsGroup_Sender(const QCPBarsGroup* self) {
    auto* vqcpbarsgroup = const_cast<VirtualQCPBarsGroup*>(dynamic_cast<const VirtualQCPBarsGroup*>(self));
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        return vqcpbarsgroup->sender();
    } else {
        return ((VirtualQCPBarsGroup*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPBarsGroup_QBaseSender(const QCPBarsGroup* self) {
    auto* vqcpbarsgroup = const_cast<VirtualQCPBarsGroup*>(dynamic_cast<const VirtualQCPBarsGroup*>(self));
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_Sender_IsBase(true);
        return vqcpbarsgroup->sender();
    } else {
        return ((VirtualQCPBarsGroup*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBarsGroup_OnSender(const QCPBarsGroup* self, intptr_t slot) {
    auto* vqcpbarsgroup = const_cast<VirtualQCPBarsGroup*>(dynamic_cast<const VirtualQCPBarsGroup*>(self));
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_Sender_Callback(reinterpret_cast<VirtualQCPBarsGroup::QCPBarsGroup_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPBarsGroup_SenderSignalIndex(const QCPBarsGroup* self) {
    auto* vqcpbarsgroup = const_cast<VirtualQCPBarsGroup*>(dynamic_cast<const VirtualQCPBarsGroup*>(self));
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        return vqcpbarsgroup->senderSignalIndex();
    } else {
        return ((VirtualQCPBarsGroup*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPBarsGroup_QBaseSenderSignalIndex(const QCPBarsGroup* self) {
    auto* vqcpbarsgroup = const_cast<VirtualQCPBarsGroup*>(dynamic_cast<const VirtualQCPBarsGroup*>(self));
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_SenderSignalIndex_IsBase(true);
        return vqcpbarsgroup->senderSignalIndex();
    } else {
        return ((VirtualQCPBarsGroup*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBarsGroup_OnSenderSignalIndex(const QCPBarsGroup* self, intptr_t slot) {
    auto* vqcpbarsgroup = const_cast<VirtualQCPBarsGroup*>(dynamic_cast<const VirtualQCPBarsGroup*>(self));
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPBarsGroup::QCPBarsGroup_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPBarsGroup_Receivers(const QCPBarsGroup* self, const char* signal) {
    auto* vqcpbarsgroup = const_cast<VirtualQCPBarsGroup*>(dynamic_cast<const VirtualQCPBarsGroup*>(self));
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        return vqcpbarsgroup->receivers(signal);
    } else {
        return ((VirtualQCPBarsGroup*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPBarsGroup_QBaseReceivers(const QCPBarsGroup* self, const char* signal) {
    auto* vqcpbarsgroup = const_cast<VirtualQCPBarsGroup*>(dynamic_cast<const VirtualQCPBarsGroup*>(self));
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_Receivers_IsBase(true);
        return vqcpbarsgroup->receivers(signal);
    } else {
        return ((VirtualQCPBarsGroup*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBarsGroup_OnReceivers(const QCPBarsGroup* self, intptr_t slot) {
    auto* vqcpbarsgroup = const_cast<VirtualQCPBarsGroup*>(dynamic_cast<const VirtualQCPBarsGroup*>(self));
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_Receivers_Callback(reinterpret_cast<VirtualQCPBarsGroup::QCPBarsGroup_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPBarsGroup_IsSignalConnected(const QCPBarsGroup* self, const QMetaMethod* signal) {
    auto* vqcpbarsgroup = const_cast<VirtualQCPBarsGroup*>(dynamic_cast<const VirtualQCPBarsGroup*>(self));
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        return vqcpbarsgroup->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPBarsGroup*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPBarsGroup_QBaseIsSignalConnected(const QCPBarsGroup* self, const QMetaMethod* signal) {
    auto* vqcpbarsgroup = const_cast<VirtualQCPBarsGroup*>(dynamic_cast<const VirtualQCPBarsGroup*>(self));
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_IsSignalConnected_IsBase(true);
        return vqcpbarsgroup->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPBarsGroup*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBarsGroup_OnIsSignalConnected(const QCPBarsGroup* self, intptr_t slot) {
    auto* vqcpbarsgroup = const_cast<VirtualQCPBarsGroup*>(dynamic_cast<const VirtualQCPBarsGroup*>(self));
    if (vqcpbarsgroup && vqcpbarsgroup->isVirtualQCPBarsGroup) {
        vqcpbarsgroup->setQCPBarsGroup_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPBarsGroup::QCPBarsGroup_IsSignalConnected_Callback>(slot));
    }
}

void QCPBarsGroup_Delete(QCPBarsGroup* self) {
    delete self;
}

QCPBarsData* QCPBarsData_new(const QCPBarsData* other) {
    return new QCPBarsData(*other);
}

QCPBarsData* QCPBarsData_new2(QCPBarsData* other) {
    return new QCPBarsData(std::move(*other));
}

QCPBarsData* QCPBarsData_new3() {
    return new QCPBarsData();
}

QCPBarsData* QCPBarsData_new4(double key, double value) {
    return new QCPBarsData(static_cast<double>(key), static_cast<double>(value));
}

QCPBarsData* QCPBarsData_new5(const QCPBarsData* param1) {
    return new QCPBarsData(*param1);
}

void QCPBarsData_CopyAssign(QCPBarsData* self, QCPBarsData* other) {
    *self = *other;
}

void QCPBarsData_MoveAssign(QCPBarsData* self, QCPBarsData* other) {
    *self = std::move(*other);
}

double QCPBarsData_SortKey(const QCPBarsData* self) {
    return self->sortKey();
}

QCPBarsData* QCPBarsData_FromSortKey(double sortKey) {
    return new QCPBarsData(QCPBarsData::fromSortKey(static_cast<double>(sortKey)));
}

bool QCPBarsData_SortKeyIsMainKey() {
    return QCPBarsData::sortKeyIsMainKey();
}

double QCPBarsData_MainKey(const QCPBarsData* self) {
    return self->mainKey();
}

double QCPBarsData_MainValue(const QCPBarsData* self) {
    return self->mainValue();
}

QCPRange* QCPBarsData_ValueRange(const QCPBarsData* self) {
    return new QCPRange(self->valueRange());
}

double QCPBarsData_Key(const QCPBarsData* self) {
    return self->key;
}

void QCPBarsData_SetKey(QCPBarsData* self, double key) {
    self->key = static_cast<double>(key);
}

double QCPBarsData_Value(const QCPBarsData* self) {
    return self->value;
}

void QCPBarsData_SetValue(QCPBarsData* self, double value) {
    self->value = static_cast<double>(value);
}

void QCPBarsData_Delete(QCPBarsData* self) {
    delete self;
}

QCPBars* QCPBars_new(QCPAxis* keyAxis, QCPAxis* valueAxis) {
    return new VirtualQCPBars(keyAxis, valueAxis);
}

QMetaObject* QCPBars_MetaObject(const QCPBars* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPBars_Metacast(QCPBars* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPBars_Metacall(QCPBars* self, int param1, int param2, void** param3) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPBars*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPBars_Tr(const char* s) {
    QString _ret = QCPBars::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

double QCPBars_Width(const QCPBars* self) {
    return self->width();
}

int QCPBars_WidthType(const QCPBars* self) {
    return static_cast<int>(self->widthType());
}

QCPBarsGroup* QCPBars_BarsGroup(const QCPBars* self) {
    return self->barsGroup();
}

double QCPBars_BaseValue(const QCPBars* self) {
    return self->baseValue();
}

double QCPBars_StackingGap(const QCPBars* self) {
    return self->stackingGap();
}

QCPBars* QCPBars_BarBelow(const QCPBars* self) {
    return self->barBelow();
}

QCPBars* QCPBars_BarAbove(const QCPBars* self) {
    return self->barAbove();
}

void QCPBars_SetData2(QCPBars* self, const libqt_list /* of double */ keys, const libqt_list /* of double */ values) {
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> values_QVector;
    values_QVector.reserve(values.len);
    double* values_arr = static_cast<double*>(values.data);
    for (size_t i = 0; i < values.len; ++i) {
        values_QVector.push_back(static_cast<double>(values_arr[i]));
    }
    self->setData(keys_QVector, values_QVector);
}

void QCPBars_SetWidth(QCPBars* self, double width) {
    self->setWidth(static_cast<double>(width));
}

void QCPBars_SetWidthType(QCPBars* self, int widthType) {
    self->setWidthType(static_cast<QCPBars::WidthType>(widthType));
}

void QCPBars_SetBarsGroup(QCPBars* self, QCPBarsGroup* barsGroup) {
    self->setBarsGroup(barsGroup);
}

void QCPBars_SetBaseValue(QCPBars* self, double baseValue) {
    self->setBaseValue(static_cast<double>(baseValue));
}

void QCPBars_SetStackingGap(QCPBars* self, double pixels) {
    self->setStackingGap(static_cast<double>(pixels));
}

void QCPBars_AddData(QCPBars* self, const libqt_list /* of double */ keys, const libqt_list /* of double */ values) {
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> values_QVector;
    values_QVector.reserve(values.len);
    double* values_arr = static_cast<double*>(values.data);
    for (size_t i = 0; i < values.len; ++i) {
        values_QVector.push_back(static_cast<double>(values_arr[i]));
    }
    self->addData(keys_QVector, values_QVector);
}

void QCPBars_AddData2(QCPBars* self, double key, double value) {
    self->addData(static_cast<double>(key), static_cast<double>(value));
}

void QCPBars_MoveBelow(QCPBars* self, QCPBars* bars) {
    self->moveBelow(bars);
}

void QCPBars_MoveAbove(QCPBars* self, QCPBars* bars) {
    self->moveAbove(bars);
}

QCPDataSelection* QCPBars_SelectTestRect(const QCPBars* self, const QRectF* rect, bool onlySelectable) {
    auto* vqcpbars = dynamic_cast<const VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return new QCPDataSelection(self->selectTestRect(*rect, onlySelectable));
    } else {
        return new QCPDataSelection(((VirtualQCPBars*)self)->selectTestRect(*rect, onlySelectable));
    }
}

double QCPBars_SelectTest(const QCPBars* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpbars = dynamic_cast<const VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPBars*)self)->selectTest(*pos, onlySelectable, details);
    }
}

QCPRange* QCPBars_GetKeyRange(const QCPBars* self, bool* foundRange, int inSignDomain) {
    auto* vqcpbars = dynamic_cast<const VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return new QCPRange(self->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    } else {
        return new QCPRange(((VirtualQCPBars*)self)->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    }
}

QCPRange* QCPBars_GetValueRange(const QCPBars* self, bool* foundRange, int inSignDomain, const QCPRange* inKeyRange) {
    auto* vqcpbars = dynamic_cast<const VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return new QCPRange(self->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    } else {
        return new QCPRange(((VirtualQCPBars*)self)->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    }
}

QPointF* QCPBars_DataPixelPosition(const QCPBars* self, int index) {
    auto* vqcpbars = dynamic_cast<const VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return new QPointF(self->dataPixelPosition(static_cast<int>(index)));
    } else {
        return new QPointF(((VirtualQCPBars*)self)->dataPixelPosition(static_cast<int>(index)));
    }
}

void QCPBars_Draw(QCPBars* self, QCPPainter* painter) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->draw(painter);
    }
}

void QCPBars_DrawLegendIcon(const QCPBars* self, QCPPainter* painter, const QRectF* rect) {
    auto* vqcpbars = dynamic_cast<const VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->drawLegendIcon(painter, *rect);
    }
}

libqt_string QCPBars_Tr2(const char* s, const char* c) {
    QString _ret = QCPBars::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPBars_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPBars::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

void QCPBars_SetData3(QCPBars* self, const libqt_list /* of double */ keys, const libqt_list /* of double */ values, bool alreadySorted) {
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> values_QVector;
    values_QVector.reserve(values.len);
    double* values_arr = static_cast<double*>(values.data);
    for (size_t i = 0; i < values.len; ++i) {
        values_QVector.push_back(static_cast<double>(values_arr[i]));
    }
    self->setData(keys_QVector, values_QVector, alreadySorted);
}

void QCPBars_AddData3(QCPBars* self, const libqt_list /* of double */ keys, const libqt_list /* of double */ values, bool alreadySorted) {
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> values_QVector;
    values_QVector.reserve(values.len);
    double* values_arr = static_cast<double*>(values.data);
    for (size_t i = 0; i < values.len; ++i) {
        values_QVector.push_back(static_cast<double>(values_arr[i]));
    }
    self->addData(keys_QVector, values_QVector, alreadySorted);
}

// Base class handler implementation
int QCPBars_QBaseMetacall(QCPBars* self, int param1, int param2, void** param3) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_Metacall_IsBase(true);
        return vqcpbars->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPBars::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnMetacall(QCPBars* self, intptr_t slot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_Metacall_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
QCPDataSelection* QCPBars_QBaseSelectTestRect(const QCPBars* self, const QRectF* rect, bool onlySelectable) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_SelectTestRect_IsBase(true);
        return new QCPDataSelection(vqcpbars->selectTestRect(*rect, onlySelectable));
    } else {
        return new QCPDataSelection(((VirtualQCPBars*)self)->selectTestRect(*rect, onlySelectable));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnSelectTestRect(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_SelectTestRect_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_SelectTestRect_Callback>(slot));
    }
}

// Base class handler implementation
double QCPBars_QBaseSelectTest(const QCPBars* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_SelectTest_IsBase(true);
        return vqcpbars->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPBars::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnSelectTest(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_SelectTest_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
QCPRange* QCPBars_QBaseGetKeyRange(const QCPBars* self, bool* foundRange, int inSignDomain) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_GetKeyRange_IsBase(true);
        return new QCPRange(vqcpbars->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    } else {
        return new QCPRange(((VirtualQCPBars*)self)->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnGetKeyRange(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_GetKeyRange_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_GetKeyRange_Callback>(slot));
    }
}

// Base class handler implementation
QCPRange* QCPBars_QBaseGetValueRange(const QCPBars* self, bool* foundRange, int inSignDomain, const QCPRange* inKeyRange) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_GetValueRange_IsBase(true);
        return new QCPRange(vqcpbars->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    } else {
        return new QCPRange(((VirtualQCPBars*)self)->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnGetValueRange(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_GetValueRange_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_GetValueRange_Callback>(slot));
    }
}

// Base class handler implementation
QPointF* QCPBars_QBaseDataPixelPosition(const QCPBars* self, int index) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_DataPixelPosition_IsBase(true);
        return new QPointF(vqcpbars->dataPixelPosition(static_cast<int>(index)));
    } else {
        return new QPointF(((VirtualQCPBars*)self)->dataPixelPosition(static_cast<int>(index)));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnDataPixelPosition(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_DataPixelPosition_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_DataPixelPosition_Callback>(slot));
    }
}

// Base class handler implementation
void QCPBars_QBaseDraw(QCPBars* self, QCPPainter* painter) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_Draw_IsBase(true);
        vqcpbars->draw(painter);
    } else {
        ((VirtualQCPBars*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnDraw(QCPBars* self, intptr_t slot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_Draw_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_Draw_Callback>(slot));
    }
}

// Base class handler implementation
void QCPBars_QBaseDrawLegendIcon(const QCPBars* self, QCPPainter* painter, const QRectF* rect) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_DrawLegendIcon_IsBase(true);
        vqcpbars->drawLegendIcon(painter, *rect);
    } else {
        ((VirtualQCPBars*)self)->drawLegendIcon(painter, *rect);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnDrawLegendIcon(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_DrawLegendIcon_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_DrawLegendIcon_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPBars_DataCount(const QCPBars* self) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return vqcpbars->dataCount();
    } else {
        return ((VirtualQCPBars*)self)->dataCount();
    }
}

// Base class handler implementation
int QCPBars_QBaseDataCount(const QCPBars* self) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_DataCount_IsBase(true);
        return vqcpbars->dataCount();
    } else {
        return ((VirtualQCPBars*)self)->dataCount();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnDataCount(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_DataCount_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_DataCount_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPBars_DataMainKey(const QCPBars* self, int index) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return vqcpbars->dataMainKey(static_cast<int>(index));
    } else {
        return ((VirtualQCPBars*)self)->dataMainKey(static_cast<int>(index));
    }
}

// Base class handler implementation
double QCPBars_QBaseDataMainKey(const QCPBars* self, int index) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_DataMainKey_IsBase(true);
        return vqcpbars->dataMainKey(static_cast<int>(index));
    } else {
        return ((VirtualQCPBars*)self)->dataMainKey(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnDataMainKey(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_DataMainKey_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_DataMainKey_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPBars_DataSortKey(const QCPBars* self, int index) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return vqcpbars->dataSortKey(static_cast<int>(index));
    } else {
        return ((VirtualQCPBars*)self)->dataSortKey(static_cast<int>(index));
    }
}

// Base class handler implementation
double QCPBars_QBaseDataSortKey(const QCPBars* self, int index) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_DataSortKey_IsBase(true);
        return vqcpbars->dataSortKey(static_cast<int>(index));
    } else {
        return ((VirtualQCPBars*)self)->dataSortKey(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnDataSortKey(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_DataSortKey_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_DataSortKey_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPBars_DataMainValue(const QCPBars* self, int index) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return vqcpbars->dataMainValue(static_cast<int>(index));
    } else {
        return ((VirtualQCPBars*)self)->dataMainValue(static_cast<int>(index));
    }
}

// Base class handler implementation
double QCPBars_QBaseDataMainValue(const QCPBars* self, int index) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_DataMainValue_IsBase(true);
        return vqcpbars->dataMainValue(static_cast<int>(index));
    } else {
        return ((VirtualQCPBars*)self)->dataMainValue(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnDataMainValue(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_DataMainValue_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_DataMainValue_Callback>(slot));
    }
}

// Derived class handler implementation
QCPRange* QCPBars_DataValueRange(const QCPBars* self, int index) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return new QCPRange(vqcpbars->dataValueRange(static_cast<int>(index)));
    } else {
        return new QCPRange(((VirtualQCPBars*)self)->dataValueRange(static_cast<int>(index)));
    }
}

// Base class handler implementation
QCPRange* QCPBars_QBaseDataValueRange(const QCPBars* self, int index) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_DataValueRange_IsBase(true);
        return new QCPRange(vqcpbars->dataValueRange(static_cast<int>(index)));
    } else {
        return new QCPRange(((VirtualQCPBars*)self)->dataValueRange(static_cast<int>(index)));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnDataValueRange(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_DataValueRange_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_DataValueRange_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPBars_SortKeyIsMainKey(const QCPBars* self) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return vqcpbars->sortKeyIsMainKey();
    } else {
        return ((VirtualQCPBars*)self)->sortKeyIsMainKey();
    }
}

// Base class handler implementation
bool QCPBars_QBaseSortKeyIsMainKey(const QCPBars* self) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_SortKeyIsMainKey_IsBase(true);
        return vqcpbars->sortKeyIsMainKey();
    } else {
        return ((VirtualQCPBars*)self)->sortKeyIsMainKey();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnSortKeyIsMainKey(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_SortKeyIsMainKey_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_SortKeyIsMainKey_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPBars_FindBegin(const QCPBars* self, double sortKey, bool expandedRange) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return vqcpbars->findBegin(static_cast<double>(sortKey), expandedRange);
    } else {
        return ((VirtualQCPBars*)self)->findBegin(static_cast<double>(sortKey), expandedRange);
    }
}

// Base class handler implementation
int QCPBars_QBaseFindBegin(const QCPBars* self, double sortKey, bool expandedRange) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_FindBegin_IsBase(true);
        return vqcpbars->findBegin(static_cast<double>(sortKey), expandedRange);
    } else {
        return ((VirtualQCPBars*)self)->findBegin(static_cast<double>(sortKey), expandedRange);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnFindBegin(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_FindBegin_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_FindBegin_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPBars_FindEnd(const QCPBars* self, double sortKey, bool expandedRange) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return vqcpbars->findEnd(static_cast<double>(sortKey), expandedRange);
    } else {
        return ((VirtualQCPBars*)self)->findEnd(static_cast<double>(sortKey), expandedRange);
    }
}

// Base class handler implementation
int QCPBars_QBaseFindEnd(const QCPBars* self, double sortKey, bool expandedRange) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_FindEnd_IsBase(true);
        return vqcpbars->findEnd(static_cast<double>(sortKey), expandedRange);
    } else {
        return ((VirtualQCPBars*)self)->findEnd(static_cast<double>(sortKey), expandedRange);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnFindEnd(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_FindEnd_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_FindEnd_Callback>(slot));
    }
}

// Derived class handler implementation
QCPPlottableInterface1D* QCPBars_Interface1D(QCPBars* self) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return vqcpbars->interface1D();
    } else {
        return self->QCPBars::interface1D();
    }
}

// Base class handler implementation
QCPPlottableInterface1D* QCPBars_QBaseInterface1D(QCPBars* self) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_Interface1D_IsBase(true);
        return vqcpbars->interface1D();
    } else {
        return self->QCPBars::interface1D();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnInterface1D(QCPBars* self, intptr_t slot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_Interface1D_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_Interface1D_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPBars_ClipRect(const QCPBars* self) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return new QRect(vqcpbars->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPBars_QBaseClipRect(const QCPBars* self) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_ClipRect_IsBase(true);
        return new QRect(vqcpbars->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnClipRect(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_ClipRect_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPBars_SelectionCategory(const QCPBars* self) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return static_cast<int>(vqcpbars->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPBars*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPBars_QBaseSelectionCategory(const QCPBars* self) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcpbars->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPBars*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnSelectionCategory(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_SelectionCategory_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBars_ApplyDefaultAntialiasingHint(const QCPBars* self, QCPPainter* painter) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPBars*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPBars_QBaseApplyDefaultAntialiasingHint(const QCPBars* self, QCPPainter* painter) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcpbars->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPBars*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnApplyDefaultAntialiasingHint(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBars_SelectEvent(QCPBars* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPBars*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPBars_QBaseSelectEvent(QCPBars* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_SelectEvent_IsBase(true);
        vqcpbars->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPBars*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnSelectEvent(QCPBars* self, intptr_t slot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_SelectEvent_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBars_DeselectEvent(QCPBars* self, bool* selectionStateChanged) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPBars*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPBars_QBaseDeselectEvent(QCPBars* self, bool* selectionStateChanged) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_DeselectEvent_IsBase(true);
        vqcpbars->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPBars*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnDeselectEvent(QCPBars* self, intptr_t slot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_DeselectEvent_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBars_ParentPlotInitialized(QCPBars* self, QCustomPlot* parentPlot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPBars*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPBars_QBaseParentPlotInitialized(QCPBars* self, QCustomPlot* parentPlot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_ParentPlotInitialized_IsBase(true);
        vqcpbars->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPBars*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnParentPlotInitialized(QCPBars* self, intptr_t slot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBars_MousePressEvent(QCPBars* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPBars*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPBars_QBaseMousePressEvent(QCPBars* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_MousePressEvent_IsBase(true);
        vqcpbars->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPBars*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnMousePressEvent(QCPBars* self, intptr_t slot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_MousePressEvent_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBars_MouseMoveEvent(QCPBars* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPBars*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPBars_QBaseMouseMoveEvent(QCPBars* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_MouseMoveEvent_IsBase(true);
        vqcpbars->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPBars*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnMouseMoveEvent(QCPBars* self, intptr_t slot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBars_MouseReleaseEvent(QCPBars* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPBars*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPBars_QBaseMouseReleaseEvent(QCPBars* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_MouseReleaseEvent_IsBase(true);
        vqcpbars->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPBars*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnMouseReleaseEvent(QCPBars* self, intptr_t slot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBars_MouseDoubleClickEvent(QCPBars* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPBars*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPBars_QBaseMouseDoubleClickEvent(QCPBars* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_MouseDoubleClickEvent_IsBase(true);
        vqcpbars->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPBars*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnMouseDoubleClickEvent(QCPBars* self, intptr_t slot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBars_WheelEvent(QCPBars* self, QWheelEvent* event) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->wheelEvent(event);
    } else {
        ((VirtualQCPBars*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPBars_QBaseWheelEvent(QCPBars* self, QWheelEvent* event) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_WheelEvent_IsBase(true);
        vqcpbars->wheelEvent(event);
    } else {
        ((VirtualQCPBars*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnWheelEvent(QCPBars* self, intptr_t slot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_WheelEvent_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPBars_Event(QCPBars* self, QEvent* event) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return vqcpbars->event(event);
    } else {
        return self->QCPBars::event(event);
    }
}

// Base class handler implementation
bool QCPBars_QBaseEvent(QCPBars* self, QEvent* event) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_Event_IsBase(true);
        return vqcpbars->event(event);
    } else {
        return self->QCPBars::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnEvent(QCPBars* self, intptr_t slot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_Event_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPBars_EventFilter(QCPBars* self, QObject* watched, QEvent* event) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return vqcpbars->eventFilter(watched, event);
    } else {
        return self->QCPBars::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPBars_QBaseEventFilter(QCPBars* self, QObject* watched, QEvent* event) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_EventFilter_IsBase(true);
        return vqcpbars->eventFilter(watched, event);
    } else {
        return self->QCPBars::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnEventFilter(QCPBars* self, intptr_t slot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_EventFilter_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBars_TimerEvent(QCPBars* self, QTimerEvent* event) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->timerEvent(event);
    } else {
        ((VirtualQCPBars*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPBars_QBaseTimerEvent(QCPBars* self, QTimerEvent* event) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_TimerEvent_IsBase(true);
        vqcpbars->timerEvent(event);
    } else {
        ((VirtualQCPBars*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnTimerEvent(QCPBars* self, intptr_t slot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_TimerEvent_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBars_ChildEvent(QCPBars* self, QChildEvent* event) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->childEvent(event);
    } else {
        ((VirtualQCPBars*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPBars_QBaseChildEvent(QCPBars* self, QChildEvent* event) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_ChildEvent_IsBase(true);
        vqcpbars->childEvent(event);
    } else {
        ((VirtualQCPBars*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnChildEvent(QCPBars* self, intptr_t slot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_ChildEvent_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBars_CustomEvent(QCPBars* self, QEvent* event) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->customEvent(event);
    } else {
        ((VirtualQCPBars*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPBars_QBaseCustomEvent(QCPBars* self, QEvent* event) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_CustomEvent_IsBase(true);
        vqcpbars->customEvent(event);
    } else {
        ((VirtualQCPBars*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnCustomEvent(QCPBars* self, intptr_t slot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_CustomEvent_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBars_ConnectNotify(QCPBars* self, const QMetaMethod* signal) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->connectNotify(*signal);
    } else {
        ((VirtualQCPBars*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPBars_QBaseConnectNotify(QCPBars* self, const QMetaMethod* signal) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_ConnectNotify_IsBase(true);
        vqcpbars->connectNotify(*signal);
    } else {
        ((VirtualQCPBars*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnConnectNotify(QCPBars* self, intptr_t slot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_ConnectNotify_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBars_DisconnectNotify(QCPBars* self, const QMetaMethod* signal) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->disconnectNotify(*signal);
    } else {
        ((VirtualQCPBars*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPBars_QBaseDisconnectNotify(QCPBars* self, const QMetaMethod* signal) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_DisconnectNotify_IsBase(true);
        vqcpbars->disconnectNotify(*signal);
    } else {
        ((VirtualQCPBars*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnDisconnectNotify(QCPBars* self, intptr_t slot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
QRectF* QCPBars_GetBarRect(const QCPBars* self, double key, double value) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return new QRectF(vqcpbars->getBarRect(static_cast<double>(key), static_cast<double>(value)));
    }
    return {};
}

// Base class handler implementation
QRectF* QCPBars_QBaseGetBarRect(const QCPBars* self, double key, double value) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_GetBarRect_IsBase(true);
        return new QRectF(vqcpbars->getBarRect(static_cast<double>(key), static_cast<double>(value)));
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnGetBarRect(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_GetBarRect_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_GetBarRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBars_GetPixelWidth(const QCPBars* self, double key, double* lower, double* upper) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->getPixelWidth(static_cast<double>(key), static_cast<double&>(*lower), static_cast<double&>(*upper));
    } else {
        ((VirtualQCPBars*)self)->getPixelWidth(static_cast<double>(key), static_cast<double&>(*lower), static_cast<double&>(*upper));
    }
}

// Base class handler implementation
void QCPBars_QBaseGetPixelWidth(const QCPBars* self, double key, double* lower, double* upper) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_GetPixelWidth_IsBase(true);
        vqcpbars->getPixelWidth(static_cast<double>(key), static_cast<double&>(*lower), static_cast<double&>(*upper));
    } else {
        ((VirtualQCPBars*)self)->getPixelWidth(static_cast<double>(key), static_cast<double&>(*lower), static_cast<double&>(*upper));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnGetPixelWidth(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_GetPixelWidth_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_GetPixelWidth_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPBars_GetStackedBaseValue(const QCPBars* self, double key, bool positive) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return vqcpbars->getStackedBaseValue(static_cast<double>(key), positive);
    } else {
        return ((VirtualQCPBars*)self)->getStackedBaseValue(static_cast<double>(key), positive);
    }
}

// Base class handler implementation
double QCPBars_QBaseGetStackedBaseValue(const QCPBars* self, double key, bool positive) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_GetStackedBaseValue_IsBase(true);
        return vqcpbars->getStackedBaseValue(static_cast<double>(key), positive);
    } else {
        return ((VirtualQCPBars*)self)->getStackedBaseValue(static_cast<double>(key), positive);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnGetStackedBaseValue(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_GetStackedBaseValue_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_GetStackedBaseValue_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBars_ConnectBars(QCPBars* self, QCPBars* lower, QCPBars* upper) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->connectBars(lower, upper);
    } else {
        ((VirtualQCPBars*)self)->connectBars(lower, upper);
    }
}

// Base class handler implementation
void QCPBars_QBaseConnectBars(QCPBars* self, QCPBars* lower, QCPBars* upper) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_ConnectBars_IsBase(true);
        vqcpbars->connectBars(lower, upper);
    } else {
        ((VirtualQCPBars*)self)->connectBars(lower, upper);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnConnectBars(QCPBars* self, intptr_t slot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_ConnectBars_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_ConnectBars_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBars_ApplyFillAntialiasingHint(const QCPBars* self, QCPPainter* painter) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->applyFillAntialiasingHint(painter);
    } else {
        ((VirtualQCPBars*)self)->applyFillAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPBars_QBaseApplyFillAntialiasingHint(const QCPBars* self, QCPPainter* painter) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_ApplyFillAntialiasingHint_IsBase(true);
        vqcpbars->applyFillAntialiasingHint(painter);
    } else {
        ((VirtualQCPBars*)self)->applyFillAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnApplyFillAntialiasingHint(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_ApplyFillAntialiasingHint_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_ApplyFillAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBars_ApplyScattersAntialiasingHint(const QCPBars* self, QCPPainter* painter) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->applyScattersAntialiasingHint(painter);
    } else {
        ((VirtualQCPBars*)self)->applyScattersAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPBars_QBaseApplyScattersAntialiasingHint(const QCPBars* self, QCPPainter* painter) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_ApplyScattersAntialiasingHint_IsBase(true);
        vqcpbars->applyScattersAntialiasingHint(painter);
    } else {
        ((VirtualQCPBars*)self)->applyScattersAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnApplyScattersAntialiasingHint(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_ApplyScattersAntialiasingHint_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_ApplyScattersAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBars_InitializeParentPlot(QCPBars* self, QCustomPlot* parentPlot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPBars*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPBars_QBaseInitializeParentPlot(QCPBars* self, QCustomPlot* parentPlot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_InitializeParentPlot_IsBase(true);
        vqcpbars->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPBars*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnInitializeParentPlot(QCPBars* self, intptr_t slot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBars_SetParentLayerable(QCPBars* self, QCPLayerable* parentLayerable) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPBars*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPBars_QBaseSetParentLayerable(QCPBars* self, QCPLayerable* parentLayerable) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_SetParentLayerable_IsBase(true);
        vqcpbars->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPBars*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnSetParentLayerable(QCPBars* self, intptr_t slot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPBars_MoveToLayer(QCPBars* self, QCPLayer* layer, bool prepend) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return vqcpbars->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPBars*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPBars_QBaseMoveToLayer(QCPBars* self, QCPLayer* layer, bool prepend) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_MoveToLayer_IsBase(true);
        return vqcpbars->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPBars*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnMoveToLayer(QCPBars* self, intptr_t slot) {
    auto* vqcpbars = dynamic_cast<VirtualQCPBars*>(self);
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_MoveToLayer_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPBars_ApplyAntialiasingHint(const QCPBars* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPBars*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPBars_QBaseApplyAntialiasingHint(const QCPBars* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_ApplyAntialiasingHint_IsBase(true);
        vqcpbars->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPBars*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnApplyAntialiasingHint(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPBars_Sender(const QCPBars* self) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return vqcpbars->sender();
    } else {
        return ((VirtualQCPBars*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPBars_QBaseSender(const QCPBars* self) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_Sender_IsBase(true);
        return vqcpbars->sender();
    } else {
        return ((VirtualQCPBars*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnSender(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_Sender_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPBars_SenderSignalIndex(const QCPBars* self) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return vqcpbars->senderSignalIndex();
    } else {
        return ((VirtualQCPBars*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPBars_QBaseSenderSignalIndex(const QCPBars* self) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_SenderSignalIndex_IsBase(true);
        return vqcpbars->senderSignalIndex();
    } else {
        return ((VirtualQCPBars*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnSenderSignalIndex(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPBars_Receivers(const QCPBars* self, const char* signal) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return vqcpbars->receivers(signal);
    } else {
        return ((VirtualQCPBars*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPBars_QBaseReceivers(const QCPBars* self, const char* signal) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_Receivers_IsBase(true);
        return vqcpbars->receivers(signal);
    } else {
        return ((VirtualQCPBars*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnReceivers(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_Receivers_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPBars_IsSignalConnected(const QCPBars* self, const QMetaMethod* signal) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        return vqcpbars->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPBars*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPBars_QBaseIsSignalConnected(const QCPBars* self, const QMetaMethod* signal) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_IsSignalConnected_IsBase(true);
        return vqcpbars->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPBars*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPBars_OnIsSignalConnected(const QCPBars* self, intptr_t slot) {
    auto* vqcpbars = const_cast<VirtualQCPBars*>(dynamic_cast<const VirtualQCPBars*>(self));
    if (vqcpbars && vqcpbars->isVirtualQCPBars) {
        vqcpbars->setQCPBars_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPBars::QCPBars_IsSignalConnected_Callback>(slot));
    }
}

void QCPBars_Delete(QCPBars* self) {
    delete self;
}

QCPStatisticalBoxData* QCPStatisticalBoxData_new() {
    return new QCPStatisticalBoxData();
}

QCPStatisticalBoxData* QCPStatisticalBoxData_new2(double key, double minimum, double lowerQuartile, double median, double upperQuartile, double maximum) {
    return new QCPStatisticalBoxData(static_cast<double>(key), static_cast<double>(minimum), static_cast<double>(lowerQuartile), static_cast<double>(median), static_cast<double>(upperQuartile), static_cast<double>(maximum));
}

QCPStatisticalBoxData* QCPStatisticalBoxData_new3(const QCPStatisticalBoxData* param1) {
    return new QCPStatisticalBoxData(*param1);
}

QCPStatisticalBoxData* QCPStatisticalBoxData_new4(double key, double minimum, double lowerQuartile, double median, double upperQuartile, double maximum, const libqt_list /* of double */ outliers) {
    QVector<double> outliers_QVector;
    outliers_QVector.reserve(outliers.len);
    double* outliers_arr = static_cast<double*>(outliers.data);
    for (size_t i = 0; i < outliers.len; ++i) {
        outliers_QVector.push_back(static_cast<double>(outliers_arr[i]));
    }
    return new QCPStatisticalBoxData(static_cast<double>(key), static_cast<double>(minimum), static_cast<double>(lowerQuartile), static_cast<double>(median), static_cast<double>(upperQuartile), static_cast<double>(maximum), outliers_QVector);
}

double QCPStatisticalBoxData_SortKey(const QCPStatisticalBoxData* self) {
    return self->sortKey();
}

QCPStatisticalBoxData* QCPStatisticalBoxData_FromSortKey(double sortKey) {
    return new QCPStatisticalBoxData(QCPStatisticalBoxData::fromSortKey(static_cast<double>(sortKey)));
}

bool QCPStatisticalBoxData_SortKeyIsMainKey() {
    return QCPStatisticalBoxData::sortKeyIsMainKey();
}

double QCPStatisticalBoxData_MainKey(const QCPStatisticalBoxData* self) {
    return self->mainKey();
}

double QCPStatisticalBoxData_MainValue(const QCPStatisticalBoxData* self) {
    return self->mainValue();
}

QCPRange* QCPStatisticalBoxData_ValueRange(const QCPStatisticalBoxData* self) {
    return new QCPRange(self->valueRange());
}

double QCPStatisticalBoxData_Key(const QCPStatisticalBoxData* self) {
    return self->key;
}

void QCPStatisticalBoxData_SetKey(QCPStatisticalBoxData* self, double key) {
    self->key = static_cast<double>(key);
}

double QCPStatisticalBoxData_Minimum(const QCPStatisticalBoxData* self) {
    return self->minimum;
}

void QCPStatisticalBoxData_SetMinimum(QCPStatisticalBoxData* self, double minimum) {
    self->minimum = static_cast<double>(minimum);
}

double QCPStatisticalBoxData_LowerQuartile(const QCPStatisticalBoxData* self) {
    return self->lowerQuartile;
}

void QCPStatisticalBoxData_SetLowerQuartile(QCPStatisticalBoxData* self, double lowerQuartile) {
    self->lowerQuartile = static_cast<double>(lowerQuartile);
}

double QCPStatisticalBoxData_Median(const QCPStatisticalBoxData* self) {
    return self->median;
}

void QCPStatisticalBoxData_SetMedian(QCPStatisticalBoxData* self, double median) {
    self->median = static_cast<double>(median);
}

double QCPStatisticalBoxData_UpperQuartile(const QCPStatisticalBoxData* self) {
    return self->upperQuartile;
}

void QCPStatisticalBoxData_SetUpperQuartile(QCPStatisticalBoxData* self, double upperQuartile) {
    self->upperQuartile = static_cast<double>(upperQuartile);
}

double QCPStatisticalBoxData_Maximum(const QCPStatisticalBoxData* self) {
    return self->maximum;
}

void QCPStatisticalBoxData_SetMaximum(QCPStatisticalBoxData* self, double maximum) {
    self->maximum = static_cast<double>(maximum);
}

libqt_list /* of double */ QCPStatisticalBoxData_Outliers(const QCPStatisticalBoxData* self) {
    QList<double> outliers_ret = self->outliers;
    // Convert QList<> from C++ memory to manually-managed C memory
    double* outliers_arr = static_cast<double*>(malloc(sizeof(double) * (outliers_ret.size() + 1)));
    for (qsizetype i = 0; i < outliers_ret.size(); ++i) {
        outliers_arr[i] = outliers_ret[i];
    }
    libqt_list outliers_out;
    outliers_out.len = outliers_ret.size();
    outliers_out.data = static_cast<void*>(outliers_arr);
    return outliers_out;
}

void QCPStatisticalBoxData_SetOutliers(QCPStatisticalBoxData* self, libqt_list /* of double */ outliers) {
    QList<double> outliers_QList;
    outliers_QList.reserve(outliers.len);
    double* outliers_arr = static_cast<double*>(outliers.data);
    for (size_t i = 0; i < outliers.len; ++i) {
        outliers_QList.push_back(static_cast<double>(outliers_arr[i]));
    }
    self->outliers = outliers_QList;
}

void QCPStatisticalBoxData_Delete(QCPStatisticalBoxData* self) {
    delete self;
}

QCPStatisticalBox* QCPStatisticalBox_new(QCPAxis* keyAxis, QCPAxis* valueAxis) {
    return new VirtualQCPStatisticalBox(keyAxis, valueAxis);
}

QMetaObject* QCPStatisticalBox_MetaObject(const QCPStatisticalBox* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPStatisticalBox_Metacast(QCPStatisticalBox* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPStatisticalBox_Metacall(QCPStatisticalBox* self, int param1, int param2, void** param3) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPStatisticalBox*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPStatisticalBox_Tr(const char* s) {
    QString _ret = QCPStatisticalBox::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

double QCPStatisticalBox_Width(const QCPStatisticalBox* self) {
    return self->width();
}

double QCPStatisticalBox_WhiskerWidth(const QCPStatisticalBox* self) {
    return self->whiskerWidth();
}

QPen* QCPStatisticalBox_WhiskerPen(const QCPStatisticalBox* self) {
    return new QPen(self->whiskerPen());
}

QPen* QCPStatisticalBox_WhiskerBarPen(const QCPStatisticalBox* self) {
    return new QPen(self->whiskerBarPen());
}

bool QCPStatisticalBox_WhiskerAntialiased(const QCPStatisticalBox* self) {
    return self->whiskerAntialiased();
}

QPen* QCPStatisticalBox_MedianPen(const QCPStatisticalBox* self) {
    return new QPen(self->medianPen());
}

QCPScatterStyle* QCPStatisticalBox_OutlierStyle(const QCPStatisticalBox* self) {
    return new QCPScatterStyle(self->outlierStyle());
}

void QCPStatisticalBox_SetData2(QCPStatisticalBox* self, const libqt_list /* of double */ keys, const libqt_list /* of double */ minimum, const libqt_list /* of double */ lowerQuartile, const libqt_list /* of double */ median, const libqt_list /* of double */ upperQuartile, const libqt_list /* of double */ maximum) {
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> minimum_QVector;
    minimum_QVector.reserve(minimum.len);
    double* minimum_arr = static_cast<double*>(minimum.data);
    for (size_t i = 0; i < minimum.len; ++i) {
        minimum_QVector.push_back(static_cast<double>(minimum_arr[i]));
    }
    QVector<double> lowerQuartile_QVector;
    lowerQuartile_QVector.reserve(lowerQuartile.len);
    double* lowerQuartile_arr = static_cast<double*>(lowerQuartile.data);
    for (size_t i = 0; i < lowerQuartile.len; ++i) {
        lowerQuartile_QVector.push_back(static_cast<double>(lowerQuartile_arr[i]));
    }
    QVector<double> median_QVector;
    median_QVector.reserve(median.len);
    double* median_arr = static_cast<double*>(median.data);
    for (size_t i = 0; i < median.len; ++i) {
        median_QVector.push_back(static_cast<double>(median_arr[i]));
    }
    QVector<double> upperQuartile_QVector;
    upperQuartile_QVector.reserve(upperQuartile.len);
    double* upperQuartile_arr = static_cast<double*>(upperQuartile.data);
    for (size_t i = 0; i < upperQuartile.len; ++i) {
        upperQuartile_QVector.push_back(static_cast<double>(upperQuartile_arr[i]));
    }
    QVector<double> maximum_QVector;
    maximum_QVector.reserve(maximum.len);
    double* maximum_arr = static_cast<double*>(maximum.data);
    for (size_t i = 0; i < maximum.len; ++i) {
        maximum_QVector.push_back(static_cast<double>(maximum_arr[i]));
    }
    self->setData(keys_QVector, minimum_QVector, lowerQuartile_QVector, median_QVector, upperQuartile_QVector, maximum_QVector);
}

void QCPStatisticalBox_SetWidth(QCPStatisticalBox* self, double width) {
    self->setWidth(static_cast<double>(width));
}

void QCPStatisticalBox_SetWhiskerWidth(QCPStatisticalBox* self, double width) {
    self->setWhiskerWidth(static_cast<double>(width));
}

void QCPStatisticalBox_SetWhiskerPen(QCPStatisticalBox* self, const QPen* pen) {
    self->setWhiskerPen(*pen);
}

void QCPStatisticalBox_SetWhiskerBarPen(QCPStatisticalBox* self, const QPen* pen) {
    self->setWhiskerBarPen(*pen);
}

void QCPStatisticalBox_SetWhiskerAntialiased(QCPStatisticalBox* self, bool enabled) {
    self->setWhiskerAntialiased(enabled);
}

void QCPStatisticalBox_SetMedianPen(QCPStatisticalBox* self, const QPen* pen) {
    self->setMedianPen(*pen);
}

void QCPStatisticalBox_SetOutlierStyle(QCPStatisticalBox* self, const QCPScatterStyle* style) {
    self->setOutlierStyle(*style);
}

void QCPStatisticalBox_AddData(QCPStatisticalBox* self, const libqt_list /* of double */ keys, const libqt_list /* of double */ minimum, const libqt_list /* of double */ lowerQuartile, const libqt_list /* of double */ median, const libqt_list /* of double */ upperQuartile, const libqt_list /* of double */ maximum) {
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> minimum_QVector;
    minimum_QVector.reserve(minimum.len);
    double* minimum_arr = static_cast<double*>(minimum.data);
    for (size_t i = 0; i < minimum.len; ++i) {
        minimum_QVector.push_back(static_cast<double>(minimum_arr[i]));
    }
    QVector<double> lowerQuartile_QVector;
    lowerQuartile_QVector.reserve(lowerQuartile.len);
    double* lowerQuartile_arr = static_cast<double*>(lowerQuartile.data);
    for (size_t i = 0; i < lowerQuartile.len; ++i) {
        lowerQuartile_QVector.push_back(static_cast<double>(lowerQuartile_arr[i]));
    }
    QVector<double> median_QVector;
    median_QVector.reserve(median.len);
    double* median_arr = static_cast<double*>(median.data);
    for (size_t i = 0; i < median.len; ++i) {
        median_QVector.push_back(static_cast<double>(median_arr[i]));
    }
    QVector<double> upperQuartile_QVector;
    upperQuartile_QVector.reserve(upperQuartile.len);
    double* upperQuartile_arr = static_cast<double*>(upperQuartile.data);
    for (size_t i = 0; i < upperQuartile.len; ++i) {
        upperQuartile_QVector.push_back(static_cast<double>(upperQuartile_arr[i]));
    }
    QVector<double> maximum_QVector;
    maximum_QVector.reserve(maximum.len);
    double* maximum_arr = static_cast<double*>(maximum.data);
    for (size_t i = 0; i < maximum.len; ++i) {
        maximum_QVector.push_back(static_cast<double>(maximum_arr[i]));
    }
    self->addData(keys_QVector, minimum_QVector, lowerQuartile_QVector, median_QVector, upperQuartile_QVector, maximum_QVector);
}

void QCPStatisticalBox_AddData2(QCPStatisticalBox* self, double key, double minimum, double lowerQuartile, double median, double upperQuartile, double maximum) {
    self->addData(static_cast<double>(key), static_cast<double>(minimum), static_cast<double>(lowerQuartile), static_cast<double>(median), static_cast<double>(upperQuartile), static_cast<double>(maximum));
}

QCPDataSelection* QCPStatisticalBox_SelectTestRect(const QCPStatisticalBox* self, const QRectF* rect, bool onlySelectable) {
    auto* vqcpstatisticalbox = dynamic_cast<const VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        return new QCPDataSelection(self->selectTestRect(*rect, onlySelectable));
    } else {
        return new QCPDataSelection(((VirtualQCPStatisticalBox*)self)->selectTestRect(*rect, onlySelectable));
    }
}

double QCPStatisticalBox_SelectTest(const QCPStatisticalBox* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpstatisticalbox = dynamic_cast<const VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPStatisticalBox*)self)->selectTest(*pos, onlySelectable, details);
    }
}

QCPRange* QCPStatisticalBox_GetKeyRange(const QCPStatisticalBox* self, bool* foundRange, int inSignDomain) {
    auto* vqcpstatisticalbox = dynamic_cast<const VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        return new QCPRange(self->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    } else {
        return new QCPRange(((VirtualQCPStatisticalBox*)self)->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    }
}

QCPRange* QCPStatisticalBox_GetValueRange(const QCPStatisticalBox* self, bool* foundRange, int inSignDomain, const QCPRange* inKeyRange) {
    auto* vqcpstatisticalbox = dynamic_cast<const VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        return new QCPRange(self->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    } else {
        return new QCPRange(((VirtualQCPStatisticalBox*)self)->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    }
}

void QCPStatisticalBox_Draw(QCPStatisticalBox* self, QCPPainter* painter) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->draw(painter);
    }
}

void QCPStatisticalBox_DrawLegendIcon(const QCPStatisticalBox* self, QCPPainter* painter, const QRectF* rect) {
    auto* vqcpstatisticalbox = dynamic_cast<const VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->drawLegendIcon(painter, *rect);
    }
}

libqt_string QCPStatisticalBox_Tr2(const char* s, const char* c) {
    QString _ret = QCPStatisticalBox::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPStatisticalBox_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPStatisticalBox::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

void QCPStatisticalBox_SetData7(QCPStatisticalBox* self, const libqt_list /* of double */ keys, const libqt_list /* of double */ minimum, const libqt_list /* of double */ lowerQuartile, const libqt_list /* of double */ median, const libqt_list /* of double */ upperQuartile, const libqt_list /* of double */ maximum, bool alreadySorted) {
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> minimum_QVector;
    minimum_QVector.reserve(minimum.len);
    double* minimum_arr = static_cast<double*>(minimum.data);
    for (size_t i = 0; i < minimum.len; ++i) {
        minimum_QVector.push_back(static_cast<double>(minimum_arr[i]));
    }
    QVector<double> lowerQuartile_QVector;
    lowerQuartile_QVector.reserve(lowerQuartile.len);
    double* lowerQuartile_arr = static_cast<double*>(lowerQuartile.data);
    for (size_t i = 0; i < lowerQuartile.len; ++i) {
        lowerQuartile_QVector.push_back(static_cast<double>(lowerQuartile_arr[i]));
    }
    QVector<double> median_QVector;
    median_QVector.reserve(median.len);
    double* median_arr = static_cast<double*>(median.data);
    for (size_t i = 0; i < median.len; ++i) {
        median_QVector.push_back(static_cast<double>(median_arr[i]));
    }
    QVector<double> upperQuartile_QVector;
    upperQuartile_QVector.reserve(upperQuartile.len);
    double* upperQuartile_arr = static_cast<double*>(upperQuartile.data);
    for (size_t i = 0; i < upperQuartile.len; ++i) {
        upperQuartile_QVector.push_back(static_cast<double>(upperQuartile_arr[i]));
    }
    QVector<double> maximum_QVector;
    maximum_QVector.reserve(maximum.len);
    double* maximum_arr = static_cast<double*>(maximum.data);
    for (size_t i = 0; i < maximum.len; ++i) {
        maximum_QVector.push_back(static_cast<double>(maximum_arr[i]));
    }
    self->setData(keys_QVector, minimum_QVector, lowerQuartile_QVector, median_QVector, upperQuartile_QVector, maximum_QVector, alreadySorted);
}

void QCPStatisticalBox_AddData7(QCPStatisticalBox* self, const libqt_list /* of double */ keys, const libqt_list /* of double */ minimum, const libqt_list /* of double */ lowerQuartile, const libqt_list /* of double */ median, const libqt_list /* of double */ upperQuartile, const libqt_list /* of double */ maximum, bool alreadySorted) {
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> minimum_QVector;
    minimum_QVector.reserve(minimum.len);
    double* minimum_arr = static_cast<double*>(minimum.data);
    for (size_t i = 0; i < minimum.len; ++i) {
        minimum_QVector.push_back(static_cast<double>(minimum_arr[i]));
    }
    QVector<double> lowerQuartile_QVector;
    lowerQuartile_QVector.reserve(lowerQuartile.len);
    double* lowerQuartile_arr = static_cast<double*>(lowerQuartile.data);
    for (size_t i = 0; i < lowerQuartile.len; ++i) {
        lowerQuartile_QVector.push_back(static_cast<double>(lowerQuartile_arr[i]));
    }
    QVector<double> median_QVector;
    median_QVector.reserve(median.len);
    double* median_arr = static_cast<double*>(median.data);
    for (size_t i = 0; i < median.len; ++i) {
        median_QVector.push_back(static_cast<double>(median_arr[i]));
    }
    QVector<double> upperQuartile_QVector;
    upperQuartile_QVector.reserve(upperQuartile.len);
    double* upperQuartile_arr = static_cast<double*>(upperQuartile.data);
    for (size_t i = 0; i < upperQuartile.len; ++i) {
        upperQuartile_QVector.push_back(static_cast<double>(upperQuartile_arr[i]));
    }
    QVector<double> maximum_QVector;
    maximum_QVector.reserve(maximum.len);
    double* maximum_arr = static_cast<double*>(maximum.data);
    for (size_t i = 0; i < maximum.len; ++i) {
        maximum_QVector.push_back(static_cast<double>(maximum_arr[i]));
    }
    self->addData(keys_QVector, minimum_QVector, lowerQuartile_QVector, median_QVector, upperQuartile_QVector, maximum_QVector, alreadySorted);
}

void QCPStatisticalBox_AddData72(QCPStatisticalBox* self, double key, double minimum, double lowerQuartile, double median, double upperQuartile, double maximum, const libqt_list /* of double */ outliers) {
    QVector<double> outliers_QVector;
    outliers_QVector.reserve(outliers.len);
    double* outliers_arr = static_cast<double*>(outliers.data);
    for (size_t i = 0; i < outliers.len; ++i) {
        outliers_QVector.push_back(static_cast<double>(outliers_arr[i]));
    }
    self->addData(static_cast<double>(key), static_cast<double>(minimum), static_cast<double>(lowerQuartile), static_cast<double>(median), static_cast<double>(upperQuartile), static_cast<double>(maximum), outliers_QVector);
}

// Base class handler implementation
int QCPStatisticalBox_QBaseMetacall(QCPStatisticalBox* self, int param1, int param2, void** param3) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_Metacall_IsBase(true);
        return vqcpstatisticalbox->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPStatisticalBox::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnMetacall(QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_Metacall_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
QCPDataSelection* QCPStatisticalBox_QBaseSelectTestRect(const QCPStatisticalBox* self, const QRectF* rect, bool onlySelectable) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_SelectTestRect_IsBase(true);
        return new QCPDataSelection(vqcpstatisticalbox->selectTestRect(*rect, onlySelectable));
    } else {
        return new QCPDataSelection(((VirtualQCPStatisticalBox*)self)->selectTestRect(*rect, onlySelectable));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnSelectTestRect(const QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_SelectTestRect_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_SelectTestRect_Callback>(slot));
    }
}

// Base class handler implementation
double QCPStatisticalBox_QBaseSelectTest(const QCPStatisticalBox* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_SelectTest_IsBase(true);
        return vqcpstatisticalbox->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPStatisticalBox::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnSelectTest(const QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_SelectTest_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
QCPRange* QCPStatisticalBox_QBaseGetKeyRange(const QCPStatisticalBox* self, bool* foundRange, int inSignDomain) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_GetKeyRange_IsBase(true);
        return new QCPRange(vqcpstatisticalbox->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    } else {
        return new QCPRange(((VirtualQCPStatisticalBox*)self)->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnGetKeyRange(const QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_GetKeyRange_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_GetKeyRange_Callback>(slot));
    }
}

// Base class handler implementation
QCPRange* QCPStatisticalBox_QBaseGetValueRange(const QCPStatisticalBox* self, bool* foundRange, int inSignDomain, const QCPRange* inKeyRange) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_GetValueRange_IsBase(true);
        return new QCPRange(vqcpstatisticalbox->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    } else {
        return new QCPRange(((VirtualQCPStatisticalBox*)self)->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnGetValueRange(const QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_GetValueRange_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_GetValueRange_Callback>(slot));
    }
}

// Base class handler implementation
void QCPStatisticalBox_QBaseDraw(QCPStatisticalBox* self, QCPPainter* painter) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_Draw_IsBase(true);
        vqcpstatisticalbox->draw(painter);
    } else {
        ((VirtualQCPStatisticalBox*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnDraw(QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_Draw_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_Draw_Callback>(slot));
    }
}

// Base class handler implementation
void QCPStatisticalBox_QBaseDrawLegendIcon(const QCPStatisticalBox* self, QCPPainter* painter, const QRectF* rect) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_DrawLegendIcon_IsBase(true);
        vqcpstatisticalbox->drawLegendIcon(painter, *rect);
    } else {
        ((VirtualQCPStatisticalBox*)self)->drawLegendIcon(painter, *rect);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnDrawLegendIcon(const QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_DrawLegendIcon_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_DrawLegendIcon_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPStatisticalBox_DataCount(const QCPStatisticalBox* self) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        return vqcpstatisticalbox->dataCount();
    } else {
        return ((VirtualQCPStatisticalBox*)self)->dataCount();
    }
}

// Base class handler implementation
int QCPStatisticalBox_QBaseDataCount(const QCPStatisticalBox* self) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_DataCount_IsBase(true);
        return vqcpstatisticalbox->dataCount();
    } else {
        return ((VirtualQCPStatisticalBox*)self)->dataCount();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnDataCount(const QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_DataCount_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_DataCount_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPStatisticalBox_DataMainKey(const QCPStatisticalBox* self, int index) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        return vqcpstatisticalbox->dataMainKey(static_cast<int>(index));
    } else {
        return ((VirtualQCPStatisticalBox*)self)->dataMainKey(static_cast<int>(index));
    }
}

// Base class handler implementation
double QCPStatisticalBox_QBaseDataMainKey(const QCPStatisticalBox* self, int index) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_DataMainKey_IsBase(true);
        return vqcpstatisticalbox->dataMainKey(static_cast<int>(index));
    } else {
        return ((VirtualQCPStatisticalBox*)self)->dataMainKey(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnDataMainKey(const QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_DataMainKey_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_DataMainKey_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPStatisticalBox_DataSortKey(const QCPStatisticalBox* self, int index) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        return vqcpstatisticalbox->dataSortKey(static_cast<int>(index));
    } else {
        return ((VirtualQCPStatisticalBox*)self)->dataSortKey(static_cast<int>(index));
    }
}

// Base class handler implementation
double QCPStatisticalBox_QBaseDataSortKey(const QCPStatisticalBox* self, int index) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_DataSortKey_IsBase(true);
        return vqcpstatisticalbox->dataSortKey(static_cast<int>(index));
    } else {
        return ((VirtualQCPStatisticalBox*)self)->dataSortKey(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnDataSortKey(const QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_DataSortKey_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_DataSortKey_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPStatisticalBox_DataMainValue(const QCPStatisticalBox* self, int index) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        return vqcpstatisticalbox->dataMainValue(static_cast<int>(index));
    } else {
        return ((VirtualQCPStatisticalBox*)self)->dataMainValue(static_cast<int>(index));
    }
}

// Base class handler implementation
double QCPStatisticalBox_QBaseDataMainValue(const QCPStatisticalBox* self, int index) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_DataMainValue_IsBase(true);
        return vqcpstatisticalbox->dataMainValue(static_cast<int>(index));
    } else {
        return ((VirtualQCPStatisticalBox*)self)->dataMainValue(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnDataMainValue(const QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_DataMainValue_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_DataMainValue_Callback>(slot));
    }
}

// Derived class handler implementation
QCPRange* QCPStatisticalBox_DataValueRange(const QCPStatisticalBox* self, int index) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        return new QCPRange(vqcpstatisticalbox->dataValueRange(static_cast<int>(index)));
    } else {
        return new QCPRange(((VirtualQCPStatisticalBox*)self)->dataValueRange(static_cast<int>(index)));
    }
}

// Base class handler implementation
QCPRange* QCPStatisticalBox_QBaseDataValueRange(const QCPStatisticalBox* self, int index) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_DataValueRange_IsBase(true);
        return new QCPRange(vqcpstatisticalbox->dataValueRange(static_cast<int>(index)));
    } else {
        return new QCPRange(((VirtualQCPStatisticalBox*)self)->dataValueRange(static_cast<int>(index)));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnDataValueRange(const QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_DataValueRange_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_DataValueRange_Callback>(slot));
    }
}

// Derived class handler implementation
QPointF* QCPStatisticalBox_DataPixelPosition(const QCPStatisticalBox* self, int index) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        return new QPointF(vqcpstatisticalbox->dataPixelPosition(static_cast<int>(index)));
    } else {
        return new QPointF(((VirtualQCPStatisticalBox*)self)->dataPixelPosition(static_cast<int>(index)));
    }
}

// Base class handler implementation
QPointF* QCPStatisticalBox_QBaseDataPixelPosition(const QCPStatisticalBox* self, int index) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_DataPixelPosition_IsBase(true);
        return new QPointF(vqcpstatisticalbox->dataPixelPosition(static_cast<int>(index)));
    } else {
        return new QPointF(((VirtualQCPStatisticalBox*)self)->dataPixelPosition(static_cast<int>(index)));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnDataPixelPosition(const QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_DataPixelPosition_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_DataPixelPosition_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPStatisticalBox_SortKeyIsMainKey(const QCPStatisticalBox* self) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        return vqcpstatisticalbox->sortKeyIsMainKey();
    } else {
        return ((VirtualQCPStatisticalBox*)self)->sortKeyIsMainKey();
    }
}

// Base class handler implementation
bool QCPStatisticalBox_QBaseSortKeyIsMainKey(const QCPStatisticalBox* self) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_SortKeyIsMainKey_IsBase(true);
        return vqcpstatisticalbox->sortKeyIsMainKey();
    } else {
        return ((VirtualQCPStatisticalBox*)self)->sortKeyIsMainKey();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnSortKeyIsMainKey(const QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_SortKeyIsMainKey_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_SortKeyIsMainKey_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPStatisticalBox_FindBegin(const QCPStatisticalBox* self, double sortKey, bool expandedRange) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        return vqcpstatisticalbox->findBegin(static_cast<double>(sortKey), expandedRange);
    } else {
        return ((VirtualQCPStatisticalBox*)self)->findBegin(static_cast<double>(sortKey), expandedRange);
    }
}

// Base class handler implementation
int QCPStatisticalBox_QBaseFindBegin(const QCPStatisticalBox* self, double sortKey, bool expandedRange) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_FindBegin_IsBase(true);
        return vqcpstatisticalbox->findBegin(static_cast<double>(sortKey), expandedRange);
    } else {
        return ((VirtualQCPStatisticalBox*)self)->findBegin(static_cast<double>(sortKey), expandedRange);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnFindBegin(const QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_FindBegin_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_FindBegin_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPStatisticalBox_FindEnd(const QCPStatisticalBox* self, double sortKey, bool expandedRange) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        return vqcpstatisticalbox->findEnd(static_cast<double>(sortKey), expandedRange);
    } else {
        return ((VirtualQCPStatisticalBox*)self)->findEnd(static_cast<double>(sortKey), expandedRange);
    }
}

// Base class handler implementation
int QCPStatisticalBox_QBaseFindEnd(const QCPStatisticalBox* self, double sortKey, bool expandedRange) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_FindEnd_IsBase(true);
        return vqcpstatisticalbox->findEnd(static_cast<double>(sortKey), expandedRange);
    } else {
        return ((VirtualQCPStatisticalBox*)self)->findEnd(static_cast<double>(sortKey), expandedRange);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnFindEnd(const QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_FindEnd_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_FindEnd_Callback>(slot));
    }
}

// Derived class handler implementation
QCPPlottableInterface1D* QCPStatisticalBox_Interface1D(QCPStatisticalBox* self) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        return vqcpstatisticalbox->interface1D();
    } else {
        return self->QCPStatisticalBox::interface1D();
    }
}

// Base class handler implementation
QCPPlottableInterface1D* QCPStatisticalBox_QBaseInterface1D(QCPStatisticalBox* self) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_Interface1D_IsBase(true);
        return vqcpstatisticalbox->interface1D();
    } else {
        return self->QCPStatisticalBox::interface1D();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnInterface1D(QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_Interface1D_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_Interface1D_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPStatisticalBox_ClipRect(const QCPStatisticalBox* self) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        return new QRect(vqcpstatisticalbox->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPStatisticalBox_QBaseClipRect(const QCPStatisticalBox* self) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_ClipRect_IsBase(true);
        return new QRect(vqcpstatisticalbox->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnClipRect(const QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_ClipRect_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPStatisticalBox_SelectionCategory(const QCPStatisticalBox* self) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        return static_cast<int>(vqcpstatisticalbox->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPStatisticalBox*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPStatisticalBox_QBaseSelectionCategory(const QCPStatisticalBox* self) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcpstatisticalbox->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPStatisticalBox*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnSelectionCategory(const QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_SelectionCategory_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPStatisticalBox_ApplyDefaultAntialiasingHint(const QCPStatisticalBox* self, QCPPainter* painter) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPStatisticalBox*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPStatisticalBox_QBaseApplyDefaultAntialiasingHint(const QCPStatisticalBox* self, QCPPainter* painter) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcpstatisticalbox->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPStatisticalBox*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnApplyDefaultAntialiasingHint(const QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPStatisticalBox_SelectEvent(QCPStatisticalBox* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPStatisticalBox*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPStatisticalBox_QBaseSelectEvent(QCPStatisticalBox* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_SelectEvent_IsBase(true);
        vqcpstatisticalbox->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPStatisticalBox*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnSelectEvent(QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_SelectEvent_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPStatisticalBox_DeselectEvent(QCPStatisticalBox* self, bool* selectionStateChanged) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPStatisticalBox*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPStatisticalBox_QBaseDeselectEvent(QCPStatisticalBox* self, bool* selectionStateChanged) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_DeselectEvent_IsBase(true);
        vqcpstatisticalbox->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPStatisticalBox*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnDeselectEvent(QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_DeselectEvent_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPStatisticalBox_ParentPlotInitialized(QCPStatisticalBox* self, QCustomPlot* parentPlot) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPStatisticalBox*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPStatisticalBox_QBaseParentPlotInitialized(QCPStatisticalBox* self, QCustomPlot* parentPlot) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_ParentPlotInitialized_IsBase(true);
        vqcpstatisticalbox->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPStatisticalBox*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnParentPlotInitialized(QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPStatisticalBox_MousePressEvent(QCPStatisticalBox* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPStatisticalBox*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPStatisticalBox_QBaseMousePressEvent(QCPStatisticalBox* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_MousePressEvent_IsBase(true);
        vqcpstatisticalbox->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPStatisticalBox*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnMousePressEvent(QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_MousePressEvent_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPStatisticalBox_MouseMoveEvent(QCPStatisticalBox* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPStatisticalBox*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPStatisticalBox_QBaseMouseMoveEvent(QCPStatisticalBox* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_MouseMoveEvent_IsBase(true);
        vqcpstatisticalbox->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPStatisticalBox*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnMouseMoveEvent(QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPStatisticalBox_MouseReleaseEvent(QCPStatisticalBox* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPStatisticalBox*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPStatisticalBox_QBaseMouseReleaseEvent(QCPStatisticalBox* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_MouseReleaseEvent_IsBase(true);
        vqcpstatisticalbox->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPStatisticalBox*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnMouseReleaseEvent(QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPStatisticalBox_MouseDoubleClickEvent(QCPStatisticalBox* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPStatisticalBox*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPStatisticalBox_QBaseMouseDoubleClickEvent(QCPStatisticalBox* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_MouseDoubleClickEvent_IsBase(true);
        vqcpstatisticalbox->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPStatisticalBox*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnMouseDoubleClickEvent(QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPStatisticalBox_WheelEvent(QCPStatisticalBox* self, QWheelEvent* event) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->wheelEvent(event);
    } else {
        ((VirtualQCPStatisticalBox*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPStatisticalBox_QBaseWheelEvent(QCPStatisticalBox* self, QWheelEvent* event) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_WheelEvent_IsBase(true);
        vqcpstatisticalbox->wheelEvent(event);
    } else {
        ((VirtualQCPStatisticalBox*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnWheelEvent(QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_WheelEvent_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPStatisticalBox_Event(QCPStatisticalBox* self, QEvent* event) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        return vqcpstatisticalbox->event(event);
    } else {
        return self->QCPStatisticalBox::event(event);
    }
}

// Base class handler implementation
bool QCPStatisticalBox_QBaseEvent(QCPStatisticalBox* self, QEvent* event) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_Event_IsBase(true);
        return vqcpstatisticalbox->event(event);
    } else {
        return self->QCPStatisticalBox::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnEvent(QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_Event_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPStatisticalBox_EventFilter(QCPStatisticalBox* self, QObject* watched, QEvent* event) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        return vqcpstatisticalbox->eventFilter(watched, event);
    } else {
        return self->QCPStatisticalBox::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPStatisticalBox_QBaseEventFilter(QCPStatisticalBox* self, QObject* watched, QEvent* event) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_EventFilter_IsBase(true);
        return vqcpstatisticalbox->eventFilter(watched, event);
    } else {
        return self->QCPStatisticalBox::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnEventFilter(QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_EventFilter_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPStatisticalBox_TimerEvent(QCPStatisticalBox* self, QTimerEvent* event) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->timerEvent(event);
    } else {
        ((VirtualQCPStatisticalBox*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPStatisticalBox_QBaseTimerEvent(QCPStatisticalBox* self, QTimerEvent* event) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_TimerEvent_IsBase(true);
        vqcpstatisticalbox->timerEvent(event);
    } else {
        ((VirtualQCPStatisticalBox*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnTimerEvent(QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_TimerEvent_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPStatisticalBox_ChildEvent(QCPStatisticalBox* self, QChildEvent* event) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->childEvent(event);
    } else {
        ((VirtualQCPStatisticalBox*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPStatisticalBox_QBaseChildEvent(QCPStatisticalBox* self, QChildEvent* event) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_ChildEvent_IsBase(true);
        vqcpstatisticalbox->childEvent(event);
    } else {
        ((VirtualQCPStatisticalBox*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnChildEvent(QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_ChildEvent_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPStatisticalBox_CustomEvent(QCPStatisticalBox* self, QEvent* event) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->customEvent(event);
    } else {
        ((VirtualQCPStatisticalBox*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPStatisticalBox_QBaseCustomEvent(QCPStatisticalBox* self, QEvent* event) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_CustomEvent_IsBase(true);
        vqcpstatisticalbox->customEvent(event);
    } else {
        ((VirtualQCPStatisticalBox*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnCustomEvent(QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_CustomEvent_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPStatisticalBox_ConnectNotify(QCPStatisticalBox* self, const QMetaMethod* signal) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->connectNotify(*signal);
    } else {
        ((VirtualQCPStatisticalBox*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPStatisticalBox_QBaseConnectNotify(QCPStatisticalBox* self, const QMetaMethod* signal) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_ConnectNotify_IsBase(true);
        vqcpstatisticalbox->connectNotify(*signal);
    } else {
        ((VirtualQCPStatisticalBox*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnConnectNotify(QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_ConnectNotify_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPStatisticalBox_DisconnectNotify(QCPStatisticalBox* self, const QMetaMethod* signal) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->disconnectNotify(*signal);
    } else {
        ((VirtualQCPStatisticalBox*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPStatisticalBox_QBaseDisconnectNotify(QCPStatisticalBox* self, const QMetaMethod* signal) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_DisconnectNotify_IsBase(true);
        vqcpstatisticalbox->disconnectNotify(*signal);
    } else {
        ((VirtualQCPStatisticalBox*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnDisconnectNotify(QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPStatisticalBox_ApplyFillAntialiasingHint(const QCPStatisticalBox* self, QCPPainter* painter) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->applyFillAntialiasingHint(painter);
    } else {
        ((VirtualQCPStatisticalBox*)self)->applyFillAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPStatisticalBox_QBaseApplyFillAntialiasingHint(const QCPStatisticalBox* self, QCPPainter* painter) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_ApplyFillAntialiasingHint_IsBase(true);
        vqcpstatisticalbox->applyFillAntialiasingHint(painter);
    } else {
        ((VirtualQCPStatisticalBox*)self)->applyFillAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnApplyFillAntialiasingHint(const QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_ApplyFillAntialiasingHint_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_ApplyFillAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPStatisticalBox_ApplyScattersAntialiasingHint(const QCPStatisticalBox* self, QCPPainter* painter) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->applyScattersAntialiasingHint(painter);
    } else {
        ((VirtualQCPStatisticalBox*)self)->applyScattersAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPStatisticalBox_QBaseApplyScattersAntialiasingHint(const QCPStatisticalBox* self, QCPPainter* painter) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_ApplyScattersAntialiasingHint_IsBase(true);
        vqcpstatisticalbox->applyScattersAntialiasingHint(painter);
    } else {
        ((VirtualQCPStatisticalBox*)self)->applyScattersAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnApplyScattersAntialiasingHint(const QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_ApplyScattersAntialiasingHint_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_ApplyScattersAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPStatisticalBox_InitializeParentPlot(QCPStatisticalBox* self, QCustomPlot* parentPlot) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPStatisticalBox*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPStatisticalBox_QBaseInitializeParentPlot(QCPStatisticalBox* self, QCustomPlot* parentPlot) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_InitializeParentPlot_IsBase(true);
        vqcpstatisticalbox->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPStatisticalBox*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnInitializeParentPlot(QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPStatisticalBox_SetParentLayerable(QCPStatisticalBox* self, QCPLayerable* parentLayerable) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPStatisticalBox*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPStatisticalBox_QBaseSetParentLayerable(QCPStatisticalBox* self, QCPLayerable* parentLayerable) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_SetParentLayerable_IsBase(true);
        vqcpstatisticalbox->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPStatisticalBox*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnSetParentLayerable(QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPStatisticalBox_MoveToLayer(QCPStatisticalBox* self, QCPLayer* layer, bool prepend) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        return vqcpstatisticalbox->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPStatisticalBox*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPStatisticalBox_QBaseMoveToLayer(QCPStatisticalBox* self, QCPLayer* layer, bool prepend) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_MoveToLayer_IsBase(true);
        return vqcpstatisticalbox->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPStatisticalBox*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnMoveToLayer(QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = dynamic_cast<VirtualQCPStatisticalBox*>(self);
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_MoveToLayer_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPStatisticalBox_ApplyAntialiasingHint(const QCPStatisticalBox* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPStatisticalBox*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPStatisticalBox_QBaseApplyAntialiasingHint(const QCPStatisticalBox* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_ApplyAntialiasingHint_IsBase(true);
        vqcpstatisticalbox->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPStatisticalBox*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnApplyAntialiasingHint(const QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPStatisticalBox_Sender(const QCPStatisticalBox* self) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        return vqcpstatisticalbox->sender();
    } else {
        return ((VirtualQCPStatisticalBox*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPStatisticalBox_QBaseSender(const QCPStatisticalBox* self) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_Sender_IsBase(true);
        return vqcpstatisticalbox->sender();
    } else {
        return ((VirtualQCPStatisticalBox*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnSender(const QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_Sender_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPStatisticalBox_SenderSignalIndex(const QCPStatisticalBox* self) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        return vqcpstatisticalbox->senderSignalIndex();
    } else {
        return ((VirtualQCPStatisticalBox*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPStatisticalBox_QBaseSenderSignalIndex(const QCPStatisticalBox* self) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_SenderSignalIndex_IsBase(true);
        return vqcpstatisticalbox->senderSignalIndex();
    } else {
        return ((VirtualQCPStatisticalBox*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnSenderSignalIndex(const QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPStatisticalBox_Receivers(const QCPStatisticalBox* self, const char* signal) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        return vqcpstatisticalbox->receivers(signal);
    } else {
        return ((VirtualQCPStatisticalBox*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPStatisticalBox_QBaseReceivers(const QCPStatisticalBox* self, const char* signal) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_Receivers_IsBase(true);
        return vqcpstatisticalbox->receivers(signal);
    } else {
        return ((VirtualQCPStatisticalBox*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnReceivers(const QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_Receivers_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPStatisticalBox_IsSignalConnected(const QCPStatisticalBox* self, const QMetaMethod* signal) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        return vqcpstatisticalbox->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPStatisticalBox*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPStatisticalBox_QBaseIsSignalConnected(const QCPStatisticalBox* self, const QMetaMethod* signal) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_IsSignalConnected_IsBase(true);
        return vqcpstatisticalbox->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPStatisticalBox*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPStatisticalBox_OnIsSignalConnected(const QCPStatisticalBox* self, intptr_t slot) {
    auto* vqcpstatisticalbox = const_cast<VirtualQCPStatisticalBox*>(dynamic_cast<const VirtualQCPStatisticalBox*>(self));
    if (vqcpstatisticalbox && vqcpstatisticalbox->isVirtualQCPStatisticalBox) {
        vqcpstatisticalbox->setQCPStatisticalBox_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPStatisticalBox::QCPStatisticalBox_IsSignalConnected_Callback>(slot));
    }
}

void QCPStatisticalBox_Delete(QCPStatisticalBox* self) {
    delete self;
}

QCPColorMapData* QCPColorMapData_new(int keySize, int valueSize, const QCPRange* keyRange, const QCPRange* valueRange) {
    return new QCPColorMapData(static_cast<int>(keySize), static_cast<int>(valueSize), *keyRange, *valueRange);
}

QCPColorMapData* QCPColorMapData_new2(const QCPColorMapData* other) {
    return new QCPColorMapData(*other);
}

void QCPColorMapData_OperatorAssign(QCPColorMapData* self, const QCPColorMapData* other) {
    self->operator=(*other);
}

int QCPColorMapData_KeySize(const QCPColorMapData* self) {
    return self->keySize();
}

int QCPColorMapData_ValueSize(const QCPColorMapData* self) {
    return self->valueSize();
}

QCPRange* QCPColorMapData_KeyRange(const QCPColorMapData* self) {
    return new QCPRange(self->keyRange());
}

QCPRange* QCPColorMapData_ValueRange(const QCPColorMapData* self) {
    return new QCPRange(self->valueRange());
}

QCPRange* QCPColorMapData_DataBounds(const QCPColorMapData* self) {
    return new QCPRange(self->dataBounds());
}

double QCPColorMapData_Data(QCPColorMapData* self, double key, double value) {
    return self->data(static_cast<double>(key), static_cast<double>(value));
}

double QCPColorMapData_Cell(QCPColorMapData* self, int keyIndex, int valueIndex) {
    return self->cell(static_cast<int>(keyIndex), static_cast<int>(valueIndex));
}

unsigned char QCPColorMapData_Alpha(QCPColorMapData* self, int keyIndex, int valueIndex) {
    return self->alpha(static_cast<int>(keyIndex), static_cast<int>(valueIndex));
}

void QCPColorMapData_SetSize(QCPColorMapData* self, int keySize, int valueSize) {
    self->setSize(static_cast<int>(keySize), static_cast<int>(valueSize));
}

void QCPColorMapData_SetKeySize(QCPColorMapData* self, int keySize) {
    self->setKeySize(static_cast<int>(keySize));
}

void QCPColorMapData_SetValueSize(QCPColorMapData* self, int valueSize) {
    self->setValueSize(static_cast<int>(valueSize));
}

void QCPColorMapData_SetRange(QCPColorMapData* self, const QCPRange* keyRange, const QCPRange* valueRange) {
    self->setRange(*keyRange, *valueRange);
}

void QCPColorMapData_SetKeyRange(QCPColorMapData* self, const QCPRange* keyRange) {
    self->setKeyRange(*keyRange);
}

void QCPColorMapData_SetValueRange(QCPColorMapData* self, const QCPRange* valueRange) {
    self->setValueRange(*valueRange);
}

void QCPColorMapData_SetData(QCPColorMapData* self, double key, double value, double z) {
    self->setData(static_cast<double>(key), static_cast<double>(value), static_cast<double>(z));
}

void QCPColorMapData_SetCell(QCPColorMapData* self, int keyIndex, int valueIndex, double z) {
    self->setCell(static_cast<int>(keyIndex), static_cast<int>(valueIndex), static_cast<double>(z));
}

void QCPColorMapData_SetAlpha(QCPColorMapData* self, int keyIndex, int valueIndex, unsigned char alpha) {
    self->setAlpha(static_cast<int>(keyIndex), static_cast<int>(valueIndex), static_cast<unsigned char>(alpha));
}

void QCPColorMapData_RecalculateDataBounds(QCPColorMapData* self) {
    self->recalculateDataBounds();
}

void QCPColorMapData_Clear(QCPColorMapData* self) {
    self->clear();
}

void QCPColorMapData_ClearAlpha(QCPColorMapData* self) {
    self->clearAlpha();
}

void QCPColorMapData_Fill(QCPColorMapData* self, double z) {
    self->fill(static_cast<double>(z));
}

void QCPColorMapData_FillAlpha(QCPColorMapData* self, unsigned char alpha) {
    self->fillAlpha(static_cast<unsigned char>(alpha));
}

bool QCPColorMapData_IsEmpty(const QCPColorMapData* self) {
    return self->isEmpty();
}

void QCPColorMapData_CoordToCell(const QCPColorMapData* self, double key, double value, int* keyIndex, int* valueIndex) {
    self->coordToCell(static_cast<double>(key), static_cast<double>(value), static_cast<int*>(keyIndex), static_cast<int*>(valueIndex));
}

void QCPColorMapData_CellToCoord(const QCPColorMapData* self, int keyIndex, int valueIndex, double* key, double* value) {
    self->cellToCoord(static_cast<int>(keyIndex), static_cast<int>(valueIndex), static_cast<double*>(key), static_cast<double*>(value));
}

void QCPColorMapData_Delete(QCPColorMapData* self) {
    delete self;
}

QCPColorMap* QCPColorMap_new(QCPAxis* keyAxis, QCPAxis* valueAxis) {
    return new VirtualQCPColorMap(keyAxis, valueAxis);
}

QMetaObject* QCPColorMap_MetaObject(const QCPColorMap* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPColorMap_Metacast(QCPColorMap* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPColorMap_Metacall(QCPColorMap* self, int param1, int param2, void** param3) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPColorMap*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPColorMap_Tr(const char* s) {
    QString _ret = QCPColorMap::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

QCPColorMapData* QCPColorMap_Data(const QCPColorMap* self) {
    return self->data();
}

QCPRange* QCPColorMap_DataRange(const QCPColorMap* self) {
    return new QCPRange(self->dataRange());
}

int QCPColorMap_DataScaleType(const QCPColorMap* self) {
    return static_cast<int>(self->dataScaleType());
}

bool QCPColorMap_Interpolate(const QCPColorMap* self) {
    return self->interpolate();
}

bool QCPColorMap_TightBoundary(const QCPColorMap* self) {
    return self->tightBoundary();
}

QCPColorGradient* QCPColorMap_Gradient(const QCPColorMap* self) {
    return new QCPColorGradient(self->gradient());
}

QCPColorScale* QCPColorMap_ColorScale(const QCPColorMap* self) {
    return self->colorScale();
}

void QCPColorMap_SetData(QCPColorMap* self, QCPColorMapData* data) {
    self->setData(data);
}

void QCPColorMap_SetDataRange(QCPColorMap* self, const QCPRange* dataRange) {
    self->setDataRange(*dataRange);
}

void QCPColorMap_SetDataScaleType(QCPColorMap* self, int scaleType) {
    self->setDataScaleType(static_cast<QCPAxis::ScaleType>(scaleType));
}

void QCPColorMap_SetGradient(QCPColorMap* self, const QCPColorGradient* gradient) {
    self->setGradient(*gradient);
}

void QCPColorMap_SetInterpolate(QCPColorMap* self, bool enabled) {
    self->setInterpolate(enabled);
}

void QCPColorMap_SetTightBoundary(QCPColorMap* self, bool enabled) {
    self->setTightBoundary(enabled);
}

void QCPColorMap_SetColorScale(QCPColorMap* self, QCPColorScale* colorScale) {
    self->setColorScale(colorScale);
}

void QCPColorMap_RescaleDataRange(QCPColorMap* self) {
    self->rescaleDataRange();
}

void QCPColorMap_UpdateLegendIcon(QCPColorMap* self) {
    self->updateLegendIcon();
}

double QCPColorMap_SelectTest(const QCPColorMap* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpcolormap = dynamic_cast<const VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPColorMap*)self)->selectTest(*pos, onlySelectable, details);
    }
}

QCPRange* QCPColorMap_GetKeyRange(const QCPColorMap* self, bool* foundRange, int inSignDomain) {
    auto* vqcpcolormap = dynamic_cast<const VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        return new QCPRange(self->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    } else {
        return new QCPRange(((VirtualQCPColorMap*)self)->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    }
}

QCPRange* QCPColorMap_GetValueRange(const QCPColorMap* self, bool* foundRange, int inSignDomain, const QCPRange* inKeyRange) {
    auto* vqcpcolormap = dynamic_cast<const VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        return new QCPRange(self->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    } else {
        return new QCPRange(((VirtualQCPColorMap*)self)->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    }
}

void QCPColorMap_DataRangeChanged(QCPColorMap* self, const QCPRange* newRange) {
    self->dataRangeChanged(*newRange);
}

void QCPColorMap_Connect_DataRangeChanged(QCPColorMap* self, intptr_t slot) {
    void (*slotFunc)(QCPColorMap*, QCPRange*) = reinterpret_cast<void (*)(QCPColorMap*, QCPRange*)>(slot);
    QCPColorMap::connect(self, &QCPColorMap::dataRangeChanged, [self, slotFunc](const QCPRange& newRange) {
        const QCPRange& newRange_ret = newRange;
        // Cast returned reference into pointer
        QCPRange* sigval1 = const_cast<QCPRange*>(&newRange_ret);
        slotFunc(self, sigval1);
    });
}

void QCPColorMap_DataScaleTypeChanged(QCPColorMap* self, int scaleType) {
    self->dataScaleTypeChanged(static_cast<QCPAxis::ScaleType>(scaleType));
}

void QCPColorMap_Connect_DataScaleTypeChanged(QCPColorMap* self, intptr_t slot) {
    void (*slotFunc)(QCPColorMap*, int) = reinterpret_cast<void (*)(QCPColorMap*, int)>(slot);
    QCPColorMap::connect(self, &QCPColorMap::dataScaleTypeChanged, [self, slotFunc](QCPAxis::ScaleType scaleType) {
        int sigval1 = static_cast<int>(scaleType);
        slotFunc(self, sigval1);
    });
}

void QCPColorMap_GradientChanged(QCPColorMap* self, const QCPColorGradient* newGradient) {
    self->gradientChanged(*newGradient);
}

void QCPColorMap_Connect_GradientChanged(QCPColorMap* self, intptr_t slot) {
    void (*slotFunc)(QCPColorMap*, QCPColorGradient*) = reinterpret_cast<void (*)(QCPColorMap*, QCPColorGradient*)>(slot);
    QCPColorMap::connect(self, &QCPColorMap::gradientChanged, [self, slotFunc](const QCPColorGradient& newGradient) {
        const QCPColorGradient& newGradient_ret = newGradient;
        // Cast returned reference into pointer
        QCPColorGradient* sigval1 = const_cast<QCPColorGradient*>(&newGradient_ret);
        slotFunc(self, sigval1);
    });
}

void QCPColorMap_UpdateMapImage(QCPColorMap* self) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->updateMapImage();
    }
}

void QCPColorMap_Draw(QCPColorMap* self, QCPPainter* painter) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->draw(painter);
    }
}

void QCPColorMap_DrawLegendIcon(const QCPColorMap* self, QCPPainter* painter, const QRectF* rect) {
    auto* vqcpcolormap = dynamic_cast<const VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->drawLegendIcon(painter, *rect);
    }
}

libqt_string QCPColorMap_Tr2(const char* s, const char* c) {
    QString _ret = QCPColorMap::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPColorMap_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPColorMap::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

void QCPColorMap_SetData2(QCPColorMap* self, QCPColorMapData* data, bool copyVal) {
    self->setData(data, copyVal);
}

void QCPColorMap_RescaleDataRange1(QCPColorMap* self, bool recalculateDataBounds) {
    self->rescaleDataRange(recalculateDataBounds);
}

void QCPColorMap_UpdateLegendIcon1(QCPColorMap* self, int transformMode) {
    self->updateLegendIcon(static_cast<Qt::TransformationMode>(transformMode));
}

void QCPColorMap_UpdateLegendIcon2(QCPColorMap* self, int transformMode, const QSize* thumbSize) {
    self->updateLegendIcon(static_cast<Qt::TransformationMode>(transformMode), *thumbSize);
}

// Base class handler implementation
int QCPColorMap_QBaseMetacall(QCPColorMap* self, int param1, int param2, void** param3) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_Metacall_IsBase(true);
        return vqcpcolormap->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPColorMap::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnMetacall(QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_Metacall_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
double QCPColorMap_QBaseSelectTest(const QCPColorMap* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_SelectTest_IsBase(true);
        return vqcpcolormap->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPColorMap::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnSelectTest(const QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_SelectTest_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
QCPRange* QCPColorMap_QBaseGetKeyRange(const QCPColorMap* self, bool* foundRange, int inSignDomain) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_GetKeyRange_IsBase(true);
        return new QCPRange(vqcpcolormap->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    } else {
        return new QCPRange(((VirtualQCPColorMap*)self)->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnGetKeyRange(const QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_GetKeyRange_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_GetKeyRange_Callback>(slot));
    }
}

// Base class handler implementation
QCPRange* QCPColorMap_QBaseGetValueRange(const QCPColorMap* self, bool* foundRange, int inSignDomain, const QCPRange* inKeyRange) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_GetValueRange_IsBase(true);
        return new QCPRange(vqcpcolormap->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    } else {
        return new QCPRange(((VirtualQCPColorMap*)self)->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnGetValueRange(const QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_GetValueRange_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_GetValueRange_Callback>(slot));
    }
}

// Base class handler implementation
void QCPColorMap_QBaseUpdateMapImage(QCPColorMap* self) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_UpdateMapImage_IsBase(true);
        vqcpcolormap->updateMapImage();
    } else {
        ((VirtualQCPColorMap*)self)->updateMapImage();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnUpdateMapImage(QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_UpdateMapImage_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_UpdateMapImage_Callback>(slot));
    }
}

// Base class handler implementation
void QCPColorMap_QBaseDraw(QCPColorMap* self, QCPPainter* painter) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_Draw_IsBase(true);
        vqcpcolormap->draw(painter);
    } else {
        ((VirtualQCPColorMap*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnDraw(QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_Draw_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_Draw_Callback>(slot));
    }
}

// Base class handler implementation
void QCPColorMap_QBaseDrawLegendIcon(const QCPColorMap* self, QCPPainter* painter, const QRectF* rect) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_DrawLegendIcon_IsBase(true);
        vqcpcolormap->drawLegendIcon(painter, *rect);
    } else {
        ((VirtualQCPColorMap*)self)->drawLegendIcon(painter, *rect);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnDrawLegendIcon(const QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_DrawLegendIcon_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_DrawLegendIcon_Callback>(slot));
    }
}

// Derived class handler implementation
QCPPlottableInterface1D* QCPColorMap_Interface1D(QCPColorMap* self) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        return vqcpcolormap->interface1D();
    } else {
        return self->QCPColorMap::interface1D();
    }
}

// Base class handler implementation
QCPPlottableInterface1D* QCPColorMap_QBaseInterface1D(QCPColorMap* self) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_Interface1D_IsBase(true);
        return vqcpcolormap->interface1D();
    } else {
        return self->QCPColorMap::interface1D();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnInterface1D(QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_Interface1D_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_Interface1D_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPColorMap_ClipRect(const QCPColorMap* self) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        return new QRect(vqcpcolormap->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPColorMap_QBaseClipRect(const QCPColorMap* self) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_ClipRect_IsBase(true);
        return new QRect(vqcpcolormap->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnClipRect(const QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_ClipRect_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPColorMap_SelectionCategory(const QCPColorMap* self) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        return static_cast<int>(vqcpcolormap->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPColorMap*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPColorMap_QBaseSelectionCategory(const QCPColorMap* self) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcpcolormap->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPColorMap*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnSelectionCategory(const QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_SelectionCategory_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorMap_ApplyDefaultAntialiasingHint(const QCPColorMap* self, QCPPainter* painter) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPColorMap*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPColorMap_QBaseApplyDefaultAntialiasingHint(const QCPColorMap* self, QCPPainter* painter) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcpcolormap->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPColorMap*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnApplyDefaultAntialiasingHint(const QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorMap_SelectEvent(QCPColorMap* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPColorMap*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPColorMap_QBaseSelectEvent(QCPColorMap* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_SelectEvent_IsBase(true);
        vqcpcolormap->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPColorMap*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnSelectEvent(QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_SelectEvent_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorMap_DeselectEvent(QCPColorMap* self, bool* selectionStateChanged) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPColorMap*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPColorMap_QBaseDeselectEvent(QCPColorMap* self, bool* selectionStateChanged) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_DeselectEvent_IsBase(true);
        vqcpcolormap->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPColorMap*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnDeselectEvent(QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_DeselectEvent_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorMap_ParentPlotInitialized(QCPColorMap* self, QCustomPlot* parentPlot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPColorMap*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPColorMap_QBaseParentPlotInitialized(QCPColorMap* self, QCustomPlot* parentPlot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_ParentPlotInitialized_IsBase(true);
        vqcpcolormap->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPColorMap*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnParentPlotInitialized(QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorMap_MousePressEvent(QCPColorMap* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPColorMap*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPColorMap_QBaseMousePressEvent(QCPColorMap* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_MousePressEvent_IsBase(true);
        vqcpcolormap->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPColorMap*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnMousePressEvent(QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_MousePressEvent_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorMap_MouseMoveEvent(QCPColorMap* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPColorMap*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPColorMap_QBaseMouseMoveEvent(QCPColorMap* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_MouseMoveEvent_IsBase(true);
        vqcpcolormap->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPColorMap*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnMouseMoveEvent(QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorMap_MouseReleaseEvent(QCPColorMap* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPColorMap*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPColorMap_QBaseMouseReleaseEvent(QCPColorMap* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_MouseReleaseEvent_IsBase(true);
        vqcpcolormap->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPColorMap*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnMouseReleaseEvent(QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorMap_MouseDoubleClickEvent(QCPColorMap* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPColorMap*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPColorMap_QBaseMouseDoubleClickEvent(QCPColorMap* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_MouseDoubleClickEvent_IsBase(true);
        vqcpcolormap->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPColorMap*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnMouseDoubleClickEvent(QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorMap_WheelEvent(QCPColorMap* self, QWheelEvent* event) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->wheelEvent(event);
    } else {
        ((VirtualQCPColorMap*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPColorMap_QBaseWheelEvent(QCPColorMap* self, QWheelEvent* event) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_WheelEvent_IsBase(true);
        vqcpcolormap->wheelEvent(event);
    } else {
        ((VirtualQCPColorMap*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnWheelEvent(QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_WheelEvent_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPColorMap_Event(QCPColorMap* self, QEvent* event) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        return vqcpcolormap->event(event);
    } else {
        return self->QCPColorMap::event(event);
    }
}

// Base class handler implementation
bool QCPColorMap_QBaseEvent(QCPColorMap* self, QEvent* event) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_Event_IsBase(true);
        return vqcpcolormap->event(event);
    } else {
        return self->QCPColorMap::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnEvent(QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_Event_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPColorMap_EventFilter(QCPColorMap* self, QObject* watched, QEvent* event) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        return vqcpcolormap->eventFilter(watched, event);
    } else {
        return self->QCPColorMap::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPColorMap_QBaseEventFilter(QCPColorMap* self, QObject* watched, QEvent* event) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_EventFilter_IsBase(true);
        return vqcpcolormap->eventFilter(watched, event);
    } else {
        return self->QCPColorMap::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnEventFilter(QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_EventFilter_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorMap_TimerEvent(QCPColorMap* self, QTimerEvent* event) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->timerEvent(event);
    } else {
        ((VirtualQCPColorMap*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPColorMap_QBaseTimerEvent(QCPColorMap* self, QTimerEvent* event) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_TimerEvent_IsBase(true);
        vqcpcolormap->timerEvent(event);
    } else {
        ((VirtualQCPColorMap*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnTimerEvent(QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_TimerEvent_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorMap_ChildEvent(QCPColorMap* self, QChildEvent* event) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->childEvent(event);
    } else {
        ((VirtualQCPColorMap*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPColorMap_QBaseChildEvent(QCPColorMap* self, QChildEvent* event) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_ChildEvent_IsBase(true);
        vqcpcolormap->childEvent(event);
    } else {
        ((VirtualQCPColorMap*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnChildEvent(QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_ChildEvent_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorMap_CustomEvent(QCPColorMap* self, QEvent* event) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->customEvent(event);
    } else {
        ((VirtualQCPColorMap*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPColorMap_QBaseCustomEvent(QCPColorMap* self, QEvent* event) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_CustomEvent_IsBase(true);
        vqcpcolormap->customEvent(event);
    } else {
        ((VirtualQCPColorMap*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnCustomEvent(QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_CustomEvent_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorMap_ConnectNotify(QCPColorMap* self, const QMetaMethod* signal) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->connectNotify(*signal);
    } else {
        ((VirtualQCPColorMap*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPColorMap_QBaseConnectNotify(QCPColorMap* self, const QMetaMethod* signal) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_ConnectNotify_IsBase(true);
        vqcpcolormap->connectNotify(*signal);
    } else {
        ((VirtualQCPColorMap*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnConnectNotify(QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_ConnectNotify_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorMap_DisconnectNotify(QCPColorMap* self, const QMetaMethod* signal) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->disconnectNotify(*signal);
    } else {
        ((VirtualQCPColorMap*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPColorMap_QBaseDisconnectNotify(QCPColorMap* self, const QMetaMethod* signal) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_DisconnectNotify_IsBase(true);
        vqcpcolormap->disconnectNotify(*signal);
    } else {
        ((VirtualQCPColorMap*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnDisconnectNotify(QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorMap_ApplyFillAntialiasingHint(const QCPColorMap* self, QCPPainter* painter) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->applyFillAntialiasingHint(painter);
    } else {
        ((VirtualQCPColorMap*)self)->applyFillAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPColorMap_QBaseApplyFillAntialiasingHint(const QCPColorMap* self, QCPPainter* painter) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_ApplyFillAntialiasingHint_IsBase(true);
        vqcpcolormap->applyFillAntialiasingHint(painter);
    } else {
        ((VirtualQCPColorMap*)self)->applyFillAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnApplyFillAntialiasingHint(const QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_ApplyFillAntialiasingHint_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_ApplyFillAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorMap_ApplyScattersAntialiasingHint(const QCPColorMap* self, QCPPainter* painter) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->applyScattersAntialiasingHint(painter);
    } else {
        ((VirtualQCPColorMap*)self)->applyScattersAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPColorMap_QBaseApplyScattersAntialiasingHint(const QCPColorMap* self, QCPPainter* painter) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_ApplyScattersAntialiasingHint_IsBase(true);
        vqcpcolormap->applyScattersAntialiasingHint(painter);
    } else {
        ((VirtualQCPColorMap*)self)->applyScattersAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnApplyScattersAntialiasingHint(const QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_ApplyScattersAntialiasingHint_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_ApplyScattersAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorMap_InitializeParentPlot(QCPColorMap* self, QCustomPlot* parentPlot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPColorMap*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPColorMap_QBaseInitializeParentPlot(QCPColorMap* self, QCustomPlot* parentPlot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_InitializeParentPlot_IsBase(true);
        vqcpcolormap->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPColorMap*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnInitializeParentPlot(QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorMap_SetParentLayerable(QCPColorMap* self, QCPLayerable* parentLayerable) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPColorMap*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPColorMap_QBaseSetParentLayerable(QCPColorMap* self, QCPLayerable* parentLayerable) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_SetParentLayerable_IsBase(true);
        vqcpcolormap->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPColorMap*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnSetParentLayerable(QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPColorMap_MoveToLayer(QCPColorMap* self, QCPLayer* layer, bool prepend) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        return vqcpcolormap->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPColorMap*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPColorMap_QBaseMoveToLayer(QCPColorMap* self, QCPLayer* layer, bool prepend) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_MoveToLayer_IsBase(true);
        return vqcpcolormap->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPColorMap*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnMoveToLayer(QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = dynamic_cast<VirtualQCPColorMap*>(self);
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_MoveToLayer_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPColorMap_ApplyAntialiasingHint(const QCPColorMap* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPColorMap*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPColorMap_QBaseApplyAntialiasingHint(const QCPColorMap* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_ApplyAntialiasingHint_IsBase(true);
        vqcpcolormap->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPColorMap*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnApplyAntialiasingHint(const QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPColorMap_Sender(const QCPColorMap* self) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        return vqcpcolormap->sender();
    } else {
        return ((VirtualQCPColorMap*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPColorMap_QBaseSender(const QCPColorMap* self) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_Sender_IsBase(true);
        return vqcpcolormap->sender();
    } else {
        return ((VirtualQCPColorMap*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnSender(const QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_Sender_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPColorMap_SenderSignalIndex(const QCPColorMap* self) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        return vqcpcolormap->senderSignalIndex();
    } else {
        return ((VirtualQCPColorMap*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPColorMap_QBaseSenderSignalIndex(const QCPColorMap* self) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_SenderSignalIndex_IsBase(true);
        return vqcpcolormap->senderSignalIndex();
    } else {
        return ((VirtualQCPColorMap*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnSenderSignalIndex(const QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPColorMap_Receivers(const QCPColorMap* self, const char* signal) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        return vqcpcolormap->receivers(signal);
    } else {
        return ((VirtualQCPColorMap*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPColorMap_QBaseReceivers(const QCPColorMap* self, const char* signal) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_Receivers_IsBase(true);
        return vqcpcolormap->receivers(signal);
    } else {
        return ((VirtualQCPColorMap*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnReceivers(const QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_Receivers_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPColorMap_IsSignalConnected(const QCPColorMap* self, const QMetaMethod* signal) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        return vqcpcolormap->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPColorMap*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPColorMap_QBaseIsSignalConnected(const QCPColorMap* self, const QMetaMethod* signal) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_IsSignalConnected_IsBase(true);
        return vqcpcolormap->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPColorMap*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPColorMap_OnIsSignalConnected(const QCPColorMap* self, intptr_t slot) {
    auto* vqcpcolormap = const_cast<VirtualQCPColorMap*>(dynamic_cast<const VirtualQCPColorMap*>(self));
    if (vqcpcolormap && vqcpcolormap->isVirtualQCPColorMap) {
        vqcpcolormap->setQCPColorMap_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPColorMap::QCPColorMap_IsSignalConnected_Callback>(slot));
    }
}

void QCPColorMap_Delete(QCPColorMap* self) {
    delete self;
}

QCPFinancialData* QCPFinancialData_new(const QCPFinancialData* other) {
    return new QCPFinancialData(*other);
}

QCPFinancialData* QCPFinancialData_new2(QCPFinancialData* other) {
    return new QCPFinancialData(std::move(*other));
}

QCPFinancialData* QCPFinancialData_new3() {
    return new QCPFinancialData();
}

QCPFinancialData* QCPFinancialData_new4(double key, double open, double high, double low, double close) {
    return new QCPFinancialData(static_cast<double>(key), static_cast<double>(open), static_cast<double>(high), static_cast<double>(low), static_cast<double>(close));
}

QCPFinancialData* QCPFinancialData_new5(const QCPFinancialData* param1) {
    return new QCPFinancialData(*param1);
}

void QCPFinancialData_CopyAssign(QCPFinancialData* self, QCPFinancialData* other) {
    *self = *other;
}

void QCPFinancialData_MoveAssign(QCPFinancialData* self, QCPFinancialData* other) {
    *self = std::move(*other);
}

double QCPFinancialData_SortKey(const QCPFinancialData* self) {
    return self->sortKey();
}

QCPFinancialData* QCPFinancialData_FromSortKey(double sortKey) {
    return new QCPFinancialData(QCPFinancialData::fromSortKey(static_cast<double>(sortKey)));
}

bool QCPFinancialData_SortKeyIsMainKey() {
    return QCPFinancialData::sortKeyIsMainKey();
}

double QCPFinancialData_MainKey(const QCPFinancialData* self) {
    return self->mainKey();
}

double QCPFinancialData_MainValue(const QCPFinancialData* self) {
    return self->mainValue();
}

QCPRange* QCPFinancialData_ValueRange(const QCPFinancialData* self) {
    return new QCPRange(self->valueRange());
}

double QCPFinancialData_Key(const QCPFinancialData* self) {
    return self->key;
}

void QCPFinancialData_SetKey(QCPFinancialData* self, double key) {
    self->key = static_cast<double>(key);
}

double QCPFinancialData_Open(const QCPFinancialData* self) {
    return self->open;
}

void QCPFinancialData_SetOpen(QCPFinancialData* self, double open) {
    self->open = static_cast<double>(open);
}

double QCPFinancialData_High(const QCPFinancialData* self) {
    return self->high;
}

void QCPFinancialData_SetHigh(QCPFinancialData* self, double high) {
    self->high = static_cast<double>(high);
}

double QCPFinancialData_Low(const QCPFinancialData* self) {
    return self->low;
}

void QCPFinancialData_SetLow(QCPFinancialData* self, double low) {
    self->low = static_cast<double>(low);
}

double QCPFinancialData_Close(const QCPFinancialData* self) {
    return self->close;
}

void QCPFinancialData_SetClose(QCPFinancialData* self, double close) {
    self->close = static_cast<double>(close);
}

void QCPFinancialData_Delete(QCPFinancialData* self) {
    delete self;
}

QCPFinancial* QCPFinancial_new(QCPAxis* keyAxis, QCPAxis* valueAxis) {
    return new VirtualQCPFinancial(keyAxis, valueAxis);
}

QMetaObject* QCPFinancial_MetaObject(const QCPFinancial* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPFinancial_Metacast(QCPFinancial* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPFinancial_Metacall(QCPFinancial* self, int param1, int param2, void** param3) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPFinancial*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPFinancial_Tr(const char* s) {
    QString _ret = QCPFinancial::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

int QCPFinancial_ChartStyle(const QCPFinancial* self) {
    return static_cast<int>(self->chartStyle());
}

double QCPFinancial_Width(const QCPFinancial* self) {
    return self->width();
}

int QCPFinancial_WidthType(const QCPFinancial* self) {
    return static_cast<int>(self->widthType());
}

bool QCPFinancial_TwoColored(const QCPFinancial* self) {
    return self->twoColored();
}

QBrush* QCPFinancial_BrushPositive(const QCPFinancial* self) {
    return new QBrush(self->brushPositive());
}

QBrush* QCPFinancial_BrushNegative(const QCPFinancial* self) {
    return new QBrush(self->brushNegative());
}

QPen* QCPFinancial_PenPositive(const QCPFinancial* self) {
    return new QPen(self->penPositive());
}

QPen* QCPFinancial_PenNegative(const QCPFinancial* self) {
    return new QPen(self->penNegative());
}

void QCPFinancial_SetData2(QCPFinancial* self, const libqt_list /* of double */ keys, const libqt_list /* of double */ open, const libqt_list /* of double */ high, const libqt_list /* of double */ low, const libqt_list /* of double */ close) {
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> open_QVector;
    open_QVector.reserve(open.len);
    double* open_arr = static_cast<double*>(open.data);
    for (size_t i = 0; i < open.len; ++i) {
        open_QVector.push_back(static_cast<double>(open_arr[i]));
    }
    QVector<double> high_QVector;
    high_QVector.reserve(high.len);
    double* high_arr = static_cast<double*>(high.data);
    for (size_t i = 0; i < high.len; ++i) {
        high_QVector.push_back(static_cast<double>(high_arr[i]));
    }
    QVector<double> low_QVector;
    low_QVector.reserve(low.len);
    double* low_arr = static_cast<double*>(low.data);
    for (size_t i = 0; i < low.len; ++i) {
        low_QVector.push_back(static_cast<double>(low_arr[i]));
    }
    QVector<double> close_QVector;
    close_QVector.reserve(close.len);
    double* close_arr = static_cast<double*>(close.data);
    for (size_t i = 0; i < close.len; ++i) {
        close_QVector.push_back(static_cast<double>(close_arr[i]));
    }
    self->setData(keys_QVector, open_QVector, high_QVector, low_QVector, close_QVector);
}

void QCPFinancial_SetChartStyle(QCPFinancial* self, int style) {
    self->setChartStyle(static_cast<QCPFinancial::ChartStyle>(style));
}

void QCPFinancial_SetWidth(QCPFinancial* self, double width) {
    self->setWidth(static_cast<double>(width));
}

void QCPFinancial_SetWidthType(QCPFinancial* self, int widthType) {
    self->setWidthType(static_cast<QCPFinancial::WidthType>(widthType));
}

void QCPFinancial_SetTwoColored(QCPFinancial* self, bool twoColored) {
    self->setTwoColored(twoColored);
}

void QCPFinancial_SetBrushPositive(QCPFinancial* self, const QBrush* brush) {
    self->setBrushPositive(*brush);
}

void QCPFinancial_SetBrushNegative(QCPFinancial* self, const QBrush* brush) {
    self->setBrushNegative(*brush);
}

void QCPFinancial_SetPenPositive(QCPFinancial* self, const QPen* pen) {
    self->setPenPositive(*pen);
}

void QCPFinancial_SetPenNegative(QCPFinancial* self, const QPen* pen) {
    self->setPenNegative(*pen);
}

void QCPFinancial_AddData(QCPFinancial* self, const libqt_list /* of double */ keys, const libqt_list /* of double */ open, const libqt_list /* of double */ high, const libqt_list /* of double */ low, const libqt_list /* of double */ close) {
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> open_QVector;
    open_QVector.reserve(open.len);
    double* open_arr = static_cast<double*>(open.data);
    for (size_t i = 0; i < open.len; ++i) {
        open_QVector.push_back(static_cast<double>(open_arr[i]));
    }
    QVector<double> high_QVector;
    high_QVector.reserve(high.len);
    double* high_arr = static_cast<double*>(high.data);
    for (size_t i = 0; i < high.len; ++i) {
        high_QVector.push_back(static_cast<double>(high_arr[i]));
    }
    QVector<double> low_QVector;
    low_QVector.reserve(low.len);
    double* low_arr = static_cast<double*>(low.data);
    for (size_t i = 0; i < low.len; ++i) {
        low_QVector.push_back(static_cast<double>(low_arr[i]));
    }
    QVector<double> close_QVector;
    close_QVector.reserve(close.len);
    double* close_arr = static_cast<double*>(close.data);
    for (size_t i = 0; i < close.len; ++i) {
        close_QVector.push_back(static_cast<double>(close_arr[i]));
    }
    self->addData(keys_QVector, open_QVector, high_QVector, low_QVector, close_QVector);
}

void QCPFinancial_AddData2(QCPFinancial* self, double key, double open, double high, double low, double close) {
    self->addData(static_cast<double>(key), static_cast<double>(open), static_cast<double>(high), static_cast<double>(low), static_cast<double>(close));
}

QCPDataSelection* QCPFinancial_SelectTestRect(const QCPFinancial* self, const QRectF* rect, bool onlySelectable) {
    auto* vqcpfinancial = dynamic_cast<const VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        return new QCPDataSelection(self->selectTestRect(*rect, onlySelectable));
    } else {
        return new QCPDataSelection(((VirtualQCPFinancial*)self)->selectTestRect(*rect, onlySelectable));
    }
}

double QCPFinancial_SelectTest(const QCPFinancial* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpfinancial = dynamic_cast<const VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPFinancial*)self)->selectTest(*pos, onlySelectable, details);
    }
}

QCPRange* QCPFinancial_GetKeyRange(const QCPFinancial* self, bool* foundRange, int inSignDomain) {
    auto* vqcpfinancial = dynamic_cast<const VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        return new QCPRange(self->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    } else {
        return new QCPRange(((VirtualQCPFinancial*)self)->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    }
}

QCPRange* QCPFinancial_GetValueRange(const QCPFinancial* self, bool* foundRange, int inSignDomain, const QCPRange* inKeyRange) {
    auto* vqcpfinancial = dynamic_cast<const VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        return new QCPRange(self->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    } else {
        return new QCPRange(((VirtualQCPFinancial*)self)->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    }
}

void QCPFinancial_Draw(QCPFinancial* self, QCPPainter* painter) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->draw(painter);
    }
}

void QCPFinancial_DrawLegendIcon(const QCPFinancial* self, QCPPainter* painter, const QRectF* rect) {
    auto* vqcpfinancial = dynamic_cast<const VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->drawLegendIcon(painter, *rect);
    }
}

libqt_string QCPFinancial_Tr2(const char* s, const char* c) {
    QString _ret = QCPFinancial::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPFinancial_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPFinancial::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

void QCPFinancial_SetData6(QCPFinancial* self, const libqt_list /* of double */ keys, const libqt_list /* of double */ open, const libqt_list /* of double */ high, const libqt_list /* of double */ low, const libqt_list /* of double */ close, bool alreadySorted) {
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> open_QVector;
    open_QVector.reserve(open.len);
    double* open_arr = static_cast<double*>(open.data);
    for (size_t i = 0; i < open.len; ++i) {
        open_QVector.push_back(static_cast<double>(open_arr[i]));
    }
    QVector<double> high_QVector;
    high_QVector.reserve(high.len);
    double* high_arr = static_cast<double*>(high.data);
    for (size_t i = 0; i < high.len; ++i) {
        high_QVector.push_back(static_cast<double>(high_arr[i]));
    }
    QVector<double> low_QVector;
    low_QVector.reserve(low.len);
    double* low_arr = static_cast<double*>(low.data);
    for (size_t i = 0; i < low.len; ++i) {
        low_QVector.push_back(static_cast<double>(low_arr[i]));
    }
    QVector<double> close_QVector;
    close_QVector.reserve(close.len);
    double* close_arr = static_cast<double*>(close.data);
    for (size_t i = 0; i < close.len; ++i) {
        close_QVector.push_back(static_cast<double>(close_arr[i]));
    }
    self->setData(keys_QVector, open_QVector, high_QVector, low_QVector, close_QVector, alreadySorted);
}

void QCPFinancial_AddData6(QCPFinancial* self, const libqt_list /* of double */ keys, const libqt_list /* of double */ open, const libqt_list /* of double */ high, const libqt_list /* of double */ low, const libqt_list /* of double */ close, bool alreadySorted) {
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> open_QVector;
    open_QVector.reserve(open.len);
    double* open_arr = static_cast<double*>(open.data);
    for (size_t i = 0; i < open.len; ++i) {
        open_QVector.push_back(static_cast<double>(open_arr[i]));
    }
    QVector<double> high_QVector;
    high_QVector.reserve(high.len);
    double* high_arr = static_cast<double*>(high.data);
    for (size_t i = 0; i < high.len; ++i) {
        high_QVector.push_back(static_cast<double>(high_arr[i]));
    }
    QVector<double> low_QVector;
    low_QVector.reserve(low.len);
    double* low_arr = static_cast<double*>(low.data);
    for (size_t i = 0; i < low.len; ++i) {
        low_QVector.push_back(static_cast<double>(low_arr[i]));
    }
    QVector<double> close_QVector;
    close_QVector.reserve(close.len);
    double* close_arr = static_cast<double*>(close.data);
    for (size_t i = 0; i < close.len; ++i) {
        close_QVector.push_back(static_cast<double>(close_arr[i]));
    }
    self->addData(keys_QVector, open_QVector, high_QVector, low_QVector, close_QVector, alreadySorted);
}

// Base class handler implementation
int QCPFinancial_QBaseMetacall(QCPFinancial* self, int param1, int param2, void** param3) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_Metacall_IsBase(true);
        return vqcpfinancial->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPFinancial::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnMetacall(QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_Metacall_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
QCPDataSelection* QCPFinancial_QBaseSelectTestRect(const QCPFinancial* self, const QRectF* rect, bool onlySelectable) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_SelectTestRect_IsBase(true);
        return new QCPDataSelection(vqcpfinancial->selectTestRect(*rect, onlySelectable));
    } else {
        return new QCPDataSelection(((VirtualQCPFinancial*)self)->selectTestRect(*rect, onlySelectable));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnSelectTestRect(const QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_SelectTestRect_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_SelectTestRect_Callback>(slot));
    }
}

// Base class handler implementation
double QCPFinancial_QBaseSelectTest(const QCPFinancial* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_SelectTest_IsBase(true);
        return vqcpfinancial->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPFinancial::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnSelectTest(const QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_SelectTest_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
QCPRange* QCPFinancial_QBaseGetKeyRange(const QCPFinancial* self, bool* foundRange, int inSignDomain) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_GetKeyRange_IsBase(true);
        return new QCPRange(vqcpfinancial->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    } else {
        return new QCPRange(((VirtualQCPFinancial*)self)->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnGetKeyRange(const QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_GetKeyRange_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_GetKeyRange_Callback>(slot));
    }
}

// Base class handler implementation
QCPRange* QCPFinancial_QBaseGetValueRange(const QCPFinancial* self, bool* foundRange, int inSignDomain, const QCPRange* inKeyRange) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_GetValueRange_IsBase(true);
        return new QCPRange(vqcpfinancial->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    } else {
        return new QCPRange(((VirtualQCPFinancial*)self)->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnGetValueRange(const QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_GetValueRange_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_GetValueRange_Callback>(slot));
    }
}

// Base class handler implementation
void QCPFinancial_QBaseDraw(QCPFinancial* self, QCPPainter* painter) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_Draw_IsBase(true);
        vqcpfinancial->draw(painter);
    } else {
        ((VirtualQCPFinancial*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnDraw(QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_Draw_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_Draw_Callback>(slot));
    }
}

// Base class handler implementation
void QCPFinancial_QBaseDrawLegendIcon(const QCPFinancial* self, QCPPainter* painter, const QRectF* rect) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_DrawLegendIcon_IsBase(true);
        vqcpfinancial->drawLegendIcon(painter, *rect);
    } else {
        ((VirtualQCPFinancial*)self)->drawLegendIcon(painter, *rect);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnDrawLegendIcon(const QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_DrawLegendIcon_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_DrawLegendIcon_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPFinancial_DataCount(const QCPFinancial* self) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        return vqcpfinancial->dataCount();
    } else {
        return ((VirtualQCPFinancial*)self)->dataCount();
    }
}

// Base class handler implementation
int QCPFinancial_QBaseDataCount(const QCPFinancial* self) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_DataCount_IsBase(true);
        return vqcpfinancial->dataCount();
    } else {
        return ((VirtualQCPFinancial*)self)->dataCount();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnDataCount(const QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_DataCount_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_DataCount_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPFinancial_DataMainKey(const QCPFinancial* self, int index) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        return vqcpfinancial->dataMainKey(static_cast<int>(index));
    } else {
        return ((VirtualQCPFinancial*)self)->dataMainKey(static_cast<int>(index));
    }
}

// Base class handler implementation
double QCPFinancial_QBaseDataMainKey(const QCPFinancial* self, int index) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_DataMainKey_IsBase(true);
        return vqcpfinancial->dataMainKey(static_cast<int>(index));
    } else {
        return ((VirtualQCPFinancial*)self)->dataMainKey(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnDataMainKey(const QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_DataMainKey_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_DataMainKey_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPFinancial_DataSortKey(const QCPFinancial* self, int index) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        return vqcpfinancial->dataSortKey(static_cast<int>(index));
    } else {
        return ((VirtualQCPFinancial*)self)->dataSortKey(static_cast<int>(index));
    }
}

// Base class handler implementation
double QCPFinancial_QBaseDataSortKey(const QCPFinancial* self, int index) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_DataSortKey_IsBase(true);
        return vqcpfinancial->dataSortKey(static_cast<int>(index));
    } else {
        return ((VirtualQCPFinancial*)self)->dataSortKey(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnDataSortKey(const QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_DataSortKey_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_DataSortKey_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPFinancial_DataMainValue(const QCPFinancial* self, int index) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        return vqcpfinancial->dataMainValue(static_cast<int>(index));
    } else {
        return ((VirtualQCPFinancial*)self)->dataMainValue(static_cast<int>(index));
    }
}

// Base class handler implementation
double QCPFinancial_QBaseDataMainValue(const QCPFinancial* self, int index) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_DataMainValue_IsBase(true);
        return vqcpfinancial->dataMainValue(static_cast<int>(index));
    } else {
        return ((VirtualQCPFinancial*)self)->dataMainValue(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnDataMainValue(const QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_DataMainValue_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_DataMainValue_Callback>(slot));
    }
}

// Derived class handler implementation
QCPRange* QCPFinancial_DataValueRange(const QCPFinancial* self, int index) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        return new QCPRange(vqcpfinancial->dataValueRange(static_cast<int>(index)));
    } else {
        return new QCPRange(((VirtualQCPFinancial*)self)->dataValueRange(static_cast<int>(index)));
    }
}

// Base class handler implementation
QCPRange* QCPFinancial_QBaseDataValueRange(const QCPFinancial* self, int index) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_DataValueRange_IsBase(true);
        return new QCPRange(vqcpfinancial->dataValueRange(static_cast<int>(index)));
    } else {
        return new QCPRange(((VirtualQCPFinancial*)self)->dataValueRange(static_cast<int>(index)));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnDataValueRange(const QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_DataValueRange_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_DataValueRange_Callback>(slot));
    }
}

// Derived class handler implementation
QPointF* QCPFinancial_DataPixelPosition(const QCPFinancial* self, int index) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        return new QPointF(vqcpfinancial->dataPixelPosition(static_cast<int>(index)));
    } else {
        return new QPointF(((VirtualQCPFinancial*)self)->dataPixelPosition(static_cast<int>(index)));
    }
}

// Base class handler implementation
QPointF* QCPFinancial_QBaseDataPixelPosition(const QCPFinancial* self, int index) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_DataPixelPosition_IsBase(true);
        return new QPointF(vqcpfinancial->dataPixelPosition(static_cast<int>(index)));
    } else {
        return new QPointF(((VirtualQCPFinancial*)self)->dataPixelPosition(static_cast<int>(index)));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnDataPixelPosition(const QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_DataPixelPosition_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_DataPixelPosition_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPFinancial_SortKeyIsMainKey(const QCPFinancial* self) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        return vqcpfinancial->sortKeyIsMainKey();
    } else {
        return ((VirtualQCPFinancial*)self)->sortKeyIsMainKey();
    }
}

// Base class handler implementation
bool QCPFinancial_QBaseSortKeyIsMainKey(const QCPFinancial* self) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_SortKeyIsMainKey_IsBase(true);
        return vqcpfinancial->sortKeyIsMainKey();
    } else {
        return ((VirtualQCPFinancial*)self)->sortKeyIsMainKey();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnSortKeyIsMainKey(const QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_SortKeyIsMainKey_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_SortKeyIsMainKey_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPFinancial_FindBegin(const QCPFinancial* self, double sortKey, bool expandedRange) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        return vqcpfinancial->findBegin(static_cast<double>(sortKey), expandedRange);
    } else {
        return ((VirtualQCPFinancial*)self)->findBegin(static_cast<double>(sortKey), expandedRange);
    }
}

// Base class handler implementation
int QCPFinancial_QBaseFindBegin(const QCPFinancial* self, double sortKey, bool expandedRange) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_FindBegin_IsBase(true);
        return vqcpfinancial->findBegin(static_cast<double>(sortKey), expandedRange);
    } else {
        return ((VirtualQCPFinancial*)self)->findBegin(static_cast<double>(sortKey), expandedRange);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnFindBegin(const QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_FindBegin_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_FindBegin_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPFinancial_FindEnd(const QCPFinancial* self, double sortKey, bool expandedRange) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        return vqcpfinancial->findEnd(static_cast<double>(sortKey), expandedRange);
    } else {
        return ((VirtualQCPFinancial*)self)->findEnd(static_cast<double>(sortKey), expandedRange);
    }
}

// Base class handler implementation
int QCPFinancial_QBaseFindEnd(const QCPFinancial* self, double sortKey, bool expandedRange) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_FindEnd_IsBase(true);
        return vqcpfinancial->findEnd(static_cast<double>(sortKey), expandedRange);
    } else {
        return ((VirtualQCPFinancial*)self)->findEnd(static_cast<double>(sortKey), expandedRange);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnFindEnd(const QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_FindEnd_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_FindEnd_Callback>(slot));
    }
}

// Derived class handler implementation
QCPPlottableInterface1D* QCPFinancial_Interface1D(QCPFinancial* self) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        return vqcpfinancial->interface1D();
    } else {
        return self->QCPFinancial::interface1D();
    }
}

// Base class handler implementation
QCPPlottableInterface1D* QCPFinancial_QBaseInterface1D(QCPFinancial* self) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_Interface1D_IsBase(true);
        return vqcpfinancial->interface1D();
    } else {
        return self->QCPFinancial::interface1D();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnInterface1D(QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_Interface1D_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_Interface1D_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPFinancial_ClipRect(const QCPFinancial* self) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        return new QRect(vqcpfinancial->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPFinancial_QBaseClipRect(const QCPFinancial* self) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_ClipRect_IsBase(true);
        return new QRect(vqcpfinancial->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnClipRect(const QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_ClipRect_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPFinancial_SelectionCategory(const QCPFinancial* self) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        return static_cast<int>(vqcpfinancial->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPFinancial*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPFinancial_QBaseSelectionCategory(const QCPFinancial* self) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcpfinancial->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPFinancial*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnSelectionCategory(const QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_SelectionCategory_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPFinancial_ApplyDefaultAntialiasingHint(const QCPFinancial* self, QCPPainter* painter) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPFinancial*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPFinancial_QBaseApplyDefaultAntialiasingHint(const QCPFinancial* self, QCPPainter* painter) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcpfinancial->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPFinancial*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnApplyDefaultAntialiasingHint(const QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPFinancial_SelectEvent(QCPFinancial* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPFinancial*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPFinancial_QBaseSelectEvent(QCPFinancial* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_SelectEvent_IsBase(true);
        vqcpfinancial->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPFinancial*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnSelectEvent(QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_SelectEvent_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPFinancial_DeselectEvent(QCPFinancial* self, bool* selectionStateChanged) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPFinancial*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPFinancial_QBaseDeselectEvent(QCPFinancial* self, bool* selectionStateChanged) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_DeselectEvent_IsBase(true);
        vqcpfinancial->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPFinancial*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnDeselectEvent(QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_DeselectEvent_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPFinancial_ParentPlotInitialized(QCPFinancial* self, QCustomPlot* parentPlot) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPFinancial*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPFinancial_QBaseParentPlotInitialized(QCPFinancial* self, QCustomPlot* parentPlot) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_ParentPlotInitialized_IsBase(true);
        vqcpfinancial->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPFinancial*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnParentPlotInitialized(QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPFinancial_MousePressEvent(QCPFinancial* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPFinancial*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPFinancial_QBaseMousePressEvent(QCPFinancial* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_MousePressEvent_IsBase(true);
        vqcpfinancial->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPFinancial*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnMousePressEvent(QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_MousePressEvent_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPFinancial_MouseMoveEvent(QCPFinancial* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPFinancial*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPFinancial_QBaseMouseMoveEvent(QCPFinancial* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_MouseMoveEvent_IsBase(true);
        vqcpfinancial->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPFinancial*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnMouseMoveEvent(QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPFinancial_MouseReleaseEvent(QCPFinancial* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPFinancial*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPFinancial_QBaseMouseReleaseEvent(QCPFinancial* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_MouseReleaseEvent_IsBase(true);
        vqcpfinancial->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPFinancial*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnMouseReleaseEvent(QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPFinancial_MouseDoubleClickEvent(QCPFinancial* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPFinancial*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPFinancial_QBaseMouseDoubleClickEvent(QCPFinancial* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_MouseDoubleClickEvent_IsBase(true);
        vqcpfinancial->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPFinancial*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnMouseDoubleClickEvent(QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPFinancial_WheelEvent(QCPFinancial* self, QWheelEvent* event) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->wheelEvent(event);
    } else {
        ((VirtualQCPFinancial*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPFinancial_QBaseWheelEvent(QCPFinancial* self, QWheelEvent* event) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_WheelEvent_IsBase(true);
        vqcpfinancial->wheelEvent(event);
    } else {
        ((VirtualQCPFinancial*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnWheelEvent(QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_WheelEvent_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPFinancial_Event(QCPFinancial* self, QEvent* event) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        return vqcpfinancial->event(event);
    } else {
        return self->QCPFinancial::event(event);
    }
}

// Base class handler implementation
bool QCPFinancial_QBaseEvent(QCPFinancial* self, QEvent* event) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_Event_IsBase(true);
        return vqcpfinancial->event(event);
    } else {
        return self->QCPFinancial::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnEvent(QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_Event_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPFinancial_EventFilter(QCPFinancial* self, QObject* watched, QEvent* event) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        return vqcpfinancial->eventFilter(watched, event);
    } else {
        return self->QCPFinancial::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPFinancial_QBaseEventFilter(QCPFinancial* self, QObject* watched, QEvent* event) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_EventFilter_IsBase(true);
        return vqcpfinancial->eventFilter(watched, event);
    } else {
        return self->QCPFinancial::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnEventFilter(QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_EventFilter_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPFinancial_TimerEvent(QCPFinancial* self, QTimerEvent* event) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->timerEvent(event);
    } else {
        ((VirtualQCPFinancial*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPFinancial_QBaseTimerEvent(QCPFinancial* self, QTimerEvent* event) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_TimerEvent_IsBase(true);
        vqcpfinancial->timerEvent(event);
    } else {
        ((VirtualQCPFinancial*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnTimerEvent(QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_TimerEvent_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPFinancial_ChildEvent(QCPFinancial* self, QChildEvent* event) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->childEvent(event);
    } else {
        ((VirtualQCPFinancial*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPFinancial_QBaseChildEvent(QCPFinancial* self, QChildEvent* event) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_ChildEvent_IsBase(true);
        vqcpfinancial->childEvent(event);
    } else {
        ((VirtualQCPFinancial*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnChildEvent(QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_ChildEvent_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPFinancial_CustomEvent(QCPFinancial* self, QEvent* event) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->customEvent(event);
    } else {
        ((VirtualQCPFinancial*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPFinancial_QBaseCustomEvent(QCPFinancial* self, QEvent* event) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_CustomEvent_IsBase(true);
        vqcpfinancial->customEvent(event);
    } else {
        ((VirtualQCPFinancial*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnCustomEvent(QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_CustomEvent_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPFinancial_ConnectNotify(QCPFinancial* self, const QMetaMethod* signal) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->connectNotify(*signal);
    } else {
        ((VirtualQCPFinancial*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPFinancial_QBaseConnectNotify(QCPFinancial* self, const QMetaMethod* signal) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_ConnectNotify_IsBase(true);
        vqcpfinancial->connectNotify(*signal);
    } else {
        ((VirtualQCPFinancial*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnConnectNotify(QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_ConnectNotify_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPFinancial_DisconnectNotify(QCPFinancial* self, const QMetaMethod* signal) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->disconnectNotify(*signal);
    } else {
        ((VirtualQCPFinancial*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPFinancial_QBaseDisconnectNotify(QCPFinancial* self, const QMetaMethod* signal) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_DisconnectNotify_IsBase(true);
        vqcpfinancial->disconnectNotify(*signal);
    } else {
        ((VirtualQCPFinancial*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnDisconnectNotify(QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPFinancial_GetPixelWidth(const QCPFinancial* self, double key, double keyPixel) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        return vqcpfinancial->getPixelWidth(static_cast<double>(key), static_cast<double>(keyPixel));
    } else {
        return ((VirtualQCPFinancial*)self)->getPixelWidth(static_cast<double>(key), static_cast<double>(keyPixel));
    }
}

// Base class handler implementation
double QCPFinancial_QBaseGetPixelWidth(const QCPFinancial* self, double key, double keyPixel) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_GetPixelWidth_IsBase(true);
        return vqcpfinancial->getPixelWidth(static_cast<double>(key), static_cast<double>(keyPixel));
    } else {
        return ((VirtualQCPFinancial*)self)->getPixelWidth(static_cast<double>(key), static_cast<double>(keyPixel));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnGetPixelWidth(const QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_GetPixelWidth_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_GetPixelWidth_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPFinancial_ApplyFillAntialiasingHint(const QCPFinancial* self, QCPPainter* painter) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->applyFillAntialiasingHint(painter);
    } else {
        ((VirtualQCPFinancial*)self)->applyFillAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPFinancial_QBaseApplyFillAntialiasingHint(const QCPFinancial* self, QCPPainter* painter) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_ApplyFillAntialiasingHint_IsBase(true);
        vqcpfinancial->applyFillAntialiasingHint(painter);
    } else {
        ((VirtualQCPFinancial*)self)->applyFillAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnApplyFillAntialiasingHint(const QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_ApplyFillAntialiasingHint_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_ApplyFillAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPFinancial_ApplyScattersAntialiasingHint(const QCPFinancial* self, QCPPainter* painter) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->applyScattersAntialiasingHint(painter);
    } else {
        ((VirtualQCPFinancial*)self)->applyScattersAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPFinancial_QBaseApplyScattersAntialiasingHint(const QCPFinancial* self, QCPPainter* painter) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_ApplyScattersAntialiasingHint_IsBase(true);
        vqcpfinancial->applyScattersAntialiasingHint(painter);
    } else {
        ((VirtualQCPFinancial*)self)->applyScattersAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnApplyScattersAntialiasingHint(const QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_ApplyScattersAntialiasingHint_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_ApplyScattersAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPFinancial_InitializeParentPlot(QCPFinancial* self, QCustomPlot* parentPlot) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPFinancial*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPFinancial_QBaseInitializeParentPlot(QCPFinancial* self, QCustomPlot* parentPlot) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_InitializeParentPlot_IsBase(true);
        vqcpfinancial->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPFinancial*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnInitializeParentPlot(QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPFinancial_SetParentLayerable(QCPFinancial* self, QCPLayerable* parentLayerable) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPFinancial*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPFinancial_QBaseSetParentLayerable(QCPFinancial* self, QCPLayerable* parentLayerable) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_SetParentLayerable_IsBase(true);
        vqcpfinancial->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPFinancial*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnSetParentLayerable(QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPFinancial_MoveToLayer(QCPFinancial* self, QCPLayer* layer, bool prepend) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        return vqcpfinancial->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPFinancial*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPFinancial_QBaseMoveToLayer(QCPFinancial* self, QCPLayer* layer, bool prepend) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_MoveToLayer_IsBase(true);
        return vqcpfinancial->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPFinancial*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnMoveToLayer(QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = dynamic_cast<VirtualQCPFinancial*>(self);
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_MoveToLayer_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPFinancial_ApplyAntialiasingHint(const QCPFinancial* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPFinancial*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPFinancial_QBaseApplyAntialiasingHint(const QCPFinancial* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_ApplyAntialiasingHint_IsBase(true);
        vqcpfinancial->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPFinancial*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnApplyAntialiasingHint(const QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPFinancial_Sender(const QCPFinancial* self) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        return vqcpfinancial->sender();
    } else {
        return ((VirtualQCPFinancial*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPFinancial_QBaseSender(const QCPFinancial* self) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_Sender_IsBase(true);
        return vqcpfinancial->sender();
    } else {
        return ((VirtualQCPFinancial*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnSender(const QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_Sender_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPFinancial_SenderSignalIndex(const QCPFinancial* self) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        return vqcpfinancial->senderSignalIndex();
    } else {
        return ((VirtualQCPFinancial*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPFinancial_QBaseSenderSignalIndex(const QCPFinancial* self) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_SenderSignalIndex_IsBase(true);
        return vqcpfinancial->senderSignalIndex();
    } else {
        return ((VirtualQCPFinancial*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnSenderSignalIndex(const QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPFinancial_Receivers(const QCPFinancial* self, const char* signal) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        return vqcpfinancial->receivers(signal);
    } else {
        return ((VirtualQCPFinancial*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPFinancial_QBaseReceivers(const QCPFinancial* self, const char* signal) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_Receivers_IsBase(true);
        return vqcpfinancial->receivers(signal);
    } else {
        return ((VirtualQCPFinancial*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnReceivers(const QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_Receivers_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPFinancial_IsSignalConnected(const QCPFinancial* self, const QMetaMethod* signal) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        return vqcpfinancial->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPFinancial*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPFinancial_QBaseIsSignalConnected(const QCPFinancial* self, const QMetaMethod* signal) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_IsSignalConnected_IsBase(true);
        return vqcpfinancial->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPFinancial*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPFinancial_OnIsSignalConnected(const QCPFinancial* self, intptr_t slot) {
    auto* vqcpfinancial = const_cast<VirtualQCPFinancial*>(dynamic_cast<const VirtualQCPFinancial*>(self));
    if (vqcpfinancial && vqcpfinancial->isVirtualQCPFinancial) {
        vqcpfinancial->setQCPFinancial_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPFinancial::QCPFinancial_IsSignalConnected_Callback>(slot));
    }
}

void QCPFinancial_Delete(QCPFinancial* self) {
    delete self;
}

QCPErrorBarsData* QCPErrorBarsData_new(const QCPErrorBarsData* other) {
    return new QCPErrorBarsData(*other);
}

QCPErrorBarsData* QCPErrorBarsData_new2(QCPErrorBarsData* other) {
    return new QCPErrorBarsData(std::move(*other));
}

QCPErrorBarsData* QCPErrorBarsData_new3() {
    return new QCPErrorBarsData();
}

QCPErrorBarsData* QCPErrorBarsData_new4(double errorVal) {
    return new QCPErrorBarsData(static_cast<double>(errorVal));
}

QCPErrorBarsData* QCPErrorBarsData_new5(double errorMinus, double errorPlus) {
    return new QCPErrorBarsData(static_cast<double>(errorMinus), static_cast<double>(errorPlus));
}

QCPErrorBarsData* QCPErrorBarsData_new6(const QCPErrorBarsData* param1) {
    return new QCPErrorBarsData(*param1);
}

void QCPErrorBarsData_CopyAssign(QCPErrorBarsData* self, QCPErrorBarsData* other) {
    *self = *other;
}

void QCPErrorBarsData_MoveAssign(QCPErrorBarsData* self, QCPErrorBarsData* other) {
    *self = std::move(*other);
}

double QCPErrorBarsData_ErrorMinus(const QCPErrorBarsData* self) {
    return self->errorMinus;
}

void QCPErrorBarsData_SetErrorMinus(QCPErrorBarsData* self, double errorMinus) {
    self->errorMinus = static_cast<double>(errorMinus);
}

double QCPErrorBarsData_ErrorPlus(const QCPErrorBarsData* self) {
    return self->errorPlus;
}

void QCPErrorBarsData_SetErrorPlus(QCPErrorBarsData* self, double errorPlus) {
    self->errorPlus = static_cast<double>(errorPlus);
}

void QCPErrorBarsData_Delete(QCPErrorBarsData* self) {
    delete self;
}

QCPErrorBars* QCPErrorBars_new(QCPAxis* keyAxis, QCPAxis* valueAxis) {
    return new VirtualQCPErrorBars(keyAxis, valueAxis);
}

QMetaObject* QCPErrorBars_MetaObject(const QCPErrorBars* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPErrorBars_Metacast(QCPErrorBars* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPErrorBars_Metacall(QCPErrorBars* self, int param1, int param2, void** param3) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPErrorBars*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPErrorBars_Tr(const char* s) {
    QString _ret = QCPErrorBars::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

QCPAbstractPlottable* QCPErrorBars_DataPlottable(const QCPErrorBars* self) {
    return self->dataPlottable();
}

int QCPErrorBars_ErrorType(const QCPErrorBars* self) {
    return static_cast<int>(self->errorType());
}

double QCPErrorBars_WhiskerWidth(const QCPErrorBars* self) {
    return self->whiskerWidth();
}

double QCPErrorBars_SymbolGap(const QCPErrorBars* self) {
    return self->symbolGap();
}

void QCPErrorBars_SetData2(QCPErrorBars* self, const libqt_list /* of double */ errorVal) {
    QVector<double> errorVal_QVector;
    errorVal_QVector.reserve(errorVal.len);
    double* errorVal_arr = static_cast<double*>(errorVal.data);
    for (size_t i = 0; i < errorVal.len; ++i) {
        errorVal_QVector.push_back(static_cast<double>(errorVal_arr[i]));
    }
    self->setData(errorVal_QVector);
}

void QCPErrorBars_SetData3(QCPErrorBars* self, const libqt_list /* of double */ errorMinus, const libqt_list /* of double */ errorPlus) {
    QVector<double> errorMinus_QVector;
    errorMinus_QVector.reserve(errorMinus.len);
    double* errorMinus_arr = static_cast<double*>(errorMinus.data);
    for (size_t i = 0; i < errorMinus.len; ++i) {
        errorMinus_QVector.push_back(static_cast<double>(errorMinus_arr[i]));
    }
    QVector<double> errorPlus_QVector;
    errorPlus_QVector.reserve(errorPlus.len);
    double* errorPlus_arr = static_cast<double*>(errorPlus.data);
    for (size_t i = 0; i < errorPlus.len; ++i) {
        errorPlus_QVector.push_back(static_cast<double>(errorPlus_arr[i]));
    }
    self->setData(errorMinus_QVector, errorPlus_QVector);
}

void QCPErrorBars_SetDataPlottable(QCPErrorBars* self, QCPAbstractPlottable* plottable) {
    self->setDataPlottable(plottable);
}

void QCPErrorBars_SetErrorType(QCPErrorBars* self, int typeVal) {
    self->setErrorType(static_cast<QCPErrorBars::ErrorType>(typeVal));
}

void QCPErrorBars_SetWhiskerWidth(QCPErrorBars* self, double pixels) {
    self->setWhiskerWidth(static_cast<double>(pixels));
}

void QCPErrorBars_SetSymbolGap(QCPErrorBars* self, double pixels) {
    self->setSymbolGap(static_cast<double>(pixels));
}

void QCPErrorBars_AddData(QCPErrorBars* self, const libqt_list /* of double */ errorVal) {
    QVector<double> errorVal_QVector;
    errorVal_QVector.reserve(errorVal.len);
    double* errorVal_arr = static_cast<double*>(errorVal.data);
    for (size_t i = 0; i < errorVal.len; ++i) {
        errorVal_QVector.push_back(static_cast<double>(errorVal_arr[i]));
    }
    self->addData(errorVal_QVector);
}

void QCPErrorBars_AddData2(QCPErrorBars* self, const libqt_list /* of double */ errorMinus, const libqt_list /* of double */ errorPlus) {
    QVector<double> errorMinus_QVector;
    errorMinus_QVector.reserve(errorMinus.len);
    double* errorMinus_arr = static_cast<double*>(errorMinus.data);
    for (size_t i = 0; i < errorMinus.len; ++i) {
        errorMinus_QVector.push_back(static_cast<double>(errorMinus_arr[i]));
    }
    QVector<double> errorPlus_QVector;
    errorPlus_QVector.reserve(errorPlus.len);
    double* errorPlus_arr = static_cast<double*>(errorPlus.data);
    for (size_t i = 0; i < errorPlus.len; ++i) {
        errorPlus_QVector.push_back(static_cast<double>(errorPlus_arr[i]));
    }
    self->addData(errorMinus_QVector, errorPlus_QVector);
}

void QCPErrorBars_AddData3(QCPErrorBars* self, double errorVal) {
    self->addData(static_cast<double>(errorVal));
}

void QCPErrorBars_AddData4(QCPErrorBars* self, double errorMinus, double errorPlus) {
    self->addData(static_cast<double>(errorMinus), static_cast<double>(errorPlus));
}

int QCPErrorBars_DataCount(const QCPErrorBars* self) {
    auto* vqcperrorbars = dynamic_cast<const VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return self->dataCount();
    } else {
        return ((VirtualQCPErrorBars*)self)->dataCount();
    }
}

double QCPErrorBars_DataMainKey(const QCPErrorBars* self, int index) {
    auto* vqcperrorbars = dynamic_cast<const VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return self->dataMainKey(static_cast<int>(index));
    } else {
        return ((VirtualQCPErrorBars*)self)->dataMainKey(static_cast<int>(index));
    }
}

double QCPErrorBars_DataSortKey(const QCPErrorBars* self, int index) {
    auto* vqcperrorbars = dynamic_cast<const VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return self->dataSortKey(static_cast<int>(index));
    } else {
        return ((VirtualQCPErrorBars*)self)->dataSortKey(static_cast<int>(index));
    }
}

double QCPErrorBars_DataMainValue(const QCPErrorBars* self, int index) {
    auto* vqcperrorbars = dynamic_cast<const VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return self->dataMainValue(static_cast<int>(index));
    } else {
        return ((VirtualQCPErrorBars*)self)->dataMainValue(static_cast<int>(index));
    }
}

QCPRange* QCPErrorBars_DataValueRange(const QCPErrorBars* self, int index) {
    auto* vqcperrorbars = dynamic_cast<const VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return new QCPRange(self->dataValueRange(static_cast<int>(index)));
    } else {
        return new QCPRange(((VirtualQCPErrorBars*)self)->dataValueRange(static_cast<int>(index)));
    }
}

QPointF* QCPErrorBars_DataPixelPosition(const QCPErrorBars* self, int index) {
    auto* vqcperrorbars = dynamic_cast<const VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return new QPointF(self->dataPixelPosition(static_cast<int>(index)));
    } else {
        return new QPointF(((VirtualQCPErrorBars*)self)->dataPixelPosition(static_cast<int>(index)));
    }
}

bool QCPErrorBars_SortKeyIsMainKey(const QCPErrorBars* self) {
    auto* vqcperrorbars = dynamic_cast<const VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return self->sortKeyIsMainKey();
    } else {
        return ((VirtualQCPErrorBars*)self)->sortKeyIsMainKey();
    }
}

QCPDataSelection* QCPErrorBars_SelectTestRect(const QCPErrorBars* self, const QRectF* rect, bool onlySelectable) {
    auto* vqcperrorbars = dynamic_cast<const VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return new QCPDataSelection(self->selectTestRect(*rect, onlySelectable));
    } else {
        return new QCPDataSelection(((VirtualQCPErrorBars*)self)->selectTestRect(*rect, onlySelectable));
    }
}

int QCPErrorBars_FindBegin(const QCPErrorBars* self, double sortKey, bool expandedRange) {
    auto* vqcperrorbars = dynamic_cast<const VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return self->findBegin(static_cast<double>(sortKey), expandedRange);
    } else {
        return ((VirtualQCPErrorBars*)self)->findBegin(static_cast<double>(sortKey), expandedRange);
    }
}

int QCPErrorBars_FindEnd(const QCPErrorBars* self, double sortKey, bool expandedRange) {
    auto* vqcperrorbars = dynamic_cast<const VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return self->findEnd(static_cast<double>(sortKey), expandedRange);
    } else {
        return ((VirtualQCPErrorBars*)self)->findEnd(static_cast<double>(sortKey), expandedRange);
    }
}

double QCPErrorBars_SelectTest(const QCPErrorBars* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcperrorbars = dynamic_cast<const VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPErrorBars*)self)->selectTest(*pos, onlySelectable, details);
    }
}

QCPPlottableInterface1D* QCPErrorBars_Interface1D(QCPErrorBars* self) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return self->interface1D();
    } else {
        return ((VirtualQCPErrorBars*)self)->interface1D();
    }
}

void QCPErrorBars_Draw(QCPErrorBars* self, QCPPainter* painter) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->draw(painter);
    }
}

void QCPErrorBars_DrawLegendIcon(const QCPErrorBars* self, QCPPainter* painter, const QRectF* rect) {
    auto* vqcperrorbars = dynamic_cast<const VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->drawLegendIcon(painter, *rect);
    }
}

QCPRange* QCPErrorBars_GetKeyRange(const QCPErrorBars* self, bool* foundRange, int inSignDomain) {
    auto* vqcperrorbars = dynamic_cast<const VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return new QCPRange(vqcperrorbars->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    }
    return {};
}

QCPRange* QCPErrorBars_GetValueRange(const QCPErrorBars* self, bool* foundRange, int inSignDomain, const QCPRange* inKeyRange) {
    auto* vqcperrorbars = dynamic_cast<const VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return new QCPRange(vqcperrorbars->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    }
    return {};
}

libqt_string QCPErrorBars_Tr2(const char* s, const char* c) {
    QString _ret = QCPErrorBars::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPErrorBars_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPErrorBars::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPErrorBars_QBaseMetacall(QCPErrorBars* self, int param1, int param2, void** param3) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_Metacall_IsBase(true);
        return vqcperrorbars->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPErrorBars::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnMetacall(QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_Metacall_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
int QCPErrorBars_QBaseDataCount(const QCPErrorBars* self) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_DataCount_IsBase(true);
        return vqcperrorbars->dataCount();
    } else {
        return self->QCPErrorBars::dataCount();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnDataCount(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_DataCount_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_DataCount_Callback>(slot));
    }
}

// Base class handler implementation
double QCPErrorBars_QBaseDataMainKey(const QCPErrorBars* self, int index) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_DataMainKey_IsBase(true);
        return vqcperrorbars->dataMainKey(static_cast<int>(index));
    } else {
        return self->QCPErrorBars::dataMainKey(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnDataMainKey(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_DataMainKey_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_DataMainKey_Callback>(slot));
    }
}

// Base class handler implementation
double QCPErrorBars_QBaseDataSortKey(const QCPErrorBars* self, int index) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_DataSortKey_IsBase(true);
        return vqcperrorbars->dataSortKey(static_cast<int>(index));
    } else {
        return self->QCPErrorBars::dataSortKey(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnDataSortKey(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_DataSortKey_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_DataSortKey_Callback>(slot));
    }
}

// Base class handler implementation
double QCPErrorBars_QBaseDataMainValue(const QCPErrorBars* self, int index) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_DataMainValue_IsBase(true);
        return vqcperrorbars->dataMainValue(static_cast<int>(index));
    } else {
        return self->QCPErrorBars::dataMainValue(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnDataMainValue(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_DataMainValue_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_DataMainValue_Callback>(slot));
    }
}

// Base class handler implementation
QCPRange* QCPErrorBars_QBaseDataValueRange(const QCPErrorBars* self, int index) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_DataValueRange_IsBase(true);
        return new QCPRange(vqcperrorbars->dataValueRange(static_cast<int>(index)));
    } else {
        return new QCPRange(((VirtualQCPErrorBars*)self)->dataValueRange(static_cast<int>(index)));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnDataValueRange(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_DataValueRange_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_DataValueRange_Callback>(slot));
    }
}

// Base class handler implementation
QPointF* QCPErrorBars_QBaseDataPixelPosition(const QCPErrorBars* self, int index) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_DataPixelPosition_IsBase(true);
        return new QPointF(vqcperrorbars->dataPixelPosition(static_cast<int>(index)));
    } else {
        return new QPointF(((VirtualQCPErrorBars*)self)->dataPixelPosition(static_cast<int>(index)));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnDataPixelPosition(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_DataPixelPosition_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_DataPixelPosition_Callback>(slot));
    }
}

// Base class handler implementation
bool QCPErrorBars_QBaseSortKeyIsMainKey(const QCPErrorBars* self) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_SortKeyIsMainKey_IsBase(true);
        return vqcperrorbars->sortKeyIsMainKey();
    } else {
        return self->QCPErrorBars::sortKeyIsMainKey();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnSortKeyIsMainKey(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_SortKeyIsMainKey_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_SortKeyIsMainKey_Callback>(slot));
    }
}

// Base class handler implementation
QCPDataSelection* QCPErrorBars_QBaseSelectTestRect(const QCPErrorBars* self, const QRectF* rect, bool onlySelectable) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_SelectTestRect_IsBase(true);
        return new QCPDataSelection(vqcperrorbars->selectTestRect(*rect, onlySelectable));
    } else {
        return new QCPDataSelection(((VirtualQCPErrorBars*)self)->selectTestRect(*rect, onlySelectable));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnSelectTestRect(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_SelectTestRect_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_SelectTestRect_Callback>(slot));
    }
}

// Base class handler implementation
int QCPErrorBars_QBaseFindBegin(const QCPErrorBars* self, double sortKey, bool expandedRange) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_FindBegin_IsBase(true);
        return vqcperrorbars->findBegin(static_cast<double>(sortKey), expandedRange);
    } else {
        return self->QCPErrorBars::findBegin(static_cast<double>(sortKey), expandedRange);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnFindBegin(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_FindBegin_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_FindBegin_Callback>(slot));
    }
}

// Base class handler implementation
int QCPErrorBars_QBaseFindEnd(const QCPErrorBars* self, double sortKey, bool expandedRange) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_FindEnd_IsBase(true);
        return vqcperrorbars->findEnd(static_cast<double>(sortKey), expandedRange);
    } else {
        return self->QCPErrorBars::findEnd(static_cast<double>(sortKey), expandedRange);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnFindEnd(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_FindEnd_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_FindEnd_Callback>(slot));
    }
}

// Base class handler implementation
double QCPErrorBars_QBaseSelectTest(const QCPErrorBars* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_SelectTest_IsBase(true);
        return vqcperrorbars->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPErrorBars::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnSelectTest(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_SelectTest_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
QCPPlottableInterface1D* QCPErrorBars_QBaseInterface1D(QCPErrorBars* self) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_Interface1D_IsBase(true);
        return vqcperrorbars->interface1D();
    } else {
        return self->QCPErrorBars::interface1D();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnInterface1D(QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_Interface1D_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_Interface1D_Callback>(slot));
    }
}

// Base class handler implementation
void QCPErrorBars_QBaseDraw(QCPErrorBars* self, QCPPainter* painter) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_Draw_IsBase(true);
        vqcperrorbars->draw(painter);
    } else {
        ((VirtualQCPErrorBars*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnDraw(QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_Draw_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_Draw_Callback>(slot));
    }
}

// Base class handler implementation
void QCPErrorBars_QBaseDrawLegendIcon(const QCPErrorBars* self, QCPPainter* painter, const QRectF* rect) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_DrawLegendIcon_IsBase(true);
        vqcperrorbars->drawLegendIcon(painter, *rect);
    } else {
        ((VirtualQCPErrorBars*)self)->drawLegendIcon(painter, *rect);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnDrawLegendIcon(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_DrawLegendIcon_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_DrawLegendIcon_Callback>(slot));
    }
}

// Base class handler implementation
QCPRange* QCPErrorBars_QBaseGetKeyRange(const QCPErrorBars* self, bool* foundRange, int inSignDomain) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_GetKeyRange_IsBase(true);
        return new QCPRange(vqcperrorbars->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnGetKeyRange(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_GetKeyRange_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_GetKeyRange_Callback>(slot));
    }
}

// Base class handler implementation
QCPRange* QCPErrorBars_QBaseGetValueRange(const QCPErrorBars* self, bool* foundRange, int inSignDomain, const QCPRange* inKeyRange) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_GetValueRange_IsBase(true);
        return new QCPRange(vqcperrorbars->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnGetValueRange(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_GetValueRange_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_GetValueRange_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPErrorBars_ClipRect(const QCPErrorBars* self) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return new QRect(vqcperrorbars->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPErrorBars_QBaseClipRect(const QCPErrorBars* self) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_ClipRect_IsBase(true);
        return new QRect(vqcperrorbars->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnClipRect(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_ClipRect_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPErrorBars_SelectionCategory(const QCPErrorBars* self) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return static_cast<int>(vqcperrorbars->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPErrorBars*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPErrorBars_QBaseSelectionCategory(const QCPErrorBars* self) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcperrorbars->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPErrorBars*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnSelectionCategory(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_SelectionCategory_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPErrorBars_ApplyDefaultAntialiasingHint(const QCPErrorBars* self, QCPPainter* painter) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPErrorBars*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPErrorBars_QBaseApplyDefaultAntialiasingHint(const QCPErrorBars* self, QCPPainter* painter) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcperrorbars->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPErrorBars*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnApplyDefaultAntialiasingHint(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPErrorBars_SelectEvent(QCPErrorBars* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPErrorBars*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPErrorBars_QBaseSelectEvent(QCPErrorBars* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_SelectEvent_IsBase(true);
        vqcperrorbars->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPErrorBars*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnSelectEvent(QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_SelectEvent_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPErrorBars_DeselectEvent(QCPErrorBars* self, bool* selectionStateChanged) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPErrorBars*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPErrorBars_QBaseDeselectEvent(QCPErrorBars* self, bool* selectionStateChanged) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_DeselectEvent_IsBase(true);
        vqcperrorbars->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPErrorBars*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnDeselectEvent(QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_DeselectEvent_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPErrorBars_ParentPlotInitialized(QCPErrorBars* self, QCustomPlot* parentPlot) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPErrorBars*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPErrorBars_QBaseParentPlotInitialized(QCPErrorBars* self, QCustomPlot* parentPlot) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_ParentPlotInitialized_IsBase(true);
        vqcperrorbars->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPErrorBars*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnParentPlotInitialized(QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPErrorBars_MousePressEvent(QCPErrorBars* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPErrorBars*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPErrorBars_QBaseMousePressEvent(QCPErrorBars* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_MousePressEvent_IsBase(true);
        vqcperrorbars->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPErrorBars*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnMousePressEvent(QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_MousePressEvent_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPErrorBars_MouseMoveEvent(QCPErrorBars* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPErrorBars*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPErrorBars_QBaseMouseMoveEvent(QCPErrorBars* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_MouseMoveEvent_IsBase(true);
        vqcperrorbars->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPErrorBars*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnMouseMoveEvent(QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPErrorBars_MouseReleaseEvent(QCPErrorBars* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPErrorBars*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPErrorBars_QBaseMouseReleaseEvent(QCPErrorBars* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_MouseReleaseEvent_IsBase(true);
        vqcperrorbars->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPErrorBars*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnMouseReleaseEvent(QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPErrorBars_MouseDoubleClickEvent(QCPErrorBars* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPErrorBars*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPErrorBars_QBaseMouseDoubleClickEvent(QCPErrorBars* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_MouseDoubleClickEvent_IsBase(true);
        vqcperrorbars->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPErrorBars*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnMouseDoubleClickEvent(QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPErrorBars_WheelEvent(QCPErrorBars* self, QWheelEvent* event) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->wheelEvent(event);
    } else {
        ((VirtualQCPErrorBars*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPErrorBars_QBaseWheelEvent(QCPErrorBars* self, QWheelEvent* event) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_WheelEvent_IsBase(true);
        vqcperrorbars->wheelEvent(event);
    } else {
        ((VirtualQCPErrorBars*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnWheelEvent(QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_WheelEvent_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPErrorBars_Event(QCPErrorBars* self, QEvent* event) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return vqcperrorbars->event(event);
    } else {
        return self->QCPErrorBars::event(event);
    }
}

// Base class handler implementation
bool QCPErrorBars_QBaseEvent(QCPErrorBars* self, QEvent* event) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_Event_IsBase(true);
        return vqcperrorbars->event(event);
    } else {
        return self->QCPErrorBars::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnEvent(QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_Event_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPErrorBars_EventFilter(QCPErrorBars* self, QObject* watched, QEvent* event) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return vqcperrorbars->eventFilter(watched, event);
    } else {
        return self->QCPErrorBars::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPErrorBars_QBaseEventFilter(QCPErrorBars* self, QObject* watched, QEvent* event) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_EventFilter_IsBase(true);
        return vqcperrorbars->eventFilter(watched, event);
    } else {
        return self->QCPErrorBars::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnEventFilter(QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_EventFilter_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPErrorBars_TimerEvent(QCPErrorBars* self, QTimerEvent* event) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->timerEvent(event);
    } else {
        ((VirtualQCPErrorBars*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPErrorBars_QBaseTimerEvent(QCPErrorBars* self, QTimerEvent* event) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_TimerEvent_IsBase(true);
        vqcperrorbars->timerEvent(event);
    } else {
        ((VirtualQCPErrorBars*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnTimerEvent(QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_TimerEvent_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPErrorBars_ChildEvent(QCPErrorBars* self, QChildEvent* event) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->childEvent(event);
    } else {
        ((VirtualQCPErrorBars*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPErrorBars_QBaseChildEvent(QCPErrorBars* self, QChildEvent* event) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_ChildEvent_IsBase(true);
        vqcperrorbars->childEvent(event);
    } else {
        ((VirtualQCPErrorBars*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnChildEvent(QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_ChildEvent_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPErrorBars_CustomEvent(QCPErrorBars* self, QEvent* event) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->customEvent(event);
    } else {
        ((VirtualQCPErrorBars*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPErrorBars_QBaseCustomEvent(QCPErrorBars* self, QEvent* event) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_CustomEvent_IsBase(true);
        vqcperrorbars->customEvent(event);
    } else {
        ((VirtualQCPErrorBars*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnCustomEvent(QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_CustomEvent_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPErrorBars_ConnectNotify(QCPErrorBars* self, const QMetaMethod* signal) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->connectNotify(*signal);
    } else {
        ((VirtualQCPErrorBars*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPErrorBars_QBaseConnectNotify(QCPErrorBars* self, const QMetaMethod* signal) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_ConnectNotify_IsBase(true);
        vqcperrorbars->connectNotify(*signal);
    } else {
        ((VirtualQCPErrorBars*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnConnectNotify(QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_ConnectNotify_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPErrorBars_DisconnectNotify(QCPErrorBars* self, const QMetaMethod* signal) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->disconnectNotify(*signal);
    } else {
        ((VirtualQCPErrorBars*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPErrorBars_QBaseDisconnectNotify(QCPErrorBars* self, const QMetaMethod* signal) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_DisconnectNotify_IsBase(true);
        vqcperrorbars->disconnectNotify(*signal);
    } else {
        ((VirtualQCPErrorBars*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnDisconnectNotify(QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPErrorBars_GetDataSegments(const QCPErrorBars* self, libqt_list /* of QCPDataRange* */ selectedSegments, libqt_list /* of QCPDataRange* */ unselectedSegments) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    QList<QCPDataRange> selectedSegments_QList;
    selectedSegments_QList.reserve(selectedSegments.len);
    QCPDataRange** selectedSegments_arr = static_cast<QCPDataRange**>(selectedSegments.data);
    for (size_t i = 0; i < selectedSegments.len; ++i) {
        selectedSegments_QList.push_back(*(selectedSegments_arr[i]));
    }
    QList<QCPDataRange> unselectedSegments_QList;
    unselectedSegments_QList.reserve(unselectedSegments.len);
    QCPDataRange** unselectedSegments_arr = static_cast<QCPDataRange**>(unselectedSegments.data);
    for (size_t i = 0; i < unselectedSegments.len; ++i) {
        unselectedSegments_QList.push_back(*(unselectedSegments_arr[i]));
    }
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->getDataSegments(selectedSegments_QList, unselectedSegments_QList);
    } else {
        ((VirtualQCPErrorBars*)self)->getDataSegments(selectedSegments_QList, unselectedSegments_QList);
    }
}

// Base class handler implementation
void QCPErrorBars_QBaseGetDataSegments(const QCPErrorBars* self, libqt_list /* of QCPDataRange* */ selectedSegments, libqt_list /* of QCPDataRange* */ unselectedSegments) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    QList<QCPDataRange> selectedSegments_QList;
    selectedSegments_QList.reserve(selectedSegments.len);
    QCPDataRange** selectedSegments_arr = static_cast<QCPDataRange**>(selectedSegments.data);
    for (size_t i = 0; i < selectedSegments.len; ++i) {
        selectedSegments_QList.push_back(*(selectedSegments_arr[i]));
    }
    QList<QCPDataRange> unselectedSegments_QList;
    unselectedSegments_QList.reserve(unselectedSegments.len);
    QCPDataRange** unselectedSegments_arr = static_cast<QCPDataRange**>(unselectedSegments.data);
    for (size_t i = 0; i < unselectedSegments.len; ++i) {
        unselectedSegments_QList.push_back(*(unselectedSegments_arr[i]));
    }
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_GetDataSegments_IsBase(true);
        vqcperrorbars->getDataSegments(selectedSegments_QList, unselectedSegments_QList);
    } else {
        ((VirtualQCPErrorBars*)self)->getDataSegments(selectedSegments_QList, unselectedSegments_QList);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnGetDataSegments(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_GetDataSegments_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_GetDataSegments_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPErrorBars_ErrorBarVisible(const QCPErrorBars* self, int index) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return vqcperrorbars->errorBarVisible(static_cast<int>(index));
    } else {
        return ((VirtualQCPErrorBars*)self)->errorBarVisible(static_cast<int>(index));
    }
}

// Base class handler implementation
bool QCPErrorBars_QBaseErrorBarVisible(const QCPErrorBars* self, int index) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_ErrorBarVisible_IsBase(true);
        return vqcperrorbars->errorBarVisible(static_cast<int>(index));
    } else {
        return ((VirtualQCPErrorBars*)self)->errorBarVisible(static_cast<int>(index));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnErrorBarVisible(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_ErrorBarVisible_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_ErrorBarVisible_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPErrorBars_RectIntersectsLine(const QCPErrorBars* self, const QRectF* pixelRect, const QLineF* line) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return vqcperrorbars->rectIntersectsLine(*pixelRect, *line);
    } else {
        return ((VirtualQCPErrorBars*)self)->rectIntersectsLine(*pixelRect, *line);
    }
}

// Base class handler implementation
bool QCPErrorBars_QBaseRectIntersectsLine(const QCPErrorBars* self, const QRectF* pixelRect, const QLineF* line) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_RectIntersectsLine_IsBase(true);
        return vqcperrorbars->rectIntersectsLine(*pixelRect, *line);
    } else {
        return ((VirtualQCPErrorBars*)self)->rectIntersectsLine(*pixelRect, *line);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnRectIntersectsLine(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_RectIntersectsLine_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_RectIntersectsLine_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPErrorBars_ApplyFillAntialiasingHint(const QCPErrorBars* self, QCPPainter* painter) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->applyFillAntialiasingHint(painter);
    } else {
        ((VirtualQCPErrorBars*)self)->applyFillAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPErrorBars_QBaseApplyFillAntialiasingHint(const QCPErrorBars* self, QCPPainter* painter) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_ApplyFillAntialiasingHint_IsBase(true);
        vqcperrorbars->applyFillAntialiasingHint(painter);
    } else {
        ((VirtualQCPErrorBars*)self)->applyFillAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnApplyFillAntialiasingHint(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_ApplyFillAntialiasingHint_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_ApplyFillAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPErrorBars_ApplyScattersAntialiasingHint(const QCPErrorBars* self, QCPPainter* painter) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->applyScattersAntialiasingHint(painter);
    } else {
        ((VirtualQCPErrorBars*)self)->applyScattersAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPErrorBars_QBaseApplyScattersAntialiasingHint(const QCPErrorBars* self, QCPPainter* painter) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_ApplyScattersAntialiasingHint_IsBase(true);
        vqcperrorbars->applyScattersAntialiasingHint(painter);
    } else {
        ((VirtualQCPErrorBars*)self)->applyScattersAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnApplyScattersAntialiasingHint(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_ApplyScattersAntialiasingHint_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_ApplyScattersAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPErrorBars_InitializeParentPlot(QCPErrorBars* self, QCustomPlot* parentPlot) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPErrorBars*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPErrorBars_QBaseInitializeParentPlot(QCPErrorBars* self, QCustomPlot* parentPlot) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_InitializeParentPlot_IsBase(true);
        vqcperrorbars->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPErrorBars*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnInitializeParentPlot(QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPErrorBars_SetParentLayerable(QCPErrorBars* self, QCPLayerable* parentLayerable) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPErrorBars*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPErrorBars_QBaseSetParentLayerable(QCPErrorBars* self, QCPLayerable* parentLayerable) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_SetParentLayerable_IsBase(true);
        vqcperrorbars->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPErrorBars*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnSetParentLayerable(QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPErrorBars_MoveToLayer(QCPErrorBars* self, QCPLayer* layer, bool prepend) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return vqcperrorbars->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPErrorBars*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPErrorBars_QBaseMoveToLayer(QCPErrorBars* self, QCPLayer* layer, bool prepend) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_MoveToLayer_IsBase(true);
        return vqcperrorbars->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPErrorBars*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnMoveToLayer(QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = dynamic_cast<VirtualQCPErrorBars*>(self);
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_MoveToLayer_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPErrorBars_ApplyAntialiasingHint(const QCPErrorBars* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPErrorBars*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPErrorBars_QBaseApplyAntialiasingHint(const QCPErrorBars* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_ApplyAntialiasingHint_IsBase(true);
        vqcperrorbars->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPErrorBars*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnApplyAntialiasingHint(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPErrorBars_Sender(const QCPErrorBars* self) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return vqcperrorbars->sender();
    } else {
        return ((VirtualQCPErrorBars*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPErrorBars_QBaseSender(const QCPErrorBars* self) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_Sender_IsBase(true);
        return vqcperrorbars->sender();
    } else {
        return ((VirtualQCPErrorBars*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnSender(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_Sender_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPErrorBars_SenderSignalIndex(const QCPErrorBars* self) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return vqcperrorbars->senderSignalIndex();
    } else {
        return ((VirtualQCPErrorBars*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPErrorBars_QBaseSenderSignalIndex(const QCPErrorBars* self) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_SenderSignalIndex_IsBase(true);
        return vqcperrorbars->senderSignalIndex();
    } else {
        return ((VirtualQCPErrorBars*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnSenderSignalIndex(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPErrorBars_Receivers(const QCPErrorBars* self, const char* signal) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return vqcperrorbars->receivers(signal);
    } else {
        return ((VirtualQCPErrorBars*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPErrorBars_QBaseReceivers(const QCPErrorBars* self, const char* signal) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_Receivers_IsBase(true);
        return vqcperrorbars->receivers(signal);
    } else {
        return ((VirtualQCPErrorBars*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnReceivers(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_Receivers_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPErrorBars_IsSignalConnected(const QCPErrorBars* self, const QMetaMethod* signal) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        return vqcperrorbars->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPErrorBars*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPErrorBars_QBaseIsSignalConnected(const QCPErrorBars* self, const QMetaMethod* signal) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_IsSignalConnected_IsBase(true);
        return vqcperrorbars->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPErrorBars*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPErrorBars_OnIsSignalConnected(const QCPErrorBars* self, intptr_t slot) {
    auto* vqcperrorbars = const_cast<VirtualQCPErrorBars*>(dynamic_cast<const VirtualQCPErrorBars*>(self));
    if (vqcperrorbars && vqcperrorbars->isVirtualQCPErrorBars) {
        vqcperrorbars->setQCPErrorBars_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPErrorBars::QCPErrorBars_IsSignalConnected_Callback>(slot));
    }
}

void QCPErrorBars_Delete(QCPErrorBars* self) {
    delete self;
}

QCPItemStraightLine* QCPItemStraightLine_new(QCustomPlot* parentPlot) {
    return new VirtualQCPItemStraightLine(parentPlot);
}

QMetaObject* QCPItemStraightLine_MetaObject(const QCPItemStraightLine* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPItemStraightLine_Metacast(QCPItemStraightLine* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPItemStraightLine_Metacall(QCPItemStraightLine* self, int param1, int param2, void** param3) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPItemStraightLine*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPItemStraightLine_Tr(const char* s) {
    QString _ret = QCPItemStraightLine::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

QPen* QCPItemStraightLine_Pen(const QCPItemStraightLine* self) {
    return new QPen(self->pen());
}

QPen* QCPItemStraightLine_SelectedPen(const QCPItemStraightLine* self) {
    return new QPen(self->selectedPen());
}

void QCPItemStraightLine_SetPen(QCPItemStraightLine* self, const QPen* pen) {
    self->setPen(*pen);
}

void QCPItemStraightLine_SetSelectedPen(QCPItemStraightLine* self, const QPen* pen) {
    self->setSelectedPen(*pen);
}

double QCPItemStraightLine_SelectTest(const QCPItemStraightLine* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpitemstraightline = dynamic_cast<const VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPItemStraightLine*)self)->selectTest(*pos, onlySelectable, details);
    }
}

QCPItemPosition* QCPItemStraightLine_Point1(const QCPItemStraightLine* self) {
    return (QCPItemPosition*)self->point1;
}

QCPItemPosition* QCPItemStraightLine_Point2(const QCPItemStraightLine* self) {
    return (QCPItemPosition*)self->point2;
}

void QCPItemStraightLine_Draw(QCPItemStraightLine* self, QCPPainter* painter) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->draw(painter);
    }
}

libqt_string QCPItemStraightLine_Tr2(const char* s, const char* c) {
    QString _ret = QCPItemStraightLine::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPItemStraightLine_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPItemStraightLine::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPItemStraightLine_QBaseMetacall(QCPItemStraightLine* self, int param1, int param2, void** param3) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_Metacall_IsBase(true);
        return vqcpitemstraightline->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPItemStraightLine::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnMetacall(QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_Metacall_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
double QCPItemStraightLine_QBaseSelectTest(const QCPItemStraightLine* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_SelectTest_IsBase(true);
        return vqcpitemstraightline->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPItemStraightLine::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnSelectTest(const QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_SelectTest_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
void QCPItemStraightLine_QBaseDraw(QCPItemStraightLine* self, QCPPainter* painter) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_Draw_IsBase(true);
        vqcpitemstraightline->draw(painter);
    } else {
        ((VirtualQCPItemStraightLine*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnDraw(QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_Draw_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_Draw_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemStraightLine_SelectionCategory(const QCPItemStraightLine* self) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        return static_cast<int>(vqcpitemstraightline->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPItemStraightLine*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPItemStraightLine_QBaseSelectionCategory(const QCPItemStraightLine* self) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcpitemstraightline->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPItemStraightLine*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnSelectionCategory(const QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_SelectionCategory_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPItemStraightLine_ClipRect(const QCPItemStraightLine* self) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        return new QRect(vqcpitemstraightline->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPItemStraightLine_QBaseClipRect(const QCPItemStraightLine* self) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_ClipRect_IsBase(true);
        return new QRect(vqcpitemstraightline->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnClipRect(const QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_ClipRect_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemStraightLine_ApplyDefaultAntialiasingHint(const QCPItemStraightLine* self, QCPPainter* painter) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPItemStraightLine*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPItemStraightLine_QBaseApplyDefaultAntialiasingHint(const QCPItemStraightLine* self, QCPPainter* painter) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcpitemstraightline->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPItemStraightLine*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnApplyDefaultAntialiasingHint(const QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemStraightLine_SelectEvent(QCPItemStraightLine* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPItemStraightLine*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPItemStraightLine_QBaseSelectEvent(QCPItemStraightLine* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_SelectEvent_IsBase(true);
        vqcpitemstraightline->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPItemStraightLine*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnSelectEvent(QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_SelectEvent_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemStraightLine_DeselectEvent(QCPItemStraightLine* self, bool* selectionStateChanged) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPItemStraightLine*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPItemStraightLine_QBaseDeselectEvent(QCPItemStraightLine* self, bool* selectionStateChanged) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_DeselectEvent_IsBase(true);
        vqcpitemstraightline->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPItemStraightLine*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnDeselectEvent(QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_DeselectEvent_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
QPointF* QCPItemStraightLine_AnchorPixelPosition(const QCPItemStraightLine* self, int anchorId) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        return new QPointF(vqcpitemstraightline->anchorPixelPosition(static_cast<int>(anchorId)));
    }
    return {};
}

// Base class handler implementation
QPointF* QCPItemStraightLine_QBaseAnchorPixelPosition(const QCPItemStraightLine* self, int anchorId) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_AnchorPixelPosition_IsBase(true);
        return new QPointF(vqcpitemstraightline->anchorPixelPosition(static_cast<int>(anchorId)));
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnAnchorPixelPosition(const QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_AnchorPixelPosition_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_AnchorPixelPosition_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemStraightLine_ParentPlotInitialized(QCPItemStraightLine* self, QCustomPlot* parentPlot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPItemStraightLine*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPItemStraightLine_QBaseParentPlotInitialized(QCPItemStraightLine* self, QCustomPlot* parentPlot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_ParentPlotInitialized_IsBase(true);
        vqcpitemstraightline->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPItemStraightLine*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnParentPlotInitialized(QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemStraightLine_MousePressEvent(QCPItemStraightLine* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPItemStraightLine*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPItemStraightLine_QBaseMousePressEvent(QCPItemStraightLine* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_MousePressEvent_IsBase(true);
        vqcpitemstraightline->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPItemStraightLine*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnMousePressEvent(QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_MousePressEvent_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemStraightLine_MouseMoveEvent(QCPItemStraightLine* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPItemStraightLine*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPItemStraightLine_QBaseMouseMoveEvent(QCPItemStraightLine* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_MouseMoveEvent_IsBase(true);
        vqcpitemstraightline->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPItemStraightLine*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnMouseMoveEvent(QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemStraightLine_MouseReleaseEvent(QCPItemStraightLine* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPItemStraightLine*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPItemStraightLine_QBaseMouseReleaseEvent(QCPItemStraightLine* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_MouseReleaseEvent_IsBase(true);
        vqcpitemstraightline->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPItemStraightLine*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnMouseReleaseEvent(QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemStraightLine_MouseDoubleClickEvent(QCPItemStraightLine* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPItemStraightLine*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPItemStraightLine_QBaseMouseDoubleClickEvent(QCPItemStraightLine* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_MouseDoubleClickEvent_IsBase(true);
        vqcpitemstraightline->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPItemStraightLine*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnMouseDoubleClickEvent(QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemStraightLine_WheelEvent(QCPItemStraightLine* self, QWheelEvent* event) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->wheelEvent(event);
    } else {
        ((VirtualQCPItemStraightLine*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPItemStraightLine_QBaseWheelEvent(QCPItemStraightLine* self, QWheelEvent* event) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_WheelEvent_IsBase(true);
        vqcpitemstraightline->wheelEvent(event);
    } else {
        ((VirtualQCPItemStraightLine*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnWheelEvent(QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_WheelEvent_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemStraightLine_Event(QCPItemStraightLine* self, QEvent* event) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        return vqcpitemstraightline->event(event);
    } else {
        return self->QCPItemStraightLine::event(event);
    }
}

// Base class handler implementation
bool QCPItemStraightLine_QBaseEvent(QCPItemStraightLine* self, QEvent* event) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_Event_IsBase(true);
        return vqcpitemstraightline->event(event);
    } else {
        return self->QCPItemStraightLine::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnEvent(QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_Event_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemStraightLine_EventFilter(QCPItemStraightLine* self, QObject* watched, QEvent* event) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        return vqcpitemstraightline->eventFilter(watched, event);
    } else {
        return self->QCPItemStraightLine::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPItemStraightLine_QBaseEventFilter(QCPItemStraightLine* self, QObject* watched, QEvent* event) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_EventFilter_IsBase(true);
        return vqcpitemstraightline->eventFilter(watched, event);
    } else {
        return self->QCPItemStraightLine::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnEventFilter(QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_EventFilter_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemStraightLine_TimerEvent(QCPItemStraightLine* self, QTimerEvent* event) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->timerEvent(event);
    } else {
        ((VirtualQCPItemStraightLine*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPItemStraightLine_QBaseTimerEvent(QCPItemStraightLine* self, QTimerEvent* event) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_TimerEvent_IsBase(true);
        vqcpitemstraightline->timerEvent(event);
    } else {
        ((VirtualQCPItemStraightLine*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnTimerEvent(QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_TimerEvent_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemStraightLine_ChildEvent(QCPItemStraightLine* self, QChildEvent* event) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->childEvent(event);
    } else {
        ((VirtualQCPItemStraightLine*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPItemStraightLine_QBaseChildEvent(QCPItemStraightLine* self, QChildEvent* event) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_ChildEvent_IsBase(true);
        vqcpitemstraightline->childEvent(event);
    } else {
        ((VirtualQCPItemStraightLine*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnChildEvent(QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_ChildEvent_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemStraightLine_CustomEvent(QCPItemStraightLine* self, QEvent* event) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->customEvent(event);
    } else {
        ((VirtualQCPItemStraightLine*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPItemStraightLine_QBaseCustomEvent(QCPItemStraightLine* self, QEvent* event) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_CustomEvent_IsBase(true);
        vqcpitemstraightline->customEvent(event);
    } else {
        ((VirtualQCPItemStraightLine*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnCustomEvent(QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_CustomEvent_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemStraightLine_ConnectNotify(QCPItemStraightLine* self, const QMetaMethod* signal) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->connectNotify(*signal);
    } else {
        ((VirtualQCPItemStraightLine*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPItemStraightLine_QBaseConnectNotify(QCPItemStraightLine* self, const QMetaMethod* signal) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_ConnectNotify_IsBase(true);
        vqcpitemstraightline->connectNotify(*signal);
    } else {
        ((VirtualQCPItemStraightLine*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnConnectNotify(QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_ConnectNotify_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemStraightLine_DisconnectNotify(QCPItemStraightLine* self, const QMetaMethod* signal) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->disconnectNotify(*signal);
    } else {
        ((VirtualQCPItemStraightLine*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPItemStraightLine_QBaseDisconnectNotify(QCPItemStraightLine* self, const QMetaMethod* signal) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_DisconnectNotify_IsBase(true);
        vqcpitemstraightline->disconnectNotify(*signal);
    } else {
        ((VirtualQCPItemStraightLine*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnDisconnectNotify(QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
QLineF* QCPItemStraightLine_GetRectClippedStraightLine(const QCPItemStraightLine* self, const QCPVector2D* base, const QCPVector2D* vec, const QRect* rect) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        return new QLineF(vqcpitemstraightline->getRectClippedStraightLine(*base, *vec, *rect));
    }
    return {};
}

// Base class handler implementation
QLineF* QCPItemStraightLine_QBaseGetRectClippedStraightLine(const QCPItemStraightLine* self, const QCPVector2D* base, const QCPVector2D* vec, const QRect* rect) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_GetRectClippedStraightLine_IsBase(true);
        return new QLineF(vqcpitemstraightline->getRectClippedStraightLine(*base, *vec, *rect));
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnGetRectClippedStraightLine(const QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_GetRectClippedStraightLine_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_GetRectClippedStraightLine_Callback>(slot));
    }
}

// Derived class handler implementation
QPen* QCPItemStraightLine_MainPen(const QCPItemStraightLine* self) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        return new QPen(vqcpitemstraightline->mainPen());
    }
    return {};
}

// Base class handler implementation
QPen* QCPItemStraightLine_QBaseMainPen(const QCPItemStraightLine* self) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_MainPen_IsBase(true);
        return new QPen(vqcpitemstraightline->mainPen());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnMainPen(const QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_MainPen_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_MainPen_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPItemStraightLine_RectDistance(const QCPItemStraightLine* self, const QRectF* rect, const QPointF* pos, bool filledRect) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        return vqcpitemstraightline->rectDistance(*rect, *pos, filledRect);
    } else {
        return ((VirtualQCPItemStraightLine*)self)->rectDistance(*rect, *pos, filledRect);
    }
}

// Base class handler implementation
double QCPItemStraightLine_QBaseRectDistance(const QCPItemStraightLine* self, const QRectF* rect, const QPointF* pos, bool filledRect) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_RectDistance_IsBase(true);
        return vqcpitemstraightline->rectDistance(*rect, *pos, filledRect);
    } else {
        return ((VirtualQCPItemStraightLine*)self)->rectDistance(*rect, *pos, filledRect);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnRectDistance(const QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_RectDistance_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_RectDistance_Callback>(slot));
    }
}

// Derived class handler implementation
QCPItemPosition* QCPItemStraightLine_CreatePosition(QCPItemStraightLine* self, const libqt_string name) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        return vqcpitemstraightline->createPosition(name_QString);
    } else {
        return ((VirtualQCPItemStraightLine*)self)->createPosition(name_QString);
    }
}

// Base class handler implementation
QCPItemPosition* QCPItemStraightLine_QBaseCreatePosition(QCPItemStraightLine* self, const libqt_string name) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_CreatePosition_IsBase(true);
        return vqcpitemstraightline->createPosition(name_QString);
    } else {
        return ((VirtualQCPItemStraightLine*)self)->createPosition(name_QString);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnCreatePosition(QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_CreatePosition_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_CreatePosition_Callback>(slot));
    }
}

// Derived class handler implementation
QCPItemAnchor* QCPItemStraightLine_CreateAnchor(QCPItemStraightLine* self, const libqt_string name, int anchorId) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        return vqcpitemstraightline->createAnchor(name_QString, static_cast<int>(anchorId));
    } else {
        return ((VirtualQCPItemStraightLine*)self)->createAnchor(name_QString, static_cast<int>(anchorId));
    }
}

// Base class handler implementation
QCPItemAnchor* QCPItemStraightLine_QBaseCreateAnchor(QCPItemStraightLine* self, const libqt_string name, int anchorId) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_CreateAnchor_IsBase(true);
        return vqcpitemstraightline->createAnchor(name_QString, static_cast<int>(anchorId));
    } else {
        return ((VirtualQCPItemStraightLine*)self)->createAnchor(name_QString, static_cast<int>(anchorId));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnCreateAnchor(QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_CreateAnchor_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_CreateAnchor_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemStraightLine_InitializeParentPlot(QCPItemStraightLine* self, QCustomPlot* parentPlot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPItemStraightLine*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPItemStraightLine_QBaseInitializeParentPlot(QCPItemStraightLine* self, QCustomPlot* parentPlot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_InitializeParentPlot_IsBase(true);
        vqcpitemstraightline->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPItemStraightLine*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnInitializeParentPlot(QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemStraightLine_SetParentLayerable(QCPItemStraightLine* self, QCPLayerable* parentLayerable) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPItemStraightLine*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPItemStraightLine_QBaseSetParentLayerable(QCPItemStraightLine* self, QCPLayerable* parentLayerable) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_SetParentLayerable_IsBase(true);
        vqcpitemstraightline->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPItemStraightLine*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnSetParentLayerable(QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemStraightLine_MoveToLayer(QCPItemStraightLine* self, QCPLayer* layer, bool prepend) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        return vqcpitemstraightline->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPItemStraightLine*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPItemStraightLine_QBaseMoveToLayer(QCPItemStraightLine* self, QCPLayer* layer, bool prepend) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_MoveToLayer_IsBase(true);
        return vqcpitemstraightline->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPItemStraightLine*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnMoveToLayer(QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = dynamic_cast<VirtualQCPItemStraightLine*>(self);
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_MoveToLayer_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemStraightLine_ApplyAntialiasingHint(const QCPItemStraightLine* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPItemStraightLine*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPItemStraightLine_QBaseApplyAntialiasingHint(const QCPItemStraightLine* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_ApplyAntialiasingHint_IsBase(true);
        vqcpitemstraightline->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPItemStraightLine*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnApplyAntialiasingHint(const QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPItemStraightLine_Sender(const QCPItemStraightLine* self) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        return vqcpitemstraightline->sender();
    } else {
        return ((VirtualQCPItemStraightLine*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPItemStraightLine_QBaseSender(const QCPItemStraightLine* self) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_Sender_IsBase(true);
        return vqcpitemstraightline->sender();
    } else {
        return ((VirtualQCPItemStraightLine*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnSender(const QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_Sender_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemStraightLine_SenderSignalIndex(const QCPItemStraightLine* self) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        return vqcpitemstraightline->senderSignalIndex();
    } else {
        return ((VirtualQCPItemStraightLine*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPItemStraightLine_QBaseSenderSignalIndex(const QCPItemStraightLine* self) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_SenderSignalIndex_IsBase(true);
        return vqcpitemstraightline->senderSignalIndex();
    } else {
        return ((VirtualQCPItemStraightLine*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnSenderSignalIndex(const QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemStraightLine_Receivers(const QCPItemStraightLine* self, const char* signal) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        return vqcpitemstraightline->receivers(signal);
    } else {
        return ((VirtualQCPItemStraightLine*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPItemStraightLine_QBaseReceivers(const QCPItemStraightLine* self, const char* signal) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_Receivers_IsBase(true);
        return vqcpitemstraightline->receivers(signal);
    } else {
        return ((VirtualQCPItemStraightLine*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnReceivers(const QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_Receivers_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemStraightLine_IsSignalConnected(const QCPItemStraightLine* self, const QMetaMethod* signal) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        return vqcpitemstraightline->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPItemStraightLine*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPItemStraightLine_QBaseIsSignalConnected(const QCPItemStraightLine* self, const QMetaMethod* signal) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_IsSignalConnected_IsBase(true);
        return vqcpitemstraightline->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPItemStraightLine*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemStraightLine_OnIsSignalConnected(const QCPItemStraightLine* self, intptr_t slot) {
    auto* vqcpitemstraightline = const_cast<VirtualQCPItemStraightLine*>(dynamic_cast<const VirtualQCPItemStraightLine*>(self));
    if (vqcpitemstraightline && vqcpitemstraightline->isVirtualQCPItemStraightLine) {
        vqcpitemstraightline->setQCPItemStraightLine_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPItemStraightLine::QCPItemStraightLine_IsSignalConnected_Callback>(slot));
    }
}

void QCPItemStraightLine_Delete(QCPItemStraightLine* self) {
    delete self;
}

QCPItemLine* QCPItemLine_new(QCustomPlot* parentPlot) {
    return new VirtualQCPItemLine(parentPlot);
}

QMetaObject* QCPItemLine_MetaObject(const QCPItemLine* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPItemLine_Metacast(QCPItemLine* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPItemLine_Metacall(QCPItemLine* self, int param1, int param2, void** param3) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPItemLine*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPItemLine_Tr(const char* s) {
    QString _ret = QCPItemLine::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

QPen* QCPItemLine_Pen(const QCPItemLine* self) {
    return new QPen(self->pen());
}

QPen* QCPItemLine_SelectedPen(const QCPItemLine* self) {
    return new QPen(self->selectedPen());
}

QCPLineEnding* QCPItemLine_Head(const QCPItemLine* self) {
    return new QCPLineEnding(self->head());
}

QCPLineEnding* QCPItemLine_Tail(const QCPItemLine* self) {
    return new QCPLineEnding(self->tail());
}

void QCPItemLine_SetPen(QCPItemLine* self, const QPen* pen) {
    self->setPen(*pen);
}

void QCPItemLine_SetSelectedPen(QCPItemLine* self, const QPen* pen) {
    self->setSelectedPen(*pen);
}

void QCPItemLine_SetHead(QCPItemLine* self, const QCPLineEnding* head) {
    self->setHead(*head);
}

void QCPItemLine_SetTail(QCPItemLine* self, const QCPLineEnding* tail) {
    self->setTail(*tail);
}

double QCPItemLine_SelectTest(const QCPItemLine* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpitemline = dynamic_cast<const VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPItemLine*)self)->selectTest(*pos, onlySelectable, details);
    }
}

QCPItemPosition* QCPItemLine_Start(const QCPItemLine* self) {
    return (QCPItemPosition*)self->start;
}

QCPItemPosition* QCPItemLine_End(const QCPItemLine* self) {
    return (QCPItemPosition*)self->end;
}

void QCPItemLine_Draw(QCPItemLine* self, QCPPainter* painter) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->draw(painter);
    }
}

libqt_string QCPItemLine_Tr2(const char* s, const char* c) {
    QString _ret = QCPItemLine::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPItemLine_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPItemLine::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPItemLine_QBaseMetacall(QCPItemLine* self, int param1, int param2, void** param3) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_Metacall_IsBase(true);
        return vqcpitemline->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPItemLine::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnMetacall(QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_Metacall_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
double QCPItemLine_QBaseSelectTest(const QCPItemLine* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_SelectTest_IsBase(true);
        return vqcpitemline->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPItemLine::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnSelectTest(const QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_SelectTest_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
void QCPItemLine_QBaseDraw(QCPItemLine* self, QCPPainter* painter) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_Draw_IsBase(true);
        vqcpitemline->draw(painter);
    } else {
        ((VirtualQCPItemLine*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnDraw(QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_Draw_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_Draw_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemLine_SelectionCategory(const QCPItemLine* self) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        return static_cast<int>(vqcpitemline->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPItemLine*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPItemLine_QBaseSelectionCategory(const QCPItemLine* self) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcpitemline->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPItemLine*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnSelectionCategory(const QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_SelectionCategory_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPItemLine_ClipRect(const QCPItemLine* self) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        return new QRect(vqcpitemline->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPItemLine_QBaseClipRect(const QCPItemLine* self) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_ClipRect_IsBase(true);
        return new QRect(vqcpitemline->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnClipRect(const QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_ClipRect_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemLine_ApplyDefaultAntialiasingHint(const QCPItemLine* self, QCPPainter* painter) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPItemLine*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPItemLine_QBaseApplyDefaultAntialiasingHint(const QCPItemLine* self, QCPPainter* painter) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcpitemline->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPItemLine*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnApplyDefaultAntialiasingHint(const QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemLine_SelectEvent(QCPItemLine* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPItemLine*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPItemLine_QBaseSelectEvent(QCPItemLine* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_SelectEvent_IsBase(true);
        vqcpitemline->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPItemLine*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnSelectEvent(QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_SelectEvent_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemLine_DeselectEvent(QCPItemLine* self, bool* selectionStateChanged) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPItemLine*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPItemLine_QBaseDeselectEvent(QCPItemLine* self, bool* selectionStateChanged) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_DeselectEvent_IsBase(true);
        vqcpitemline->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPItemLine*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnDeselectEvent(QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_DeselectEvent_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
QPointF* QCPItemLine_AnchorPixelPosition(const QCPItemLine* self, int anchorId) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        return new QPointF(vqcpitemline->anchorPixelPosition(static_cast<int>(anchorId)));
    }
    return {};
}

// Base class handler implementation
QPointF* QCPItemLine_QBaseAnchorPixelPosition(const QCPItemLine* self, int anchorId) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_AnchorPixelPosition_IsBase(true);
        return new QPointF(vqcpitemline->anchorPixelPosition(static_cast<int>(anchorId)));
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnAnchorPixelPosition(const QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_AnchorPixelPosition_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_AnchorPixelPosition_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemLine_ParentPlotInitialized(QCPItemLine* self, QCustomPlot* parentPlot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPItemLine*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPItemLine_QBaseParentPlotInitialized(QCPItemLine* self, QCustomPlot* parentPlot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_ParentPlotInitialized_IsBase(true);
        vqcpitemline->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPItemLine*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnParentPlotInitialized(QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemLine_MousePressEvent(QCPItemLine* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPItemLine*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPItemLine_QBaseMousePressEvent(QCPItemLine* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_MousePressEvent_IsBase(true);
        vqcpitemline->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPItemLine*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnMousePressEvent(QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_MousePressEvent_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemLine_MouseMoveEvent(QCPItemLine* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPItemLine*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPItemLine_QBaseMouseMoveEvent(QCPItemLine* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_MouseMoveEvent_IsBase(true);
        vqcpitemline->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPItemLine*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnMouseMoveEvent(QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemLine_MouseReleaseEvent(QCPItemLine* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPItemLine*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPItemLine_QBaseMouseReleaseEvent(QCPItemLine* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_MouseReleaseEvent_IsBase(true);
        vqcpitemline->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPItemLine*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnMouseReleaseEvent(QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemLine_MouseDoubleClickEvent(QCPItemLine* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPItemLine*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPItemLine_QBaseMouseDoubleClickEvent(QCPItemLine* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_MouseDoubleClickEvent_IsBase(true);
        vqcpitemline->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPItemLine*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnMouseDoubleClickEvent(QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemLine_WheelEvent(QCPItemLine* self, QWheelEvent* event) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->wheelEvent(event);
    } else {
        ((VirtualQCPItemLine*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPItemLine_QBaseWheelEvent(QCPItemLine* self, QWheelEvent* event) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_WheelEvent_IsBase(true);
        vqcpitemline->wheelEvent(event);
    } else {
        ((VirtualQCPItemLine*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnWheelEvent(QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_WheelEvent_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemLine_Event(QCPItemLine* self, QEvent* event) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        return vqcpitemline->event(event);
    } else {
        return self->QCPItemLine::event(event);
    }
}

// Base class handler implementation
bool QCPItemLine_QBaseEvent(QCPItemLine* self, QEvent* event) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_Event_IsBase(true);
        return vqcpitemline->event(event);
    } else {
        return self->QCPItemLine::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnEvent(QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_Event_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemLine_EventFilter(QCPItemLine* self, QObject* watched, QEvent* event) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        return vqcpitemline->eventFilter(watched, event);
    } else {
        return self->QCPItemLine::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPItemLine_QBaseEventFilter(QCPItemLine* self, QObject* watched, QEvent* event) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_EventFilter_IsBase(true);
        return vqcpitemline->eventFilter(watched, event);
    } else {
        return self->QCPItemLine::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnEventFilter(QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_EventFilter_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemLine_TimerEvent(QCPItemLine* self, QTimerEvent* event) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->timerEvent(event);
    } else {
        ((VirtualQCPItemLine*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPItemLine_QBaseTimerEvent(QCPItemLine* self, QTimerEvent* event) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_TimerEvent_IsBase(true);
        vqcpitemline->timerEvent(event);
    } else {
        ((VirtualQCPItemLine*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnTimerEvent(QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_TimerEvent_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemLine_ChildEvent(QCPItemLine* self, QChildEvent* event) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->childEvent(event);
    } else {
        ((VirtualQCPItemLine*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPItemLine_QBaseChildEvent(QCPItemLine* self, QChildEvent* event) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_ChildEvent_IsBase(true);
        vqcpitemline->childEvent(event);
    } else {
        ((VirtualQCPItemLine*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnChildEvent(QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_ChildEvent_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemLine_CustomEvent(QCPItemLine* self, QEvent* event) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->customEvent(event);
    } else {
        ((VirtualQCPItemLine*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPItemLine_QBaseCustomEvent(QCPItemLine* self, QEvent* event) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_CustomEvent_IsBase(true);
        vqcpitemline->customEvent(event);
    } else {
        ((VirtualQCPItemLine*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnCustomEvent(QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_CustomEvent_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemLine_ConnectNotify(QCPItemLine* self, const QMetaMethod* signal) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->connectNotify(*signal);
    } else {
        ((VirtualQCPItemLine*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPItemLine_QBaseConnectNotify(QCPItemLine* self, const QMetaMethod* signal) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_ConnectNotify_IsBase(true);
        vqcpitemline->connectNotify(*signal);
    } else {
        ((VirtualQCPItemLine*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnConnectNotify(QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_ConnectNotify_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemLine_DisconnectNotify(QCPItemLine* self, const QMetaMethod* signal) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->disconnectNotify(*signal);
    } else {
        ((VirtualQCPItemLine*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPItemLine_QBaseDisconnectNotify(QCPItemLine* self, const QMetaMethod* signal) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_DisconnectNotify_IsBase(true);
        vqcpitemline->disconnectNotify(*signal);
    } else {
        ((VirtualQCPItemLine*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnDisconnectNotify(QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
QLineF* QCPItemLine_GetRectClippedLine(const QCPItemLine* self, const QCPVector2D* start, const QCPVector2D* end, const QRect* rect) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        return new QLineF(vqcpitemline->getRectClippedLine(*start, *end, *rect));
    }
    return {};
}

// Base class handler implementation
QLineF* QCPItemLine_QBaseGetRectClippedLine(const QCPItemLine* self, const QCPVector2D* start, const QCPVector2D* end, const QRect* rect) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_GetRectClippedLine_IsBase(true);
        return new QLineF(vqcpitemline->getRectClippedLine(*start, *end, *rect));
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnGetRectClippedLine(const QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_GetRectClippedLine_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_GetRectClippedLine_Callback>(slot));
    }
}

// Derived class handler implementation
QPen* QCPItemLine_MainPen(const QCPItemLine* self) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        return new QPen(vqcpitemline->mainPen());
    }
    return {};
}

// Base class handler implementation
QPen* QCPItemLine_QBaseMainPen(const QCPItemLine* self) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_MainPen_IsBase(true);
        return new QPen(vqcpitemline->mainPen());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnMainPen(const QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_MainPen_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_MainPen_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPItemLine_RectDistance(const QCPItemLine* self, const QRectF* rect, const QPointF* pos, bool filledRect) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        return vqcpitemline->rectDistance(*rect, *pos, filledRect);
    } else {
        return ((VirtualQCPItemLine*)self)->rectDistance(*rect, *pos, filledRect);
    }
}

// Base class handler implementation
double QCPItemLine_QBaseRectDistance(const QCPItemLine* self, const QRectF* rect, const QPointF* pos, bool filledRect) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_RectDistance_IsBase(true);
        return vqcpitemline->rectDistance(*rect, *pos, filledRect);
    } else {
        return ((VirtualQCPItemLine*)self)->rectDistance(*rect, *pos, filledRect);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnRectDistance(const QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_RectDistance_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_RectDistance_Callback>(slot));
    }
}

// Derived class handler implementation
QCPItemPosition* QCPItemLine_CreatePosition(QCPItemLine* self, const libqt_string name) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        return vqcpitemline->createPosition(name_QString);
    } else {
        return ((VirtualQCPItemLine*)self)->createPosition(name_QString);
    }
}

// Base class handler implementation
QCPItemPosition* QCPItemLine_QBaseCreatePosition(QCPItemLine* self, const libqt_string name) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_CreatePosition_IsBase(true);
        return vqcpitemline->createPosition(name_QString);
    } else {
        return ((VirtualQCPItemLine*)self)->createPosition(name_QString);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnCreatePosition(QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_CreatePosition_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_CreatePosition_Callback>(slot));
    }
}

// Derived class handler implementation
QCPItemAnchor* QCPItemLine_CreateAnchor(QCPItemLine* self, const libqt_string name, int anchorId) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        return vqcpitemline->createAnchor(name_QString, static_cast<int>(anchorId));
    } else {
        return ((VirtualQCPItemLine*)self)->createAnchor(name_QString, static_cast<int>(anchorId));
    }
}

// Base class handler implementation
QCPItemAnchor* QCPItemLine_QBaseCreateAnchor(QCPItemLine* self, const libqt_string name, int anchorId) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_CreateAnchor_IsBase(true);
        return vqcpitemline->createAnchor(name_QString, static_cast<int>(anchorId));
    } else {
        return ((VirtualQCPItemLine*)self)->createAnchor(name_QString, static_cast<int>(anchorId));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnCreateAnchor(QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_CreateAnchor_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_CreateAnchor_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemLine_InitializeParentPlot(QCPItemLine* self, QCustomPlot* parentPlot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPItemLine*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPItemLine_QBaseInitializeParentPlot(QCPItemLine* self, QCustomPlot* parentPlot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_InitializeParentPlot_IsBase(true);
        vqcpitemline->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPItemLine*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnInitializeParentPlot(QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemLine_SetParentLayerable(QCPItemLine* self, QCPLayerable* parentLayerable) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPItemLine*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPItemLine_QBaseSetParentLayerable(QCPItemLine* self, QCPLayerable* parentLayerable) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_SetParentLayerable_IsBase(true);
        vqcpitemline->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPItemLine*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnSetParentLayerable(QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemLine_MoveToLayer(QCPItemLine* self, QCPLayer* layer, bool prepend) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        return vqcpitemline->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPItemLine*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPItemLine_QBaseMoveToLayer(QCPItemLine* self, QCPLayer* layer, bool prepend) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_MoveToLayer_IsBase(true);
        return vqcpitemline->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPItemLine*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnMoveToLayer(QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = dynamic_cast<VirtualQCPItemLine*>(self);
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_MoveToLayer_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemLine_ApplyAntialiasingHint(const QCPItemLine* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPItemLine*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPItemLine_QBaseApplyAntialiasingHint(const QCPItemLine* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_ApplyAntialiasingHint_IsBase(true);
        vqcpitemline->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPItemLine*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnApplyAntialiasingHint(const QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPItemLine_Sender(const QCPItemLine* self) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        return vqcpitemline->sender();
    } else {
        return ((VirtualQCPItemLine*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPItemLine_QBaseSender(const QCPItemLine* self) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_Sender_IsBase(true);
        return vqcpitemline->sender();
    } else {
        return ((VirtualQCPItemLine*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnSender(const QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_Sender_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemLine_SenderSignalIndex(const QCPItemLine* self) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        return vqcpitemline->senderSignalIndex();
    } else {
        return ((VirtualQCPItemLine*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPItemLine_QBaseSenderSignalIndex(const QCPItemLine* self) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_SenderSignalIndex_IsBase(true);
        return vqcpitemline->senderSignalIndex();
    } else {
        return ((VirtualQCPItemLine*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnSenderSignalIndex(const QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemLine_Receivers(const QCPItemLine* self, const char* signal) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        return vqcpitemline->receivers(signal);
    } else {
        return ((VirtualQCPItemLine*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPItemLine_QBaseReceivers(const QCPItemLine* self, const char* signal) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_Receivers_IsBase(true);
        return vqcpitemline->receivers(signal);
    } else {
        return ((VirtualQCPItemLine*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnReceivers(const QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_Receivers_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemLine_IsSignalConnected(const QCPItemLine* self, const QMetaMethod* signal) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        return vqcpitemline->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPItemLine*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPItemLine_QBaseIsSignalConnected(const QCPItemLine* self, const QMetaMethod* signal) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_IsSignalConnected_IsBase(true);
        return vqcpitemline->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPItemLine*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemLine_OnIsSignalConnected(const QCPItemLine* self, intptr_t slot) {
    auto* vqcpitemline = const_cast<VirtualQCPItemLine*>(dynamic_cast<const VirtualQCPItemLine*>(self));
    if (vqcpitemline && vqcpitemline->isVirtualQCPItemLine) {
        vqcpitemline->setQCPItemLine_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPItemLine::QCPItemLine_IsSignalConnected_Callback>(slot));
    }
}

void QCPItemLine_Delete(QCPItemLine* self) {
    delete self;
}

QCPItemCurve* QCPItemCurve_new(QCustomPlot* parentPlot) {
    return new VirtualQCPItemCurve(parentPlot);
}

QMetaObject* QCPItemCurve_MetaObject(const QCPItemCurve* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPItemCurve_Metacast(QCPItemCurve* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPItemCurve_Metacall(QCPItemCurve* self, int param1, int param2, void** param3) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPItemCurve*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPItemCurve_Tr(const char* s) {
    QString _ret = QCPItemCurve::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

QPen* QCPItemCurve_Pen(const QCPItemCurve* self) {
    return new QPen(self->pen());
}

QPen* QCPItemCurve_SelectedPen(const QCPItemCurve* self) {
    return new QPen(self->selectedPen());
}

QCPLineEnding* QCPItemCurve_Head(const QCPItemCurve* self) {
    return new QCPLineEnding(self->head());
}

QCPLineEnding* QCPItemCurve_Tail(const QCPItemCurve* self) {
    return new QCPLineEnding(self->tail());
}

void QCPItemCurve_SetPen(QCPItemCurve* self, const QPen* pen) {
    self->setPen(*pen);
}

void QCPItemCurve_SetSelectedPen(QCPItemCurve* self, const QPen* pen) {
    self->setSelectedPen(*pen);
}

void QCPItemCurve_SetHead(QCPItemCurve* self, const QCPLineEnding* head) {
    self->setHead(*head);
}

void QCPItemCurve_SetTail(QCPItemCurve* self, const QCPLineEnding* tail) {
    self->setTail(*tail);
}

double QCPItemCurve_SelectTest(const QCPItemCurve* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpitemcurve = dynamic_cast<const VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPItemCurve*)self)->selectTest(*pos, onlySelectable, details);
    }
}

QCPItemPosition* QCPItemCurve_Start(const QCPItemCurve* self) {
    return (QCPItemPosition*)self->start;
}

QCPItemPosition* QCPItemCurve_StartDir(const QCPItemCurve* self) {
    return (QCPItemPosition*)self->startDir;
}

QCPItemPosition* QCPItemCurve_EndDir(const QCPItemCurve* self) {
    return (QCPItemPosition*)self->endDir;
}

QCPItemPosition* QCPItemCurve_End(const QCPItemCurve* self) {
    return (QCPItemPosition*)self->end;
}

void QCPItemCurve_Draw(QCPItemCurve* self, QCPPainter* painter) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->draw(painter);
    }
}

libqt_string QCPItemCurve_Tr2(const char* s, const char* c) {
    QString _ret = QCPItemCurve::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPItemCurve_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPItemCurve::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPItemCurve_QBaseMetacall(QCPItemCurve* self, int param1, int param2, void** param3) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_Metacall_IsBase(true);
        return vqcpitemcurve->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPItemCurve::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnMetacall(QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_Metacall_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
double QCPItemCurve_QBaseSelectTest(const QCPItemCurve* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_SelectTest_IsBase(true);
        return vqcpitemcurve->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPItemCurve::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnSelectTest(const QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_SelectTest_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
void QCPItemCurve_QBaseDraw(QCPItemCurve* self, QCPPainter* painter) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_Draw_IsBase(true);
        vqcpitemcurve->draw(painter);
    } else {
        ((VirtualQCPItemCurve*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnDraw(QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_Draw_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_Draw_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemCurve_SelectionCategory(const QCPItemCurve* self) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        return static_cast<int>(vqcpitemcurve->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPItemCurve*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPItemCurve_QBaseSelectionCategory(const QCPItemCurve* self) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcpitemcurve->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPItemCurve*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnSelectionCategory(const QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_SelectionCategory_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPItemCurve_ClipRect(const QCPItemCurve* self) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        return new QRect(vqcpitemcurve->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPItemCurve_QBaseClipRect(const QCPItemCurve* self) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_ClipRect_IsBase(true);
        return new QRect(vqcpitemcurve->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnClipRect(const QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_ClipRect_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemCurve_ApplyDefaultAntialiasingHint(const QCPItemCurve* self, QCPPainter* painter) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPItemCurve*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPItemCurve_QBaseApplyDefaultAntialiasingHint(const QCPItemCurve* self, QCPPainter* painter) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcpitemcurve->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPItemCurve*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnApplyDefaultAntialiasingHint(const QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemCurve_SelectEvent(QCPItemCurve* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPItemCurve*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPItemCurve_QBaseSelectEvent(QCPItemCurve* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_SelectEvent_IsBase(true);
        vqcpitemcurve->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPItemCurve*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnSelectEvent(QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_SelectEvent_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemCurve_DeselectEvent(QCPItemCurve* self, bool* selectionStateChanged) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPItemCurve*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPItemCurve_QBaseDeselectEvent(QCPItemCurve* self, bool* selectionStateChanged) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_DeselectEvent_IsBase(true);
        vqcpitemcurve->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPItemCurve*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnDeselectEvent(QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_DeselectEvent_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
QPointF* QCPItemCurve_AnchorPixelPosition(const QCPItemCurve* self, int anchorId) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        return new QPointF(vqcpitemcurve->anchorPixelPosition(static_cast<int>(anchorId)));
    }
    return {};
}

// Base class handler implementation
QPointF* QCPItemCurve_QBaseAnchorPixelPosition(const QCPItemCurve* self, int anchorId) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_AnchorPixelPosition_IsBase(true);
        return new QPointF(vqcpitemcurve->anchorPixelPosition(static_cast<int>(anchorId)));
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnAnchorPixelPosition(const QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_AnchorPixelPosition_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_AnchorPixelPosition_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemCurve_ParentPlotInitialized(QCPItemCurve* self, QCustomPlot* parentPlot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPItemCurve*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPItemCurve_QBaseParentPlotInitialized(QCPItemCurve* self, QCustomPlot* parentPlot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_ParentPlotInitialized_IsBase(true);
        vqcpitemcurve->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPItemCurve*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnParentPlotInitialized(QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemCurve_MousePressEvent(QCPItemCurve* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPItemCurve*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPItemCurve_QBaseMousePressEvent(QCPItemCurve* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_MousePressEvent_IsBase(true);
        vqcpitemcurve->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPItemCurve*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnMousePressEvent(QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_MousePressEvent_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemCurve_MouseMoveEvent(QCPItemCurve* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPItemCurve*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPItemCurve_QBaseMouseMoveEvent(QCPItemCurve* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_MouseMoveEvent_IsBase(true);
        vqcpitemcurve->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPItemCurve*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnMouseMoveEvent(QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemCurve_MouseReleaseEvent(QCPItemCurve* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPItemCurve*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPItemCurve_QBaseMouseReleaseEvent(QCPItemCurve* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_MouseReleaseEvent_IsBase(true);
        vqcpitemcurve->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPItemCurve*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnMouseReleaseEvent(QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemCurve_MouseDoubleClickEvent(QCPItemCurve* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPItemCurve*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPItemCurve_QBaseMouseDoubleClickEvent(QCPItemCurve* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_MouseDoubleClickEvent_IsBase(true);
        vqcpitemcurve->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPItemCurve*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnMouseDoubleClickEvent(QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemCurve_WheelEvent(QCPItemCurve* self, QWheelEvent* event) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->wheelEvent(event);
    } else {
        ((VirtualQCPItemCurve*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPItemCurve_QBaseWheelEvent(QCPItemCurve* self, QWheelEvent* event) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_WheelEvent_IsBase(true);
        vqcpitemcurve->wheelEvent(event);
    } else {
        ((VirtualQCPItemCurve*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnWheelEvent(QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_WheelEvent_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemCurve_Event(QCPItemCurve* self, QEvent* event) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        return vqcpitemcurve->event(event);
    } else {
        return self->QCPItemCurve::event(event);
    }
}

// Base class handler implementation
bool QCPItemCurve_QBaseEvent(QCPItemCurve* self, QEvent* event) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_Event_IsBase(true);
        return vqcpitemcurve->event(event);
    } else {
        return self->QCPItemCurve::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnEvent(QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_Event_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemCurve_EventFilter(QCPItemCurve* self, QObject* watched, QEvent* event) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        return vqcpitemcurve->eventFilter(watched, event);
    } else {
        return self->QCPItemCurve::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPItemCurve_QBaseEventFilter(QCPItemCurve* self, QObject* watched, QEvent* event) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_EventFilter_IsBase(true);
        return vqcpitemcurve->eventFilter(watched, event);
    } else {
        return self->QCPItemCurve::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnEventFilter(QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_EventFilter_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemCurve_TimerEvent(QCPItemCurve* self, QTimerEvent* event) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->timerEvent(event);
    } else {
        ((VirtualQCPItemCurve*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPItemCurve_QBaseTimerEvent(QCPItemCurve* self, QTimerEvent* event) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_TimerEvent_IsBase(true);
        vqcpitemcurve->timerEvent(event);
    } else {
        ((VirtualQCPItemCurve*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnTimerEvent(QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_TimerEvent_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemCurve_ChildEvent(QCPItemCurve* self, QChildEvent* event) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->childEvent(event);
    } else {
        ((VirtualQCPItemCurve*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPItemCurve_QBaseChildEvent(QCPItemCurve* self, QChildEvent* event) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_ChildEvent_IsBase(true);
        vqcpitemcurve->childEvent(event);
    } else {
        ((VirtualQCPItemCurve*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnChildEvent(QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_ChildEvent_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemCurve_CustomEvent(QCPItemCurve* self, QEvent* event) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->customEvent(event);
    } else {
        ((VirtualQCPItemCurve*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPItemCurve_QBaseCustomEvent(QCPItemCurve* self, QEvent* event) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_CustomEvent_IsBase(true);
        vqcpitemcurve->customEvent(event);
    } else {
        ((VirtualQCPItemCurve*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnCustomEvent(QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_CustomEvent_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemCurve_ConnectNotify(QCPItemCurve* self, const QMetaMethod* signal) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->connectNotify(*signal);
    } else {
        ((VirtualQCPItemCurve*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPItemCurve_QBaseConnectNotify(QCPItemCurve* self, const QMetaMethod* signal) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_ConnectNotify_IsBase(true);
        vqcpitemcurve->connectNotify(*signal);
    } else {
        ((VirtualQCPItemCurve*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnConnectNotify(QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_ConnectNotify_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemCurve_DisconnectNotify(QCPItemCurve* self, const QMetaMethod* signal) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->disconnectNotify(*signal);
    } else {
        ((VirtualQCPItemCurve*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPItemCurve_QBaseDisconnectNotify(QCPItemCurve* self, const QMetaMethod* signal) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_DisconnectNotify_IsBase(true);
        vqcpitemcurve->disconnectNotify(*signal);
    } else {
        ((VirtualQCPItemCurve*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnDisconnectNotify(QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
QPen* QCPItemCurve_MainPen(const QCPItemCurve* self) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        return new QPen(vqcpitemcurve->mainPen());
    }
    return {};
}

// Base class handler implementation
QPen* QCPItemCurve_QBaseMainPen(const QCPItemCurve* self) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_MainPen_IsBase(true);
        return new QPen(vqcpitemcurve->mainPen());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnMainPen(const QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_MainPen_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_MainPen_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPItemCurve_RectDistance(const QCPItemCurve* self, const QRectF* rect, const QPointF* pos, bool filledRect) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        return vqcpitemcurve->rectDistance(*rect, *pos, filledRect);
    } else {
        return ((VirtualQCPItemCurve*)self)->rectDistance(*rect, *pos, filledRect);
    }
}

// Base class handler implementation
double QCPItemCurve_QBaseRectDistance(const QCPItemCurve* self, const QRectF* rect, const QPointF* pos, bool filledRect) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_RectDistance_IsBase(true);
        return vqcpitemcurve->rectDistance(*rect, *pos, filledRect);
    } else {
        return ((VirtualQCPItemCurve*)self)->rectDistance(*rect, *pos, filledRect);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnRectDistance(const QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_RectDistance_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_RectDistance_Callback>(slot));
    }
}

// Derived class handler implementation
QCPItemPosition* QCPItemCurve_CreatePosition(QCPItemCurve* self, const libqt_string name) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        return vqcpitemcurve->createPosition(name_QString);
    } else {
        return ((VirtualQCPItemCurve*)self)->createPosition(name_QString);
    }
}

// Base class handler implementation
QCPItemPosition* QCPItemCurve_QBaseCreatePosition(QCPItemCurve* self, const libqt_string name) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_CreatePosition_IsBase(true);
        return vqcpitemcurve->createPosition(name_QString);
    } else {
        return ((VirtualQCPItemCurve*)self)->createPosition(name_QString);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnCreatePosition(QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_CreatePosition_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_CreatePosition_Callback>(slot));
    }
}

// Derived class handler implementation
QCPItemAnchor* QCPItemCurve_CreateAnchor(QCPItemCurve* self, const libqt_string name, int anchorId) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        return vqcpitemcurve->createAnchor(name_QString, static_cast<int>(anchorId));
    } else {
        return ((VirtualQCPItemCurve*)self)->createAnchor(name_QString, static_cast<int>(anchorId));
    }
}

// Base class handler implementation
QCPItemAnchor* QCPItemCurve_QBaseCreateAnchor(QCPItemCurve* self, const libqt_string name, int anchorId) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_CreateAnchor_IsBase(true);
        return vqcpitemcurve->createAnchor(name_QString, static_cast<int>(anchorId));
    } else {
        return ((VirtualQCPItemCurve*)self)->createAnchor(name_QString, static_cast<int>(anchorId));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnCreateAnchor(QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_CreateAnchor_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_CreateAnchor_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemCurve_InitializeParentPlot(QCPItemCurve* self, QCustomPlot* parentPlot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPItemCurve*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPItemCurve_QBaseInitializeParentPlot(QCPItemCurve* self, QCustomPlot* parentPlot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_InitializeParentPlot_IsBase(true);
        vqcpitemcurve->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPItemCurve*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnInitializeParentPlot(QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemCurve_SetParentLayerable(QCPItemCurve* self, QCPLayerable* parentLayerable) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPItemCurve*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPItemCurve_QBaseSetParentLayerable(QCPItemCurve* self, QCPLayerable* parentLayerable) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_SetParentLayerable_IsBase(true);
        vqcpitemcurve->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPItemCurve*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnSetParentLayerable(QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemCurve_MoveToLayer(QCPItemCurve* self, QCPLayer* layer, bool prepend) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        return vqcpitemcurve->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPItemCurve*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPItemCurve_QBaseMoveToLayer(QCPItemCurve* self, QCPLayer* layer, bool prepend) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_MoveToLayer_IsBase(true);
        return vqcpitemcurve->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPItemCurve*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnMoveToLayer(QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = dynamic_cast<VirtualQCPItemCurve*>(self);
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_MoveToLayer_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemCurve_ApplyAntialiasingHint(const QCPItemCurve* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPItemCurve*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPItemCurve_QBaseApplyAntialiasingHint(const QCPItemCurve* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_ApplyAntialiasingHint_IsBase(true);
        vqcpitemcurve->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPItemCurve*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnApplyAntialiasingHint(const QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPItemCurve_Sender(const QCPItemCurve* self) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        return vqcpitemcurve->sender();
    } else {
        return ((VirtualQCPItemCurve*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPItemCurve_QBaseSender(const QCPItemCurve* self) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_Sender_IsBase(true);
        return vqcpitemcurve->sender();
    } else {
        return ((VirtualQCPItemCurve*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnSender(const QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_Sender_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemCurve_SenderSignalIndex(const QCPItemCurve* self) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        return vqcpitemcurve->senderSignalIndex();
    } else {
        return ((VirtualQCPItemCurve*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPItemCurve_QBaseSenderSignalIndex(const QCPItemCurve* self) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_SenderSignalIndex_IsBase(true);
        return vqcpitemcurve->senderSignalIndex();
    } else {
        return ((VirtualQCPItemCurve*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnSenderSignalIndex(const QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemCurve_Receivers(const QCPItemCurve* self, const char* signal) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        return vqcpitemcurve->receivers(signal);
    } else {
        return ((VirtualQCPItemCurve*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPItemCurve_QBaseReceivers(const QCPItemCurve* self, const char* signal) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_Receivers_IsBase(true);
        return vqcpitemcurve->receivers(signal);
    } else {
        return ((VirtualQCPItemCurve*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnReceivers(const QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_Receivers_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemCurve_IsSignalConnected(const QCPItemCurve* self, const QMetaMethod* signal) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        return vqcpitemcurve->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPItemCurve*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPItemCurve_QBaseIsSignalConnected(const QCPItemCurve* self, const QMetaMethod* signal) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_IsSignalConnected_IsBase(true);
        return vqcpitemcurve->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPItemCurve*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemCurve_OnIsSignalConnected(const QCPItemCurve* self, intptr_t slot) {
    auto* vqcpitemcurve = const_cast<VirtualQCPItemCurve*>(dynamic_cast<const VirtualQCPItemCurve*>(self));
    if (vqcpitemcurve && vqcpitemcurve->isVirtualQCPItemCurve) {
        vqcpitemcurve->setQCPItemCurve_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPItemCurve::QCPItemCurve_IsSignalConnected_Callback>(slot));
    }
}

void QCPItemCurve_Delete(QCPItemCurve* self) {
    delete self;
}

QCPItemRect* QCPItemRect_new(QCustomPlot* parentPlot) {
    return new VirtualQCPItemRect(parentPlot);
}

QMetaObject* QCPItemRect_MetaObject(const QCPItemRect* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPItemRect_Metacast(QCPItemRect* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPItemRect_Metacall(QCPItemRect* self, int param1, int param2, void** param3) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPItemRect*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPItemRect_Tr(const char* s) {
    QString _ret = QCPItemRect::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

QPen* QCPItemRect_Pen(const QCPItemRect* self) {
    return new QPen(self->pen());
}

QPen* QCPItemRect_SelectedPen(const QCPItemRect* self) {
    return new QPen(self->selectedPen());
}

QBrush* QCPItemRect_Brush(const QCPItemRect* self) {
    return new QBrush(self->brush());
}

QBrush* QCPItemRect_SelectedBrush(const QCPItemRect* self) {
    return new QBrush(self->selectedBrush());
}

void QCPItemRect_SetPen(QCPItemRect* self, const QPen* pen) {
    self->setPen(*pen);
}

void QCPItemRect_SetSelectedPen(QCPItemRect* self, const QPen* pen) {
    self->setSelectedPen(*pen);
}

void QCPItemRect_SetBrush(QCPItemRect* self, const QBrush* brush) {
    self->setBrush(*brush);
}

void QCPItemRect_SetSelectedBrush(QCPItemRect* self, const QBrush* brush) {
    self->setSelectedBrush(*brush);
}

double QCPItemRect_SelectTest(const QCPItemRect* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpitemrect = dynamic_cast<const VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPItemRect*)self)->selectTest(*pos, onlySelectable, details);
    }
}

QCPItemPosition* QCPItemRect_TopLeft(const QCPItemRect* self) {
    return (QCPItemPosition*)self->topLeft;
}

QCPItemPosition* QCPItemRect_BottomRight(const QCPItemRect* self) {
    return (QCPItemPosition*)self->bottomRight;
}

QCPItemAnchor* QCPItemRect_Top(const QCPItemRect* self) {
    return (QCPItemAnchor*)self->top;
}

QCPItemAnchor* QCPItemRect_TopRight(const QCPItemRect* self) {
    return (QCPItemAnchor*)self->topRight;
}

QCPItemAnchor* QCPItemRect_Right(const QCPItemRect* self) {
    return (QCPItemAnchor*)self->right;
}

QCPItemAnchor* QCPItemRect_Bottom(const QCPItemRect* self) {
    return (QCPItemAnchor*)self->bottom;
}

QCPItemAnchor* QCPItemRect_BottomLeft(const QCPItemRect* self) {
    return (QCPItemAnchor*)self->bottomLeft;
}

QCPItemAnchor* QCPItemRect_Left(const QCPItemRect* self) {
    return (QCPItemAnchor*)self->left;
}

void QCPItemRect_Draw(QCPItemRect* self, QCPPainter* painter) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->draw(painter);
    }
}

QPointF* QCPItemRect_AnchorPixelPosition(const QCPItemRect* self, int anchorId) {
    auto* vqcpitemrect = dynamic_cast<const VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        return new QPointF(vqcpitemrect->anchorPixelPosition(static_cast<int>(anchorId)));
    }
    return {};
}

libqt_string QCPItemRect_Tr2(const char* s, const char* c) {
    QString _ret = QCPItemRect::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPItemRect_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPItemRect::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPItemRect_QBaseMetacall(QCPItemRect* self, int param1, int param2, void** param3) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_Metacall_IsBase(true);
        return vqcpitemrect->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPItemRect::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnMetacall(QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_Metacall_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
double QCPItemRect_QBaseSelectTest(const QCPItemRect* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_SelectTest_IsBase(true);
        return vqcpitemrect->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPItemRect::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnSelectTest(const QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_SelectTest_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
void QCPItemRect_QBaseDraw(QCPItemRect* self, QCPPainter* painter) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_Draw_IsBase(true);
        vqcpitemrect->draw(painter);
    } else {
        ((VirtualQCPItemRect*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnDraw(QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_Draw_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_Draw_Callback>(slot));
    }
}

// Base class handler implementation
QPointF* QCPItemRect_QBaseAnchorPixelPosition(const QCPItemRect* self, int anchorId) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_AnchorPixelPosition_IsBase(true);
        return new QPointF(vqcpitemrect->anchorPixelPosition(static_cast<int>(anchorId)));
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnAnchorPixelPosition(const QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_AnchorPixelPosition_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_AnchorPixelPosition_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemRect_SelectionCategory(const QCPItemRect* self) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        return static_cast<int>(vqcpitemrect->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPItemRect*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPItemRect_QBaseSelectionCategory(const QCPItemRect* self) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcpitemrect->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPItemRect*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnSelectionCategory(const QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_SelectionCategory_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPItemRect_ClipRect(const QCPItemRect* self) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        return new QRect(vqcpitemrect->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPItemRect_QBaseClipRect(const QCPItemRect* self) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_ClipRect_IsBase(true);
        return new QRect(vqcpitemrect->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnClipRect(const QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_ClipRect_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemRect_ApplyDefaultAntialiasingHint(const QCPItemRect* self, QCPPainter* painter) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPItemRect*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPItemRect_QBaseApplyDefaultAntialiasingHint(const QCPItemRect* self, QCPPainter* painter) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcpitemrect->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPItemRect*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnApplyDefaultAntialiasingHint(const QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemRect_SelectEvent(QCPItemRect* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPItemRect*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPItemRect_QBaseSelectEvent(QCPItemRect* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_SelectEvent_IsBase(true);
        vqcpitemrect->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPItemRect*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnSelectEvent(QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_SelectEvent_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemRect_DeselectEvent(QCPItemRect* self, bool* selectionStateChanged) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPItemRect*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPItemRect_QBaseDeselectEvent(QCPItemRect* self, bool* selectionStateChanged) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_DeselectEvent_IsBase(true);
        vqcpitemrect->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPItemRect*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnDeselectEvent(QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_DeselectEvent_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemRect_ParentPlotInitialized(QCPItemRect* self, QCustomPlot* parentPlot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPItemRect*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPItemRect_QBaseParentPlotInitialized(QCPItemRect* self, QCustomPlot* parentPlot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_ParentPlotInitialized_IsBase(true);
        vqcpitemrect->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPItemRect*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnParentPlotInitialized(QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemRect_MousePressEvent(QCPItemRect* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPItemRect*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPItemRect_QBaseMousePressEvent(QCPItemRect* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_MousePressEvent_IsBase(true);
        vqcpitemrect->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPItemRect*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnMousePressEvent(QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_MousePressEvent_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemRect_MouseMoveEvent(QCPItemRect* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPItemRect*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPItemRect_QBaseMouseMoveEvent(QCPItemRect* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_MouseMoveEvent_IsBase(true);
        vqcpitemrect->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPItemRect*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnMouseMoveEvent(QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemRect_MouseReleaseEvent(QCPItemRect* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPItemRect*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPItemRect_QBaseMouseReleaseEvent(QCPItemRect* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_MouseReleaseEvent_IsBase(true);
        vqcpitemrect->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPItemRect*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnMouseReleaseEvent(QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemRect_MouseDoubleClickEvent(QCPItemRect* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPItemRect*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPItemRect_QBaseMouseDoubleClickEvent(QCPItemRect* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_MouseDoubleClickEvent_IsBase(true);
        vqcpitemrect->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPItemRect*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnMouseDoubleClickEvent(QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemRect_WheelEvent(QCPItemRect* self, QWheelEvent* event) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->wheelEvent(event);
    } else {
        ((VirtualQCPItemRect*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPItemRect_QBaseWheelEvent(QCPItemRect* self, QWheelEvent* event) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_WheelEvent_IsBase(true);
        vqcpitemrect->wheelEvent(event);
    } else {
        ((VirtualQCPItemRect*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnWheelEvent(QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_WheelEvent_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemRect_Event(QCPItemRect* self, QEvent* event) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        return vqcpitemrect->event(event);
    } else {
        return self->QCPItemRect::event(event);
    }
}

// Base class handler implementation
bool QCPItemRect_QBaseEvent(QCPItemRect* self, QEvent* event) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_Event_IsBase(true);
        return vqcpitemrect->event(event);
    } else {
        return self->QCPItemRect::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnEvent(QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_Event_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemRect_EventFilter(QCPItemRect* self, QObject* watched, QEvent* event) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        return vqcpitemrect->eventFilter(watched, event);
    } else {
        return self->QCPItemRect::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPItemRect_QBaseEventFilter(QCPItemRect* self, QObject* watched, QEvent* event) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_EventFilter_IsBase(true);
        return vqcpitemrect->eventFilter(watched, event);
    } else {
        return self->QCPItemRect::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnEventFilter(QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_EventFilter_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemRect_TimerEvent(QCPItemRect* self, QTimerEvent* event) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->timerEvent(event);
    } else {
        ((VirtualQCPItemRect*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPItemRect_QBaseTimerEvent(QCPItemRect* self, QTimerEvent* event) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_TimerEvent_IsBase(true);
        vqcpitemrect->timerEvent(event);
    } else {
        ((VirtualQCPItemRect*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnTimerEvent(QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_TimerEvent_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemRect_ChildEvent(QCPItemRect* self, QChildEvent* event) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->childEvent(event);
    } else {
        ((VirtualQCPItemRect*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPItemRect_QBaseChildEvent(QCPItemRect* self, QChildEvent* event) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_ChildEvent_IsBase(true);
        vqcpitemrect->childEvent(event);
    } else {
        ((VirtualQCPItemRect*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnChildEvent(QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_ChildEvent_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemRect_CustomEvent(QCPItemRect* self, QEvent* event) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->customEvent(event);
    } else {
        ((VirtualQCPItemRect*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPItemRect_QBaseCustomEvent(QCPItemRect* self, QEvent* event) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_CustomEvent_IsBase(true);
        vqcpitemrect->customEvent(event);
    } else {
        ((VirtualQCPItemRect*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnCustomEvent(QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_CustomEvent_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemRect_ConnectNotify(QCPItemRect* self, const QMetaMethod* signal) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->connectNotify(*signal);
    } else {
        ((VirtualQCPItemRect*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPItemRect_QBaseConnectNotify(QCPItemRect* self, const QMetaMethod* signal) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_ConnectNotify_IsBase(true);
        vqcpitemrect->connectNotify(*signal);
    } else {
        ((VirtualQCPItemRect*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnConnectNotify(QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_ConnectNotify_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemRect_DisconnectNotify(QCPItemRect* self, const QMetaMethod* signal) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->disconnectNotify(*signal);
    } else {
        ((VirtualQCPItemRect*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPItemRect_QBaseDisconnectNotify(QCPItemRect* self, const QMetaMethod* signal) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_DisconnectNotify_IsBase(true);
        vqcpitemrect->disconnectNotify(*signal);
    } else {
        ((VirtualQCPItemRect*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnDisconnectNotify(QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
QPen* QCPItemRect_MainPen(const QCPItemRect* self) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        return new QPen(vqcpitemrect->mainPen());
    }
    return {};
}

// Base class handler implementation
QPen* QCPItemRect_QBaseMainPen(const QCPItemRect* self) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_MainPen_IsBase(true);
        return new QPen(vqcpitemrect->mainPen());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnMainPen(const QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_MainPen_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_MainPen_Callback>(slot));
    }
}

// Derived class handler implementation
QBrush* QCPItemRect_MainBrush(const QCPItemRect* self) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        return new QBrush(vqcpitemrect->mainBrush());
    }
    return {};
}

// Base class handler implementation
QBrush* QCPItemRect_QBaseMainBrush(const QCPItemRect* self) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_MainBrush_IsBase(true);
        return new QBrush(vqcpitemrect->mainBrush());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnMainBrush(const QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_MainBrush_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_MainBrush_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPItemRect_RectDistance(const QCPItemRect* self, const QRectF* rect, const QPointF* pos, bool filledRect) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        return vqcpitemrect->rectDistance(*rect, *pos, filledRect);
    } else {
        return ((VirtualQCPItemRect*)self)->rectDistance(*rect, *pos, filledRect);
    }
}

// Base class handler implementation
double QCPItemRect_QBaseRectDistance(const QCPItemRect* self, const QRectF* rect, const QPointF* pos, bool filledRect) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_RectDistance_IsBase(true);
        return vqcpitemrect->rectDistance(*rect, *pos, filledRect);
    } else {
        return ((VirtualQCPItemRect*)self)->rectDistance(*rect, *pos, filledRect);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnRectDistance(const QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_RectDistance_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_RectDistance_Callback>(slot));
    }
}

// Derived class handler implementation
QCPItemPosition* QCPItemRect_CreatePosition(QCPItemRect* self, const libqt_string name) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        return vqcpitemrect->createPosition(name_QString);
    } else {
        return ((VirtualQCPItemRect*)self)->createPosition(name_QString);
    }
}

// Base class handler implementation
QCPItemPosition* QCPItemRect_QBaseCreatePosition(QCPItemRect* self, const libqt_string name) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_CreatePosition_IsBase(true);
        return vqcpitemrect->createPosition(name_QString);
    } else {
        return ((VirtualQCPItemRect*)self)->createPosition(name_QString);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnCreatePosition(QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_CreatePosition_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_CreatePosition_Callback>(slot));
    }
}

// Derived class handler implementation
QCPItemAnchor* QCPItemRect_CreateAnchor(QCPItemRect* self, const libqt_string name, int anchorId) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        return vqcpitemrect->createAnchor(name_QString, static_cast<int>(anchorId));
    } else {
        return ((VirtualQCPItemRect*)self)->createAnchor(name_QString, static_cast<int>(anchorId));
    }
}

// Base class handler implementation
QCPItemAnchor* QCPItemRect_QBaseCreateAnchor(QCPItemRect* self, const libqt_string name, int anchorId) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_CreateAnchor_IsBase(true);
        return vqcpitemrect->createAnchor(name_QString, static_cast<int>(anchorId));
    } else {
        return ((VirtualQCPItemRect*)self)->createAnchor(name_QString, static_cast<int>(anchorId));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnCreateAnchor(QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_CreateAnchor_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_CreateAnchor_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemRect_InitializeParentPlot(QCPItemRect* self, QCustomPlot* parentPlot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPItemRect*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPItemRect_QBaseInitializeParentPlot(QCPItemRect* self, QCustomPlot* parentPlot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_InitializeParentPlot_IsBase(true);
        vqcpitemrect->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPItemRect*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnInitializeParentPlot(QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemRect_SetParentLayerable(QCPItemRect* self, QCPLayerable* parentLayerable) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPItemRect*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPItemRect_QBaseSetParentLayerable(QCPItemRect* self, QCPLayerable* parentLayerable) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_SetParentLayerable_IsBase(true);
        vqcpitemrect->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPItemRect*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnSetParentLayerable(QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemRect_MoveToLayer(QCPItemRect* self, QCPLayer* layer, bool prepend) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        return vqcpitemrect->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPItemRect*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPItemRect_QBaseMoveToLayer(QCPItemRect* self, QCPLayer* layer, bool prepend) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_MoveToLayer_IsBase(true);
        return vqcpitemrect->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPItemRect*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnMoveToLayer(QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = dynamic_cast<VirtualQCPItemRect*>(self);
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_MoveToLayer_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemRect_ApplyAntialiasingHint(const QCPItemRect* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPItemRect*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPItemRect_QBaseApplyAntialiasingHint(const QCPItemRect* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_ApplyAntialiasingHint_IsBase(true);
        vqcpitemrect->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPItemRect*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnApplyAntialiasingHint(const QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPItemRect_Sender(const QCPItemRect* self) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        return vqcpitemrect->sender();
    } else {
        return ((VirtualQCPItemRect*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPItemRect_QBaseSender(const QCPItemRect* self) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_Sender_IsBase(true);
        return vqcpitemrect->sender();
    } else {
        return ((VirtualQCPItemRect*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnSender(const QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_Sender_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemRect_SenderSignalIndex(const QCPItemRect* self) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        return vqcpitemrect->senderSignalIndex();
    } else {
        return ((VirtualQCPItemRect*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPItemRect_QBaseSenderSignalIndex(const QCPItemRect* self) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_SenderSignalIndex_IsBase(true);
        return vqcpitemrect->senderSignalIndex();
    } else {
        return ((VirtualQCPItemRect*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnSenderSignalIndex(const QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemRect_Receivers(const QCPItemRect* self, const char* signal) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        return vqcpitemrect->receivers(signal);
    } else {
        return ((VirtualQCPItemRect*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPItemRect_QBaseReceivers(const QCPItemRect* self, const char* signal) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_Receivers_IsBase(true);
        return vqcpitemrect->receivers(signal);
    } else {
        return ((VirtualQCPItemRect*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnReceivers(const QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_Receivers_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemRect_IsSignalConnected(const QCPItemRect* self, const QMetaMethod* signal) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        return vqcpitemrect->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPItemRect*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPItemRect_QBaseIsSignalConnected(const QCPItemRect* self, const QMetaMethod* signal) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_IsSignalConnected_IsBase(true);
        return vqcpitemrect->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPItemRect*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemRect_OnIsSignalConnected(const QCPItemRect* self, intptr_t slot) {
    auto* vqcpitemrect = const_cast<VirtualQCPItemRect*>(dynamic_cast<const VirtualQCPItemRect*>(self));
    if (vqcpitemrect && vqcpitemrect->isVirtualQCPItemRect) {
        vqcpitemrect->setQCPItemRect_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPItemRect::QCPItemRect_IsSignalConnected_Callback>(slot));
    }
}

void QCPItemRect_Delete(QCPItemRect* self) {
    delete self;
}

QCPItemText* QCPItemText_new(QCustomPlot* parentPlot) {
    return new VirtualQCPItemText(parentPlot);
}

QMetaObject* QCPItemText_MetaObject(const QCPItemText* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPItemText_Metacast(QCPItemText* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPItemText_Metacall(QCPItemText* self, int param1, int param2, void** param3) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPItemText*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPItemText_Tr(const char* s) {
    QString _ret = QCPItemText::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

QColor* QCPItemText_Color(const QCPItemText* self) {
    return new QColor(self->color());
}

QColor* QCPItemText_SelectedColor(const QCPItemText* self) {
    return new QColor(self->selectedColor());
}

QPen* QCPItemText_Pen(const QCPItemText* self) {
    return new QPen(self->pen());
}

QPen* QCPItemText_SelectedPen(const QCPItemText* self) {
    return new QPen(self->selectedPen());
}

QBrush* QCPItemText_Brush(const QCPItemText* self) {
    return new QBrush(self->brush());
}

QBrush* QCPItemText_SelectedBrush(const QCPItemText* self) {
    return new QBrush(self->selectedBrush());
}

QFont* QCPItemText_Font(const QCPItemText* self) {
    return new QFont(self->font());
}

QFont* QCPItemText_SelectedFont(const QCPItemText* self) {
    return new QFont(self->selectedFont());
}

libqt_string QCPItemText_Text(const QCPItemText* self) {
    QString _ret = self->text();
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

int QCPItemText_PositionAlignment(const QCPItemText* self) {
    return static_cast<int>(self->positionAlignment());
}

int QCPItemText_TextAlignment(const QCPItemText* self) {
    return static_cast<int>(self->textAlignment());
}

double QCPItemText_Rotation(const QCPItemText* self) {
    return self->rotation();
}

QMargins* QCPItemText_Padding(const QCPItemText* self) {
    return new QMargins(self->padding());
}

void QCPItemText_SetColor(QCPItemText* self, const QColor* color) {
    self->setColor(*color);
}

void QCPItemText_SetSelectedColor(QCPItemText* self, const QColor* color) {
    self->setSelectedColor(*color);
}

void QCPItemText_SetPen(QCPItemText* self, const QPen* pen) {
    self->setPen(*pen);
}

void QCPItemText_SetSelectedPen(QCPItemText* self, const QPen* pen) {
    self->setSelectedPen(*pen);
}

void QCPItemText_SetBrush(QCPItemText* self, const QBrush* brush) {
    self->setBrush(*brush);
}

void QCPItemText_SetSelectedBrush(QCPItemText* self, const QBrush* brush) {
    self->setSelectedBrush(*brush);
}

void QCPItemText_SetFont(QCPItemText* self, const QFont* font) {
    self->setFont(*font);
}

void QCPItemText_SetSelectedFont(QCPItemText* self, const QFont* font) {
    self->setSelectedFont(*font);
}

void QCPItemText_SetText(QCPItemText* self, const libqt_string text) {
    QString text_QString = QString::fromUtf8(text.data, text.len);
    self->setText(text_QString);
}

void QCPItemText_SetPositionAlignment(QCPItemText* self, int alignment) {
    self->setPositionAlignment(static_cast<Qt::Alignment>(alignment));
}

void QCPItemText_SetTextAlignment(QCPItemText* self, int alignment) {
    self->setTextAlignment(static_cast<Qt::Alignment>(alignment));
}

void QCPItemText_SetRotation(QCPItemText* self, double degrees) {
    self->setRotation(static_cast<double>(degrees));
}

void QCPItemText_SetPadding(QCPItemText* self, const QMargins* padding) {
    self->setPadding(*padding);
}

double QCPItemText_SelectTest(const QCPItemText* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpitemtext = dynamic_cast<const VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPItemText*)self)->selectTest(*pos, onlySelectable, details);
    }
}

QCPItemPosition* QCPItemText_Position(const QCPItemText* self) {
    return (QCPItemPosition*)self->position;
}

QCPItemAnchor* QCPItemText_TopLeft(const QCPItemText* self) {
    return (QCPItemAnchor*)self->topLeft;
}

QCPItemAnchor* QCPItemText_Top(const QCPItemText* self) {
    return (QCPItemAnchor*)self->top;
}

QCPItemAnchor* QCPItemText_TopRight(const QCPItemText* self) {
    return (QCPItemAnchor*)self->topRight;
}

QCPItemAnchor* QCPItemText_Right(const QCPItemText* self) {
    return (QCPItemAnchor*)self->right;
}

QCPItemAnchor* QCPItemText_BottomRight(const QCPItemText* self) {
    return (QCPItemAnchor*)self->bottomRight;
}

QCPItemAnchor* QCPItemText_Bottom(const QCPItemText* self) {
    return (QCPItemAnchor*)self->bottom;
}

QCPItemAnchor* QCPItemText_BottomLeft(const QCPItemText* self) {
    return (QCPItemAnchor*)self->bottomLeft;
}

QCPItemAnchor* QCPItemText_Left(const QCPItemText* self) {
    return (QCPItemAnchor*)self->left;
}

void QCPItemText_Draw(QCPItemText* self, QCPPainter* painter) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->draw(painter);
    }
}

QPointF* QCPItemText_AnchorPixelPosition(const QCPItemText* self, int anchorId) {
    auto* vqcpitemtext = dynamic_cast<const VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        return new QPointF(vqcpitemtext->anchorPixelPosition(static_cast<int>(anchorId)));
    }
    return {};
}

libqt_string QCPItemText_Tr2(const char* s, const char* c) {
    QString _ret = QCPItemText::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPItemText_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPItemText::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPItemText_QBaseMetacall(QCPItemText* self, int param1, int param2, void** param3) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_Metacall_IsBase(true);
        return vqcpitemtext->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPItemText::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnMetacall(QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_Metacall_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
double QCPItemText_QBaseSelectTest(const QCPItemText* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_SelectTest_IsBase(true);
        return vqcpitemtext->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPItemText::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnSelectTest(const QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_SelectTest_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
void QCPItemText_QBaseDraw(QCPItemText* self, QCPPainter* painter) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_Draw_IsBase(true);
        vqcpitemtext->draw(painter);
    } else {
        ((VirtualQCPItemText*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnDraw(QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_Draw_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_Draw_Callback>(slot));
    }
}

// Base class handler implementation
QPointF* QCPItemText_QBaseAnchorPixelPosition(const QCPItemText* self, int anchorId) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_AnchorPixelPosition_IsBase(true);
        return new QPointF(vqcpitemtext->anchorPixelPosition(static_cast<int>(anchorId)));
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnAnchorPixelPosition(const QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_AnchorPixelPosition_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_AnchorPixelPosition_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemText_SelectionCategory(const QCPItemText* self) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        return static_cast<int>(vqcpitemtext->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPItemText*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPItemText_QBaseSelectionCategory(const QCPItemText* self) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcpitemtext->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPItemText*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnSelectionCategory(const QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_SelectionCategory_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPItemText_ClipRect(const QCPItemText* self) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        return new QRect(vqcpitemtext->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPItemText_QBaseClipRect(const QCPItemText* self) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_ClipRect_IsBase(true);
        return new QRect(vqcpitemtext->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnClipRect(const QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_ClipRect_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemText_ApplyDefaultAntialiasingHint(const QCPItemText* self, QCPPainter* painter) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPItemText*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPItemText_QBaseApplyDefaultAntialiasingHint(const QCPItemText* self, QCPPainter* painter) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcpitemtext->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPItemText*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnApplyDefaultAntialiasingHint(const QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemText_SelectEvent(QCPItemText* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPItemText*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPItemText_QBaseSelectEvent(QCPItemText* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_SelectEvent_IsBase(true);
        vqcpitemtext->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPItemText*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnSelectEvent(QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_SelectEvent_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemText_DeselectEvent(QCPItemText* self, bool* selectionStateChanged) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPItemText*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPItemText_QBaseDeselectEvent(QCPItemText* self, bool* selectionStateChanged) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_DeselectEvent_IsBase(true);
        vqcpitemtext->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPItemText*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnDeselectEvent(QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_DeselectEvent_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemText_ParentPlotInitialized(QCPItemText* self, QCustomPlot* parentPlot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPItemText*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPItemText_QBaseParentPlotInitialized(QCPItemText* self, QCustomPlot* parentPlot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_ParentPlotInitialized_IsBase(true);
        vqcpitemtext->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPItemText*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnParentPlotInitialized(QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemText_MousePressEvent(QCPItemText* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPItemText*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPItemText_QBaseMousePressEvent(QCPItemText* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_MousePressEvent_IsBase(true);
        vqcpitemtext->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPItemText*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnMousePressEvent(QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_MousePressEvent_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemText_MouseMoveEvent(QCPItemText* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPItemText*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPItemText_QBaseMouseMoveEvent(QCPItemText* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_MouseMoveEvent_IsBase(true);
        vqcpitemtext->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPItemText*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnMouseMoveEvent(QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemText_MouseReleaseEvent(QCPItemText* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPItemText*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPItemText_QBaseMouseReleaseEvent(QCPItemText* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_MouseReleaseEvent_IsBase(true);
        vqcpitemtext->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPItemText*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnMouseReleaseEvent(QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemText_MouseDoubleClickEvent(QCPItemText* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPItemText*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPItemText_QBaseMouseDoubleClickEvent(QCPItemText* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_MouseDoubleClickEvent_IsBase(true);
        vqcpitemtext->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPItemText*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnMouseDoubleClickEvent(QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemText_WheelEvent(QCPItemText* self, QWheelEvent* event) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->wheelEvent(event);
    } else {
        ((VirtualQCPItemText*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPItemText_QBaseWheelEvent(QCPItemText* self, QWheelEvent* event) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_WheelEvent_IsBase(true);
        vqcpitemtext->wheelEvent(event);
    } else {
        ((VirtualQCPItemText*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnWheelEvent(QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_WheelEvent_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemText_Event(QCPItemText* self, QEvent* event) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        return vqcpitemtext->event(event);
    } else {
        return self->QCPItemText::event(event);
    }
}

// Base class handler implementation
bool QCPItemText_QBaseEvent(QCPItemText* self, QEvent* event) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_Event_IsBase(true);
        return vqcpitemtext->event(event);
    } else {
        return self->QCPItemText::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnEvent(QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_Event_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemText_EventFilter(QCPItemText* self, QObject* watched, QEvent* event) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        return vqcpitemtext->eventFilter(watched, event);
    } else {
        return self->QCPItemText::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPItemText_QBaseEventFilter(QCPItemText* self, QObject* watched, QEvent* event) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_EventFilter_IsBase(true);
        return vqcpitemtext->eventFilter(watched, event);
    } else {
        return self->QCPItemText::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnEventFilter(QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_EventFilter_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemText_TimerEvent(QCPItemText* self, QTimerEvent* event) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->timerEvent(event);
    } else {
        ((VirtualQCPItemText*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPItemText_QBaseTimerEvent(QCPItemText* self, QTimerEvent* event) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_TimerEvent_IsBase(true);
        vqcpitemtext->timerEvent(event);
    } else {
        ((VirtualQCPItemText*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnTimerEvent(QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_TimerEvent_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemText_ChildEvent(QCPItemText* self, QChildEvent* event) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->childEvent(event);
    } else {
        ((VirtualQCPItemText*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPItemText_QBaseChildEvent(QCPItemText* self, QChildEvent* event) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_ChildEvent_IsBase(true);
        vqcpitemtext->childEvent(event);
    } else {
        ((VirtualQCPItemText*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnChildEvent(QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_ChildEvent_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemText_CustomEvent(QCPItemText* self, QEvent* event) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->customEvent(event);
    } else {
        ((VirtualQCPItemText*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPItemText_QBaseCustomEvent(QCPItemText* self, QEvent* event) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_CustomEvent_IsBase(true);
        vqcpitemtext->customEvent(event);
    } else {
        ((VirtualQCPItemText*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnCustomEvent(QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_CustomEvent_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemText_ConnectNotify(QCPItemText* self, const QMetaMethod* signal) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->connectNotify(*signal);
    } else {
        ((VirtualQCPItemText*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPItemText_QBaseConnectNotify(QCPItemText* self, const QMetaMethod* signal) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_ConnectNotify_IsBase(true);
        vqcpitemtext->connectNotify(*signal);
    } else {
        ((VirtualQCPItemText*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnConnectNotify(QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_ConnectNotify_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemText_DisconnectNotify(QCPItemText* self, const QMetaMethod* signal) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->disconnectNotify(*signal);
    } else {
        ((VirtualQCPItemText*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPItemText_QBaseDisconnectNotify(QCPItemText* self, const QMetaMethod* signal) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_DisconnectNotify_IsBase(true);
        vqcpitemtext->disconnectNotify(*signal);
    } else {
        ((VirtualQCPItemText*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnDisconnectNotify(QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
QPointF* QCPItemText_GetTextDrawPoint(const QCPItemText* self, const QPointF* pos, const QRectF* rect, int positionAlignment) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        return new QPointF(vqcpitemtext->getTextDrawPoint(*pos, *rect, static_cast<Qt::Alignment>(positionAlignment)));
    }
    return {};
}

// Base class handler implementation
QPointF* QCPItemText_QBaseGetTextDrawPoint(const QCPItemText* self, const QPointF* pos, const QRectF* rect, int positionAlignment) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_GetTextDrawPoint_IsBase(true);
        return new QPointF(vqcpitemtext->getTextDrawPoint(*pos, *rect, static_cast<Qt::Alignment>(positionAlignment)));
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnGetTextDrawPoint(const QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_GetTextDrawPoint_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_GetTextDrawPoint_Callback>(slot));
    }
}

// Derived class handler implementation
QFont* QCPItemText_MainFont(const QCPItemText* self) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        return new QFont(vqcpitemtext->mainFont());
    }
    return {};
}

// Base class handler implementation
QFont* QCPItemText_QBaseMainFont(const QCPItemText* self) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_MainFont_IsBase(true);
        return new QFont(vqcpitemtext->mainFont());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnMainFont(const QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_MainFont_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_MainFont_Callback>(slot));
    }
}

// Derived class handler implementation
QColor* QCPItemText_MainColor(const QCPItemText* self) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        return new QColor(vqcpitemtext->mainColor());
    }
    return {};
}

// Base class handler implementation
QColor* QCPItemText_QBaseMainColor(const QCPItemText* self) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_MainColor_IsBase(true);
        return new QColor(vqcpitemtext->mainColor());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnMainColor(const QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_MainColor_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_MainColor_Callback>(slot));
    }
}

// Derived class handler implementation
QPen* QCPItemText_MainPen(const QCPItemText* self) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        return new QPen(vqcpitemtext->mainPen());
    }
    return {};
}

// Base class handler implementation
QPen* QCPItemText_QBaseMainPen(const QCPItemText* self) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_MainPen_IsBase(true);
        return new QPen(vqcpitemtext->mainPen());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnMainPen(const QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_MainPen_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_MainPen_Callback>(slot));
    }
}

// Derived class handler implementation
QBrush* QCPItemText_MainBrush(const QCPItemText* self) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        return new QBrush(vqcpitemtext->mainBrush());
    }
    return {};
}

// Base class handler implementation
QBrush* QCPItemText_QBaseMainBrush(const QCPItemText* self) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_MainBrush_IsBase(true);
        return new QBrush(vqcpitemtext->mainBrush());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnMainBrush(const QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_MainBrush_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_MainBrush_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPItemText_RectDistance(const QCPItemText* self, const QRectF* rect, const QPointF* pos, bool filledRect) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        return vqcpitemtext->rectDistance(*rect, *pos, filledRect);
    } else {
        return ((VirtualQCPItemText*)self)->rectDistance(*rect, *pos, filledRect);
    }
}

// Base class handler implementation
double QCPItemText_QBaseRectDistance(const QCPItemText* self, const QRectF* rect, const QPointF* pos, bool filledRect) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_RectDistance_IsBase(true);
        return vqcpitemtext->rectDistance(*rect, *pos, filledRect);
    } else {
        return ((VirtualQCPItemText*)self)->rectDistance(*rect, *pos, filledRect);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnRectDistance(const QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_RectDistance_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_RectDistance_Callback>(slot));
    }
}

// Derived class handler implementation
QCPItemPosition* QCPItemText_CreatePosition(QCPItemText* self, const libqt_string name) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        return vqcpitemtext->createPosition(name_QString);
    } else {
        return ((VirtualQCPItemText*)self)->createPosition(name_QString);
    }
}

// Base class handler implementation
QCPItemPosition* QCPItemText_QBaseCreatePosition(QCPItemText* self, const libqt_string name) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_CreatePosition_IsBase(true);
        return vqcpitemtext->createPosition(name_QString);
    } else {
        return ((VirtualQCPItemText*)self)->createPosition(name_QString);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnCreatePosition(QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_CreatePosition_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_CreatePosition_Callback>(slot));
    }
}

// Derived class handler implementation
QCPItemAnchor* QCPItemText_CreateAnchor(QCPItemText* self, const libqt_string name, int anchorId) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        return vqcpitemtext->createAnchor(name_QString, static_cast<int>(anchorId));
    } else {
        return ((VirtualQCPItemText*)self)->createAnchor(name_QString, static_cast<int>(anchorId));
    }
}

// Base class handler implementation
QCPItemAnchor* QCPItemText_QBaseCreateAnchor(QCPItemText* self, const libqt_string name, int anchorId) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_CreateAnchor_IsBase(true);
        return vqcpitemtext->createAnchor(name_QString, static_cast<int>(anchorId));
    } else {
        return ((VirtualQCPItemText*)self)->createAnchor(name_QString, static_cast<int>(anchorId));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnCreateAnchor(QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_CreateAnchor_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_CreateAnchor_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemText_InitializeParentPlot(QCPItemText* self, QCustomPlot* parentPlot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPItemText*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPItemText_QBaseInitializeParentPlot(QCPItemText* self, QCustomPlot* parentPlot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_InitializeParentPlot_IsBase(true);
        vqcpitemtext->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPItemText*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnInitializeParentPlot(QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemText_SetParentLayerable(QCPItemText* self, QCPLayerable* parentLayerable) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPItemText*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPItemText_QBaseSetParentLayerable(QCPItemText* self, QCPLayerable* parentLayerable) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_SetParentLayerable_IsBase(true);
        vqcpitemtext->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPItemText*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnSetParentLayerable(QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemText_MoveToLayer(QCPItemText* self, QCPLayer* layer, bool prepend) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        return vqcpitemtext->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPItemText*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPItemText_QBaseMoveToLayer(QCPItemText* self, QCPLayer* layer, bool prepend) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_MoveToLayer_IsBase(true);
        return vqcpitemtext->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPItemText*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnMoveToLayer(QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = dynamic_cast<VirtualQCPItemText*>(self);
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_MoveToLayer_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemText_ApplyAntialiasingHint(const QCPItemText* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPItemText*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPItemText_QBaseApplyAntialiasingHint(const QCPItemText* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_ApplyAntialiasingHint_IsBase(true);
        vqcpitemtext->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPItemText*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnApplyAntialiasingHint(const QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPItemText_Sender(const QCPItemText* self) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        return vqcpitemtext->sender();
    } else {
        return ((VirtualQCPItemText*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPItemText_QBaseSender(const QCPItemText* self) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_Sender_IsBase(true);
        return vqcpitemtext->sender();
    } else {
        return ((VirtualQCPItemText*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnSender(const QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_Sender_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemText_SenderSignalIndex(const QCPItemText* self) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        return vqcpitemtext->senderSignalIndex();
    } else {
        return ((VirtualQCPItemText*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPItemText_QBaseSenderSignalIndex(const QCPItemText* self) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_SenderSignalIndex_IsBase(true);
        return vqcpitemtext->senderSignalIndex();
    } else {
        return ((VirtualQCPItemText*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnSenderSignalIndex(const QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemText_Receivers(const QCPItemText* self, const char* signal) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        return vqcpitemtext->receivers(signal);
    } else {
        return ((VirtualQCPItemText*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPItemText_QBaseReceivers(const QCPItemText* self, const char* signal) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_Receivers_IsBase(true);
        return vqcpitemtext->receivers(signal);
    } else {
        return ((VirtualQCPItemText*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnReceivers(const QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_Receivers_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemText_IsSignalConnected(const QCPItemText* self, const QMetaMethod* signal) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        return vqcpitemtext->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPItemText*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPItemText_QBaseIsSignalConnected(const QCPItemText* self, const QMetaMethod* signal) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_IsSignalConnected_IsBase(true);
        return vqcpitemtext->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPItemText*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemText_OnIsSignalConnected(const QCPItemText* self, intptr_t slot) {
    auto* vqcpitemtext = const_cast<VirtualQCPItemText*>(dynamic_cast<const VirtualQCPItemText*>(self));
    if (vqcpitemtext && vqcpitemtext->isVirtualQCPItemText) {
        vqcpitemtext->setQCPItemText_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPItemText::QCPItemText_IsSignalConnected_Callback>(slot));
    }
}

void QCPItemText_Delete(QCPItemText* self) {
    delete self;
}

QCPItemEllipse* QCPItemEllipse_new(QCustomPlot* parentPlot) {
    return new VirtualQCPItemEllipse(parentPlot);
}

QMetaObject* QCPItemEllipse_MetaObject(const QCPItemEllipse* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPItemEllipse_Metacast(QCPItemEllipse* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPItemEllipse_Metacall(QCPItemEllipse* self, int param1, int param2, void** param3) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPItemEllipse*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPItemEllipse_Tr(const char* s) {
    QString _ret = QCPItemEllipse::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

QPen* QCPItemEllipse_Pen(const QCPItemEllipse* self) {
    return new QPen(self->pen());
}

QPen* QCPItemEllipse_SelectedPen(const QCPItemEllipse* self) {
    return new QPen(self->selectedPen());
}

QBrush* QCPItemEllipse_Brush(const QCPItemEllipse* self) {
    return new QBrush(self->brush());
}

QBrush* QCPItemEllipse_SelectedBrush(const QCPItemEllipse* self) {
    return new QBrush(self->selectedBrush());
}

void QCPItemEllipse_SetPen(QCPItemEllipse* self, const QPen* pen) {
    self->setPen(*pen);
}

void QCPItemEllipse_SetSelectedPen(QCPItemEllipse* self, const QPen* pen) {
    self->setSelectedPen(*pen);
}

void QCPItemEllipse_SetBrush(QCPItemEllipse* self, const QBrush* brush) {
    self->setBrush(*brush);
}

void QCPItemEllipse_SetSelectedBrush(QCPItemEllipse* self, const QBrush* brush) {
    self->setSelectedBrush(*brush);
}

double QCPItemEllipse_SelectTest(const QCPItemEllipse* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpitemellipse = dynamic_cast<const VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPItemEllipse*)self)->selectTest(*pos, onlySelectable, details);
    }
}

QCPItemPosition* QCPItemEllipse_TopLeft(const QCPItemEllipse* self) {
    return (QCPItemPosition*)self->topLeft;
}

QCPItemPosition* QCPItemEllipse_BottomRight(const QCPItemEllipse* self) {
    return (QCPItemPosition*)self->bottomRight;
}

QCPItemAnchor* QCPItemEllipse_TopLeftRim(const QCPItemEllipse* self) {
    return (QCPItemAnchor*)self->topLeftRim;
}

QCPItemAnchor* QCPItemEllipse_Top(const QCPItemEllipse* self) {
    return (QCPItemAnchor*)self->top;
}

QCPItemAnchor* QCPItemEllipse_TopRightRim(const QCPItemEllipse* self) {
    return (QCPItemAnchor*)self->topRightRim;
}

QCPItemAnchor* QCPItemEllipse_Right(const QCPItemEllipse* self) {
    return (QCPItemAnchor*)self->right;
}

QCPItemAnchor* QCPItemEllipse_BottomRightRim(const QCPItemEllipse* self) {
    return (QCPItemAnchor*)self->bottomRightRim;
}

QCPItemAnchor* QCPItemEllipse_Bottom(const QCPItemEllipse* self) {
    return (QCPItemAnchor*)self->bottom;
}

QCPItemAnchor* QCPItemEllipse_BottomLeftRim(const QCPItemEllipse* self) {
    return (QCPItemAnchor*)self->bottomLeftRim;
}

QCPItemAnchor* QCPItemEllipse_Left(const QCPItemEllipse* self) {
    return (QCPItemAnchor*)self->left;
}

QCPItemAnchor* QCPItemEllipse_Center(const QCPItemEllipse* self) {
    return (QCPItemAnchor*)self->center;
}

void QCPItemEllipse_Draw(QCPItemEllipse* self, QCPPainter* painter) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->draw(painter);
    }
}

QPointF* QCPItemEllipse_AnchorPixelPosition(const QCPItemEllipse* self, int anchorId) {
    auto* vqcpitemellipse = dynamic_cast<const VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        return new QPointF(vqcpitemellipse->anchorPixelPosition(static_cast<int>(anchorId)));
    }
    return {};
}

libqt_string QCPItemEllipse_Tr2(const char* s, const char* c) {
    QString _ret = QCPItemEllipse::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPItemEllipse_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPItemEllipse::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPItemEllipse_QBaseMetacall(QCPItemEllipse* self, int param1, int param2, void** param3) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_Metacall_IsBase(true);
        return vqcpitemellipse->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPItemEllipse::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnMetacall(QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_Metacall_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
double QCPItemEllipse_QBaseSelectTest(const QCPItemEllipse* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_SelectTest_IsBase(true);
        return vqcpitemellipse->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPItemEllipse::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnSelectTest(const QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_SelectTest_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
void QCPItemEllipse_QBaseDraw(QCPItemEllipse* self, QCPPainter* painter) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_Draw_IsBase(true);
        vqcpitemellipse->draw(painter);
    } else {
        ((VirtualQCPItemEllipse*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnDraw(QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_Draw_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_Draw_Callback>(slot));
    }
}

// Base class handler implementation
QPointF* QCPItemEllipse_QBaseAnchorPixelPosition(const QCPItemEllipse* self, int anchorId) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_AnchorPixelPosition_IsBase(true);
        return new QPointF(vqcpitemellipse->anchorPixelPosition(static_cast<int>(anchorId)));
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnAnchorPixelPosition(const QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_AnchorPixelPosition_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_AnchorPixelPosition_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemEllipse_SelectionCategory(const QCPItemEllipse* self) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        return static_cast<int>(vqcpitemellipse->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPItemEllipse*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPItemEllipse_QBaseSelectionCategory(const QCPItemEllipse* self) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcpitemellipse->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPItemEllipse*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnSelectionCategory(const QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_SelectionCategory_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPItemEllipse_ClipRect(const QCPItemEllipse* self) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        return new QRect(vqcpitemellipse->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPItemEllipse_QBaseClipRect(const QCPItemEllipse* self) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_ClipRect_IsBase(true);
        return new QRect(vqcpitemellipse->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnClipRect(const QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_ClipRect_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemEllipse_ApplyDefaultAntialiasingHint(const QCPItemEllipse* self, QCPPainter* painter) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPItemEllipse*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPItemEllipse_QBaseApplyDefaultAntialiasingHint(const QCPItemEllipse* self, QCPPainter* painter) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcpitemellipse->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPItemEllipse*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnApplyDefaultAntialiasingHint(const QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemEllipse_SelectEvent(QCPItemEllipse* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPItemEllipse*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPItemEllipse_QBaseSelectEvent(QCPItemEllipse* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_SelectEvent_IsBase(true);
        vqcpitemellipse->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPItemEllipse*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnSelectEvent(QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_SelectEvent_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemEllipse_DeselectEvent(QCPItemEllipse* self, bool* selectionStateChanged) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPItemEllipse*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPItemEllipse_QBaseDeselectEvent(QCPItemEllipse* self, bool* selectionStateChanged) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_DeselectEvent_IsBase(true);
        vqcpitemellipse->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPItemEllipse*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnDeselectEvent(QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_DeselectEvent_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemEllipse_ParentPlotInitialized(QCPItemEllipse* self, QCustomPlot* parentPlot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPItemEllipse*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPItemEllipse_QBaseParentPlotInitialized(QCPItemEllipse* self, QCustomPlot* parentPlot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_ParentPlotInitialized_IsBase(true);
        vqcpitemellipse->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPItemEllipse*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnParentPlotInitialized(QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemEllipse_MousePressEvent(QCPItemEllipse* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPItemEllipse*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPItemEllipse_QBaseMousePressEvent(QCPItemEllipse* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_MousePressEvent_IsBase(true);
        vqcpitemellipse->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPItemEllipse*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnMousePressEvent(QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_MousePressEvent_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemEllipse_MouseMoveEvent(QCPItemEllipse* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPItemEllipse*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPItemEllipse_QBaseMouseMoveEvent(QCPItemEllipse* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_MouseMoveEvent_IsBase(true);
        vqcpitemellipse->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPItemEllipse*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnMouseMoveEvent(QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemEllipse_MouseReleaseEvent(QCPItemEllipse* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPItemEllipse*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPItemEllipse_QBaseMouseReleaseEvent(QCPItemEllipse* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_MouseReleaseEvent_IsBase(true);
        vqcpitemellipse->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPItemEllipse*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnMouseReleaseEvent(QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemEllipse_MouseDoubleClickEvent(QCPItemEllipse* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPItemEllipse*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPItemEllipse_QBaseMouseDoubleClickEvent(QCPItemEllipse* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_MouseDoubleClickEvent_IsBase(true);
        vqcpitemellipse->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPItemEllipse*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnMouseDoubleClickEvent(QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemEllipse_WheelEvent(QCPItemEllipse* self, QWheelEvent* event) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->wheelEvent(event);
    } else {
        ((VirtualQCPItemEllipse*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPItemEllipse_QBaseWheelEvent(QCPItemEllipse* self, QWheelEvent* event) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_WheelEvent_IsBase(true);
        vqcpitemellipse->wheelEvent(event);
    } else {
        ((VirtualQCPItemEllipse*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnWheelEvent(QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_WheelEvent_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemEllipse_Event(QCPItemEllipse* self, QEvent* event) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        return vqcpitemellipse->event(event);
    } else {
        return self->QCPItemEllipse::event(event);
    }
}

// Base class handler implementation
bool QCPItemEllipse_QBaseEvent(QCPItemEllipse* self, QEvent* event) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_Event_IsBase(true);
        return vqcpitemellipse->event(event);
    } else {
        return self->QCPItemEllipse::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnEvent(QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_Event_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemEllipse_EventFilter(QCPItemEllipse* self, QObject* watched, QEvent* event) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        return vqcpitemellipse->eventFilter(watched, event);
    } else {
        return self->QCPItemEllipse::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPItemEllipse_QBaseEventFilter(QCPItemEllipse* self, QObject* watched, QEvent* event) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_EventFilter_IsBase(true);
        return vqcpitemellipse->eventFilter(watched, event);
    } else {
        return self->QCPItemEllipse::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnEventFilter(QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_EventFilter_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemEllipse_TimerEvent(QCPItemEllipse* self, QTimerEvent* event) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->timerEvent(event);
    } else {
        ((VirtualQCPItemEllipse*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPItemEllipse_QBaseTimerEvent(QCPItemEllipse* self, QTimerEvent* event) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_TimerEvent_IsBase(true);
        vqcpitemellipse->timerEvent(event);
    } else {
        ((VirtualQCPItemEllipse*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnTimerEvent(QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_TimerEvent_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemEllipse_ChildEvent(QCPItemEllipse* self, QChildEvent* event) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->childEvent(event);
    } else {
        ((VirtualQCPItemEllipse*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPItemEllipse_QBaseChildEvent(QCPItemEllipse* self, QChildEvent* event) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_ChildEvent_IsBase(true);
        vqcpitemellipse->childEvent(event);
    } else {
        ((VirtualQCPItemEllipse*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnChildEvent(QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_ChildEvent_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemEllipse_CustomEvent(QCPItemEllipse* self, QEvent* event) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->customEvent(event);
    } else {
        ((VirtualQCPItemEllipse*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPItemEllipse_QBaseCustomEvent(QCPItemEllipse* self, QEvent* event) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_CustomEvent_IsBase(true);
        vqcpitemellipse->customEvent(event);
    } else {
        ((VirtualQCPItemEllipse*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnCustomEvent(QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_CustomEvent_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemEllipse_ConnectNotify(QCPItemEllipse* self, const QMetaMethod* signal) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->connectNotify(*signal);
    } else {
        ((VirtualQCPItemEllipse*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPItemEllipse_QBaseConnectNotify(QCPItemEllipse* self, const QMetaMethod* signal) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_ConnectNotify_IsBase(true);
        vqcpitemellipse->connectNotify(*signal);
    } else {
        ((VirtualQCPItemEllipse*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnConnectNotify(QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_ConnectNotify_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemEllipse_DisconnectNotify(QCPItemEllipse* self, const QMetaMethod* signal) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->disconnectNotify(*signal);
    } else {
        ((VirtualQCPItemEllipse*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPItemEllipse_QBaseDisconnectNotify(QCPItemEllipse* self, const QMetaMethod* signal) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_DisconnectNotify_IsBase(true);
        vqcpitemellipse->disconnectNotify(*signal);
    } else {
        ((VirtualQCPItemEllipse*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnDisconnectNotify(QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
QPen* QCPItemEllipse_MainPen(const QCPItemEllipse* self) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        return new QPen(vqcpitemellipse->mainPen());
    }
    return {};
}

// Base class handler implementation
QPen* QCPItemEllipse_QBaseMainPen(const QCPItemEllipse* self) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_MainPen_IsBase(true);
        return new QPen(vqcpitemellipse->mainPen());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnMainPen(const QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_MainPen_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_MainPen_Callback>(slot));
    }
}

// Derived class handler implementation
QBrush* QCPItemEllipse_MainBrush(const QCPItemEllipse* self) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        return new QBrush(vqcpitemellipse->mainBrush());
    }
    return {};
}

// Base class handler implementation
QBrush* QCPItemEllipse_QBaseMainBrush(const QCPItemEllipse* self) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_MainBrush_IsBase(true);
        return new QBrush(vqcpitemellipse->mainBrush());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnMainBrush(const QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_MainBrush_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_MainBrush_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPItemEllipse_RectDistance(const QCPItemEllipse* self, const QRectF* rect, const QPointF* pos, bool filledRect) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        return vqcpitemellipse->rectDistance(*rect, *pos, filledRect);
    } else {
        return ((VirtualQCPItemEllipse*)self)->rectDistance(*rect, *pos, filledRect);
    }
}

// Base class handler implementation
double QCPItemEllipse_QBaseRectDistance(const QCPItemEllipse* self, const QRectF* rect, const QPointF* pos, bool filledRect) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_RectDistance_IsBase(true);
        return vqcpitemellipse->rectDistance(*rect, *pos, filledRect);
    } else {
        return ((VirtualQCPItemEllipse*)self)->rectDistance(*rect, *pos, filledRect);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnRectDistance(const QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_RectDistance_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_RectDistance_Callback>(slot));
    }
}

// Derived class handler implementation
QCPItemPosition* QCPItemEllipse_CreatePosition(QCPItemEllipse* self, const libqt_string name) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        return vqcpitemellipse->createPosition(name_QString);
    } else {
        return ((VirtualQCPItemEllipse*)self)->createPosition(name_QString);
    }
}

// Base class handler implementation
QCPItemPosition* QCPItemEllipse_QBaseCreatePosition(QCPItemEllipse* self, const libqt_string name) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_CreatePosition_IsBase(true);
        return vqcpitemellipse->createPosition(name_QString);
    } else {
        return ((VirtualQCPItemEllipse*)self)->createPosition(name_QString);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnCreatePosition(QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_CreatePosition_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_CreatePosition_Callback>(slot));
    }
}

// Derived class handler implementation
QCPItemAnchor* QCPItemEllipse_CreateAnchor(QCPItemEllipse* self, const libqt_string name, int anchorId) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        return vqcpitemellipse->createAnchor(name_QString, static_cast<int>(anchorId));
    } else {
        return ((VirtualQCPItemEllipse*)self)->createAnchor(name_QString, static_cast<int>(anchorId));
    }
}

// Base class handler implementation
QCPItemAnchor* QCPItemEllipse_QBaseCreateAnchor(QCPItemEllipse* self, const libqt_string name, int anchorId) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_CreateAnchor_IsBase(true);
        return vqcpitemellipse->createAnchor(name_QString, static_cast<int>(anchorId));
    } else {
        return ((VirtualQCPItemEllipse*)self)->createAnchor(name_QString, static_cast<int>(anchorId));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnCreateAnchor(QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_CreateAnchor_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_CreateAnchor_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemEllipse_InitializeParentPlot(QCPItemEllipse* self, QCustomPlot* parentPlot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPItemEllipse*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPItemEllipse_QBaseInitializeParentPlot(QCPItemEllipse* self, QCustomPlot* parentPlot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_InitializeParentPlot_IsBase(true);
        vqcpitemellipse->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPItemEllipse*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnInitializeParentPlot(QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemEllipse_SetParentLayerable(QCPItemEllipse* self, QCPLayerable* parentLayerable) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPItemEllipse*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPItemEllipse_QBaseSetParentLayerable(QCPItemEllipse* self, QCPLayerable* parentLayerable) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_SetParentLayerable_IsBase(true);
        vqcpitemellipse->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPItemEllipse*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnSetParentLayerable(QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemEllipse_MoveToLayer(QCPItemEllipse* self, QCPLayer* layer, bool prepend) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        return vqcpitemellipse->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPItemEllipse*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPItemEllipse_QBaseMoveToLayer(QCPItemEllipse* self, QCPLayer* layer, bool prepend) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_MoveToLayer_IsBase(true);
        return vqcpitemellipse->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPItemEllipse*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnMoveToLayer(QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = dynamic_cast<VirtualQCPItemEllipse*>(self);
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_MoveToLayer_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemEllipse_ApplyAntialiasingHint(const QCPItemEllipse* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPItemEllipse*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPItemEllipse_QBaseApplyAntialiasingHint(const QCPItemEllipse* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_ApplyAntialiasingHint_IsBase(true);
        vqcpitemellipse->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPItemEllipse*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnApplyAntialiasingHint(const QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPItemEllipse_Sender(const QCPItemEllipse* self) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        return vqcpitemellipse->sender();
    } else {
        return ((VirtualQCPItemEllipse*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPItemEllipse_QBaseSender(const QCPItemEllipse* self) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_Sender_IsBase(true);
        return vqcpitemellipse->sender();
    } else {
        return ((VirtualQCPItemEllipse*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnSender(const QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_Sender_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemEllipse_SenderSignalIndex(const QCPItemEllipse* self) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        return vqcpitemellipse->senderSignalIndex();
    } else {
        return ((VirtualQCPItemEllipse*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPItemEllipse_QBaseSenderSignalIndex(const QCPItemEllipse* self) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_SenderSignalIndex_IsBase(true);
        return vqcpitemellipse->senderSignalIndex();
    } else {
        return ((VirtualQCPItemEllipse*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnSenderSignalIndex(const QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemEllipse_Receivers(const QCPItemEllipse* self, const char* signal) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        return vqcpitemellipse->receivers(signal);
    } else {
        return ((VirtualQCPItemEllipse*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPItemEllipse_QBaseReceivers(const QCPItemEllipse* self, const char* signal) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_Receivers_IsBase(true);
        return vqcpitemellipse->receivers(signal);
    } else {
        return ((VirtualQCPItemEllipse*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnReceivers(const QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_Receivers_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemEllipse_IsSignalConnected(const QCPItemEllipse* self, const QMetaMethod* signal) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        return vqcpitemellipse->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPItemEllipse*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPItemEllipse_QBaseIsSignalConnected(const QCPItemEllipse* self, const QMetaMethod* signal) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_IsSignalConnected_IsBase(true);
        return vqcpitemellipse->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPItemEllipse*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemEllipse_OnIsSignalConnected(const QCPItemEllipse* self, intptr_t slot) {
    auto* vqcpitemellipse = const_cast<VirtualQCPItemEllipse*>(dynamic_cast<const VirtualQCPItemEllipse*>(self));
    if (vqcpitemellipse && vqcpitemellipse->isVirtualQCPItemEllipse) {
        vqcpitemellipse->setQCPItemEllipse_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPItemEllipse::QCPItemEllipse_IsSignalConnected_Callback>(slot));
    }
}

void QCPItemEllipse_Delete(QCPItemEllipse* self) {
    delete self;
}

QCPItemPixmap* QCPItemPixmap_new(QCustomPlot* parentPlot) {
    return new VirtualQCPItemPixmap(parentPlot);
}

QMetaObject* QCPItemPixmap_MetaObject(const QCPItemPixmap* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPItemPixmap_Metacast(QCPItemPixmap* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPItemPixmap_Metacall(QCPItemPixmap* self, int param1, int param2, void** param3) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPItemPixmap*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPItemPixmap_Tr(const char* s) {
    QString _ret = QCPItemPixmap::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

QPixmap* QCPItemPixmap_Pixmap(const QCPItemPixmap* self) {
    return new QPixmap(self->pixmap());
}

bool QCPItemPixmap_Scaled(const QCPItemPixmap* self) {
    return self->scaled();
}

int QCPItemPixmap_AspectRatioMode(const QCPItemPixmap* self) {
    return static_cast<int>(self->aspectRatioMode());
}

int QCPItemPixmap_TransformationMode(const QCPItemPixmap* self) {
    return static_cast<int>(self->transformationMode());
}

QPen* QCPItemPixmap_Pen(const QCPItemPixmap* self) {
    return new QPen(self->pen());
}

QPen* QCPItemPixmap_SelectedPen(const QCPItemPixmap* self) {
    return new QPen(self->selectedPen());
}

void QCPItemPixmap_SetPixmap(QCPItemPixmap* self, const QPixmap* pixmap) {
    self->setPixmap(*pixmap);
}

void QCPItemPixmap_SetScaled(QCPItemPixmap* self, bool scaled) {
    self->setScaled(scaled);
}

void QCPItemPixmap_SetPen(QCPItemPixmap* self, const QPen* pen) {
    self->setPen(*pen);
}

void QCPItemPixmap_SetSelectedPen(QCPItemPixmap* self, const QPen* pen) {
    self->setSelectedPen(*pen);
}

double QCPItemPixmap_SelectTest(const QCPItemPixmap* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpitempixmap = dynamic_cast<const VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPItemPixmap*)self)->selectTest(*pos, onlySelectable, details);
    }
}

QCPItemPosition* QCPItemPixmap_TopLeft(const QCPItemPixmap* self) {
    return (QCPItemPosition*)self->topLeft;
}

QCPItemPosition* QCPItemPixmap_BottomRight(const QCPItemPixmap* self) {
    return (QCPItemPosition*)self->bottomRight;
}

QCPItemAnchor* QCPItemPixmap_Top(const QCPItemPixmap* self) {
    return (QCPItemAnchor*)self->top;
}

QCPItemAnchor* QCPItemPixmap_TopRight(const QCPItemPixmap* self) {
    return (QCPItemAnchor*)self->topRight;
}

QCPItemAnchor* QCPItemPixmap_Right(const QCPItemPixmap* self) {
    return (QCPItemAnchor*)self->right;
}

QCPItemAnchor* QCPItemPixmap_Bottom(const QCPItemPixmap* self) {
    return (QCPItemAnchor*)self->bottom;
}

QCPItemAnchor* QCPItemPixmap_BottomLeft(const QCPItemPixmap* self) {
    return (QCPItemAnchor*)self->bottomLeft;
}

QCPItemAnchor* QCPItemPixmap_Left(const QCPItemPixmap* self) {
    return (QCPItemAnchor*)self->left;
}

void QCPItemPixmap_Draw(QCPItemPixmap* self, QCPPainter* painter) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->draw(painter);
    }
}

QPointF* QCPItemPixmap_AnchorPixelPosition(const QCPItemPixmap* self, int anchorId) {
    auto* vqcpitempixmap = dynamic_cast<const VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        return new QPointF(vqcpitempixmap->anchorPixelPosition(static_cast<int>(anchorId)));
    }
    return {};
}

libqt_string QCPItemPixmap_Tr2(const char* s, const char* c) {
    QString _ret = QCPItemPixmap::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPItemPixmap_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPItemPixmap::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

void QCPItemPixmap_SetScaled2(QCPItemPixmap* self, bool scaled, int aspectRatioMode) {
    self->setScaled(scaled, static_cast<Qt::AspectRatioMode>(aspectRatioMode));
}

void QCPItemPixmap_SetScaled3(QCPItemPixmap* self, bool scaled, int aspectRatioMode, int transformationMode) {
    self->setScaled(scaled, static_cast<Qt::AspectRatioMode>(aspectRatioMode), static_cast<Qt::TransformationMode>(transformationMode));
}

// Base class handler implementation
int QCPItemPixmap_QBaseMetacall(QCPItemPixmap* self, int param1, int param2, void** param3) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_Metacall_IsBase(true);
        return vqcpitempixmap->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPItemPixmap::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnMetacall(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_Metacall_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
double QCPItemPixmap_QBaseSelectTest(const QCPItemPixmap* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_SelectTest_IsBase(true);
        return vqcpitempixmap->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPItemPixmap::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnSelectTest(const QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_SelectTest_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
void QCPItemPixmap_QBaseDraw(QCPItemPixmap* self, QCPPainter* painter) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_Draw_IsBase(true);
        vqcpitempixmap->draw(painter);
    } else {
        ((VirtualQCPItemPixmap*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnDraw(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_Draw_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_Draw_Callback>(slot));
    }
}

// Base class handler implementation
QPointF* QCPItemPixmap_QBaseAnchorPixelPosition(const QCPItemPixmap* self, int anchorId) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_AnchorPixelPosition_IsBase(true);
        return new QPointF(vqcpitempixmap->anchorPixelPosition(static_cast<int>(anchorId)));
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnAnchorPixelPosition(const QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_AnchorPixelPosition_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_AnchorPixelPosition_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemPixmap_SelectionCategory(const QCPItemPixmap* self) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        return static_cast<int>(vqcpitempixmap->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPItemPixmap*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPItemPixmap_QBaseSelectionCategory(const QCPItemPixmap* self) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcpitempixmap->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPItemPixmap*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnSelectionCategory(const QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_SelectionCategory_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPItemPixmap_ClipRect(const QCPItemPixmap* self) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        return new QRect(vqcpitempixmap->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPItemPixmap_QBaseClipRect(const QCPItemPixmap* self) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_ClipRect_IsBase(true);
        return new QRect(vqcpitempixmap->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnClipRect(const QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_ClipRect_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemPixmap_ApplyDefaultAntialiasingHint(const QCPItemPixmap* self, QCPPainter* painter) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPItemPixmap*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPItemPixmap_QBaseApplyDefaultAntialiasingHint(const QCPItemPixmap* self, QCPPainter* painter) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcpitempixmap->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPItemPixmap*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnApplyDefaultAntialiasingHint(const QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemPixmap_SelectEvent(QCPItemPixmap* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPItemPixmap*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPItemPixmap_QBaseSelectEvent(QCPItemPixmap* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_SelectEvent_IsBase(true);
        vqcpitempixmap->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPItemPixmap*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnSelectEvent(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_SelectEvent_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemPixmap_DeselectEvent(QCPItemPixmap* self, bool* selectionStateChanged) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPItemPixmap*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPItemPixmap_QBaseDeselectEvent(QCPItemPixmap* self, bool* selectionStateChanged) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_DeselectEvent_IsBase(true);
        vqcpitempixmap->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPItemPixmap*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnDeselectEvent(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_DeselectEvent_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemPixmap_ParentPlotInitialized(QCPItemPixmap* self, QCustomPlot* parentPlot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPItemPixmap*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPItemPixmap_QBaseParentPlotInitialized(QCPItemPixmap* self, QCustomPlot* parentPlot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_ParentPlotInitialized_IsBase(true);
        vqcpitempixmap->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPItemPixmap*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnParentPlotInitialized(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemPixmap_MousePressEvent(QCPItemPixmap* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPItemPixmap*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPItemPixmap_QBaseMousePressEvent(QCPItemPixmap* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_MousePressEvent_IsBase(true);
        vqcpitempixmap->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPItemPixmap*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnMousePressEvent(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_MousePressEvent_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemPixmap_MouseMoveEvent(QCPItemPixmap* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPItemPixmap*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPItemPixmap_QBaseMouseMoveEvent(QCPItemPixmap* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_MouseMoveEvent_IsBase(true);
        vqcpitempixmap->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPItemPixmap*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnMouseMoveEvent(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemPixmap_MouseReleaseEvent(QCPItemPixmap* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPItemPixmap*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPItemPixmap_QBaseMouseReleaseEvent(QCPItemPixmap* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_MouseReleaseEvent_IsBase(true);
        vqcpitempixmap->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPItemPixmap*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnMouseReleaseEvent(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemPixmap_MouseDoubleClickEvent(QCPItemPixmap* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPItemPixmap*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPItemPixmap_QBaseMouseDoubleClickEvent(QCPItemPixmap* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_MouseDoubleClickEvent_IsBase(true);
        vqcpitempixmap->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPItemPixmap*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnMouseDoubleClickEvent(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemPixmap_WheelEvent(QCPItemPixmap* self, QWheelEvent* event) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->wheelEvent(event);
    } else {
        ((VirtualQCPItemPixmap*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPItemPixmap_QBaseWheelEvent(QCPItemPixmap* self, QWheelEvent* event) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_WheelEvent_IsBase(true);
        vqcpitempixmap->wheelEvent(event);
    } else {
        ((VirtualQCPItemPixmap*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnWheelEvent(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_WheelEvent_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemPixmap_Event(QCPItemPixmap* self, QEvent* event) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        return vqcpitempixmap->event(event);
    } else {
        return self->QCPItemPixmap::event(event);
    }
}

// Base class handler implementation
bool QCPItemPixmap_QBaseEvent(QCPItemPixmap* self, QEvent* event) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_Event_IsBase(true);
        return vqcpitempixmap->event(event);
    } else {
        return self->QCPItemPixmap::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnEvent(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_Event_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemPixmap_EventFilter(QCPItemPixmap* self, QObject* watched, QEvent* event) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        return vqcpitempixmap->eventFilter(watched, event);
    } else {
        return self->QCPItemPixmap::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPItemPixmap_QBaseEventFilter(QCPItemPixmap* self, QObject* watched, QEvent* event) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_EventFilter_IsBase(true);
        return vqcpitempixmap->eventFilter(watched, event);
    } else {
        return self->QCPItemPixmap::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnEventFilter(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_EventFilter_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemPixmap_TimerEvent(QCPItemPixmap* self, QTimerEvent* event) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->timerEvent(event);
    } else {
        ((VirtualQCPItemPixmap*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPItemPixmap_QBaseTimerEvent(QCPItemPixmap* self, QTimerEvent* event) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_TimerEvent_IsBase(true);
        vqcpitempixmap->timerEvent(event);
    } else {
        ((VirtualQCPItemPixmap*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnTimerEvent(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_TimerEvent_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemPixmap_ChildEvent(QCPItemPixmap* self, QChildEvent* event) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->childEvent(event);
    } else {
        ((VirtualQCPItemPixmap*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPItemPixmap_QBaseChildEvent(QCPItemPixmap* self, QChildEvent* event) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_ChildEvent_IsBase(true);
        vqcpitempixmap->childEvent(event);
    } else {
        ((VirtualQCPItemPixmap*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnChildEvent(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_ChildEvent_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemPixmap_CustomEvent(QCPItemPixmap* self, QEvent* event) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->customEvent(event);
    } else {
        ((VirtualQCPItemPixmap*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPItemPixmap_QBaseCustomEvent(QCPItemPixmap* self, QEvent* event) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_CustomEvent_IsBase(true);
        vqcpitempixmap->customEvent(event);
    } else {
        ((VirtualQCPItemPixmap*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnCustomEvent(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_CustomEvent_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemPixmap_ConnectNotify(QCPItemPixmap* self, const QMetaMethod* signal) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->connectNotify(*signal);
    } else {
        ((VirtualQCPItemPixmap*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPItemPixmap_QBaseConnectNotify(QCPItemPixmap* self, const QMetaMethod* signal) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_ConnectNotify_IsBase(true);
        vqcpitempixmap->connectNotify(*signal);
    } else {
        ((VirtualQCPItemPixmap*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnConnectNotify(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_ConnectNotify_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemPixmap_DisconnectNotify(QCPItemPixmap* self, const QMetaMethod* signal) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->disconnectNotify(*signal);
    } else {
        ((VirtualQCPItemPixmap*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPItemPixmap_QBaseDisconnectNotify(QCPItemPixmap* self, const QMetaMethod* signal) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_DisconnectNotify_IsBase(true);
        vqcpitempixmap->disconnectNotify(*signal);
    } else {
        ((VirtualQCPItemPixmap*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnDisconnectNotify(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemPixmap_UpdateScaledPixmap(QCPItemPixmap* self) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->updateScaledPixmap();
    } else {
        ((VirtualQCPItemPixmap*)self)->updateScaledPixmap();
    }
}

// Base class handler implementation
void QCPItemPixmap_QBaseUpdateScaledPixmap(QCPItemPixmap* self) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_UpdateScaledPixmap_IsBase(true);
        vqcpitempixmap->updateScaledPixmap();
    } else {
        ((VirtualQCPItemPixmap*)self)->updateScaledPixmap();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnUpdateScaledPixmap(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_UpdateScaledPixmap_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_UpdateScaledPixmap_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPItemPixmap_GetFinalRect(const QCPItemPixmap* self) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        return new QRect(vqcpitempixmap->getFinalRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPItemPixmap_QBaseGetFinalRect(const QCPItemPixmap* self) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_GetFinalRect_IsBase(true);
        return new QRect(vqcpitempixmap->getFinalRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnGetFinalRect(const QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_GetFinalRect_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_GetFinalRect_Callback>(slot));
    }
}

// Derived class handler implementation
QPen* QCPItemPixmap_MainPen(const QCPItemPixmap* self) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        return new QPen(vqcpitempixmap->mainPen());
    }
    return {};
}

// Base class handler implementation
QPen* QCPItemPixmap_QBaseMainPen(const QCPItemPixmap* self) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_MainPen_IsBase(true);
        return new QPen(vqcpitempixmap->mainPen());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnMainPen(const QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_MainPen_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_MainPen_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemPixmap_UpdateScaledPixmap1(QCPItemPixmap* self, QRect* finalRect) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->updateScaledPixmap(*finalRect);
    } else {
        ((VirtualQCPItemPixmap*)self)->updateScaledPixmap(*finalRect);
    }
}

// Base class handler implementation
void QCPItemPixmap_QBaseUpdateScaledPixmap1(QCPItemPixmap* self, QRect* finalRect) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_UpdateScaledPixmap1_IsBase(true);
        vqcpitempixmap->updateScaledPixmap(*finalRect);
    } else {
        ((VirtualQCPItemPixmap*)self)->updateScaledPixmap(*finalRect);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnUpdateScaledPixmap1(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_UpdateScaledPixmap1_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_UpdateScaledPixmap1_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemPixmap_UpdateScaledPixmap2(QCPItemPixmap* self, QRect* finalRect, bool flipHorz) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->updateScaledPixmap(*finalRect, flipHorz);
    } else {
        ((VirtualQCPItemPixmap*)self)->updateScaledPixmap(*finalRect, flipHorz);
    }
}

// Base class handler implementation
void QCPItemPixmap_QBaseUpdateScaledPixmap2(QCPItemPixmap* self, QRect* finalRect, bool flipHorz) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_UpdateScaledPixmap2_IsBase(true);
        vqcpitempixmap->updateScaledPixmap(*finalRect, flipHorz);
    } else {
        ((VirtualQCPItemPixmap*)self)->updateScaledPixmap(*finalRect, flipHorz);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnUpdateScaledPixmap2(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_UpdateScaledPixmap2_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_UpdateScaledPixmap2_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemPixmap_UpdateScaledPixmap3(QCPItemPixmap* self, QRect* finalRect, bool flipHorz, bool flipVert) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->updateScaledPixmap(*finalRect, flipHorz, flipVert);
    } else {
        ((VirtualQCPItemPixmap*)self)->updateScaledPixmap(*finalRect, flipHorz, flipVert);
    }
}

// Base class handler implementation
void QCPItemPixmap_QBaseUpdateScaledPixmap3(QCPItemPixmap* self, QRect* finalRect, bool flipHorz, bool flipVert) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_UpdateScaledPixmap3_IsBase(true);
        vqcpitempixmap->updateScaledPixmap(*finalRect, flipHorz, flipVert);
    } else {
        ((VirtualQCPItemPixmap*)self)->updateScaledPixmap(*finalRect, flipHorz, flipVert);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnUpdateScaledPixmap3(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_UpdateScaledPixmap3_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_UpdateScaledPixmap3_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPItemPixmap_GetFinalRect1(const QCPItemPixmap* self, bool* flippedHorz) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        return new QRect(vqcpitempixmap->getFinalRect(flippedHorz));
    }
    return {};
}

// Base class handler implementation
QRect* QCPItemPixmap_QBaseGetFinalRect1(const QCPItemPixmap* self, bool* flippedHorz) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_GetFinalRect1_IsBase(true);
        return new QRect(vqcpitempixmap->getFinalRect(flippedHorz));
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnGetFinalRect1(const QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_GetFinalRect1_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_GetFinalRect1_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPItemPixmap_GetFinalRect2(const QCPItemPixmap* self, bool* flippedHorz, bool* flippedVert) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        return new QRect(vqcpitempixmap->getFinalRect(flippedHorz, flippedVert));
    }
    return {};
}

// Base class handler implementation
QRect* QCPItemPixmap_QBaseGetFinalRect2(const QCPItemPixmap* self, bool* flippedHorz, bool* flippedVert) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_GetFinalRect2_IsBase(true);
        return new QRect(vqcpitempixmap->getFinalRect(flippedHorz, flippedVert));
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnGetFinalRect2(const QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_GetFinalRect2_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_GetFinalRect2_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPItemPixmap_RectDistance(const QCPItemPixmap* self, const QRectF* rect, const QPointF* pos, bool filledRect) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        return vqcpitempixmap->rectDistance(*rect, *pos, filledRect);
    } else {
        return ((VirtualQCPItemPixmap*)self)->rectDistance(*rect, *pos, filledRect);
    }
}

// Base class handler implementation
double QCPItemPixmap_QBaseRectDistance(const QCPItemPixmap* self, const QRectF* rect, const QPointF* pos, bool filledRect) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_RectDistance_IsBase(true);
        return vqcpitempixmap->rectDistance(*rect, *pos, filledRect);
    } else {
        return ((VirtualQCPItemPixmap*)self)->rectDistance(*rect, *pos, filledRect);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnRectDistance(const QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_RectDistance_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_RectDistance_Callback>(slot));
    }
}

// Derived class handler implementation
QCPItemPosition* QCPItemPixmap_CreatePosition(QCPItemPixmap* self, const libqt_string name) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        return vqcpitempixmap->createPosition(name_QString);
    } else {
        return ((VirtualQCPItemPixmap*)self)->createPosition(name_QString);
    }
}

// Base class handler implementation
QCPItemPosition* QCPItemPixmap_QBaseCreatePosition(QCPItemPixmap* self, const libqt_string name) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_CreatePosition_IsBase(true);
        return vqcpitempixmap->createPosition(name_QString);
    } else {
        return ((VirtualQCPItemPixmap*)self)->createPosition(name_QString);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnCreatePosition(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_CreatePosition_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_CreatePosition_Callback>(slot));
    }
}

// Derived class handler implementation
QCPItemAnchor* QCPItemPixmap_CreateAnchor(QCPItemPixmap* self, const libqt_string name, int anchorId) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        return vqcpitempixmap->createAnchor(name_QString, static_cast<int>(anchorId));
    } else {
        return ((VirtualQCPItemPixmap*)self)->createAnchor(name_QString, static_cast<int>(anchorId));
    }
}

// Base class handler implementation
QCPItemAnchor* QCPItemPixmap_QBaseCreateAnchor(QCPItemPixmap* self, const libqt_string name, int anchorId) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_CreateAnchor_IsBase(true);
        return vqcpitempixmap->createAnchor(name_QString, static_cast<int>(anchorId));
    } else {
        return ((VirtualQCPItemPixmap*)self)->createAnchor(name_QString, static_cast<int>(anchorId));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnCreateAnchor(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_CreateAnchor_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_CreateAnchor_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemPixmap_InitializeParentPlot(QCPItemPixmap* self, QCustomPlot* parentPlot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPItemPixmap*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPItemPixmap_QBaseInitializeParentPlot(QCPItemPixmap* self, QCustomPlot* parentPlot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_InitializeParentPlot_IsBase(true);
        vqcpitempixmap->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPItemPixmap*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnInitializeParentPlot(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemPixmap_SetParentLayerable(QCPItemPixmap* self, QCPLayerable* parentLayerable) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPItemPixmap*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPItemPixmap_QBaseSetParentLayerable(QCPItemPixmap* self, QCPLayerable* parentLayerable) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_SetParentLayerable_IsBase(true);
        vqcpitempixmap->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPItemPixmap*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnSetParentLayerable(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemPixmap_MoveToLayer(QCPItemPixmap* self, QCPLayer* layer, bool prepend) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        return vqcpitempixmap->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPItemPixmap*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPItemPixmap_QBaseMoveToLayer(QCPItemPixmap* self, QCPLayer* layer, bool prepend) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_MoveToLayer_IsBase(true);
        return vqcpitempixmap->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPItemPixmap*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnMoveToLayer(QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = dynamic_cast<VirtualQCPItemPixmap*>(self);
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_MoveToLayer_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemPixmap_ApplyAntialiasingHint(const QCPItemPixmap* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPItemPixmap*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPItemPixmap_QBaseApplyAntialiasingHint(const QCPItemPixmap* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_ApplyAntialiasingHint_IsBase(true);
        vqcpitempixmap->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPItemPixmap*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnApplyAntialiasingHint(const QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPItemPixmap_Sender(const QCPItemPixmap* self) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        return vqcpitempixmap->sender();
    } else {
        return ((VirtualQCPItemPixmap*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPItemPixmap_QBaseSender(const QCPItemPixmap* self) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_Sender_IsBase(true);
        return vqcpitempixmap->sender();
    } else {
        return ((VirtualQCPItemPixmap*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnSender(const QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_Sender_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemPixmap_SenderSignalIndex(const QCPItemPixmap* self) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        return vqcpitempixmap->senderSignalIndex();
    } else {
        return ((VirtualQCPItemPixmap*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPItemPixmap_QBaseSenderSignalIndex(const QCPItemPixmap* self) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_SenderSignalIndex_IsBase(true);
        return vqcpitempixmap->senderSignalIndex();
    } else {
        return ((VirtualQCPItemPixmap*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnSenderSignalIndex(const QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemPixmap_Receivers(const QCPItemPixmap* self, const char* signal) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        return vqcpitempixmap->receivers(signal);
    } else {
        return ((VirtualQCPItemPixmap*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPItemPixmap_QBaseReceivers(const QCPItemPixmap* self, const char* signal) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_Receivers_IsBase(true);
        return vqcpitempixmap->receivers(signal);
    } else {
        return ((VirtualQCPItemPixmap*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnReceivers(const QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_Receivers_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemPixmap_IsSignalConnected(const QCPItemPixmap* self, const QMetaMethod* signal) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        return vqcpitempixmap->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPItemPixmap*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPItemPixmap_QBaseIsSignalConnected(const QCPItemPixmap* self, const QMetaMethod* signal) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_IsSignalConnected_IsBase(true);
        return vqcpitempixmap->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPItemPixmap*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemPixmap_OnIsSignalConnected(const QCPItemPixmap* self, intptr_t slot) {
    auto* vqcpitempixmap = const_cast<VirtualQCPItemPixmap*>(dynamic_cast<const VirtualQCPItemPixmap*>(self));
    if (vqcpitempixmap && vqcpitempixmap->isVirtualQCPItemPixmap) {
        vqcpitempixmap->setQCPItemPixmap_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPItemPixmap::QCPItemPixmap_IsSignalConnected_Callback>(slot));
    }
}

void QCPItemPixmap_Delete(QCPItemPixmap* self) {
    delete self;
}

QCPItemTracer* QCPItemTracer_new(QCustomPlot* parentPlot) {
    return new VirtualQCPItemTracer(parentPlot);
}

QMetaObject* QCPItemTracer_MetaObject(const QCPItemTracer* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPItemTracer_Metacast(QCPItemTracer* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPItemTracer_Metacall(QCPItemTracer* self, int param1, int param2, void** param3) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPItemTracer*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPItemTracer_Tr(const char* s) {
    QString _ret = QCPItemTracer::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

QPen* QCPItemTracer_Pen(const QCPItemTracer* self) {
    return new QPen(self->pen());
}

QPen* QCPItemTracer_SelectedPen(const QCPItemTracer* self) {
    return new QPen(self->selectedPen());
}

QBrush* QCPItemTracer_Brush(const QCPItemTracer* self) {
    return new QBrush(self->brush());
}

QBrush* QCPItemTracer_SelectedBrush(const QCPItemTracer* self) {
    return new QBrush(self->selectedBrush());
}

double QCPItemTracer_Size(const QCPItemTracer* self) {
    return self->size();
}

int QCPItemTracer_Style(const QCPItemTracer* self) {
    return static_cast<int>(self->style());
}

QCPGraph* QCPItemTracer_Graph(const QCPItemTracer* self) {
    return self->graph();
}

double QCPItemTracer_GraphKey(const QCPItemTracer* self) {
    return self->graphKey();
}

bool QCPItemTracer_Interpolating(const QCPItemTracer* self) {
    return self->interpolating();
}

void QCPItemTracer_SetPen(QCPItemTracer* self, const QPen* pen) {
    self->setPen(*pen);
}

void QCPItemTracer_SetSelectedPen(QCPItemTracer* self, const QPen* pen) {
    self->setSelectedPen(*pen);
}

void QCPItemTracer_SetBrush(QCPItemTracer* self, const QBrush* brush) {
    self->setBrush(*brush);
}

void QCPItemTracer_SetSelectedBrush(QCPItemTracer* self, const QBrush* brush) {
    self->setSelectedBrush(*brush);
}

void QCPItemTracer_SetSize(QCPItemTracer* self, double size) {
    self->setSize(static_cast<double>(size));
}

void QCPItemTracer_SetStyle(QCPItemTracer* self, int style) {
    self->setStyle(static_cast<QCPItemTracer::TracerStyle>(style));
}

void QCPItemTracer_SetGraph(QCPItemTracer* self, QCPGraph* graph) {
    self->setGraph(graph);
}

void QCPItemTracer_SetGraphKey(QCPItemTracer* self, double key) {
    self->setGraphKey(static_cast<double>(key));
}

void QCPItemTracer_SetInterpolating(QCPItemTracer* self, bool enabled) {
    self->setInterpolating(enabled);
}

double QCPItemTracer_SelectTest(const QCPItemTracer* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpitemtracer = dynamic_cast<const VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPItemTracer*)self)->selectTest(*pos, onlySelectable, details);
    }
}

void QCPItemTracer_UpdatePosition(QCPItemTracer* self) {
    self->updatePosition();
}

QCPItemPosition* QCPItemTracer_Position(const QCPItemTracer* self) {
    return (QCPItemPosition*)self->position;
}

void QCPItemTracer_Draw(QCPItemTracer* self, QCPPainter* painter) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->draw(painter);
    }
}

libqt_string QCPItemTracer_Tr2(const char* s, const char* c) {
    QString _ret = QCPItemTracer::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPItemTracer_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPItemTracer::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPItemTracer_QBaseMetacall(QCPItemTracer* self, int param1, int param2, void** param3) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_Metacall_IsBase(true);
        return vqcpitemtracer->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPItemTracer::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnMetacall(QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_Metacall_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
double QCPItemTracer_QBaseSelectTest(const QCPItemTracer* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_SelectTest_IsBase(true);
        return vqcpitemtracer->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPItemTracer::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnSelectTest(const QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_SelectTest_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
void QCPItemTracer_QBaseDraw(QCPItemTracer* self, QCPPainter* painter) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_Draw_IsBase(true);
        vqcpitemtracer->draw(painter);
    } else {
        ((VirtualQCPItemTracer*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnDraw(QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_Draw_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_Draw_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemTracer_SelectionCategory(const QCPItemTracer* self) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        return static_cast<int>(vqcpitemtracer->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPItemTracer*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPItemTracer_QBaseSelectionCategory(const QCPItemTracer* self) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcpitemtracer->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPItemTracer*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnSelectionCategory(const QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_SelectionCategory_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPItemTracer_ClipRect(const QCPItemTracer* self) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        return new QRect(vqcpitemtracer->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPItemTracer_QBaseClipRect(const QCPItemTracer* self) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_ClipRect_IsBase(true);
        return new QRect(vqcpitemtracer->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnClipRect(const QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_ClipRect_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemTracer_ApplyDefaultAntialiasingHint(const QCPItemTracer* self, QCPPainter* painter) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPItemTracer*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPItemTracer_QBaseApplyDefaultAntialiasingHint(const QCPItemTracer* self, QCPPainter* painter) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcpitemtracer->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPItemTracer*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnApplyDefaultAntialiasingHint(const QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemTracer_SelectEvent(QCPItemTracer* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPItemTracer*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPItemTracer_QBaseSelectEvent(QCPItemTracer* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_SelectEvent_IsBase(true);
        vqcpitemtracer->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPItemTracer*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnSelectEvent(QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_SelectEvent_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemTracer_DeselectEvent(QCPItemTracer* self, bool* selectionStateChanged) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPItemTracer*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPItemTracer_QBaseDeselectEvent(QCPItemTracer* self, bool* selectionStateChanged) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_DeselectEvent_IsBase(true);
        vqcpitemtracer->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPItemTracer*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnDeselectEvent(QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_DeselectEvent_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
QPointF* QCPItemTracer_AnchorPixelPosition(const QCPItemTracer* self, int anchorId) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        return new QPointF(vqcpitemtracer->anchorPixelPosition(static_cast<int>(anchorId)));
    }
    return {};
}

// Base class handler implementation
QPointF* QCPItemTracer_QBaseAnchorPixelPosition(const QCPItemTracer* self, int anchorId) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_AnchorPixelPosition_IsBase(true);
        return new QPointF(vqcpitemtracer->anchorPixelPosition(static_cast<int>(anchorId)));
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnAnchorPixelPosition(const QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_AnchorPixelPosition_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_AnchorPixelPosition_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemTracer_ParentPlotInitialized(QCPItemTracer* self, QCustomPlot* parentPlot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPItemTracer*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPItemTracer_QBaseParentPlotInitialized(QCPItemTracer* self, QCustomPlot* parentPlot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_ParentPlotInitialized_IsBase(true);
        vqcpitemtracer->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPItemTracer*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnParentPlotInitialized(QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemTracer_MousePressEvent(QCPItemTracer* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPItemTracer*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPItemTracer_QBaseMousePressEvent(QCPItemTracer* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_MousePressEvent_IsBase(true);
        vqcpitemtracer->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPItemTracer*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnMousePressEvent(QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_MousePressEvent_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemTracer_MouseMoveEvent(QCPItemTracer* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPItemTracer*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPItemTracer_QBaseMouseMoveEvent(QCPItemTracer* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_MouseMoveEvent_IsBase(true);
        vqcpitemtracer->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPItemTracer*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnMouseMoveEvent(QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemTracer_MouseReleaseEvent(QCPItemTracer* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPItemTracer*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPItemTracer_QBaseMouseReleaseEvent(QCPItemTracer* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_MouseReleaseEvent_IsBase(true);
        vqcpitemtracer->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPItemTracer*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnMouseReleaseEvent(QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemTracer_MouseDoubleClickEvent(QCPItemTracer* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPItemTracer*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPItemTracer_QBaseMouseDoubleClickEvent(QCPItemTracer* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_MouseDoubleClickEvent_IsBase(true);
        vqcpitemtracer->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPItemTracer*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnMouseDoubleClickEvent(QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemTracer_WheelEvent(QCPItemTracer* self, QWheelEvent* event) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->wheelEvent(event);
    } else {
        ((VirtualQCPItemTracer*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPItemTracer_QBaseWheelEvent(QCPItemTracer* self, QWheelEvent* event) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_WheelEvent_IsBase(true);
        vqcpitemtracer->wheelEvent(event);
    } else {
        ((VirtualQCPItemTracer*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnWheelEvent(QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_WheelEvent_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemTracer_Event(QCPItemTracer* self, QEvent* event) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        return vqcpitemtracer->event(event);
    } else {
        return self->QCPItemTracer::event(event);
    }
}

// Base class handler implementation
bool QCPItemTracer_QBaseEvent(QCPItemTracer* self, QEvent* event) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_Event_IsBase(true);
        return vqcpitemtracer->event(event);
    } else {
        return self->QCPItemTracer::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnEvent(QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_Event_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemTracer_EventFilter(QCPItemTracer* self, QObject* watched, QEvent* event) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        return vqcpitemtracer->eventFilter(watched, event);
    } else {
        return self->QCPItemTracer::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPItemTracer_QBaseEventFilter(QCPItemTracer* self, QObject* watched, QEvent* event) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_EventFilter_IsBase(true);
        return vqcpitemtracer->eventFilter(watched, event);
    } else {
        return self->QCPItemTracer::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnEventFilter(QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_EventFilter_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemTracer_TimerEvent(QCPItemTracer* self, QTimerEvent* event) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->timerEvent(event);
    } else {
        ((VirtualQCPItemTracer*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPItemTracer_QBaseTimerEvent(QCPItemTracer* self, QTimerEvent* event) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_TimerEvent_IsBase(true);
        vqcpitemtracer->timerEvent(event);
    } else {
        ((VirtualQCPItemTracer*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnTimerEvent(QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_TimerEvent_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemTracer_ChildEvent(QCPItemTracer* self, QChildEvent* event) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->childEvent(event);
    } else {
        ((VirtualQCPItemTracer*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPItemTracer_QBaseChildEvent(QCPItemTracer* self, QChildEvent* event) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_ChildEvent_IsBase(true);
        vqcpitemtracer->childEvent(event);
    } else {
        ((VirtualQCPItemTracer*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnChildEvent(QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_ChildEvent_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemTracer_CustomEvent(QCPItemTracer* self, QEvent* event) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->customEvent(event);
    } else {
        ((VirtualQCPItemTracer*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPItemTracer_QBaseCustomEvent(QCPItemTracer* self, QEvent* event) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_CustomEvent_IsBase(true);
        vqcpitemtracer->customEvent(event);
    } else {
        ((VirtualQCPItemTracer*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnCustomEvent(QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_CustomEvent_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemTracer_ConnectNotify(QCPItemTracer* self, const QMetaMethod* signal) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->connectNotify(*signal);
    } else {
        ((VirtualQCPItemTracer*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPItemTracer_QBaseConnectNotify(QCPItemTracer* self, const QMetaMethod* signal) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_ConnectNotify_IsBase(true);
        vqcpitemtracer->connectNotify(*signal);
    } else {
        ((VirtualQCPItemTracer*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnConnectNotify(QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_ConnectNotify_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemTracer_DisconnectNotify(QCPItemTracer* self, const QMetaMethod* signal) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->disconnectNotify(*signal);
    } else {
        ((VirtualQCPItemTracer*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPItemTracer_QBaseDisconnectNotify(QCPItemTracer* self, const QMetaMethod* signal) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_DisconnectNotify_IsBase(true);
        vqcpitemtracer->disconnectNotify(*signal);
    } else {
        ((VirtualQCPItemTracer*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnDisconnectNotify(QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
QPen* QCPItemTracer_MainPen(const QCPItemTracer* self) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        return new QPen(vqcpitemtracer->mainPen());
    }
    return {};
}

// Base class handler implementation
QPen* QCPItemTracer_QBaseMainPen(const QCPItemTracer* self) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_MainPen_IsBase(true);
        return new QPen(vqcpitemtracer->mainPen());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnMainPen(const QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_MainPen_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_MainPen_Callback>(slot));
    }
}

// Derived class handler implementation
QBrush* QCPItemTracer_MainBrush(const QCPItemTracer* self) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        return new QBrush(vqcpitemtracer->mainBrush());
    }
    return {};
}

// Base class handler implementation
QBrush* QCPItemTracer_QBaseMainBrush(const QCPItemTracer* self) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_MainBrush_IsBase(true);
        return new QBrush(vqcpitemtracer->mainBrush());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnMainBrush(const QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_MainBrush_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_MainBrush_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPItemTracer_RectDistance(const QCPItemTracer* self, const QRectF* rect, const QPointF* pos, bool filledRect) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        return vqcpitemtracer->rectDistance(*rect, *pos, filledRect);
    } else {
        return ((VirtualQCPItemTracer*)self)->rectDistance(*rect, *pos, filledRect);
    }
}

// Base class handler implementation
double QCPItemTracer_QBaseRectDistance(const QCPItemTracer* self, const QRectF* rect, const QPointF* pos, bool filledRect) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_RectDistance_IsBase(true);
        return vqcpitemtracer->rectDistance(*rect, *pos, filledRect);
    } else {
        return ((VirtualQCPItemTracer*)self)->rectDistance(*rect, *pos, filledRect);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnRectDistance(const QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_RectDistance_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_RectDistance_Callback>(slot));
    }
}

// Derived class handler implementation
QCPItemPosition* QCPItemTracer_CreatePosition(QCPItemTracer* self, const libqt_string name) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        return vqcpitemtracer->createPosition(name_QString);
    } else {
        return ((VirtualQCPItemTracer*)self)->createPosition(name_QString);
    }
}

// Base class handler implementation
QCPItemPosition* QCPItemTracer_QBaseCreatePosition(QCPItemTracer* self, const libqt_string name) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_CreatePosition_IsBase(true);
        return vqcpitemtracer->createPosition(name_QString);
    } else {
        return ((VirtualQCPItemTracer*)self)->createPosition(name_QString);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnCreatePosition(QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_CreatePosition_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_CreatePosition_Callback>(slot));
    }
}

// Derived class handler implementation
QCPItemAnchor* QCPItemTracer_CreateAnchor(QCPItemTracer* self, const libqt_string name, int anchorId) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        return vqcpitemtracer->createAnchor(name_QString, static_cast<int>(anchorId));
    } else {
        return ((VirtualQCPItemTracer*)self)->createAnchor(name_QString, static_cast<int>(anchorId));
    }
}

// Base class handler implementation
QCPItemAnchor* QCPItemTracer_QBaseCreateAnchor(QCPItemTracer* self, const libqt_string name, int anchorId) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_CreateAnchor_IsBase(true);
        return vqcpitemtracer->createAnchor(name_QString, static_cast<int>(anchorId));
    } else {
        return ((VirtualQCPItemTracer*)self)->createAnchor(name_QString, static_cast<int>(anchorId));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnCreateAnchor(QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_CreateAnchor_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_CreateAnchor_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemTracer_InitializeParentPlot(QCPItemTracer* self, QCustomPlot* parentPlot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPItemTracer*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPItemTracer_QBaseInitializeParentPlot(QCPItemTracer* self, QCustomPlot* parentPlot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_InitializeParentPlot_IsBase(true);
        vqcpitemtracer->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPItemTracer*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnInitializeParentPlot(QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemTracer_SetParentLayerable(QCPItemTracer* self, QCPLayerable* parentLayerable) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPItemTracer*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPItemTracer_QBaseSetParentLayerable(QCPItemTracer* self, QCPLayerable* parentLayerable) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_SetParentLayerable_IsBase(true);
        vqcpitemtracer->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPItemTracer*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnSetParentLayerable(QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemTracer_MoveToLayer(QCPItemTracer* self, QCPLayer* layer, bool prepend) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        return vqcpitemtracer->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPItemTracer*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPItemTracer_QBaseMoveToLayer(QCPItemTracer* self, QCPLayer* layer, bool prepend) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_MoveToLayer_IsBase(true);
        return vqcpitemtracer->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPItemTracer*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnMoveToLayer(QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = dynamic_cast<VirtualQCPItemTracer*>(self);
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_MoveToLayer_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemTracer_ApplyAntialiasingHint(const QCPItemTracer* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPItemTracer*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPItemTracer_QBaseApplyAntialiasingHint(const QCPItemTracer* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_ApplyAntialiasingHint_IsBase(true);
        vqcpitemtracer->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPItemTracer*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnApplyAntialiasingHint(const QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPItemTracer_Sender(const QCPItemTracer* self) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        return vqcpitemtracer->sender();
    } else {
        return ((VirtualQCPItemTracer*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPItemTracer_QBaseSender(const QCPItemTracer* self) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_Sender_IsBase(true);
        return vqcpitemtracer->sender();
    } else {
        return ((VirtualQCPItemTracer*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnSender(const QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_Sender_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemTracer_SenderSignalIndex(const QCPItemTracer* self) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        return vqcpitemtracer->senderSignalIndex();
    } else {
        return ((VirtualQCPItemTracer*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPItemTracer_QBaseSenderSignalIndex(const QCPItemTracer* self) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_SenderSignalIndex_IsBase(true);
        return vqcpitemtracer->senderSignalIndex();
    } else {
        return ((VirtualQCPItemTracer*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnSenderSignalIndex(const QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemTracer_Receivers(const QCPItemTracer* self, const char* signal) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        return vqcpitemtracer->receivers(signal);
    } else {
        return ((VirtualQCPItemTracer*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPItemTracer_QBaseReceivers(const QCPItemTracer* self, const char* signal) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_Receivers_IsBase(true);
        return vqcpitemtracer->receivers(signal);
    } else {
        return ((VirtualQCPItemTracer*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnReceivers(const QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_Receivers_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemTracer_IsSignalConnected(const QCPItemTracer* self, const QMetaMethod* signal) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        return vqcpitemtracer->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPItemTracer*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPItemTracer_QBaseIsSignalConnected(const QCPItemTracer* self, const QMetaMethod* signal) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_IsSignalConnected_IsBase(true);
        return vqcpitemtracer->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPItemTracer*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemTracer_OnIsSignalConnected(const QCPItemTracer* self, intptr_t slot) {
    auto* vqcpitemtracer = const_cast<VirtualQCPItemTracer*>(dynamic_cast<const VirtualQCPItemTracer*>(self));
    if (vqcpitemtracer && vqcpitemtracer->isVirtualQCPItemTracer) {
        vqcpitemtracer->setQCPItemTracer_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPItemTracer::QCPItemTracer_IsSignalConnected_Callback>(slot));
    }
}

void QCPItemTracer_Delete(QCPItemTracer* self) {
    delete self;
}

QCPItemBracket* QCPItemBracket_new(QCustomPlot* parentPlot) {
    return new VirtualQCPItemBracket(parentPlot);
}

QMetaObject* QCPItemBracket_MetaObject(const QCPItemBracket* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPItemBracket_Metacast(QCPItemBracket* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPItemBracket_Metacall(QCPItemBracket* self, int param1, int param2, void** param3) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPItemBracket*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPItemBracket_Tr(const char* s) {
    QString _ret = QCPItemBracket::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

QPen* QCPItemBracket_Pen(const QCPItemBracket* self) {
    return new QPen(self->pen());
}

QPen* QCPItemBracket_SelectedPen(const QCPItemBracket* self) {
    return new QPen(self->selectedPen());
}

double QCPItemBracket_Length(const QCPItemBracket* self) {
    return self->length();
}

int QCPItemBracket_Style(const QCPItemBracket* self) {
    return static_cast<int>(self->style());
}

void QCPItemBracket_SetPen(QCPItemBracket* self, const QPen* pen) {
    self->setPen(*pen);
}

void QCPItemBracket_SetSelectedPen(QCPItemBracket* self, const QPen* pen) {
    self->setSelectedPen(*pen);
}

void QCPItemBracket_SetLength(QCPItemBracket* self, double length) {
    self->setLength(static_cast<double>(length));
}

void QCPItemBracket_SetStyle(QCPItemBracket* self, int style) {
    self->setStyle(static_cast<QCPItemBracket::BracketStyle>(style));
}

double QCPItemBracket_SelectTest(const QCPItemBracket* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpitembracket = dynamic_cast<const VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPItemBracket*)self)->selectTest(*pos, onlySelectable, details);
    }
}

QCPItemPosition* QCPItemBracket_Left(const QCPItemBracket* self) {
    return (QCPItemPosition*)self->left;
}

QCPItemPosition* QCPItemBracket_Right(const QCPItemBracket* self) {
    return (QCPItemPosition*)self->right;
}

QCPItemAnchor* QCPItemBracket_Center(const QCPItemBracket* self) {
    return (QCPItemAnchor*)self->center;
}

void QCPItemBracket_Draw(QCPItemBracket* self, QCPPainter* painter) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->draw(painter);
    }
}

QPointF* QCPItemBracket_AnchorPixelPosition(const QCPItemBracket* self, int anchorId) {
    auto* vqcpitembracket = dynamic_cast<const VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        return new QPointF(vqcpitembracket->anchorPixelPosition(static_cast<int>(anchorId)));
    }
    return {};
}

libqt_string QCPItemBracket_Tr2(const char* s, const char* c) {
    QString _ret = QCPItemBracket::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPItemBracket_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPItemBracket::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPItemBracket_QBaseMetacall(QCPItemBracket* self, int param1, int param2, void** param3) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_Metacall_IsBase(true);
        return vqcpitembracket->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPItemBracket::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnMetacall(QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_Metacall_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
double QCPItemBracket_QBaseSelectTest(const QCPItemBracket* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_SelectTest_IsBase(true);
        return vqcpitembracket->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPItemBracket::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnSelectTest(const QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_SelectTest_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
void QCPItemBracket_QBaseDraw(QCPItemBracket* self, QCPPainter* painter) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_Draw_IsBase(true);
        vqcpitembracket->draw(painter);
    } else {
        ((VirtualQCPItemBracket*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnDraw(QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_Draw_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_Draw_Callback>(slot));
    }
}

// Base class handler implementation
QPointF* QCPItemBracket_QBaseAnchorPixelPosition(const QCPItemBracket* self, int anchorId) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_AnchorPixelPosition_IsBase(true);
        return new QPointF(vqcpitembracket->anchorPixelPosition(static_cast<int>(anchorId)));
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnAnchorPixelPosition(const QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_AnchorPixelPosition_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_AnchorPixelPosition_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemBracket_SelectionCategory(const QCPItemBracket* self) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        return static_cast<int>(vqcpitembracket->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPItemBracket*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPItemBracket_QBaseSelectionCategory(const QCPItemBracket* self) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcpitembracket->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPItemBracket*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnSelectionCategory(const QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_SelectionCategory_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPItemBracket_ClipRect(const QCPItemBracket* self) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        return new QRect(vqcpitembracket->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPItemBracket_QBaseClipRect(const QCPItemBracket* self) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_ClipRect_IsBase(true);
        return new QRect(vqcpitembracket->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnClipRect(const QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_ClipRect_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemBracket_ApplyDefaultAntialiasingHint(const QCPItemBracket* self, QCPPainter* painter) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPItemBracket*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPItemBracket_QBaseApplyDefaultAntialiasingHint(const QCPItemBracket* self, QCPPainter* painter) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcpitembracket->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPItemBracket*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnApplyDefaultAntialiasingHint(const QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemBracket_SelectEvent(QCPItemBracket* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPItemBracket*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPItemBracket_QBaseSelectEvent(QCPItemBracket* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_SelectEvent_IsBase(true);
        vqcpitembracket->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPItemBracket*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnSelectEvent(QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_SelectEvent_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemBracket_DeselectEvent(QCPItemBracket* self, bool* selectionStateChanged) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPItemBracket*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPItemBracket_QBaseDeselectEvent(QCPItemBracket* self, bool* selectionStateChanged) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_DeselectEvent_IsBase(true);
        vqcpitembracket->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPItemBracket*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnDeselectEvent(QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_DeselectEvent_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemBracket_ParentPlotInitialized(QCPItemBracket* self, QCustomPlot* parentPlot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPItemBracket*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPItemBracket_QBaseParentPlotInitialized(QCPItemBracket* self, QCustomPlot* parentPlot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_ParentPlotInitialized_IsBase(true);
        vqcpitembracket->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPItemBracket*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnParentPlotInitialized(QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemBracket_MousePressEvent(QCPItemBracket* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPItemBracket*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPItemBracket_QBaseMousePressEvent(QCPItemBracket* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_MousePressEvent_IsBase(true);
        vqcpitembracket->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPItemBracket*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnMousePressEvent(QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_MousePressEvent_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemBracket_MouseMoveEvent(QCPItemBracket* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPItemBracket*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPItemBracket_QBaseMouseMoveEvent(QCPItemBracket* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_MouseMoveEvent_IsBase(true);
        vqcpitembracket->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPItemBracket*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnMouseMoveEvent(QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemBracket_MouseReleaseEvent(QCPItemBracket* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPItemBracket*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPItemBracket_QBaseMouseReleaseEvent(QCPItemBracket* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_MouseReleaseEvent_IsBase(true);
        vqcpitembracket->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPItemBracket*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnMouseReleaseEvent(QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemBracket_MouseDoubleClickEvent(QCPItemBracket* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPItemBracket*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPItemBracket_QBaseMouseDoubleClickEvent(QCPItemBracket* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_MouseDoubleClickEvent_IsBase(true);
        vqcpitembracket->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPItemBracket*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnMouseDoubleClickEvent(QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemBracket_WheelEvent(QCPItemBracket* self, QWheelEvent* event) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->wheelEvent(event);
    } else {
        ((VirtualQCPItemBracket*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPItemBracket_QBaseWheelEvent(QCPItemBracket* self, QWheelEvent* event) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_WheelEvent_IsBase(true);
        vqcpitembracket->wheelEvent(event);
    } else {
        ((VirtualQCPItemBracket*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnWheelEvent(QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_WheelEvent_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemBracket_Event(QCPItemBracket* self, QEvent* event) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        return vqcpitembracket->event(event);
    } else {
        return self->QCPItemBracket::event(event);
    }
}

// Base class handler implementation
bool QCPItemBracket_QBaseEvent(QCPItemBracket* self, QEvent* event) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_Event_IsBase(true);
        return vqcpitembracket->event(event);
    } else {
        return self->QCPItemBracket::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnEvent(QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_Event_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemBracket_EventFilter(QCPItemBracket* self, QObject* watched, QEvent* event) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        return vqcpitembracket->eventFilter(watched, event);
    } else {
        return self->QCPItemBracket::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPItemBracket_QBaseEventFilter(QCPItemBracket* self, QObject* watched, QEvent* event) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_EventFilter_IsBase(true);
        return vqcpitembracket->eventFilter(watched, event);
    } else {
        return self->QCPItemBracket::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnEventFilter(QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_EventFilter_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemBracket_TimerEvent(QCPItemBracket* self, QTimerEvent* event) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->timerEvent(event);
    } else {
        ((VirtualQCPItemBracket*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPItemBracket_QBaseTimerEvent(QCPItemBracket* self, QTimerEvent* event) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_TimerEvent_IsBase(true);
        vqcpitembracket->timerEvent(event);
    } else {
        ((VirtualQCPItemBracket*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnTimerEvent(QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_TimerEvent_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemBracket_ChildEvent(QCPItemBracket* self, QChildEvent* event) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->childEvent(event);
    } else {
        ((VirtualQCPItemBracket*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPItemBracket_QBaseChildEvent(QCPItemBracket* self, QChildEvent* event) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_ChildEvent_IsBase(true);
        vqcpitembracket->childEvent(event);
    } else {
        ((VirtualQCPItemBracket*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnChildEvent(QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_ChildEvent_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemBracket_CustomEvent(QCPItemBracket* self, QEvent* event) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->customEvent(event);
    } else {
        ((VirtualQCPItemBracket*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPItemBracket_QBaseCustomEvent(QCPItemBracket* self, QEvent* event) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_CustomEvent_IsBase(true);
        vqcpitembracket->customEvent(event);
    } else {
        ((VirtualQCPItemBracket*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnCustomEvent(QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_CustomEvent_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemBracket_ConnectNotify(QCPItemBracket* self, const QMetaMethod* signal) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->connectNotify(*signal);
    } else {
        ((VirtualQCPItemBracket*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPItemBracket_QBaseConnectNotify(QCPItemBracket* self, const QMetaMethod* signal) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_ConnectNotify_IsBase(true);
        vqcpitembracket->connectNotify(*signal);
    } else {
        ((VirtualQCPItemBracket*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnConnectNotify(QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_ConnectNotify_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemBracket_DisconnectNotify(QCPItemBracket* self, const QMetaMethod* signal) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->disconnectNotify(*signal);
    } else {
        ((VirtualQCPItemBracket*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPItemBracket_QBaseDisconnectNotify(QCPItemBracket* self, const QMetaMethod* signal) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_DisconnectNotify_IsBase(true);
        vqcpitembracket->disconnectNotify(*signal);
    } else {
        ((VirtualQCPItemBracket*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnDisconnectNotify(QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
QPen* QCPItemBracket_MainPen(const QCPItemBracket* self) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        return new QPen(vqcpitembracket->mainPen());
    }
    return {};
}

// Base class handler implementation
QPen* QCPItemBracket_QBaseMainPen(const QCPItemBracket* self) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_MainPen_IsBase(true);
        return new QPen(vqcpitembracket->mainPen());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnMainPen(const QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_MainPen_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_MainPen_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPItemBracket_RectDistance(const QCPItemBracket* self, const QRectF* rect, const QPointF* pos, bool filledRect) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        return vqcpitembracket->rectDistance(*rect, *pos, filledRect);
    } else {
        return ((VirtualQCPItemBracket*)self)->rectDistance(*rect, *pos, filledRect);
    }
}

// Base class handler implementation
double QCPItemBracket_QBaseRectDistance(const QCPItemBracket* self, const QRectF* rect, const QPointF* pos, bool filledRect) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_RectDistance_IsBase(true);
        return vqcpitembracket->rectDistance(*rect, *pos, filledRect);
    } else {
        return ((VirtualQCPItemBracket*)self)->rectDistance(*rect, *pos, filledRect);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnRectDistance(const QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_RectDistance_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_RectDistance_Callback>(slot));
    }
}

// Derived class handler implementation
QCPItemPosition* QCPItemBracket_CreatePosition(QCPItemBracket* self, const libqt_string name) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        return vqcpitembracket->createPosition(name_QString);
    } else {
        return ((VirtualQCPItemBracket*)self)->createPosition(name_QString);
    }
}

// Base class handler implementation
QCPItemPosition* QCPItemBracket_QBaseCreatePosition(QCPItemBracket* self, const libqt_string name) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_CreatePosition_IsBase(true);
        return vqcpitembracket->createPosition(name_QString);
    } else {
        return ((VirtualQCPItemBracket*)self)->createPosition(name_QString);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnCreatePosition(QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_CreatePosition_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_CreatePosition_Callback>(slot));
    }
}

// Derived class handler implementation
QCPItemAnchor* QCPItemBracket_CreateAnchor(QCPItemBracket* self, const libqt_string name, int anchorId) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        return vqcpitembracket->createAnchor(name_QString, static_cast<int>(anchorId));
    } else {
        return ((VirtualQCPItemBracket*)self)->createAnchor(name_QString, static_cast<int>(anchorId));
    }
}

// Base class handler implementation
QCPItemAnchor* QCPItemBracket_QBaseCreateAnchor(QCPItemBracket* self, const libqt_string name, int anchorId) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    QString name_QString = QString::fromUtf8(name.data, name.len);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_CreateAnchor_IsBase(true);
        return vqcpitembracket->createAnchor(name_QString, static_cast<int>(anchorId));
    } else {
        return ((VirtualQCPItemBracket*)self)->createAnchor(name_QString, static_cast<int>(anchorId));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnCreateAnchor(QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_CreateAnchor_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_CreateAnchor_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemBracket_InitializeParentPlot(QCPItemBracket* self, QCustomPlot* parentPlot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPItemBracket*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPItemBracket_QBaseInitializeParentPlot(QCPItemBracket* self, QCustomPlot* parentPlot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_InitializeParentPlot_IsBase(true);
        vqcpitembracket->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPItemBracket*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnInitializeParentPlot(QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemBracket_SetParentLayerable(QCPItemBracket* self, QCPLayerable* parentLayerable) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPItemBracket*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPItemBracket_QBaseSetParentLayerable(QCPItemBracket* self, QCPLayerable* parentLayerable) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_SetParentLayerable_IsBase(true);
        vqcpitembracket->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPItemBracket*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnSetParentLayerable(QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemBracket_MoveToLayer(QCPItemBracket* self, QCPLayer* layer, bool prepend) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        return vqcpitembracket->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPItemBracket*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPItemBracket_QBaseMoveToLayer(QCPItemBracket* self, QCPLayer* layer, bool prepend) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_MoveToLayer_IsBase(true);
        return vqcpitembracket->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPItemBracket*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnMoveToLayer(QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = dynamic_cast<VirtualQCPItemBracket*>(self);
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_MoveToLayer_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPItemBracket_ApplyAntialiasingHint(const QCPItemBracket* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPItemBracket*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPItemBracket_QBaseApplyAntialiasingHint(const QCPItemBracket* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_ApplyAntialiasingHint_IsBase(true);
        vqcpitembracket->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPItemBracket*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnApplyAntialiasingHint(const QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPItemBracket_Sender(const QCPItemBracket* self) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        return vqcpitembracket->sender();
    } else {
        return ((VirtualQCPItemBracket*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPItemBracket_QBaseSender(const QCPItemBracket* self) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_Sender_IsBase(true);
        return vqcpitembracket->sender();
    } else {
        return ((VirtualQCPItemBracket*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnSender(const QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_Sender_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemBracket_SenderSignalIndex(const QCPItemBracket* self) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        return vqcpitembracket->senderSignalIndex();
    } else {
        return ((VirtualQCPItemBracket*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPItemBracket_QBaseSenderSignalIndex(const QCPItemBracket* self) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_SenderSignalIndex_IsBase(true);
        return vqcpitembracket->senderSignalIndex();
    } else {
        return ((VirtualQCPItemBracket*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnSenderSignalIndex(const QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPItemBracket_Receivers(const QCPItemBracket* self, const char* signal) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        return vqcpitembracket->receivers(signal);
    } else {
        return ((VirtualQCPItemBracket*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPItemBracket_QBaseReceivers(const QCPItemBracket* self, const char* signal) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_Receivers_IsBase(true);
        return vqcpitembracket->receivers(signal);
    } else {
        return ((VirtualQCPItemBracket*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnReceivers(const QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_Receivers_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPItemBracket_IsSignalConnected(const QCPItemBracket* self, const QMetaMethod* signal) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        return vqcpitembracket->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPItemBracket*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPItemBracket_QBaseIsSignalConnected(const QCPItemBracket* self, const QMetaMethod* signal) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_IsSignalConnected_IsBase(true);
        return vqcpitembracket->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPItemBracket*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPItemBracket_OnIsSignalConnected(const QCPItemBracket* self, intptr_t slot) {
    auto* vqcpitembracket = const_cast<VirtualQCPItemBracket*>(dynamic_cast<const VirtualQCPItemBracket*>(self));
    if (vqcpitembracket && vqcpitembracket->isVirtualQCPItemBracket) {
        vqcpitembracket->setQCPItemBracket_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPItemBracket::QCPItemBracket_IsSignalConnected_Callback>(slot));
    }
}

void QCPItemBracket_Delete(QCPItemBracket* self) {
    delete self;
}

QCPPolarAxisRadial* QCPPolarAxisRadial_new(QCPPolarAxisAngular* parent) {
    return new VirtualQCPPolarAxisRadial(parent);
}

QMetaObject* QCPPolarAxisRadial_MetaObject(const QCPPolarAxisRadial* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPPolarAxisRadial_Metacast(QCPPolarAxisRadial* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPPolarAxisRadial_Metacall(QCPPolarAxisRadial* self, int param1, int param2, void** param3) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPPolarAxisRadial*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPPolarAxisRadial_Tr(const char* s) {
    QString _ret = QCPPolarAxisRadial::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

bool QCPPolarAxisRadial_RangeDrag(const QCPPolarAxisRadial* self) {
    return self->rangeDrag();
}

bool QCPPolarAxisRadial_RangeZoom(const QCPPolarAxisRadial* self) {
    return self->rangeZoom();
}

double QCPPolarAxisRadial_RangeZoomFactor(const QCPPolarAxisRadial* self) {
    return self->rangeZoomFactor();
}

QCPPolarAxisAngular* QCPPolarAxisRadial_AngularAxis(const QCPPolarAxisRadial* self) {
    return self->angularAxis();
}

int QCPPolarAxisRadial_ScaleType(const QCPPolarAxisRadial* self) {
    return static_cast<int>(self->scaleType());
}

QCPRange* QCPPolarAxisRadial_Range(const QCPPolarAxisRadial* self) {
    return new QCPRange(self->range());
}

bool QCPPolarAxisRadial_RangeReversed(const QCPPolarAxisRadial* self) {
    return self->rangeReversed();
}

double QCPPolarAxisRadial_Angle(const QCPPolarAxisRadial* self) {
    return self->angle();
}

int QCPPolarAxisRadial_AngleReference(const QCPPolarAxisRadial* self) {
    return static_cast<int>(self->angleReference());
}

bool QCPPolarAxisRadial_Ticks(const QCPPolarAxisRadial* self) {
    return self->ticks();
}

bool QCPPolarAxisRadial_TickLabels(const QCPPolarAxisRadial* self) {
    return self->tickLabels();
}

int QCPPolarAxisRadial_TickLabelPadding(const QCPPolarAxisRadial* self) {
    return self->tickLabelPadding();
}

QFont* QCPPolarAxisRadial_TickLabelFont(const QCPPolarAxisRadial* self) {
    return new QFont(self->tickLabelFont());
}

QColor* QCPPolarAxisRadial_TickLabelColor(const QCPPolarAxisRadial* self) {
    return new QColor(self->tickLabelColor());
}

double QCPPolarAxisRadial_TickLabelRotation(const QCPPolarAxisRadial* self) {
    return self->tickLabelRotation();
}

int QCPPolarAxisRadial_TickLabelMode(const QCPPolarAxisRadial* self) {
    return static_cast<int>(self->tickLabelMode());
}

libqt_string QCPPolarAxisRadial_NumberFormat(const QCPPolarAxisRadial* self) {
    QString _ret = self->numberFormat();
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

int QCPPolarAxisRadial_NumberPrecision(const QCPPolarAxisRadial* self) {
    return self->numberPrecision();
}

libqt_list /* of double */ QCPPolarAxisRadial_TickVector(const QCPPolarAxisRadial* self) {
    QVector<double> _ret = self->tickVector();
    // Convert QVector<> from C++ memory to manually-managed C memory
    double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

libqt_list /* of double */ QCPPolarAxisRadial_SubTickVector(const QCPPolarAxisRadial* self) {
    QVector<double> _ret = self->subTickVector();
    // Convert QVector<> from C++ memory to manually-managed C memory
    double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

libqt_list /* of libqt_string */ QCPPolarAxisRadial_TickVectorLabels(const QCPPolarAxisRadial* self) {
    QVector<QString> _ret = self->tickVectorLabels();
    // Convert QVector<> from C++ memory to manually-managed C memory
    libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        QString _vv_ret = _ret[i];
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _vv_b = _vv_ret.toUtf8();
        libqt_string _vv_str;
        _vv_str.len = _vv_b.length();
        _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
        memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
        ((char*)_vv_str.data)[_vv_str.len] = '\0';
        _arr[i] = _vv_str;
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

int QCPPolarAxisRadial_TickLengthIn(const QCPPolarAxisRadial* self) {
    return self->tickLengthIn();
}

int QCPPolarAxisRadial_TickLengthOut(const QCPPolarAxisRadial* self) {
    return self->tickLengthOut();
}

bool QCPPolarAxisRadial_SubTicks(const QCPPolarAxisRadial* self) {
    return self->subTicks();
}

int QCPPolarAxisRadial_SubTickLengthIn(const QCPPolarAxisRadial* self) {
    return self->subTickLengthIn();
}

int QCPPolarAxisRadial_SubTickLengthOut(const QCPPolarAxisRadial* self) {
    return self->subTickLengthOut();
}

QPen* QCPPolarAxisRadial_BasePen(const QCPPolarAxisRadial* self) {
    return new QPen(self->basePen());
}

QPen* QCPPolarAxisRadial_TickPen(const QCPPolarAxisRadial* self) {
    return new QPen(self->tickPen());
}

QPen* QCPPolarAxisRadial_SubTickPen(const QCPPolarAxisRadial* self) {
    return new QPen(self->subTickPen());
}

QFont* QCPPolarAxisRadial_LabelFont(const QCPPolarAxisRadial* self) {
    return new QFont(self->labelFont());
}

QColor* QCPPolarAxisRadial_LabelColor(const QCPPolarAxisRadial* self) {
    return new QColor(self->labelColor());
}

libqt_string QCPPolarAxisRadial_Label(const QCPPolarAxisRadial* self) {
    QString _ret = self->label();
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

int QCPPolarAxisRadial_LabelPadding(const QCPPolarAxisRadial* self) {
    return self->labelPadding();
}

int QCPPolarAxisRadial_SelectedParts(const QCPPolarAxisRadial* self) {
    return static_cast<int>(self->selectedParts());
}

int QCPPolarAxisRadial_SelectableParts(const QCPPolarAxisRadial* self) {
    return static_cast<int>(self->selectableParts());
}

QFont* QCPPolarAxisRadial_SelectedTickLabelFont(const QCPPolarAxisRadial* self) {
    return new QFont(self->selectedTickLabelFont());
}

QFont* QCPPolarAxisRadial_SelectedLabelFont(const QCPPolarAxisRadial* self) {
    return new QFont(self->selectedLabelFont());
}

QColor* QCPPolarAxisRadial_SelectedTickLabelColor(const QCPPolarAxisRadial* self) {
    return new QColor(self->selectedTickLabelColor());
}

QColor* QCPPolarAxisRadial_SelectedLabelColor(const QCPPolarAxisRadial* self) {
    return new QColor(self->selectedLabelColor());
}

QPen* QCPPolarAxisRadial_SelectedBasePen(const QCPPolarAxisRadial* self) {
    return new QPen(self->selectedBasePen());
}

QPen* QCPPolarAxisRadial_SelectedTickPen(const QCPPolarAxisRadial* self) {
    return new QPen(self->selectedTickPen());
}

QPen* QCPPolarAxisRadial_SelectedSubTickPen(const QCPPolarAxisRadial* self) {
    return new QPen(self->selectedSubTickPen());
}

void QCPPolarAxisRadial_SetRangeDrag(QCPPolarAxisRadial* self, bool enabled) {
    self->setRangeDrag(enabled);
}

void QCPPolarAxisRadial_SetRangeZoom(QCPPolarAxisRadial* self, bool enabled) {
    self->setRangeZoom(enabled);
}

void QCPPolarAxisRadial_SetRangeZoomFactor(QCPPolarAxisRadial* self, double factor) {
    self->setRangeZoomFactor(static_cast<double>(factor));
}

void QCPPolarAxisRadial_SetScaleType(QCPPolarAxisRadial* self, int typeVal) {
    self->setScaleType(static_cast<QCPPolarAxisRadial::ScaleType>(typeVal));
}

void QCPPolarAxisRadial_SetRange(QCPPolarAxisRadial* self, const QCPRange* range) {
    self->setRange(*range);
}

void QCPPolarAxisRadial_SetRange2(QCPPolarAxisRadial* self, double lower, double upper) {
    self->setRange(static_cast<double>(lower), static_cast<double>(upper));
}

void QCPPolarAxisRadial_SetRange3(QCPPolarAxisRadial* self, double position, double size, int alignment) {
    self->setRange(static_cast<double>(position), static_cast<double>(size), static_cast<Qt::AlignmentFlag>(alignment));
}

void QCPPolarAxisRadial_SetRangeLower(QCPPolarAxisRadial* self, double lower) {
    self->setRangeLower(static_cast<double>(lower));
}

void QCPPolarAxisRadial_SetRangeUpper(QCPPolarAxisRadial* self, double upper) {
    self->setRangeUpper(static_cast<double>(upper));
}

void QCPPolarAxisRadial_SetRangeReversed(QCPPolarAxisRadial* self, bool reversed) {
    self->setRangeReversed(reversed);
}

void QCPPolarAxisRadial_SetAngle(QCPPolarAxisRadial* self, double degrees) {
    self->setAngle(static_cast<double>(degrees));
}

void QCPPolarAxisRadial_SetAngleReference(QCPPolarAxisRadial* self, int reference) {
    self->setAngleReference(static_cast<QCPPolarAxisRadial::AngleReference>(reference));
}

void QCPPolarAxisRadial_SetTicks(QCPPolarAxisRadial* self, bool show) {
    self->setTicks(show);
}

void QCPPolarAxisRadial_SetTickLabels(QCPPolarAxisRadial* self, bool show) {
    self->setTickLabels(show);
}

void QCPPolarAxisRadial_SetTickLabelPadding(QCPPolarAxisRadial* self, int padding) {
    self->setTickLabelPadding(static_cast<int>(padding));
}

void QCPPolarAxisRadial_SetTickLabelFont(QCPPolarAxisRadial* self, const QFont* font) {
    self->setTickLabelFont(*font);
}

void QCPPolarAxisRadial_SetTickLabelColor(QCPPolarAxisRadial* self, const QColor* color) {
    self->setTickLabelColor(*color);
}

void QCPPolarAxisRadial_SetTickLabelRotation(QCPPolarAxisRadial* self, double degrees) {
    self->setTickLabelRotation(static_cast<double>(degrees));
}

void QCPPolarAxisRadial_SetTickLabelMode(QCPPolarAxisRadial* self, int mode) {
    self->setTickLabelMode(static_cast<QCPPolarAxisRadial::LabelMode>(mode));
}

void QCPPolarAxisRadial_SetNumberFormat(QCPPolarAxisRadial* self, const libqt_string formatCode) {
    QString formatCode_QString = QString::fromUtf8(formatCode.data, formatCode.len);
    self->setNumberFormat(formatCode_QString);
}

void QCPPolarAxisRadial_SetNumberPrecision(QCPPolarAxisRadial* self, int precision) {
    self->setNumberPrecision(static_cast<int>(precision));
}

void QCPPolarAxisRadial_SetTickLength(QCPPolarAxisRadial* self, int inside) {
    self->setTickLength(static_cast<int>(inside));
}

void QCPPolarAxisRadial_SetTickLengthIn(QCPPolarAxisRadial* self, int inside) {
    self->setTickLengthIn(static_cast<int>(inside));
}

void QCPPolarAxisRadial_SetTickLengthOut(QCPPolarAxisRadial* self, int outside) {
    self->setTickLengthOut(static_cast<int>(outside));
}

void QCPPolarAxisRadial_SetSubTicks(QCPPolarAxisRadial* self, bool show) {
    self->setSubTicks(show);
}

void QCPPolarAxisRadial_SetSubTickLength(QCPPolarAxisRadial* self, int inside) {
    self->setSubTickLength(static_cast<int>(inside));
}

void QCPPolarAxisRadial_SetSubTickLengthIn(QCPPolarAxisRadial* self, int inside) {
    self->setSubTickLengthIn(static_cast<int>(inside));
}

void QCPPolarAxisRadial_SetSubTickLengthOut(QCPPolarAxisRadial* self, int outside) {
    self->setSubTickLengthOut(static_cast<int>(outside));
}

void QCPPolarAxisRadial_SetBasePen(QCPPolarAxisRadial* self, const QPen* pen) {
    self->setBasePen(*pen);
}

void QCPPolarAxisRadial_SetTickPen(QCPPolarAxisRadial* self, const QPen* pen) {
    self->setTickPen(*pen);
}

void QCPPolarAxisRadial_SetSubTickPen(QCPPolarAxisRadial* self, const QPen* pen) {
    self->setSubTickPen(*pen);
}

void QCPPolarAxisRadial_SetLabelFont(QCPPolarAxisRadial* self, const QFont* font) {
    self->setLabelFont(*font);
}

void QCPPolarAxisRadial_SetLabelColor(QCPPolarAxisRadial* self, const QColor* color) {
    self->setLabelColor(*color);
}

void QCPPolarAxisRadial_SetLabel(QCPPolarAxisRadial* self, const libqt_string str) {
    QString str_QString = QString::fromUtf8(str.data, str.len);
    self->setLabel(str_QString);
}

void QCPPolarAxisRadial_SetLabelPadding(QCPPolarAxisRadial* self, int padding) {
    self->setLabelPadding(static_cast<int>(padding));
}

void QCPPolarAxisRadial_SetSelectedTickLabelFont(QCPPolarAxisRadial* self, const QFont* font) {
    self->setSelectedTickLabelFont(*font);
}

void QCPPolarAxisRadial_SetSelectedLabelFont(QCPPolarAxisRadial* self, const QFont* font) {
    self->setSelectedLabelFont(*font);
}

void QCPPolarAxisRadial_SetSelectedTickLabelColor(QCPPolarAxisRadial* self, const QColor* color) {
    self->setSelectedTickLabelColor(*color);
}

void QCPPolarAxisRadial_SetSelectedLabelColor(QCPPolarAxisRadial* self, const QColor* color) {
    self->setSelectedLabelColor(*color);
}

void QCPPolarAxisRadial_SetSelectedBasePen(QCPPolarAxisRadial* self, const QPen* pen) {
    self->setSelectedBasePen(*pen);
}

void QCPPolarAxisRadial_SetSelectedTickPen(QCPPolarAxisRadial* self, const QPen* pen) {
    self->setSelectedTickPen(*pen);
}

void QCPPolarAxisRadial_SetSelectedSubTickPen(QCPPolarAxisRadial* self, const QPen* pen) {
    self->setSelectedSubTickPen(*pen);
}

void QCPPolarAxisRadial_SetSelectableParts(QCPPolarAxisRadial* self, const int* selectableParts) {
    self->setSelectableParts((const QCPPolarAxisRadial::SelectableParts&)(*selectableParts));
}

void QCPPolarAxisRadial_SetSelectedParts(QCPPolarAxisRadial* self, const int* selectedParts) {
    self->setSelectedParts((const QCPPolarAxisRadial::SelectableParts&)(*selectedParts));
}

double QCPPolarAxisRadial_SelectTest(const QCPPolarAxisRadial* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcppolaraxisradial = dynamic_cast<const VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPPolarAxisRadial*)self)->selectTest(*pos, onlySelectable, details);
    }
}

void QCPPolarAxisRadial_MoveRange(QCPPolarAxisRadial* self, double diff) {
    self->moveRange(static_cast<double>(diff));
}

void QCPPolarAxisRadial_ScaleRange(QCPPolarAxisRadial* self, double factor) {
    self->scaleRange(static_cast<double>(factor));
}

void QCPPolarAxisRadial_ScaleRange2(QCPPolarAxisRadial* self, double factor, double center) {
    self->scaleRange(static_cast<double>(factor), static_cast<double>(center));
}

void QCPPolarAxisRadial_Rescale(QCPPolarAxisRadial* self) {
    self->rescale();
}

void QCPPolarAxisRadial_PixelToCoord(const QCPPolarAxisRadial* self, QPointF* pixelPos, double* angleCoord, double* radiusCoord) {
    self->pixelToCoord(*pixelPos, static_cast<double&>(*angleCoord), static_cast<double&>(*radiusCoord));
}

QPointF* QCPPolarAxisRadial_CoordToPixel(const QCPPolarAxisRadial* self, double angleCoord, double radiusCoord) {
    return new QPointF(self->coordToPixel(static_cast<double>(angleCoord), static_cast<double>(radiusCoord)));
}

double QCPPolarAxisRadial_CoordToRadius(const QCPPolarAxisRadial* self, double coord) {
    return self->coordToRadius(static_cast<double>(coord));
}

double QCPPolarAxisRadial_RadiusToCoord(const QCPPolarAxisRadial* self, double radius) {
    return self->radiusToCoord(static_cast<double>(radius));
}

int QCPPolarAxisRadial_GetPartAt(const QCPPolarAxisRadial* self, const QPointF* pos) {
    return static_cast<int>(self->getPartAt(*pos));
}

void QCPPolarAxisRadial_RangeChanged(QCPPolarAxisRadial* self, const QCPRange* newRange) {
    self->rangeChanged(*newRange);
}

void QCPPolarAxisRadial_RangeChanged2(QCPPolarAxisRadial* self, const QCPRange* newRange, const QCPRange* oldRange) {
    self->rangeChanged(*newRange, *oldRange);
}

void QCPPolarAxisRadial_ScaleTypeChanged(QCPPolarAxisRadial* self, int scaleType) {
    self->scaleTypeChanged(static_cast<QCPPolarAxisRadial::ScaleType>(scaleType));
}

void QCPPolarAxisRadial_SelectionChanged(QCPPolarAxisRadial* self, const int* parts) {
    self->selectionChanged((const QCPPolarAxisRadial::SelectableParts&)(*parts));
}

void QCPPolarAxisRadial_SelectableChanged(QCPPolarAxisRadial* self, const int* parts) {
    self->selectableChanged((const QCPPolarAxisRadial::SelectableParts&)(*parts));
}

void QCPPolarAxisRadial_ApplyDefaultAntialiasingHint(const QCPPolarAxisRadial* self, QCPPainter* painter) {
    auto* vqcppolaraxisradial = dynamic_cast<const VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->applyDefaultAntialiasingHint(painter);
    }
}

void QCPPolarAxisRadial_Draw(QCPPolarAxisRadial* self, QCPPainter* painter) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->draw(painter);
    }
}

int QCPPolarAxisRadial_SelectionCategory(const QCPPolarAxisRadial* self) {
    auto* vqcppolaraxisradial = dynamic_cast<const VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        return static_cast<int>(vqcppolaraxisradial->selectionCategory());
    }
    return {};
}

void QCPPolarAxisRadial_SelectEvent(QCPPolarAxisRadial* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

void QCPPolarAxisRadial_DeselectEvent(QCPPolarAxisRadial* self, bool* selectionStateChanged) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->deselectEvent(selectionStateChanged);
    }
}

void QCPPolarAxisRadial_MousePressEvent(QCPPolarAxisRadial* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->mousePressEvent(event, *details);
    }
}

void QCPPolarAxisRadial_MouseMoveEvent(QCPPolarAxisRadial* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->mouseMoveEvent(event, *startPos);
    }
}

void QCPPolarAxisRadial_MouseReleaseEvent(QCPPolarAxisRadial* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->mouseReleaseEvent(event, *startPos);
    }
}

void QCPPolarAxisRadial_WheelEvent(QCPPolarAxisRadial* self, QWheelEvent* event) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->wheelEvent(event);
    }
}

libqt_string QCPPolarAxisRadial_Tr2(const char* s, const char* c) {
    QString _ret = QCPPolarAxisRadial::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPPolarAxisRadial_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPPolarAxisRadial::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

void QCPPolarAxisRadial_SetTickLength2(QCPPolarAxisRadial* self, int inside, int outside) {
    self->setTickLength(static_cast<int>(inside), static_cast<int>(outside));
}

void QCPPolarAxisRadial_SetSubTickLength2(QCPPolarAxisRadial* self, int inside, int outside) {
    self->setSubTickLength(static_cast<int>(inside), static_cast<int>(outside));
}

void QCPPolarAxisRadial_Rescale1(QCPPolarAxisRadial* self, bool onlyVisiblePlottables) {
    self->rescale(onlyVisiblePlottables);
}

// Base class handler implementation
int QCPPolarAxisRadial_QBaseMetacall(QCPPolarAxisRadial* self, int param1, int param2, void** param3) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_Metacall_IsBase(true);
        return vqcppolaraxisradial->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPPolarAxisRadial::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnMetacall(QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_Metacall_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
double QCPPolarAxisRadial_QBaseSelectTest(const QCPPolarAxisRadial* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_SelectTest_IsBase(true);
        return vqcppolaraxisradial->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPPolarAxisRadial::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnSelectTest(const QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_SelectTest_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPolarAxisRadial_QBaseApplyDefaultAntialiasingHint(const QCPPolarAxisRadial* self, QCPPainter* painter) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcppolaraxisradial->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnApplyDefaultAntialiasingHint(const QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPolarAxisRadial_QBaseDraw(QCPPolarAxisRadial* self, QCPPainter* painter) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_Draw_IsBase(true);
        vqcppolaraxisradial->draw(painter);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnDraw(QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_Draw_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_Draw_Callback>(slot));
    }
}

// Base class handler implementation
int QCPPolarAxisRadial_QBaseSelectionCategory(const QCPPolarAxisRadial* self) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcppolaraxisradial->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPPolarAxisRadial*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnSelectionCategory(const QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_SelectionCategory_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_SelectionCategory_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPolarAxisRadial_QBaseSelectEvent(QCPPolarAxisRadial* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_SelectEvent_IsBase(true);
        vqcppolaraxisradial->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnSelectEvent(QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_SelectEvent_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_SelectEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPolarAxisRadial_QBaseDeselectEvent(QCPPolarAxisRadial* self, bool* selectionStateChanged) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_DeselectEvent_IsBase(true);
        vqcppolaraxisradial->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnDeselectEvent(QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_DeselectEvent_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_DeselectEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPolarAxisRadial_QBaseMousePressEvent(QCPPolarAxisRadial* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_MousePressEvent_IsBase(true);
        vqcppolaraxisradial->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnMousePressEvent(QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_MousePressEvent_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_MousePressEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPolarAxisRadial_QBaseMouseMoveEvent(QCPPolarAxisRadial* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_MouseMoveEvent_IsBase(true);
        vqcppolaraxisradial->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnMouseMoveEvent(QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_MouseMoveEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPolarAxisRadial_QBaseMouseReleaseEvent(QCPPolarAxisRadial* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_MouseReleaseEvent_IsBase(true);
        vqcppolaraxisradial->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnMouseReleaseEvent(QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_MouseReleaseEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPolarAxisRadial_QBaseWheelEvent(QCPPolarAxisRadial* self, QWheelEvent* event) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_WheelEvent_IsBase(true);
        vqcppolaraxisradial->wheelEvent(event);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnWheelEvent(QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_WheelEvent_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisRadial_ParentPlotInitialized(QCPPolarAxisRadial* self, QCustomPlot* parentPlot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPPolarAxisRadial_QBaseParentPlotInitialized(QCPPolarAxisRadial* self, QCustomPlot* parentPlot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_ParentPlotInitialized_IsBase(true);
        vqcppolaraxisradial->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnParentPlotInitialized(QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPPolarAxisRadial_ClipRect(const QCPPolarAxisRadial* self) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        return new QRect(vqcppolaraxisradial->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPPolarAxisRadial_QBaseClipRect(const QCPPolarAxisRadial* self) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_ClipRect_IsBase(true);
        return new QRect(vqcppolaraxisradial->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnClipRect(const QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_ClipRect_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisRadial_MouseDoubleClickEvent(QCPPolarAxisRadial* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPPolarAxisRadial_QBaseMouseDoubleClickEvent(QCPPolarAxisRadial* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_MouseDoubleClickEvent_IsBase(true);
        vqcppolaraxisradial->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnMouseDoubleClickEvent(QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPPolarAxisRadial_Event(QCPPolarAxisRadial* self, QEvent* event) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        return vqcppolaraxisradial->event(event);
    } else {
        return self->QCPPolarAxisRadial::event(event);
    }
}

// Base class handler implementation
bool QCPPolarAxisRadial_QBaseEvent(QCPPolarAxisRadial* self, QEvent* event) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_Event_IsBase(true);
        return vqcppolaraxisradial->event(event);
    } else {
        return self->QCPPolarAxisRadial::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnEvent(QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_Event_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPPolarAxisRadial_EventFilter(QCPPolarAxisRadial* self, QObject* watched, QEvent* event) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        return vqcppolaraxisradial->eventFilter(watched, event);
    } else {
        return self->QCPPolarAxisRadial::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPPolarAxisRadial_QBaseEventFilter(QCPPolarAxisRadial* self, QObject* watched, QEvent* event) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_EventFilter_IsBase(true);
        return vqcppolaraxisradial->eventFilter(watched, event);
    } else {
        return self->QCPPolarAxisRadial::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnEventFilter(QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_EventFilter_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisRadial_TimerEvent(QCPPolarAxisRadial* self, QTimerEvent* event) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->timerEvent(event);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPPolarAxisRadial_QBaseTimerEvent(QCPPolarAxisRadial* self, QTimerEvent* event) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_TimerEvent_IsBase(true);
        vqcppolaraxisradial->timerEvent(event);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnTimerEvent(QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_TimerEvent_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisRadial_ChildEvent(QCPPolarAxisRadial* self, QChildEvent* event) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->childEvent(event);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPPolarAxisRadial_QBaseChildEvent(QCPPolarAxisRadial* self, QChildEvent* event) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_ChildEvent_IsBase(true);
        vqcppolaraxisradial->childEvent(event);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnChildEvent(QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_ChildEvent_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisRadial_CustomEvent(QCPPolarAxisRadial* self, QEvent* event) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->customEvent(event);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPPolarAxisRadial_QBaseCustomEvent(QCPPolarAxisRadial* self, QEvent* event) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_CustomEvent_IsBase(true);
        vqcppolaraxisradial->customEvent(event);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnCustomEvent(QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_CustomEvent_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisRadial_ConnectNotify(QCPPolarAxisRadial* self, const QMetaMethod* signal) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->connectNotify(*signal);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPPolarAxisRadial_QBaseConnectNotify(QCPPolarAxisRadial* self, const QMetaMethod* signal) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_ConnectNotify_IsBase(true);
        vqcppolaraxisradial->connectNotify(*signal);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnConnectNotify(QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_ConnectNotify_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisRadial_DisconnectNotify(QCPPolarAxisRadial* self, const QMetaMethod* signal) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->disconnectNotify(*signal);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPPolarAxisRadial_QBaseDisconnectNotify(QCPPolarAxisRadial* self, const QMetaMethod* signal) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_DisconnectNotify_IsBase(true);
        vqcppolaraxisradial->disconnectNotify(*signal);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnDisconnectNotify(QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisRadial_UpdateGeometry(QCPPolarAxisRadial* self, const QPointF* center, double radius) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->updateGeometry(*center, static_cast<double>(radius));
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->updateGeometry(*center, static_cast<double>(radius));
    }
}

// Base class handler implementation
void QCPPolarAxisRadial_QBaseUpdateGeometry(QCPPolarAxisRadial* self, const QPointF* center, double radius) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_UpdateGeometry_IsBase(true);
        vqcppolaraxisradial->updateGeometry(*center, static_cast<double>(radius));
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->updateGeometry(*center, static_cast<double>(radius));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnUpdateGeometry(QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_UpdateGeometry_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_UpdateGeometry_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisRadial_SetupTickVectors(QCPPolarAxisRadial* self) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setupTickVectors();
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->setupTickVectors();
    }
}

// Base class handler implementation
void QCPPolarAxisRadial_QBaseSetupTickVectors(QCPPolarAxisRadial* self) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_SetupTickVectors_IsBase(true);
        vqcppolaraxisradial->setupTickVectors();
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->setupTickVectors();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnSetupTickVectors(QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_SetupTickVectors_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_SetupTickVectors_Callback>(slot));
    }
}

// Derived class handler implementation
QPen* QCPPolarAxisRadial_GetBasePen(const QCPPolarAxisRadial* self) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        return new QPen(vqcppolaraxisradial->getBasePen());
    }
    return {};
}

// Base class handler implementation
QPen* QCPPolarAxisRadial_QBaseGetBasePen(const QCPPolarAxisRadial* self) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_GetBasePen_IsBase(true);
        return new QPen(vqcppolaraxisradial->getBasePen());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnGetBasePen(const QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_GetBasePen_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_GetBasePen_Callback>(slot));
    }
}

// Derived class handler implementation
QPen* QCPPolarAxisRadial_GetTickPen(const QCPPolarAxisRadial* self) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        return new QPen(vqcppolaraxisradial->getTickPen());
    }
    return {};
}

// Base class handler implementation
QPen* QCPPolarAxisRadial_QBaseGetTickPen(const QCPPolarAxisRadial* self) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_GetTickPen_IsBase(true);
        return new QPen(vqcppolaraxisradial->getTickPen());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnGetTickPen(const QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_GetTickPen_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_GetTickPen_Callback>(slot));
    }
}

// Derived class handler implementation
QPen* QCPPolarAxisRadial_GetSubTickPen(const QCPPolarAxisRadial* self) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        return new QPen(vqcppolaraxisradial->getSubTickPen());
    }
    return {};
}

// Base class handler implementation
QPen* QCPPolarAxisRadial_QBaseGetSubTickPen(const QCPPolarAxisRadial* self) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_GetSubTickPen_IsBase(true);
        return new QPen(vqcppolaraxisradial->getSubTickPen());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnGetSubTickPen(const QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_GetSubTickPen_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_GetSubTickPen_Callback>(slot));
    }
}

// Derived class handler implementation
QFont* QCPPolarAxisRadial_GetTickLabelFont(const QCPPolarAxisRadial* self) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        return new QFont(vqcppolaraxisradial->getTickLabelFont());
    }
    return {};
}

// Base class handler implementation
QFont* QCPPolarAxisRadial_QBaseGetTickLabelFont(const QCPPolarAxisRadial* self) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_GetTickLabelFont_IsBase(true);
        return new QFont(vqcppolaraxisradial->getTickLabelFont());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnGetTickLabelFont(const QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_GetTickLabelFont_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_GetTickLabelFont_Callback>(slot));
    }
}

// Derived class handler implementation
QFont* QCPPolarAxisRadial_GetLabelFont(const QCPPolarAxisRadial* self) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        return new QFont(vqcppolaraxisradial->getLabelFont());
    }
    return {};
}

// Base class handler implementation
QFont* QCPPolarAxisRadial_QBaseGetLabelFont(const QCPPolarAxisRadial* self) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_GetLabelFont_IsBase(true);
        return new QFont(vqcppolaraxisradial->getLabelFont());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnGetLabelFont(const QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_GetLabelFont_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_GetLabelFont_Callback>(slot));
    }
}

// Derived class handler implementation
QColor* QCPPolarAxisRadial_GetTickLabelColor(const QCPPolarAxisRadial* self) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        return new QColor(vqcppolaraxisradial->getTickLabelColor());
    }
    return {};
}

// Base class handler implementation
QColor* QCPPolarAxisRadial_QBaseGetTickLabelColor(const QCPPolarAxisRadial* self) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_GetTickLabelColor_IsBase(true);
        return new QColor(vqcppolaraxisradial->getTickLabelColor());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnGetTickLabelColor(const QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_GetTickLabelColor_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_GetTickLabelColor_Callback>(slot));
    }
}

// Derived class handler implementation
QColor* QCPPolarAxisRadial_GetLabelColor(const QCPPolarAxisRadial* self) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        return new QColor(vqcppolaraxisradial->getLabelColor());
    }
    return {};
}

// Base class handler implementation
QColor* QCPPolarAxisRadial_QBaseGetLabelColor(const QCPPolarAxisRadial* self) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_GetLabelColor_IsBase(true);
        return new QColor(vqcppolaraxisradial->getLabelColor());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnGetLabelColor(const QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_GetLabelColor_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_GetLabelColor_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisRadial_InitializeParentPlot(QCPPolarAxisRadial* self, QCustomPlot* parentPlot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPPolarAxisRadial_QBaseInitializeParentPlot(QCPPolarAxisRadial* self, QCustomPlot* parentPlot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_InitializeParentPlot_IsBase(true);
        vqcppolaraxisradial->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnInitializeParentPlot(QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisRadial_SetParentLayerable(QCPPolarAxisRadial* self, QCPLayerable* parentLayerable) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPPolarAxisRadial_QBaseSetParentLayerable(QCPPolarAxisRadial* self, QCPLayerable* parentLayerable) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_SetParentLayerable_IsBase(true);
        vqcppolaraxisradial->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnSetParentLayerable(QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPPolarAxisRadial_MoveToLayer(QCPPolarAxisRadial* self, QCPLayer* layer, bool prepend) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        return vqcppolaraxisradial->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPPolarAxisRadial*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPPolarAxisRadial_QBaseMoveToLayer(QCPPolarAxisRadial* self, QCPLayer* layer, bool prepend) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_MoveToLayer_IsBase(true);
        return vqcppolaraxisradial->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPPolarAxisRadial*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnMoveToLayer(QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = dynamic_cast<VirtualQCPPolarAxisRadial*>(self);
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_MoveToLayer_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisRadial_ApplyAntialiasingHint(const QCPPolarAxisRadial* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPPolarAxisRadial_QBaseApplyAntialiasingHint(const QCPPolarAxisRadial* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_ApplyAntialiasingHint_IsBase(true);
        vqcppolaraxisradial->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPPolarAxisRadial*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnApplyAntialiasingHint(const QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPPolarAxisRadial_Sender(const QCPPolarAxisRadial* self) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        return vqcppolaraxisradial->sender();
    } else {
        return ((VirtualQCPPolarAxisRadial*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPPolarAxisRadial_QBaseSender(const QCPPolarAxisRadial* self) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_Sender_IsBase(true);
        return vqcppolaraxisradial->sender();
    } else {
        return ((VirtualQCPPolarAxisRadial*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnSender(const QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_Sender_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPPolarAxisRadial_SenderSignalIndex(const QCPPolarAxisRadial* self) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        return vqcppolaraxisradial->senderSignalIndex();
    } else {
        return ((VirtualQCPPolarAxisRadial*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPPolarAxisRadial_QBaseSenderSignalIndex(const QCPPolarAxisRadial* self) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_SenderSignalIndex_IsBase(true);
        return vqcppolaraxisradial->senderSignalIndex();
    } else {
        return ((VirtualQCPPolarAxisRadial*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnSenderSignalIndex(const QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPPolarAxisRadial_Receivers(const QCPPolarAxisRadial* self, const char* signal) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        return vqcppolaraxisradial->receivers(signal);
    } else {
        return ((VirtualQCPPolarAxisRadial*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPPolarAxisRadial_QBaseReceivers(const QCPPolarAxisRadial* self, const char* signal) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_Receivers_IsBase(true);
        return vqcppolaraxisradial->receivers(signal);
    } else {
        return ((VirtualQCPPolarAxisRadial*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnReceivers(const QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_Receivers_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPPolarAxisRadial_IsSignalConnected(const QCPPolarAxisRadial* self, const QMetaMethod* signal) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        return vqcppolaraxisradial->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPPolarAxisRadial*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPPolarAxisRadial_QBaseIsSignalConnected(const QCPPolarAxisRadial* self, const QMetaMethod* signal) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_IsSignalConnected_IsBase(true);
        return vqcppolaraxisradial->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPPolarAxisRadial*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisRadial_OnIsSignalConnected(const QCPPolarAxisRadial* self, intptr_t slot) {
    auto* vqcppolaraxisradial = const_cast<VirtualQCPPolarAxisRadial*>(dynamic_cast<const VirtualQCPPolarAxisRadial*>(self));
    if (vqcppolaraxisradial && vqcppolaraxisradial->isVirtualQCPPolarAxisRadial) {
        vqcppolaraxisradial->setQCPPolarAxisRadial_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPPolarAxisRadial::QCPPolarAxisRadial_IsSignalConnected_Callback>(slot));
    }
}

void QCPPolarAxisRadial_Delete(QCPPolarAxisRadial* self) {
    delete self;
}

QCPPolarAxisAngular* QCPPolarAxisAngular_new(QCustomPlot* parentPlot) {
    return new VirtualQCPPolarAxisAngular(parentPlot);
}

QMetaObject* QCPPolarAxisAngular_MetaObject(const QCPPolarAxisAngular* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPPolarAxisAngular_Metacast(QCPPolarAxisAngular* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPPolarAxisAngular_Metacall(QCPPolarAxisAngular* self, int param1, int param2, void** param3) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPPolarAxisAngular*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPPolarAxisAngular_Tr(const char* s) {
    QString _ret = QCPPolarAxisAngular::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

QPixmap* QCPPolarAxisAngular_Background(const QCPPolarAxisAngular* self) {
    return new QPixmap(self->background());
}

QBrush* QCPPolarAxisAngular_BackgroundBrush(const QCPPolarAxisAngular* self) {
    return new QBrush(self->backgroundBrush());
}

bool QCPPolarAxisAngular_BackgroundScaled(const QCPPolarAxisAngular* self) {
    return self->backgroundScaled();
}

int QCPPolarAxisAngular_BackgroundScaledMode(const QCPPolarAxisAngular* self) {
    return static_cast<int>(self->backgroundScaledMode());
}

bool QCPPolarAxisAngular_RangeDrag(const QCPPolarAxisAngular* self) {
    return self->rangeDrag();
}

bool QCPPolarAxisAngular_RangeZoom(const QCPPolarAxisAngular* self) {
    return self->rangeZoom();
}

double QCPPolarAxisAngular_RangeZoomFactor(const QCPPolarAxisAngular* self) {
    return self->rangeZoomFactor();
}

QCPRange* QCPPolarAxisAngular_Range(const QCPPolarAxisAngular* self) {
    return new QCPRange(self->range());
}

bool QCPPolarAxisAngular_RangeReversed(const QCPPolarAxisAngular* self) {
    return self->rangeReversed();
}

double QCPPolarAxisAngular_Angle(const QCPPolarAxisAngular* self) {
    return self->angle();
}

bool QCPPolarAxisAngular_Ticks(const QCPPolarAxisAngular* self) {
    return self->ticks();
}

bool QCPPolarAxisAngular_TickLabels(const QCPPolarAxisAngular* self) {
    return self->tickLabels();
}

int QCPPolarAxisAngular_TickLabelPadding(const QCPPolarAxisAngular* self) {
    return self->tickLabelPadding();
}

QFont* QCPPolarAxisAngular_TickLabelFont(const QCPPolarAxisAngular* self) {
    return new QFont(self->tickLabelFont());
}

QColor* QCPPolarAxisAngular_TickLabelColor(const QCPPolarAxisAngular* self) {
    return new QColor(self->tickLabelColor());
}

double QCPPolarAxisAngular_TickLabelRotation(const QCPPolarAxisAngular* self) {
    return self->tickLabelRotation();
}

int QCPPolarAxisAngular_TickLabelMode(const QCPPolarAxisAngular* self) {
    return static_cast<int>(self->tickLabelMode());
}

libqt_string QCPPolarAxisAngular_NumberFormat(const QCPPolarAxisAngular* self) {
    QString _ret = self->numberFormat();
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

int QCPPolarAxisAngular_NumberPrecision(const QCPPolarAxisAngular* self) {
    return self->numberPrecision();
}

libqt_list /* of double */ QCPPolarAxisAngular_TickVector(const QCPPolarAxisAngular* self) {
    QVector<double> _ret = self->tickVector();
    // Convert QVector<> from C++ memory to manually-managed C memory
    double* _arr = static_cast<double*>(malloc(sizeof(double) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

libqt_list /* of libqt_string */ QCPPolarAxisAngular_TickVectorLabels(const QCPPolarAxisAngular* self) {
    QVector<QString> _ret = self->tickVectorLabels();
    // Convert QVector<> from C++ memory to manually-managed C memory
    libqt_string* _arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        QString _vv_ret = _ret[i];
        // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
        QByteArray _vv_b = _vv_ret.toUtf8();
        libqt_string _vv_str;
        _vv_str.len = _vv_b.length();
        _vv_str.data = static_cast<const char*>(malloc(_vv_str.len + 1));
        memcpy((void*)_vv_str.data, _vv_b.data(), _vv_str.len);
        ((char*)_vv_str.data)[_vv_str.len] = '\0';
        _arr[i] = _vv_str;
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

int QCPPolarAxisAngular_TickLengthIn(const QCPPolarAxisAngular* self) {
    return self->tickLengthIn();
}

int QCPPolarAxisAngular_TickLengthOut(const QCPPolarAxisAngular* self) {
    return self->tickLengthOut();
}

bool QCPPolarAxisAngular_SubTicks(const QCPPolarAxisAngular* self) {
    return self->subTicks();
}

int QCPPolarAxisAngular_SubTickLengthIn(const QCPPolarAxisAngular* self) {
    return self->subTickLengthIn();
}

int QCPPolarAxisAngular_SubTickLengthOut(const QCPPolarAxisAngular* self) {
    return self->subTickLengthOut();
}

QPen* QCPPolarAxisAngular_BasePen(const QCPPolarAxisAngular* self) {
    return new QPen(self->basePen());
}

QPen* QCPPolarAxisAngular_TickPen(const QCPPolarAxisAngular* self) {
    return new QPen(self->tickPen());
}

QPen* QCPPolarAxisAngular_SubTickPen(const QCPPolarAxisAngular* self) {
    return new QPen(self->subTickPen());
}

QFont* QCPPolarAxisAngular_LabelFont(const QCPPolarAxisAngular* self) {
    return new QFont(self->labelFont());
}

QColor* QCPPolarAxisAngular_LabelColor(const QCPPolarAxisAngular* self) {
    return new QColor(self->labelColor());
}

libqt_string QCPPolarAxisAngular_Label(const QCPPolarAxisAngular* self) {
    QString _ret = self->label();
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

int QCPPolarAxisAngular_LabelPadding(const QCPPolarAxisAngular* self) {
    return self->labelPadding();
}

int QCPPolarAxisAngular_SelectedParts(const QCPPolarAxisAngular* self) {
    return static_cast<int>(self->selectedParts());
}

int QCPPolarAxisAngular_SelectableParts(const QCPPolarAxisAngular* self) {
    return static_cast<int>(self->selectableParts());
}

QFont* QCPPolarAxisAngular_SelectedTickLabelFont(const QCPPolarAxisAngular* self) {
    return new QFont(self->selectedTickLabelFont());
}

QFont* QCPPolarAxisAngular_SelectedLabelFont(const QCPPolarAxisAngular* self) {
    return new QFont(self->selectedLabelFont());
}

QColor* QCPPolarAxisAngular_SelectedTickLabelColor(const QCPPolarAxisAngular* self) {
    return new QColor(self->selectedTickLabelColor());
}

QColor* QCPPolarAxisAngular_SelectedLabelColor(const QCPPolarAxisAngular* self) {
    return new QColor(self->selectedLabelColor());
}

QPen* QCPPolarAxisAngular_SelectedBasePen(const QCPPolarAxisAngular* self) {
    return new QPen(self->selectedBasePen());
}

QPen* QCPPolarAxisAngular_SelectedTickPen(const QCPPolarAxisAngular* self) {
    return new QPen(self->selectedTickPen());
}

QPen* QCPPolarAxisAngular_SelectedSubTickPen(const QCPPolarAxisAngular* self) {
    return new QPen(self->selectedSubTickPen());
}

QCPPolarGrid* QCPPolarAxisAngular_Grid(const QCPPolarAxisAngular* self) {
    return self->grid();
}

void QCPPolarAxisAngular_SetBackground(QCPPolarAxisAngular* self, const QPixmap* pm) {
    self->setBackground(*pm);
}

void QCPPolarAxisAngular_SetBackground2(QCPPolarAxisAngular* self, const QPixmap* pm, bool scaled) {
    self->setBackground(*pm, scaled);
}

void QCPPolarAxisAngular_SetBackground3(QCPPolarAxisAngular* self, const QBrush* brush) {
    self->setBackground(*brush);
}

void QCPPolarAxisAngular_SetBackgroundScaled(QCPPolarAxisAngular* self, bool scaled) {
    self->setBackgroundScaled(scaled);
}

void QCPPolarAxisAngular_SetBackgroundScaledMode(QCPPolarAxisAngular* self, int mode) {
    self->setBackgroundScaledMode(static_cast<Qt::AspectRatioMode>(mode));
}

void QCPPolarAxisAngular_SetRangeDrag(QCPPolarAxisAngular* self, bool enabled) {
    self->setRangeDrag(enabled);
}

void QCPPolarAxisAngular_SetRangeZoom(QCPPolarAxisAngular* self, bool enabled) {
    self->setRangeZoom(enabled);
}

void QCPPolarAxisAngular_SetRangeZoomFactor(QCPPolarAxisAngular* self, double factor) {
    self->setRangeZoomFactor(static_cast<double>(factor));
}

void QCPPolarAxisAngular_SetRange(QCPPolarAxisAngular* self, const QCPRange* range) {
    self->setRange(*range);
}

void QCPPolarAxisAngular_SetRange2(QCPPolarAxisAngular* self, double lower, double upper) {
    self->setRange(static_cast<double>(lower), static_cast<double>(upper));
}

void QCPPolarAxisAngular_SetRange3(QCPPolarAxisAngular* self, double position, double size, int alignment) {
    self->setRange(static_cast<double>(position), static_cast<double>(size), static_cast<Qt::AlignmentFlag>(alignment));
}

void QCPPolarAxisAngular_SetRangeLower(QCPPolarAxisAngular* self, double lower) {
    self->setRangeLower(static_cast<double>(lower));
}

void QCPPolarAxisAngular_SetRangeUpper(QCPPolarAxisAngular* self, double upper) {
    self->setRangeUpper(static_cast<double>(upper));
}

void QCPPolarAxisAngular_SetRangeReversed(QCPPolarAxisAngular* self, bool reversed) {
    self->setRangeReversed(reversed);
}

void QCPPolarAxisAngular_SetAngle(QCPPolarAxisAngular* self, double degrees) {
    self->setAngle(static_cast<double>(degrees));
}

void QCPPolarAxisAngular_SetTicks(QCPPolarAxisAngular* self, bool show) {
    self->setTicks(show);
}

void QCPPolarAxisAngular_SetTickLabels(QCPPolarAxisAngular* self, bool show) {
    self->setTickLabels(show);
}

void QCPPolarAxisAngular_SetTickLabelPadding(QCPPolarAxisAngular* self, int padding) {
    self->setTickLabelPadding(static_cast<int>(padding));
}

void QCPPolarAxisAngular_SetTickLabelFont(QCPPolarAxisAngular* self, const QFont* font) {
    self->setTickLabelFont(*font);
}

void QCPPolarAxisAngular_SetTickLabelColor(QCPPolarAxisAngular* self, const QColor* color) {
    self->setTickLabelColor(*color);
}

void QCPPolarAxisAngular_SetTickLabelRotation(QCPPolarAxisAngular* self, double degrees) {
    self->setTickLabelRotation(static_cast<double>(degrees));
}

void QCPPolarAxisAngular_SetTickLabelMode(QCPPolarAxisAngular* self, int mode) {
    self->setTickLabelMode(static_cast<QCPPolarAxisAngular::LabelMode>(mode));
}

void QCPPolarAxisAngular_SetNumberFormat(QCPPolarAxisAngular* self, const libqt_string formatCode) {
    QString formatCode_QString = QString::fromUtf8(formatCode.data, formatCode.len);
    self->setNumberFormat(formatCode_QString);
}

void QCPPolarAxisAngular_SetNumberPrecision(QCPPolarAxisAngular* self, int precision) {
    self->setNumberPrecision(static_cast<int>(precision));
}

void QCPPolarAxisAngular_SetTickLength(QCPPolarAxisAngular* self, int inside) {
    self->setTickLength(static_cast<int>(inside));
}

void QCPPolarAxisAngular_SetTickLengthIn(QCPPolarAxisAngular* self, int inside) {
    self->setTickLengthIn(static_cast<int>(inside));
}

void QCPPolarAxisAngular_SetTickLengthOut(QCPPolarAxisAngular* self, int outside) {
    self->setTickLengthOut(static_cast<int>(outside));
}

void QCPPolarAxisAngular_SetSubTicks(QCPPolarAxisAngular* self, bool show) {
    self->setSubTicks(show);
}

void QCPPolarAxisAngular_SetSubTickLength(QCPPolarAxisAngular* self, int inside) {
    self->setSubTickLength(static_cast<int>(inside));
}

void QCPPolarAxisAngular_SetSubTickLengthIn(QCPPolarAxisAngular* self, int inside) {
    self->setSubTickLengthIn(static_cast<int>(inside));
}

void QCPPolarAxisAngular_SetSubTickLengthOut(QCPPolarAxisAngular* self, int outside) {
    self->setSubTickLengthOut(static_cast<int>(outside));
}

void QCPPolarAxisAngular_SetBasePen(QCPPolarAxisAngular* self, const QPen* pen) {
    self->setBasePen(*pen);
}

void QCPPolarAxisAngular_SetTickPen(QCPPolarAxisAngular* self, const QPen* pen) {
    self->setTickPen(*pen);
}

void QCPPolarAxisAngular_SetSubTickPen(QCPPolarAxisAngular* self, const QPen* pen) {
    self->setSubTickPen(*pen);
}

void QCPPolarAxisAngular_SetLabelFont(QCPPolarAxisAngular* self, const QFont* font) {
    self->setLabelFont(*font);
}

void QCPPolarAxisAngular_SetLabelColor(QCPPolarAxisAngular* self, const QColor* color) {
    self->setLabelColor(*color);
}

void QCPPolarAxisAngular_SetLabel(QCPPolarAxisAngular* self, const libqt_string str) {
    QString str_QString = QString::fromUtf8(str.data, str.len);
    self->setLabel(str_QString);
}

void QCPPolarAxisAngular_SetLabelPadding(QCPPolarAxisAngular* self, int padding) {
    self->setLabelPadding(static_cast<int>(padding));
}

void QCPPolarAxisAngular_SetSelectedTickLabelFont(QCPPolarAxisAngular* self, const QFont* font) {
    self->setSelectedTickLabelFont(*font);
}

void QCPPolarAxisAngular_SetSelectedLabelFont(QCPPolarAxisAngular* self, const QFont* font) {
    self->setSelectedLabelFont(*font);
}

void QCPPolarAxisAngular_SetSelectedTickLabelColor(QCPPolarAxisAngular* self, const QColor* color) {
    self->setSelectedTickLabelColor(*color);
}

void QCPPolarAxisAngular_SetSelectedLabelColor(QCPPolarAxisAngular* self, const QColor* color) {
    self->setSelectedLabelColor(*color);
}

void QCPPolarAxisAngular_SetSelectedBasePen(QCPPolarAxisAngular* self, const QPen* pen) {
    self->setSelectedBasePen(*pen);
}

void QCPPolarAxisAngular_SetSelectedTickPen(QCPPolarAxisAngular* self, const QPen* pen) {
    self->setSelectedTickPen(*pen);
}

void QCPPolarAxisAngular_SetSelectedSubTickPen(QCPPolarAxisAngular* self, const QPen* pen) {
    self->setSelectedSubTickPen(*pen);
}

void QCPPolarAxisAngular_SetSelectableParts(QCPPolarAxisAngular* self, const int* selectableParts) {
    self->setSelectableParts((const QCPPolarAxisAngular::SelectableParts&)(*selectableParts));
}

void QCPPolarAxisAngular_SetSelectedParts(QCPPolarAxisAngular* self, const int* selectedParts) {
    self->setSelectedParts((const QCPPolarAxisAngular::SelectableParts&)(*selectedParts));
}

double QCPPolarAxisAngular_SelectTest(const QCPPolarAxisAngular* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcppolaraxisangular = dynamic_cast<const VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPPolarAxisAngular*)self)->selectTest(*pos, onlySelectable, details);
    }
}

void QCPPolarAxisAngular_Update(QCPPolarAxisAngular* self, int phase) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        self->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    }
}

libqt_list /* of QCPLayoutElement* */ QCPPolarAxisAngular_Elements(const QCPPolarAxisAngular* self, bool recursive) {
    auto* vqcppolaraxisangular = dynamic_cast<const VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        QList<QCPLayoutElement*> _ret = self->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayoutElement*> _ret = ((VirtualQCPPolarAxisAngular*)self)->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

bool QCPPolarAxisAngular_RemoveGraph(QCPPolarAxisAngular* self, QCPPolarGraph* graph) {
    return self->removeGraph(graph);
}

int QCPPolarAxisAngular_RadialAxisCount(const QCPPolarAxisAngular* self) {
    return self->radialAxisCount();
}

QCPPolarAxisRadial* QCPPolarAxisAngular_RadialAxis(const QCPPolarAxisAngular* self) {
    return self->radialAxis();
}

libqt_list /* of QCPPolarAxisRadial* */ QCPPolarAxisAngular_RadialAxes(const QCPPolarAxisAngular* self) {
    QList<QCPPolarAxisRadial*> _ret = self->radialAxes();
    // Convert QList<> from C++ memory to manually-managed C memory
    QCPPolarAxisRadial** _arr = static_cast<QCPPolarAxisRadial**>(malloc(sizeof(QCPPolarAxisRadial*) * (_ret.size() + 1)));
    for (qsizetype i = 0; i < _ret.size(); ++i) {
        _arr[i] = _ret[i];
    }
    libqt_list _out;
    _out.len = _ret.size();
    _out.data = static_cast<void*>(_arr);
    return _out;
}

QCPPolarAxisRadial* QCPPolarAxisAngular_AddRadialAxis(QCPPolarAxisAngular* self) {
    return self->addRadialAxis();
}

bool QCPPolarAxisAngular_RemoveRadialAxis(QCPPolarAxisAngular* self, QCPPolarAxisRadial* axis) {
    return self->removeRadialAxis(axis);
}

QCPLayoutInset* QCPPolarAxisAngular_InsetLayout(const QCPPolarAxisAngular* self) {
    return self->insetLayout();
}

QRegion* QCPPolarAxisAngular_ExactClipRegion(const QCPPolarAxisAngular* self) {
    return new QRegion(self->exactClipRegion());
}

void QCPPolarAxisAngular_MoveRange(QCPPolarAxisAngular* self, double diff) {
    self->moveRange(static_cast<double>(diff));
}

void QCPPolarAxisAngular_ScaleRange(QCPPolarAxisAngular* self, double factor) {
    self->scaleRange(static_cast<double>(factor));
}

void QCPPolarAxisAngular_ScaleRange2(QCPPolarAxisAngular* self, double factor, double center) {
    self->scaleRange(static_cast<double>(factor), static_cast<double>(center));
}

void QCPPolarAxisAngular_Rescale(QCPPolarAxisAngular* self) {
    self->rescale();
}

double QCPPolarAxisAngular_CoordToAngleRad(const QCPPolarAxisAngular* self, double coord) {
    return self->coordToAngleRad(static_cast<double>(coord));
}

double QCPPolarAxisAngular_AngleRadToCoord(const QCPPolarAxisAngular* self, double angleRad) {
    return self->angleRadToCoord(static_cast<double>(angleRad));
}

void QCPPolarAxisAngular_PixelToCoord(const QCPPolarAxisAngular* self, QPointF* pixelPos, double* angleCoord, double* radiusCoord) {
    self->pixelToCoord(*pixelPos, static_cast<double&>(*angleCoord), static_cast<double&>(*radiusCoord));
}

QPointF* QCPPolarAxisAngular_CoordToPixel(const QCPPolarAxisAngular* self, double angleCoord, double radiusCoord) {
    return new QPointF(self->coordToPixel(static_cast<double>(angleCoord), static_cast<double>(radiusCoord)));
}

int QCPPolarAxisAngular_GetPartAt(const QCPPolarAxisAngular* self, const QPointF* pos) {
    return static_cast<int>(self->getPartAt(*pos));
}

int QCPPolarAxisAngular_Left(const QCPPolarAxisAngular* self) {
    return self->left();
}

int QCPPolarAxisAngular_Right(const QCPPolarAxisAngular* self) {
    return self->right();
}

int QCPPolarAxisAngular_Top(const QCPPolarAxisAngular* self) {
    return self->top();
}

int QCPPolarAxisAngular_Bottom(const QCPPolarAxisAngular* self) {
    return self->bottom();
}

int QCPPolarAxisAngular_Width(const QCPPolarAxisAngular* self) {
    return self->width();
}

int QCPPolarAxisAngular_Height(const QCPPolarAxisAngular* self) {
    return self->height();
}

QSize* QCPPolarAxisAngular_Size(const QCPPolarAxisAngular* self) {
    return new QSize(self->size());
}

QPoint* QCPPolarAxisAngular_TopLeft(const QCPPolarAxisAngular* self) {
    return new QPoint(self->topLeft());
}

QPoint* QCPPolarAxisAngular_TopRight(const QCPPolarAxisAngular* self) {
    return new QPoint(self->topRight());
}

QPoint* QCPPolarAxisAngular_BottomLeft(const QCPPolarAxisAngular* self) {
    return new QPoint(self->bottomLeft());
}

QPoint* QCPPolarAxisAngular_BottomRight(const QCPPolarAxisAngular* self) {
    return new QPoint(self->bottomRight());
}

QPointF* QCPPolarAxisAngular_Center(const QCPPolarAxisAngular* self) {
    return new QPointF(self->center());
}

double QCPPolarAxisAngular_Radius(const QCPPolarAxisAngular* self) {
    return self->radius();
}

void QCPPolarAxisAngular_RangeChanged(QCPPolarAxisAngular* self, const QCPRange* newRange) {
    self->rangeChanged(*newRange);
}

void QCPPolarAxisAngular_RangeChanged2(QCPPolarAxisAngular* self, const QCPRange* newRange, const QCPRange* oldRange) {
    self->rangeChanged(*newRange, *oldRange);
}

void QCPPolarAxisAngular_SelectionChanged(QCPPolarAxisAngular* self, const int* parts) {
    self->selectionChanged((const QCPPolarAxisAngular::SelectableParts&)(*parts));
}

void QCPPolarAxisAngular_SelectableChanged(QCPPolarAxisAngular* self, const int* parts) {
    self->selectableChanged((const QCPPolarAxisAngular::SelectableParts&)(*parts));
}

void QCPPolarAxisAngular_ApplyDefaultAntialiasingHint(const QCPPolarAxisAngular* self, QCPPainter* painter) {
    auto* vqcppolaraxisangular = dynamic_cast<const VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->applyDefaultAntialiasingHint(painter);
    }
}

void QCPPolarAxisAngular_Draw(QCPPolarAxisAngular* self, QCPPainter* painter) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->draw(painter);
    }
}

int QCPPolarAxisAngular_SelectionCategory(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = dynamic_cast<const VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        return static_cast<int>(vqcppolaraxisangular->selectionCategory());
    }
    return {};
}

void QCPPolarAxisAngular_MousePressEvent(QCPPolarAxisAngular* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->mousePressEvent(event, *details);
    }
}

void QCPPolarAxisAngular_MouseMoveEvent(QCPPolarAxisAngular* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->mouseMoveEvent(event, *startPos);
    }
}

void QCPPolarAxisAngular_MouseReleaseEvent(QCPPolarAxisAngular* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->mouseReleaseEvent(event, *startPos);
    }
}

void QCPPolarAxisAngular_WheelEvent(QCPPolarAxisAngular* self, QWheelEvent* event) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->wheelEvent(event);
    }
}

libqt_string QCPPolarAxisAngular_Tr2(const char* s, const char* c) {
    QString _ret = QCPPolarAxisAngular::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPPolarAxisAngular_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPPolarAxisAngular::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

void QCPPolarAxisAngular_SetBackground32(QCPPolarAxisAngular* self, const QPixmap* pm, bool scaled, int mode) {
    self->setBackground(*pm, scaled, static_cast<Qt::AspectRatioMode>(mode));
}

void QCPPolarAxisAngular_SetTickLength2(QCPPolarAxisAngular* self, int inside, int outside) {
    self->setTickLength(static_cast<int>(inside), static_cast<int>(outside));
}

void QCPPolarAxisAngular_SetSubTickLength2(QCPPolarAxisAngular* self, int inside, int outside) {
    self->setSubTickLength(static_cast<int>(inside), static_cast<int>(outside));
}

QCPPolarAxisRadial* QCPPolarAxisAngular_RadialAxis1(const QCPPolarAxisAngular* self, int index) {
    return self->radialAxis(static_cast<int>(index));
}

QCPPolarAxisRadial* QCPPolarAxisAngular_AddRadialAxis1(QCPPolarAxisAngular* self, QCPPolarAxisRadial* axis) {
    return self->addRadialAxis(axis);
}

void QCPPolarAxisAngular_Rescale1(QCPPolarAxisAngular* self, bool onlyVisiblePlottables) {
    self->rescale(onlyVisiblePlottables);
}

// Base class handler implementation
int QCPPolarAxisAngular_QBaseMetacall(QCPPolarAxisAngular* self, int param1, int param2, void** param3) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_Metacall_IsBase(true);
        return vqcppolaraxisangular->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPPolarAxisAngular::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnMetacall(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_Metacall_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
double QCPPolarAxisAngular_QBaseSelectTest(const QCPPolarAxisAngular* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_SelectTest_IsBase(true);
        return vqcppolaraxisangular->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPPolarAxisAngular::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnSelectTest(const QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_SelectTest_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPolarAxisAngular_QBaseUpdate(QCPPolarAxisAngular* self, int phase) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_Update_IsBase(true);
        vqcppolaraxisangular->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    } else {
        self->QCPPolarAxisAngular::update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnUpdate(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_Update_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_Update_Callback>(slot));
    }
}

// Base class handler implementation
libqt_list /* of QCPLayoutElement* */ QCPPolarAxisAngular_QBaseElements(const QCPPolarAxisAngular* self, bool recursive) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_Elements_IsBase(true);
        QList<QCPLayoutElement*> _ret = vqcppolaraxisangular->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayoutElement*> _ret = self->QCPPolarAxisAngular::elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnElements(const QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_Elements_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_Elements_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPolarAxisAngular_QBaseApplyDefaultAntialiasingHint(const QCPPolarAxisAngular* self, QCPPainter* painter) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcppolaraxisangular->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnApplyDefaultAntialiasingHint(const QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPolarAxisAngular_QBaseDraw(QCPPolarAxisAngular* self, QCPPainter* painter) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_Draw_IsBase(true);
        vqcppolaraxisangular->draw(painter);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnDraw(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_Draw_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_Draw_Callback>(slot));
    }
}

// Base class handler implementation
int QCPPolarAxisAngular_QBaseSelectionCategory(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcppolaraxisangular->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPPolarAxisAngular*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnSelectionCategory(const QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_SelectionCategory_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_SelectionCategory_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPolarAxisAngular_QBaseMousePressEvent(QCPPolarAxisAngular* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_MousePressEvent_IsBase(true);
        vqcppolaraxisangular->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnMousePressEvent(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_MousePressEvent_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_MousePressEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPolarAxisAngular_QBaseMouseMoveEvent(QCPPolarAxisAngular* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_MouseMoveEvent_IsBase(true);
        vqcppolaraxisangular->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnMouseMoveEvent(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_MouseMoveEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPolarAxisAngular_QBaseMouseReleaseEvent(QCPPolarAxisAngular* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_MouseReleaseEvent_IsBase(true);
        vqcppolaraxisangular->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnMouseReleaseEvent(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_MouseReleaseEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPolarAxisAngular_QBaseWheelEvent(QCPPolarAxisAngular* self, QWheelEvent* event) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_WheelEvent_IsBase(true);
        vqcppolaraxisangular->wheelEvent(event);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnWheelEvent(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_WheelEvent_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
QSize* QCPPolarAxisAngular_MinimumOuterSizeHint(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        return new QSize(vqcppolaraxisangular->minimumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPPolarAxisAngular*)self)->minimumOuterSizeHint());
    }
}

// Base class handler implementation
QSize* QCPPolarAxisAngular_QBaseMinimumOuterSizeHint(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_MinimumOuterSizeHint_IsBase(true);
        return new QSize(vqcppolaraxisangular->minimumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPPolarAxisAngular*)self)->minimumOuterSizeHint());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnMinimumOuterSizeHint(const QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_MinimumOuterSizeHint_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_MinimumOuterSizeHint_Callback>(slot));
    }
}

// Derived class handler implementation
QSize* QCPPolarAxisAngular_MaximumOuterSizeHint(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        return new QSize(vqcppolaraxisangular->maximumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPPolarAxisAngular*)self)->maximumOuterSizeHint());
    }
}

// Base class handler implementation
QSize* QCPPolarAxisAngular_QBaseMaximumOuterSizeHint(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_MaximumOuterSizeHint_IsBase(true);
        return new QSize(vqcppolaraxisangular->maximumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPPolarAxisAngular*)self)->maximumOuterSizeHint());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnMaximumOuterSizeHint(const QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_MaximumOuterSizeHint_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_MaximumOuterSizeHint_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPPolarAxisAngular_CalculateAutoMargin(QCPPolarAxisAngular* self, int side) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        return vqcppolaraxisangular->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    } else {
        return ((VirtualQCPPolarAxisAngular*)self)->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    }
}

// Base class handler implementation
int QCPPolarAxisAngular_QBaseCalculateAutoMargin(QCPPolarAxisAngular* self, int side) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_CalculateAutoMargin_IsBase(true);
        return vqcppolaraxisangular->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    } else {
        return ((VirtualQCPPolarAxisAngular*)self)->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnCalculateAutoMargin(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_CalculateAutoMargin_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_CalculateAutoMargin_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisAngular_LayoutChanged(QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->layoutChanged();
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->layoutChanged();
    }
}

// Base class handler implementation
void QCPPolarAxisAngular_QBaseLayoutChanged(QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_LayoutChanged_IsBase(true);
        vqcppolaraxisangular->layoutChanged();
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->layoutChanged();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnLayoutChanged(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_LayoutChanged_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_LayoutChanged_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisAngular_ParentPlotInitialized(QCPPolarAxisAngular* self, QCustomPlot* parentPlot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPPolarAxisAngular_QBaseParentPlotInitialized(QCPPolarAxisAngular* self, QCustomPlot* parentPlot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_ParentPlotInitialized_IsBase(true);
        vqcppolaraxisangular->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnParentPlotInitialized(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPPolarAxisAngular_ClipRect(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        return new QRect(vqcppolaraxisangular->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPPolarAxisAngular_QBaseClipRect(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_ClipRect_IsBase(true);
        return new QRect(vqcppolaraxisangular->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnClipRect(const QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_ClipRect_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisAngular_SelectEvent(QCPPolarAxisAngular* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPPolarAxisAngular_QBaseSelectEvent(QCPPolarAxisAngular* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_SelectEvent_IsBase(true);
        vqcppolaraxisangular->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnSelectEvent(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_SelectEvent_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisAngular_DeselectEvent(QCPPolarAxisAngular* self, bool* selectionStateChanged) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPPolarAxisAngular_QBaseDeselectEvent(QCPPolarAxisAngular* self, bool* selectionStateChanged) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_DeselectEvent_IsBase(true);
        vqcppolaraxisangular->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnDeselectEvent(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_DeselectEvent_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisAngular_MouseDoubleClickEvent(QCPPolarAxisAngular* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPPolarAxisAngular_QBaseMouseDoubleClickEvent(QCPPolarAxisAngular* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_MouseDoubleClickEvent_IsBase(true);
        vqcppolaraxisangular->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnMouseDoubleClickEvent(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPPolarAxisAngular_Event(QCPPolarAxisAngular* self, QEvent* event) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        return vqcppolaraxisangular->event(event);
    } else {
        return self->QCPPolarAxisAngular::event(event);
    }
}

// Base class handler implementation
bool QCPPolarAxisAngular_QBaseEvent(QCPPolarAxisAngular* self, QEvent* event) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_Event_IsBase(true);
        return vqcppolaraxisangular->event(event);
    } else {
        return self->QCPPolarAxisAngular::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnEvent(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_Event_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPPolarAxisAngular_EventFilter(QCPPolarAxisAngular* self, QObject* watched, QEvent* event) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        return vqcppolaraxisangular->eventFilter(watched, event);
    } else {
        return self->QCPPolarAxisAngular::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPPolarAxisAngular_QBaseEventFilter(QCPPolarAxisAngular* self, QObject* watched, QEvent* event) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_EventFilter_IsBase(true);
        return vqcppolaraxisangular->eventFilter(watched, event);
    } else {
        return self->QCPPolarAxisAngular::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnEventFilter(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_EventFilter_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisAngular_TimerEvent(QCPPolarAxisAngular* self, QTimerEvent* event) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->timerEvent(event);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPPolarAxisAngular_QBaseTimerEvent(QCPPolarAxisAngular* self, QTimerEvent* event) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_TimerEvent_IsBase(true);
        vqcppolaraxisangular->timerEvent(event);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnTimerEvent(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_TimerEvent_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisAngular_ChildEvent(QCPPolarAxisAngular* self, QChildEvent* event) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->childEvent(event);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPPolarAxisAngular_QBaseChildEvent(QCPPolarAxisAngular* self, QChildEvent* event) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_ChildEvent_IsBase(true);
        vqcppolaraxisangular->childEvent(event);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnChildEvent(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_ChildEvent_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisAngular_CustomEvent(QCPPolarAxisAngular* self, QEvent* event) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->customEvent(event);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPPolarAxisAngular_QBaseCustomEvent(QCPPolarAxisAngular* self, QEvent* event) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_CustomEvent_IsBase(true);
        vqcppolaraxisangular->customEvent(event);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnCustomEvent(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_CustomEvent_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisAngular_ConnectNotify(QCPPolarAxisAngular* self, const QMetaMethod* signal) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->connectNotify(*signal);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPPolarAxisAngular_QBaseConnectNotify(QCPPolarAxisAngular* self, const QMetaMethod* signal) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_ConnectNotify_IsBase(true);
        vqcppolaraxisangular->connectNotify(*signal);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnConnectNotify(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_ConnectNotify_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisAngular_DisconnectNotify(QCPPolarAxisAngular* self, const QMetaMethod* signal) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->disconnectNotify(*signal);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPPolarAxisAngular_QBaseDisconnectNotify(QCPPolarAxisAngular* self, const QMetaMethod* signal) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_DisconnectNotify_IsBase(true);
        vqcppolaraxisangular->disconnectNotify(*signal);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnDisconnectNotify(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPPolarAxisAngular_RegisterPolarGraph(QCPPolarAxisAngular* self, QCPPolarGraph* graph) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        return vqcppolaraxisangular->registerPolarGraph(graph);
    } else {
        return ((VirtualQCPPolarAxisAngular*)self)->registerPolarGraph(graph);
    }
}

// Base class handler implementation
bool QCPPolarAxisAngular_QBaseRegisterPolarGraph(QCPPolarAxisAngular* self, QCPPolarGraph* graph) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_RegisterPolarGraph_IsBase(true);
        return vqcppolaraxisangular->registerPolarGraph(graph);
    } else {
        return ((VirtualQCPPolarAxisAngular*)self)->registerPolarGraph(graph);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnRegisterPolarGraph(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_RegisterPolarGraph_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_RegisterPolarGraph_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisAngular_DrawBackground(QCPPolarAxisAngular* self, QCPPainter* painter, const QPointF* center, double radius) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->drawBackground(painter, *center, static_cast<double>(radius));
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->drawBackground(painter, *center, static_cast<double>(radius));
    }
}

// Base class handler implementation
void QCPPolarAxisAngular_QBaseDrawBackground(QCPPolarAxisAngular* self, QCPPainter* painter, const QPointF* center, double radius) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_DrawBackground_IsBase(true);
        vqcppolaraxisangular->drawBackground(painter, *center, static_cast<double>(radius));
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->drawBackground(painter, *center, static_cast<double>(radius));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnDrawBackground(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_DrawBackground_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_DrawBackground_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisAngular_SetupTickVectors(QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setupTickVectors();
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->setupTickVectors();
    }
}

// Base class handler implementation
void QCPPolarAxisAngular_QBaseSetupTickVectors(QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_SetupTickVectors_IsBase(true);
        vqcppolaraxisangular->setupTickVectors();
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->setupTickVectors();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnSetupTickVectors(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_SetupTickVectors_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_SetupTickVectors_Callback>(slot));
    }
}

// Derived class handler implementation
QPen* QCPPolarAxisAngular_GetBasePen(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        return new QPen(vqcppolaraxisangular->getBasePen());
    }
    return {};
}

// Base class handler implementation
QPen* QCPPolarAxisAngular_QBaseGetBasePen(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_GetBasePen_IsBase(true);
        return new QPen(vqcppolaraxisangular->getBasePen());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnGetBasePen(const QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_GetBasePen_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_GetBasePen_Callback>(slot));
    }
}

// Derived class handler implementation
QPen* QCPPolarAxisAngular_GetTickPen(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        return new QPen(vqcppolaraxisangular->getTickPen());
    }
    return {};
}

// Base class handler implementation
QPen* QCPPolarAxisAngular_QBaseGetTickPen(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_GetTickPen_IsBase(true);
        return new QPen(vqcppolaraxisangular->getTickPen());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnGetTickPen(const QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_GetTickPen_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_GetTickPen_Callback>(slot));
    }
}

// Derived class handler implementation
QPen* QCPPolarAxisAngular_GetSubTickPen(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        return new QPen(vqcppolaraxisangular->getSubTickPen());
    }
    return {};
}

// Base class handler implementation
QPen* QCPPolarAxisAngular_QBaseGetSubTickPen(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_GetSubTickPen_IsBase(true);
        return new QPen(vqcppolaraxisangular->getSubTickPen());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnGetSubTickPen(const QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_GetSubTickPen_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_GetSubTickPen_Callback>(slot));
    }
}

// Derived class handler implementation
QFont* QCPPolarAxisAngular_GetTickLabelFont(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        return new QFont(vqcppolaraxisangular->getTickLabelFont());
    }
    return {};
}

// Base class handler implementation
QFont* QCPPolarAxisAngular_QBaseGetTickLabelFont(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_GetTickLabelFont_IsBase(true);
        return new QFont(vqcppolaraxisangular->getTickLabelFont());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnGetTickLabelFont(const QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_GetTickLabelFont_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_GetTickLabelFont_Callback>(slot));
    }
}

// Derived class handler implementation
QFont* QCPPolarAxisAngular_GetLabelFont(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        return new QFont(vqcppolaraxisangular->getLabelFont());
    }
    return {};
}

// Base class handler implementation
QFont* QCPPolarAxisAngular_QBaseGetLabelFont(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_GetLabelFont_IsBase(true);
        return new QFont(vqcppolaraxisangular->getLabelFont());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnGetLabelFont(const QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_GetLabelFont_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_GetLabelFont_Callback>(slot));
    }
}

// Derived class handler implementation
QColor* QCPPolarAxisAngular_GetTickLabelColor(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        return new QColor(vqcppolaraxisangular->getTickLabelColor());
    }
    return {};
}

// Base class handler implementation
QColor* QCPPolarAxisAngular_QBaseGetTickLabelColor(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_GetTickLabelColor_IsBase(true);
        return new QColor(vqcppolaraxisangular->getTickLabelColor());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnGetTickLabelColor(const QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_GetTickLabelColor_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_GetTickLabelColor_Callback>(slot));
    }
}

// Derived class handler implementation
QColor* QCPPolarAxisAngular_GetLabelColor(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        return new QColor(vqcppolaraxisangular->getLabelColor());
    }
    return {};
}

// Base class handler implementation
QColor* QCPPolarAxisAngular_QBaseGetLabelColor(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_GetLabelColor_IsBase(true);
        return new QColor(vqcppolaraxisangular->getLabelColor());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnGetLabelColor(const QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_GetLabelColor_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_GetLabelColor_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisAngular_InitializeParentPlot(QCPPolarAxisAngular* self, QCustomPlot* parentPlot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPPolarAxisAngular_QBaseInitializeParentPlot(QCPPolarAxisAngular* self, QCustomPlot* parentPlot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_InitializeParentPlot_IsBase(true);
        vqcppolaraxisangular->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnInitializeParentPlot(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisAngular_SetParentLayerable(QCPPolarAxisAngular* self, QCPLayerable* parentLayerable) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPPolarAxisAngular_QBaseSetParentLayerable(QCPPolarAxisAngular* self, QCPLayerable* parentLayerable) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_SetParentLayerable_IsBase(true);
        vqcppolaraxisangular->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnSetParentLayerable(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPPolarAxisAngular_MoveToLayer(QCPPolarAxisAngular* self, QCPLayer* layer, bool prepend) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        return vqcppolaraxisangular->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPPolarAxisAngular*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPPolarAxisAngular_QBaseMoveToLayer(QCPPolarAxisAngular* self, QCPLayer* layer, bool prepend) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_MoveToLayer_IsBase(true);
        return vqcppolaraxisangular->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPPolarAxisAngular*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnMoveToLayer(QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = dynamic_cast<VirtualQCPPolarAxisAngular*>(self);
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_MoveToLayer_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarAxisAngular_ApplyAntialiasingHint(const QCPPolarAxisAngular* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPPolarAxisAngular_QBaseApplyAntialiasingHint(const QCPPolarAxisAngular* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_ApplyAntialiasingHint_IsBase(true);
        vqcppolaraxisangular->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPPolarAxisAngular*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnApplyAntialiasingHint(const QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPPolarAxisAngular_Sender(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        return vqcppolaraxisangular->sender();
    } else {
        return ((VirtualQCPPolarAxisAngular*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPPolarAxisAngular_QBaseSender(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_Sender_IsBase(true);
        return vqcppolaraxisangular->sender();
    } else {
        return ((VirtualQCPPolarAxisAngular*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnSender(const QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_Sender_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPPolarAxisAngular_SenderSignalIndex(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        return vqcppolaraxisangular->senderSignalIndex();
    } else {
        return ((VirtualQCPPolarAxisAngular*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPPolarAxisAngular_QBaseSenderSignalIndex(const QCPPolarAxisAngular* self) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_SenderSignalIndex_IsBase(true);
        return vqcppolaraxisangular->senderSignalIndex();
    } else {
        return ((VirtualQCPPolarAxisAngular*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnSenderSignalIndex(const QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPPolarAxisAngular_Receivers(const QCPPolarAxisAngular* self, const char* signal) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        return vqcppolaraxisangular->receivers(signal);
    } else {
        return ((VirtualQCPPolarAxisAngular*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPPolarAxisAngular_QBaseReceivers(const QCPPolarAxisAngular* self, const char* signal) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_Receivers_IsBase(true);
        return vqcppolaraxisangular->receivers(signal);
    } else {
        return ((VirtualQCPPolarAxisAngular*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnReceivers(const QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_Receivers_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPPolarAxisAngular_IsSignalConnected(const QCPPolarAxisAngular* self, const QMetaMethod* signal) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        return vqcppolaraxisangular->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPPolarAxisAngular*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPPolarAxisAngular_QBaseIsSignalConnected(const QCPPolarAxisAngular* self, const QMetaMethod* signal) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_IsSignalConnected_IsBase(true);
        return vqcppolaraxisangular->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPPolarAxisAngular*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarAxisAngular_OnIsSignalConnected(const QCPPolarAxisAngular* self, intptr_t slot) {
    auto* vqcppolaraxisangular = const_cast<VirtualQCPPolarAxisAngular*>(dynamic_cast<const VirtualQCPPolarAxisAngular*>(self));
    if (vqcppolaraxisangular && vqcppolaraxisangular->isVirtualQCPPolarAxisAngular) {
        vqcppolaraxisangular->setQCPPolarAxisAngular_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPPolarAxisAngular::QCPPolarAxisAngular_IsSignalConnected_Callback>(slot));
    }
}

void QCPPolarAxisAngular_Delete(QCPPolarAxisAngular* self) {
    delete self;
}

QCPPolarGrid* QCPPolarGrid_new(QCPPolarAxisAngular* parentAxis) {
    return new VirtualQCPPolarGrid(parentAxis);
}

QMetaObject* QCPPolarGrid_MetaObject(const QCPPolarGrid* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPPolarGrid_Metacast(QCPPolarGrid* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPPolarGrid_Metacall(QCPPolarGrid* self, int param1, int param2, void** param3) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPPolarGrid*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPPolarGrid_Tr(const char* s) {
    QString _ret = QCPPolarGrid::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

QCPPolarAxisRadial* QCPPolarGrid_RadialAxis(const QCPPolarGrid* self) {
    return self->radialAxis();
}

int QCPPolarGrid_Type(const QCPPolarGrid* self) {
    return static_cast<int>(self->type());
}

int QCPPolarGrid_SubGridType(const QCPPolarGrid* self) {
    return static_cast<int>(self->subGridType());
}

bool QCPPolarGrid_AntialiasedSubGrid(const QCPPolarGrid* self) {
    return self->antialiasedSubGrid();
}

bool QCPPolarGrid_AntialiasedZeroLine(const QCPPolarGrid* self) {
    return self->antialiasedZeroLine();
}

QPen* QCPPolarGrid_AngularPen(const QCPPolarGrid* self) {
    return new QPen(self->angularPen());
}

QPen* QCPPolarGrid_AngularSubGridPen(const QCPPolarGrid* self) {
    return new QPen(self->angularSubGridPen());
}

QPen* QCPPolarGrid_RadialPen(const QCPPolarGrid* self) {
    return new QPen(self->radialPen());
}

QPen* QCPPolarGrid_RadialSubGridPen(const QCPPolarGrid* self) {
    return new QPen(self->radialSubGridPen());
}

QPen* QCPPolarGrid_RadialZeroLinePen(const QCPPolarGrid* self) {
    return new QPen(self->radialZeroLinePen());
}

void QCPPolarGrid_SetRadialAxis(QCPPolarGrid* self, QCPPolarAxisRadial* axis) {
    self->setRadialAxis(axis);
}

void QCPPolarGrid_SetType(QCPPolarGrid* self, int typeVal) {
    self->setType(static_cast<QCPPolarGrid::GridTypes>(typeVal));
}

void QCPPolarGrid_SetSubGridType(QCPPolarGrid* self, int typeVal) {
    self->setSubGridType(static_cast<QCPPolarGrid::GridTypes>(typeVal));
}

void QCPPolarGrid_SetAntialiasedSubGrid(QCPPolarGrid* self, bool enabled) {
    self->setAntialiasedSubGrid(enabled);
}

void QCPPolarGrid_SetAntialiasedZeroLine(QCPPolarGrid* self, bool enabled) {
    self->setAntialiasedZeroLine(enabled);
}

void QCPPolarGrid_SetAngularPen(QCPPolarGrid* self, const QPen* pen) {
    self->setAngularPen(*pen);
}

void QCPPolarGrid_SetAngularSubGridPen(QCPPolarGrid* self, const QPen* pen) {
    self->setAngularSubGridPen(*pen);
}

void QCPPolarGrid_SetRadialPen(QCPPolarGrid* self, const QPen* pen) {
    self->setRadialPen(*pen);
}

void QCPPolarGrid_SetRadialSubGridPen(QCPPolarGrid* self, const QPen* pen) {
    self->setRadialSubGridPen(*pen);
}

void QCPPolarGrid_SetRadialZeroLinePen(QCPPolarGrid* self, const QPen* pen) {
    self->setRadialZeroLinePen(*pen);
}

void QCPPolarGrid_ApplyDefaultAntialiasingHint(const QCPPolarGrid* self, QCPPainter* painter) {
    auto* vqcppolargrid = dynamic_cast<const VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->applyDefaultAntialiasingHint(painter);
    }
}

void QCPPolarGrid_Draw(QCPPolarGrid* self, QCPPainter* painter) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->draw(painter);
    }
}

libqt_string QCPPolarGrid_Tr2(const char* s, const char* c) {
    QString _ret = QCPPolarGrid::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPPolarGrid_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPPolarGrid::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPPolarGrid_QBaseMetacall(QCPPolarGrid* self, int param1, int param2, void** param3) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_Metacall_IsBase(true);
        return vqcppolargrid->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPPolarGrid::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnMetacall(QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_Metacall_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPolarGrid_QBaseApplyDefaultAntialiasingHint(const QCPPolarGrid* self, QCPPainter* painter) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcppolargrid->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPPolarGrid*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnApplyDefaultAntialiasingHint(const QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPolarGrid_QBaseDraw(QCPPolarGrid* self, QCPPainter* painter) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_Draw_IsBase(true);
        vqcppolargrid->draw(painter);
    } else {
        ((VirtualQCPPolarGrid*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnDraw(QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_Draw_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_Draw_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPPolarGrid_SelectTest(const QCPPolarGrid* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        return vqcppolargrid->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPPolarGrid::selectTest(*pos, onlySelectable, details);
    }
}

// Base class handler implementation
double QCPPolarGrid_QBaseSelectTest(const QCPPolarGrid* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_SelectTest_IsBase(true);
        return vqcppolargrid->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPPolarGrid::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnSelectTest(const QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_SelectTest_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_SelectTest_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGrid_ParentPlotInitialized(QCPPolarGrid* self, QCustomPlot* parentPlot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPPolarGrid*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPPolarGrid_QBaseParentPlotInitialized(QCPPolarGrid* self, QCustomPlot* parentPlot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_ParentPlotInitialized_IsBase(true);
        vqcppolargrid->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPPolarGrid*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnParentPlotInitialized(QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPPolarGrid_SelectionCategory(const QCPPolarGrid* self) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        return static_cast<int>(vqcppolargrid->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPPolarGrid*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPPolarGrid_QBaseSelectionCategory(const QCPPolarGrid* self) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcppolargrid->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPPolarGrid*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnSelectionCategory(const QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_SelectionCategory_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPPolarGrid_ClipRect(const QCPPolarGrid* self) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        return new QRect(vqcppolargrid->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPPolarGrid_QBaseClipRect(const QCPPolarGrid* self) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_ClipRect_IsBase(true);
        return new QRect(vqcppolargrid->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnClipRect(const QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_ClipRect_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGrid_SelectEvent(QCPPolarGrid* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPPolarGrid*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPPolarGrid_QBaseSelectEvent(QCPPolarGrid* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_SelectEvent_IsBase(true);
        vqcppolargrid->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPPolarGrid*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnSelectEvent(QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_SelectEvent_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGrid_DeselectEvent(QCPPolarGrid* self, bool* selectionStateChanged) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPPolarGrid*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPPolarGrid_QBaseDeselectEvent(QCPPolarGrid* self, bool* selectionStateChanged) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_DeselectEvent_IsBase(true);
        vqcppolargrid->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPPolarGrid*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnDeselectEvent(QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_DeselectEvent_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGrid_MousePressEvent(QCPPolarGrid* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPPolarGrid*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPPolarGrid_QBaseMousePressEvent(QCPPolarGrid* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_MousePressEvent_IsBase(true);
        vqcppolargrid->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPPolarGrid*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnMousePressEvent(QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_MousePressEvent_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGrid_MouseMoveEvent(QCPPolarGrid* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPPolarGrid*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPPolarGrid_QBaseMouseMoveEvent(QCPPolarGrid* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_MouseMoveEvent_IsBase(true);
        vqcppolargrid->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPPolarGrid*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnMouseMoveEvent(QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGrid_MouseReleaseEvent(QCPPolarGrid* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPPolarGrid*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPPolarGrid_QBaseMouseReleaseEvent(QCPPolarGrid* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_MouseReleaseEvent_IsBase(true);
        vqcppolargrid->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPPolarGrid*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnMouseReleaseEvent(QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGrid_MouseDoubleClickEvent(QCPPolarGrid* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPPolarGrid*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPPolarGrid_QBaseMouseDoubleClickEvent(QCPPolarGrid* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_MouseDoubleClickEvent_IsBase(true);
        vqcppolargrid->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPPolarGrid*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnMouseDoubleClickEvent(QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGrid_WheelEvent(QCPPolarGrid* self, QWheelEvent* event) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->wheelEvent(event);
    } else {
        ((VirtualQCPPolarGrid*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPPolarGrid_QBaseWheelEvent(QCPPolarGrid* self, QWheelEvent* event) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_WheelEvent_IsBase(true);
        vqcppolargrid->wheelEvent(event);
    } else {
        ((VirtualQCPPolarGrid*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnWheelEvent(QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_WheelEvent_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPPolarGrid_Event(QCPPolarGrid* self, QEvent* event) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        return vqcppolargrid->event(event);
    } else {
        return self->QCPPolarGrid::event(event);
    }
}

// Base class handler implementation
bool QCPPolarGrid_QBaseEvent(QCPPolarGrid* self, QEvent* event) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_Event_IsBase(true);
        return vqcppolargrid->event(event);
    } else {
        return self->QCPPolarGrid::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnEvent(QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_Event_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPPolarGrid_EventFilter(QCPPolarGrid* self, QObject* watched, QEvent* event) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        return vqcppolargrid->eventFilter(watched, event);
    } else {
        return self->QCPPolarGrid::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPPolarGrid_QBaseEventFilter(QCPPolarGrid* self, QObject* watched, QEvent* event) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_EventFilter_IsBase(true);
        return vqcppolargrid->eventFilter(watched, event);
    } else {
        return self->QCPPolarGrid::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnEventFilter(QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_EventFilter_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGrid_TimerEvent(QCPPolarGrid* self, QTimerEvent* event) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->timerEvent(event);
    } else {
        ((VirtualQCPPolarGrid*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPPolarGrid_QBaseTimerEvent(QCPPolarGrid* self, QTimerEvent* event) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_TimerEvent_IsBase(true);
        vqcppolargrid->timerEvent(event);
    } else {
        ((VirtualQCPPolarGrid*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnTimerEvent(QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_TimerEvent_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGrid_ChildEvent(QCPPolarGrid* self, QChildEvent* event) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->childEvent(event);
    } else {
        ((VirtualQCPPolarGrid*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPPolarGrid_QBaseChildEvent(QCPPolarGrid* self, QChildEvent* event) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_ChildEvent_IsBase(true);
        vqcppolargrid->childEvent(event);
    } else {
        ((VirtualQCPPolarGrid*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnChildEvent(QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_ChildEvent_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGrid_CustomEvent(QCPPolarGrid* self, QEvent* event) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->customEvent(event);
    } else {
        ((VirtualQCPPolarGrid*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPPolarGrid_QBaseCustomEvent(QCPPolarGrid* self, QEvent* event) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_CustomEvent_IsBase(true);
        vqcppolargrid->customEvent(event);
    } else {
        ((VirtualQCPPolarGrid*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnCustomEvent(QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_CustomEvent_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGrid_ConnectNotify(QCPPolarGrid* self, const QMetaMethod* signal) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->connectNotify(*signal);
    } else {
        ((VirtualQCPPolarGrid*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPPolarGrid_QBaseConnectNotify(QCPPolarGrid* self, const QMetaMethod* signal) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_ConnectNotify_IsBase(true);
        vqcppolargrid->connectNotify(*signal);
    } else {
        ((VirtualQCPPolarGrid*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnConnectNotify(QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_ConnectNotify_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGrid_DisconnectNotify(QCPPolarGrid* self, const QMetaMethod* signal) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->disconnectNotify(*signal);
    } else {
        ((VirtualQCPPolarGrid*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPPolarGrid_QBaseDisconnectNotify(QCPPolarGrid* self, const QMetaMethod* signal) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_DisconnectNotify_IsBase(true);
        vqcppolargrid->disconnectNotify(*signal);
    } else {
        ((VirtualQCPPolarGrid*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnDisconnectNotify(QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGrid_DrawRadialGrid(QCPPolarGrid* self, QCPPainter* painter, const QPointF* center, const libqt_list /* of double */ coords, const QPen* pen) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    QVector<double> coords_QVector;
    coords_QVector.reserve(coords.len);
    double* coords_arr = static_cast<double*>(coords.data);
    for (size_t i = 0; i < coords.len; ++i) {
        coords_QVector.push_back(static_cast<double>(coords_arr[i]));
    }
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->drawRadialGrid(painter, *center, coords_QVector, *pen);
    } else {
        ((VirtualQCPPolarGrid*)self)->drawRadialGrid(painter, *center, coords_QVector, *pen);
    }
}

// Base class handler implementation
void QCPPolarGrid_QBaseDrawRadialGrid(QCPPolarGrid* self, QCPPainter* painter, const QPointF* center, const libqt_list /* of double */ coords, const QPen* pen) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    QVector<double> coords_QVector;
    coords_QVector.reserve(coords.len);
    double* coords_arr = static_cast<double*>(coords.data);
    for (size_t i = 0; i < coords.len; ++i) {
        coords_QVector.push_back(static_cast<double>(coords_arr[i]));
    }
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_DrawRadialGrid_IsBase(true);
        vqcppolargrid->drawRadialGrid(painter, *center, coords_QVector, *pen);
    } else {
        ((VirtualQCPPolarGrid*)self)->drawRadialGrid(painter, *center, coords_QVector, *pen);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnDrawRadialGrid(QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_DrawRadialGrid_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_DrawRadialGrid_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGrid_DrawAngularGrid(QCPPolarGrid* self, QCPPainter* painter, const QPointF* center, double radius, const libqt_list /* of QPointF* */ ticksCosSin, const QPen* pen) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    QVector<QPointF> ticksCosSin_QVector;
    ticksCosSin_QVector.reserve(ticksCosSin.len);
    QPointF** ticksCosSin_arr = static_cast<QPointF**>(ticksCosSin.data);
    for (size_t i = 0; i < ticksCosSin.len; ++i) {
        ticksCosSin_QVector.push_back(*(ticksCosSin_arr[i]));
    }
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->drawAngularGrid(painter, *center, static_cast<double>(radius), ticksCosSin_QVector, *pen);
    } else {
        ((VirtualQCPPolarGrid*)self)->drawAngularGrid(painter, *center, static_cast<double>(radius), ticksCosSin_QVector, *pen);
    }
}

// Base class handler implementation
void QCPPolarGrid_QBaseDrawAngularGrid(QCPPolarGrid* self, QCPPainter* painter, const QPointF* center, double radius, const libqt_list /* of QPointF* */ ticksCosSin, const QPen* pen) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    QVector<QPointF> ticksCosSin_QVector;
    ticksCosSin_QVector.reserve(ticksCosSin.len);
    QPointF** ticksCosSin_arr = static_cast<QPointF**>(ticksCosSin.data);
    for (size_t i = 0; i < ticksCosSin.len; ++i) {
        ticksCosSin_QVector.push_back(*(ticksCosSin_arr[i]));
    }
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_DrawAngularGrid_IsBase(true);
        vqcppolargrid->drawAngularGrid(painter, *center, static_cast<double>(radius), ticksCosSin_QVector, *pen);
    } else {
        ((VirtualQCPPolarGrid*)self)->drawAngularGrid(painter, *center, static_cast<double>(radius), ticksCosSin_QVector, *pen);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnDrawAngularGrid(QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_DrawAngularGrid_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_DrawAngularGrid_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGrid_DrawRadialGrid5(QCPPolarGrid* self, QCPPainter* painter, const QPointF* center, const libqt_list /* of double */ coords, const QPen* pen, const QPen* zeroPen) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    QVector<double> coords_QVector;
    coords_QVector.reserve(coords.len);
    double* coords_arr = static_cast<double*>(coords.data);
    for (size_t i = 0; i < coords.len; ++i) {
        coords_QVector.push_back(static_cast<double>(coords_arr[i]));
    }
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->drawRadialGrid(painter, *center, coords_QVector, *pen, *zeroPen);
    } else {
        ((VirtualQCPPolarGrid*)self)->drawRadialGrid(painter, *center, coords_QVector, *pen, *zeroPen);
    }
}

// Base class handler implementation
void QCPPolarGrid_QBaseDrawRadialGrid5(QCPPolarGrid* self, QCPPainter* painter, const QPointF* center, const libqt_list /* of double */ coords, const QPen* pen, const QPen* zeroPen) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    QVector<double> coords_QVector;
    coords_QVector.reserve(coords.len);
    double* coords_arr = static_cast<double*>(coords.data);
    for (size_t i = 0; i < coords.len; ++i) {
        coords_QVector.push_back(static_cast<double>(coords_arr[i]));
    }
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_DrawRadialGrid5_IsBase(true);
        vqcppolargrid->drawRadialGrid(painter, *center, coords_QVector, *pen, *zeroPen);
    } else {
        ((VirtualQCPPolarGrid*)self)->drawRadialGrid(painter, *center, coords_QVector, *pen, *zeroPen);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnDrawRadialGrid5(QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_DrawRadialGrid5_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_DrawRadialGrid5_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGrid_InitializeParentPlot(QCPPolarGrid* self, QCustomPlot* parentPlot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPPolarGrid*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPPolarGrid_QBaseInitializeParentPlot(QCPPolarGrid* self, QCustomPlot* parentPlot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_InitializeParentPlot_IsBase(true);
        vqcppolargrid->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPPolarGrid*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnInitializeParentPlot(QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGrid_SetParentLayerable(QCPPolarGrid* self, QCPLayerable* parentLayerable) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPPolarGrid*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPPolarGrid_QBaseSetParentLayerable(QCPPolarGrid* self, QCPLayerable* parentLayerable) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_SetParentLayerable_IsBase(true);
        vqcppolargrid->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPPolarGrid*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnSetParentLayerable(QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPPolarGrid_MoveToLayer(QCPPolarGrid* self, QCPLayer* layer, bool prepend) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        return vqcppolargrid->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPPolarGrid*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPPolarGrid_QBaseMoveToLayer(QCPPolarGrid* self, QCPLayer* layer, bool prepend) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_MoveToLayer_IsBase(true);
        return vqcppolargrid->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPPolarGrid*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnMoveToLayer(QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = dynamic_cast<VirtualQCPPolarGrid*>(self);
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_MoveToLayer_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGrid_ApplyAntialiasingHint(const QCPPolarGrid* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPPolarGrid*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPPolarGrid_QBaseApplyAntialiasingHint(const QCPPolarGrid* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_ApplyAntialiasingHint_IsBase(true);
        vqcppolargrid->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPPolarGrid*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnApplyAntialiasingHint(const QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPPolarGrid_Sender(const QCPPolarGrid* self) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        return vqcppolargrid->sender();
    } else {
        return ((VirtualQCPPolarGrid*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPPolarGrid_QBaseSender(const QCPPolarGrid* self) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_Sender_IsBase(true);
        return vqcppolargrid->sender();
    } else {
        return ((VirtualQCPPolarGrid*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnSender(const QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_Sender_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPPolarGrid_SenderSignalIndex(const QCPPolarGrid* self) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        return vqcppolargrid->senderSignalIndex();
    } else {
        return ((VirtualQCPPolarGrid*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPPolarGrid_QBaseSenderSignalIndex(const QCPPolarGrid* self) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_SenderSignalIndex_IsBase(true);
        return vqcppolargrid->senderSignalIndex();
    } else {
        return ((VirtualQCPPolarGrid*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnSenderSignalIndex(const QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPPolarGrid_Receivers(const QCPPolarGrid* self, const char* signal) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        return vqcppolargrid->receivers(signal);
    } else {
        return ((VirtualQCPPolarGrid*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPPolarGrid_QBaseReceivers(const QCPPolarGrid* self, const char* signal) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_Receivers_IsBase(true);
        return vqcppolargrid->receivers(signal);
    } else {
        return ((VirtualQCPPolarGrid*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnReceivers(const QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_Receivers_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPPolarGrid_IsSignalConnected(const QCPPolarGrid* self, const QMetaMethod* signal) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        return vqcppolargrid->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPPolarGrid*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPPolarGrid_QBaseIsSignalConnected(const QCPPolarGrid* self, const QMetaMethod* signal) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_IsSignalConnected_IsBase(true);
        return vqcppolargrid->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPPolarGrid*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGrid_OnIsSignalConnected(const QCPPolarGrid* self, intptr_t slot) {
    auto* vqcppolargrid = const_cast<VirtualQCPPolarGrid*>(dynamic_cast<const VirtualQCPPolarGrid*>(self));
    if (vqcppolargrid && vqcppolargrid->isVirtualQCPPolarGrid) {
        vqcppolargrid->setQCPPolarGrid_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPPolarGrid::QCPPolarGrid_IsSignalConnected_Callback>(slot));
    }
}

void QCPPolarGrid_Delete(QCPPolarGrid* self) {
    delete self;
}

QCPPolarLegendItem* QCPPolarLegendItem_new(QCPLegend* parent, QCPPolarGraph* graph) {
    return new VirtualQCPPolarLegendItem(parent, graph);
}

QMetaObject* QCPPolarLegendItem_MetaObject(const QCPPolarLegendItem* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPPolarLegendItem_Metacast(QCPPolarLegendItem* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPPolarLegendItem_Metacall(QCPPolarLegendItem* self, int param1, int param2, void** param3) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPPolarLegendItem*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPPolarLegendItem_Tr(const char* s) {
    QString _ret = QCPPolarLegendItem::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

QCPPolarGraph* QCPPolarLegendItem_PolarGraph(QCPPolarLegendItem* self) {
    return self->polarGraph();
}

void QCPPolarLegendItem_Draw(QCPPolarLegendItem* self, QCPPainter* painter) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->draw(painter);
    }
}

QSize* QCPPolarLegendItem_MinimumOuterSizeHint(const QCPPolarLegendItem* self) {
    auto* vqcppolarlegenditem = dynamic_cast<const VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        return new QSize(vqcppolarlegenditem->minimumOuterSizeHint());
    }
    return {};
}

libqt_string QCPPolarLegendItem_Tr2(const char* s, const char* c) {
    QString _ret = QCPPolarLegendItem::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPPolarLegendItem_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPPolarLegendItem::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

// Base class handler implementation
int QCPPolarLegendItem_QBaseMetacall(QCPPolarLegendItem* self, int param1, int param2, void** param3) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_Metacall_IsBase(true);
        return vqcppolarlegenditem->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPPolarLegendItem::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnMetacall(QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_Metacall_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPolarLegendItem_QBaseDraw(QCPPolarLegendItem* self, QCPPainter* painter) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_Draw_IsBase(true);
        vqcppolarlegenditem->draw(painter);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnDraw(QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_Draw_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_Draw_Callback>(slot));
    }
}

// Base class handler implementation
QSize* QCPPolarLegendItem_QBaseMinimumOuterSizeHint(const QCPPolarLegendItem* self) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_MinimumOuterSizeHint_IsBase(true);
        return new QSize(vqcppolarlegenditem->minimumOuterSizeHint());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnMinimumOuterSizeHint(const QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_MinimumOuterSizeHint_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_MinimumOuterSizeHint_Callback>(slot));
    }
}

// Derived class handler implementation
double QCPPolarLegendItem_SelectTest(const QCPPolarLegendItem* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        return vqcppolarlegenditem->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPPolarLegendItem::selectTest(*pos, onlySelectable, details);
    }
}

// Base class handler implementation
double QCPPolarLegendItem_QBaseSelectTest(const QCPPolarLegendItem* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_SelectTest_IsBase(true);
        return vqcppolarlegenditem->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPPolarLegendItem::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnSelectTest(const QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_SelectTest_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_SelectTest_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPPolarLegendItem_SelectionCategory(const QCPPolarLegendItem* self) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        return static_cast<int>(vqcppolarlegenditem->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPPolarLegendItem*)self)->selectionCategory());
    }
}

// Base class handler implementation
int QCPPolarLegendItem_QBaseSelectionCategory(const QCPPolarLegendItem* self) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcppolarlegenditem->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPPolarLegendItem*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnSelectionCategory(const QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_SelectionCategory_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_SelectionCategory_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarLegendItem_ApplyDefaultAntialiasingHint(const QCPPolarLegendItem* self, QCPPainter* painter) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPPolarLegendItem_QBaseApplyDefaultAntialiasingHint(const QCPPolarLegendItem* self, QCPPainter* painter) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcppolarlegenditem->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnApplyDefaultAntialiasingHint(const QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QRect* QCPPolarLegendItem_ClipRect(const QCPPolarLegendItem* self) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        return new QRect(vqcppolarlegenditem->clipRect());
    }
    return {};
}

// Base class handler implementation
QRect* QCPPolarLegendItem_QBaseClipRect(const QCPPolarLegendItem* self) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_ClipRect_IsBase(true);
        return new QRect(vqcppolarlegenditem->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnClipRect(const QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_ClipRect_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_ClipRect_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarLegendItem_SelectEvent(QCPPolarLegendItem* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Base class handler implementation
void QCPPolarLegendItem_QBaseSelectEvent(QCPPolarLegendItem* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_SelectEvent_IsBase(true);
        vqcppolarlegenditem->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnSelectEvent(QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_SelectEvent_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_SelectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarLegendItem_DeselectEvent(QCPPolarLegendItem* self, bool* selectionStateChanged) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->deselectEvent(selectionStateChanged);
    }
}

// Base class handler implementation
void QCPPolarLegendItem_QBaseDeselectEvent(QCPPolarLegendItem* self, bool* selectionStateChanged) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_DeselectEvent_IsBase(true);
        vqcppolarlegenditem->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnDeselectEvent(QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_DeselectEvent_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_DeselectEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarLegendItem_Update(QCPPolarLegendItem* self, int phase) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    } else {
        self->QCPPolarLegendItem::update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    }
}

// Base class handler implementation
void QCPPolarLegendItem_QBaseUpdate(QCPPolarLegendItem* self, int phase) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_Update_IsBase(true);
        vqcppolarlegenditem->update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    } else {
        self->QCPPolarLegendItem::update(static_cast<QCPLayoutElement::UpdatePhase>(phase));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnUpdate(QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_Update_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_Update_Callback>(slot));
    }
}

// Derived class handler implementation
QSize* QCPPolarLegendItem_MaximumOuterSizeHint(const QCPPolarLegendItem* self) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        return new QSize(vqcppolarlegenditem->maximumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPPolarLegendItem*)self)->maximumOuterSizeHint());
    }
}

// Base class handler implementation
QSize* QCPPolarLegendItem_QBaseMaximumOuterSizeHint(const QCPPolarLegendItem* self) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_MaximumOuterSizeHint_IsBase(true);
        return new QSize(vqcppolarlegenditem->maximumOuterSizeHint());
    } else {
        return new QSize(((VirtualQCPPolarLegendItem*)self)->maximumOuterSizeHint());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnMaximumOuterSizeHint(const QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_MaximumOuterSizeHint_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_MaximumOuterSizeHint_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of QCPLayoutElement* */ QCPPolarLegendItem_Elements(const QCPPolarLegendItem* self, bool recursive) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        QList<QCPLayoutElement*> _ret = vqcppolarlegenditem->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayoutElement*> _ret = self->QCPPolarLegendItem::elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of QCPLayoutElement* */ QCPPolarLegendItem_QBaseElements(const QCPPolarLegendItem* self, bool recursive) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_Elements_IsBase(true);
        QList<QCPLayoutElement*> _ret = vqcppolarlegenditem->elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QList<QCPLayoutElement*> _ret = self->QCPPolarLegendItem::elements(recursive);
        // Convert QList<> from C++ memory to manually-managed C memory
        QCPLayoutElement** _arr = static_cast<QCPLayoutElement**>(malloc(sizeof(QCPLayoutElement*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = _ret[i];
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnElements(const QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_Elements_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_Elements_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPPolarLegendItem_CalculateAutoMargin(QCPPolarLegendItem* self, int side) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        return vqcppolarlegenditem->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    } else {
        return ((VirtualQCPPolarLegendItem*)self)->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    }
}

// Base class handler implementation
int QCPPolarLegendItem_QBaseCalculateAutoMargin(QCPPolarLegendItem* self, int side) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_CalculateAutoMargin_IsBase(true);
        return vqcppolarlegenditem->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    } else {
        return ((VirtualQCPPolarLegendItem*)self)->calculateAutoMargin(static_cast<QCP::MarginSide>(side));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnCalculateAutoMargin(QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_CalculateAutoMargin_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_CalculateAutoMargin_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarLegendItem_LayoutChanged(QCPPolarLegendItem* self) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->layoutChanged();
    } else {
        ((VirtualQCPPolarLegendItem*)self)->layoutChanged();
    }
}

// Base class handler implementation
void QCPPolarLegendItem_QBaseLayoutChanged(QCPPolarLegendItem* self) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_LayoutChanged_IsBase(true);
        vqcppolarlegenditem->layoutChanged();
    } else {
        ((VirtualQCPPolarLegendItem*)self)->layoutChanged();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnLayoutChanged(QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_LayoutChanged_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_LayoutChanged_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarLegendItem_ParentPlotInitialized(QCPPolarLegendItem* self, QCustomPlot* parentPlot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPPolarLegendItem_QBaseParentPlotInitialized(QCPPolarLegendItem* self, QCustomPlot* parentPlot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_ParentPlotInitialized_IsBase(true);
        vqcppolarlegenditem->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnParentPlotInitialized(QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarLegendItem_MousePressEvent(QCPPolarLegendItem* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPPolarLegendItem_QBaseMousePressEvent(QCPPolarLegendItem* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_MousePressEvent_IsBase(true);
        vqcppolarlegenditem->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnMousePressEvent(QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_MousePressEvent_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarLegendItem_MouseMoveEvent(QCPPolarLegendItem* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPPolarLegendItem_QBaseMouseMoveEvent(QCPPolarLegendItem* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_MouseMoveEvent_IsBase(true);
        vqcppolarlegenditem->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnMouseMoveEvent(QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarLegendItem_MouseReleaseEvent(QCPPolarLegendItem* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPPolarLegendItem_QBaseMouseReleaseEvent(QCPPolarLegendItem* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_MouseReleaseEvent_IsBase(true);
        vqcppolarlegenditem->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnMouseReleaseEvent(QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarLegendItem_MouseDoubleClickEvent(QCPPolarLegendItem* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPPolarLegendItem_QBaseMouseDoubleClickEvent(QCPPolarLegendItem* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_MouseDoubleClickEvent_IsBase(true);
        vqcppolarlegenditem->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnMouseDoubleClickEvent(QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarLegendItem_WheelEvent(QCPPolarLegendItem* self, QWheelEvent* event) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->wheelEvent(event);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPPolarLegendItem_QBaseWheelEvent(QCPPolarLegendItem* self, QWheelEvent* event) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_WheelEvent_IsBase(true);
        vqcppolarlegenditem->wheelEvent(event);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnWheelEvent(QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_WheelEvent_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPPolarLegendItem_Event(QCPPolarLegendItem* self, QEvent* event) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        return vqcppolarlegenditem->event(event);
    } else {
        return self->QCPPolarLegendItem::event(event);
    }
}

// Base class handler implementation
bool QCPPolarLegendItem_QBaseEvent(QCPPolarLegendItem* self, QEvent* event) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_Event_IsBase(true);
        return vqcppolarlegenditem->event(event);
    } else {
        return self->QCPPolarLegendItem::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnEvent(QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_Event_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPPolarLegendItem_EventFilter(QCPPolarLegendItem* self, QObject* watched, QEvent* event) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        return vqcppolarlegenditem->eventFilter(watched, event);
    } else {
        return self->QCPPolarLegendItem::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPPolarLegendItem_QBaseEventFilter(QCPPolarLegendItem* self, QObject* watched, QEvent* event) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_EventFilter_IsBase(true);
        return vqcppolarlegenditem->eventFilter(watched, event);
    } else {
        return self->QCPPolarLegendItem::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnEventFilter(QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_EventFilter_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarLegendItem_TimerEvent(QCPPolarLegendItem* self, QTimerEvent* event) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->timerEvent(event);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPPolarLegendItem_QBaseTimerEvent(QCPPolarLegendItem* self, QTimerEvent* event) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_TimerEvent_IsBase(true);
        vqcppolarlegenditem->timerEvent(event);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnTimerEvent(QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_TimerEvent_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarLegendItem_ChildEvent(QCPPolarLegendItem* self, QChildEvent* event) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->childEvent(event);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPPolarLegendItem_QBaseChildEvent(QCPPolarLegendItem* self, QChildEvent* event) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_ChildEvent_IsBase(true);
        vqcppolarlegenditem->childEvent(event);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnChildEvent(QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_ChildEvent_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarLegendItem_CustomEvent(QCPPolarLegendItem* self, QEvent* event) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->customEvent(event);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPPolarLegendItem_QBaseCustomEvent(QCPPolarLegendItem* self, QEvent* event) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_CustomEvent_IsBase(true);
        vqcppolarlegenditem->customEvent(event);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnCustomEvent(QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_CustomEvent_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarLegendItem_ConnectNotify(QCPPolarLegendItem* self, const QMetaMethod* signal) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->connectNotify(*signal);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPPolarLegendItem_QBaseConnectNotify(QCPPolarLegendItem* self, const QMetaMethod* signal) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_ConnectNotify_IsBase(true);
        vqcppolarlegenditem->connectNotify(*signal);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnConnectNotify(QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_ConnectNotify_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarLegendItem_DisconnectNotify(QCPPolarLegendItem* self, const QMetaMethod* signal) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->disconnectNotify(*signal);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPPolarLegendItem_QBaseDisconnectNotify(QCPPolarLegendItem* self, const QMetaMethod* signal) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_DisconnectNotify_IsBase(true);
        vqcppolarlegenditem->disconnectNotify(*signal);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnDisconnectNotify(QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
QPen* QCPPolarLegendItem_GetIconBorderPen(const QCPPolarLegendItem* self) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        return new QPen(vqcppolarlegenditem->getIconBorderPen());
    }
    return {};
}

// Base class handler implementation
QPen* QCPPolarLegendItem_QBaseGetIconBorderPen(const QCPPolarLegendItem* self) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_GetIconBorderPen_IsBase(true);
        return new QPen(vqcppolarlegenditem->getIconBorderPen());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnGetIconBorderPen(const QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_GetIconBorderPen_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_GetIconBorderPen_Callback>(slot));
    }
}

// Derived class handler implementation
QColor* QCPPolarLegendItem_GetTextColor(const QCPPolarLegendItem* self) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        return new QColor(vqcppolarlegenditem->getTextColor());
    }
    return {};
}

// Base class handler implementation
QColor* QCPPolarLegendItem_QBaseGetTextColor(const QCPPolarLegendItem* self) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_GetTextColor_IsBase(true);
        return new QColor(vqcppolarlegenditem->getTextColor());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnGetTextColor(const QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_GetTextColor_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_GetTextColor_Callback>(slot));
    }
}

// Derived class handler implementation
QFont* QCPPolarLegendItem_GetFont(const QCPPolarLegendItem* self) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        return new QFont(vqcppolarlegenditem->getFont());
    }
    return {};
}

// Base class handler implementation
QFont* QCPPolarLegendItem_QBaseGetFont(const QCPPolarLegendItem* self) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_GetFont_IsBase(true);
        return new QFont(vqcppolarlegenditem->getFont());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnGetFont(const QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_GetFont_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_GetFont_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarLegendItem_InitializeParentPlot(QCPPolarLegendItem* self, QCustomPlot* parentPlot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPPolarLegendItem_QBaseInitializeParentPlot(QCPPolarLegendItem* self, QCustomPlot* parentPlot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_InitializeParentPlot_IsBase(true);
        vqcppolarlegenditem->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnInitializeParentPlot(QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarLegendItem_SetParentLayerable(QCPPolarLegendItem* self, QCPLayerable* parentLayerable) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPPolarLegendItem_QBaseSetParentLayerable(QCPPolarLegendItem* self, QCPLayerable* parentLayerable) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_SetParentLayerable_IsBase(true);
        vqcppolarlegenditem->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPPolarLegendItem*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnSetParentLayerable(QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPPolarLegendItem_MoveToLayer(QCPPolarLegendItem* self, QCPLayer* layer, bool prepend) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        return vqcppolarlegenditem->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPPolarLegendItem*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPPolarLegendItem_QBaseMoveToLayer(QCPPolarLegendItem* self, QCPLayer* layer, bool prepend) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_MoveToLayer_IsBase(true);
        return vqcppolarlegenditem->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPPolarLegendItem*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnMoveToLayer(QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = dynamic_cast<VirtualQCPPolarLegendItem*>(self);
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_MoveToLayer_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarLegendItem_ApplyAntialiasingHint(const QCPPolarLegendItem* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPPolarLegendItem*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPPolarLegendItem_QBaseApplyAntialiasingHint(const QCPPolarLegendItem* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_ApplyAntialiasingHint_IsBase(true);
        vqcppolarlegenditem->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPPolarLegendItem*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnApplyAntialiasingHint(const QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPPolarLegendItem_Sender(const QCPPolarLegendItem* self) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        return vqcppolarlegenditem->sender();
    } else {
        return ((VirtualQCPPolarLegendItem*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPPolarLegendItem_QBaseSender(const QCPPolarLegendItem* self) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_Sender_IsBase(true);
        return vqcppolarlegenditem->sender();
    } else {
        return ((VirtualQCPPolarLegendItem*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnSender(const QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_Sender_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPPolarLegendItem_SenderSignalIndex(const QCPPolarLegendItem* self) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        return vqcppolarlegenditem->senderSignalIndex();
    } else {
        return ((VirtualQCPPolarLegendItem*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPPolarLegendItem_QBaseSenderSignalIndex(const QCPPolarLegendItem* self) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_SenderSignalIndex_IsBase(true);
        return vqcppolarlegenditem->senderSignalIndex();
    } else {
        return ((VirtualQCPPolarLegendItem*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnSenderSignalIndex(const QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPPolarLegendItem_Receivers(const QCPPolarLegendItem* self, const char* signal) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        return vqcppolarlegenditem->receivers(signal);
    } else {
        return ((VirtualQCPPolarLegendItem*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPPolarLegendItem_QBaseReceivers(const QCPPolarLegendItem* self, const char* signal) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_Receivers_IsBase(true);
        return vqcppolarlegenditem->receivers(signal);
    } else {
        return ((VirtualQCPPolarLegendItem*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnReceivers(const QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_Receivers_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPPolarLegendItem_IsSignalConnected(const QCPPolarLegendItem* self, const QMetaMethod* signal) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        return vqcppolarlegenditem->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPPolarLegendItem*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPPolarLegendItem_QBaseIsSignalConnected(const QCPPolarLegendItem* self, const QMetaMethod* signal) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_IsSignalConnected_IsBase(true);
        return vqcppolarlegenditem->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPPolarLegendItem*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarLegendItem_OnIsSignalConnected(const QCPPolarLegendItem* self, intptr_t slot) {
    auto* vqcppolarlegenditem = const_cast<VirtualQCPPolarLegendItem*>(dynamic_cast<const VirtualQCPPolarLegendItem*>(self));
    if (vqcppolarlegenditem && vqcppolarlegenditem->isVirtualQCPPolarLegendItem) {
        vqcppolarlegenditem->setQCPPolarLegendItem_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPPolarLegendItem::QCPPolarLegendItem_IsSignalConnected_Callback>(slot));
    }
}

void QCPPolarLegendItem_Delete(QCPPolarLegendItem* self) {
    delete self;
}

QCPPolarGraph* QCPPolarGraph_new(QCPPolarAxisAngular* keyAxis, QCPPolarAxisRadial* valueAxis) {
    return new VirtualQCPPolarGraph(keyAxis, valueAxis);
}

QMetaObject* QCPPolarGraph_MetaObject(const QCPPolarGraph* self) {
    return (QMetaObject*)self->metaObject();
}

void* QCPPolarGraph_Metacast(QCPPolarGraph* self, const char* param1) {
    return self->qt_metacast(param1);
}

int QCPPolarGraph_Metacall(QCPPolarGraph* self, int param1, int param2, void** param3) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        return self->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return ((VirtualQCPPolarGraph*)self)->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

libqt_string QCPPolarGraph_Tr(const char* s) {
    QString _ret = QCPPolarGraph::tr(s);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPPolarGraph_Name(const QCPPolarGraph* self) {
    QString _ret = self->name();
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

bool QCPPolarGraph_AntialiasedFill(const QCPPolarGraph* self) {
    return self->antialiasedFill();
}

bool QCPPolarGraph_AntialiasedScatters(const QCPPolarGraph* self) {
    return self->antialiasedScatters();
}

QPen* QCPPolarGraph_Pen(const QCPPolarGraph* self) {
    return new QPen(self->pen());
}

QBrush* QCPPolarGraph_Brush(const QCPPolarGraph* self) {
    return new QBrush(self->brush());
}

bool QCPPolarGraph_Periodic(const QCPPolarGraph* self) {
    return self->periodic();
}

QCPPolarAxisAngular* QCPPolarGraph_KeyAxis(const QCPPolarGraph* self) {
    return self->keyAxis();
}

QCPPolarAxisRadial* QCPPolarGraph_ValueAxis(const QCPPolarGraph* self) {
    return self->valueAxis();
}

int QCPPolarGraph_Selectable(const QCPPolarGraph* self) {
    return static_cast<int>(self->selectable());
}

bool QCPPolarGraph_Selected(const QCPPolarGraph* self) {
    return self->selected();
}

QCPDataSelection* QCPPolarGraph_Selection(const QCPPolarGraph* self) {
    return new QCPDataSelection(self->selection());
}

int QCPPolarGraph_LineStyle(const QCPPolarGraph* self) {
    return static_cast<int>(self->lineStyle());
}

QCPScatterStyle* QCPPolarGraph_ScatterStyle(const QCPPolarGraph* self) {
    return new QCPScatterStyle(self->scatterStyle());
}

void QCPPolarGraph_SetName(QCPPolarGraph* self, const libqt_string name) {
    QString name_QString = QString::fromUtf8(name.data, name.len);
    self->setName(name_QString);
}

void QCPPolarGraph_SetAntialiasedFill(QCPPolarGraph* self, bool enabled) {
    self->setAntialiasedFill(enabled);
}

void QCPPolarGraph_SetAntialiasedScatters(QCPPolarGraph* self, bool enabled) {
    self->setAntialiasedScatters(enabled);
}

void QCPPolarGraph_SetPen(QCPPolarGraph* self, const QPen* pen) {
    self->setPen(*pen);
}

void QCPPolarGraph_SetBrush(QCPPolarGraph* self, const QBrush* brush) {
    self->setBrush(*brush);
}

void QCPPolarGraph_SetPeriodic(QCPPolarGraph* self, bool enabled) {
    self->setPeriodic(enabled);
}

void QCPPolarGraph_SetKeyAxis(QCPPolarGraph* self, QCPPolarAxisAngular* axis) {
    self->setKeyAxis(axis);
}

void QCPPolarGraph_SetValueAxis(QCPPolarGraph* self, QCPPolarAxisRadial* axis) {
    self->setValueAxis(axis);
}

void QCPPolarGraph_SetSelectable(QCPPolarGraph* self, int selectable) {
    self->setSelectable(static_cast<QCP::SelectionType>(selectable));
}

void QCPPolarGraph_SetSelection(QCPPolarGraph* self, QCPDataSelection* selection) {
    self->setSelection(*selection);
}

void QCPPolarGraph_SetData2(QCPPolarGraph* self, const libqt_list /* of double */ keys, const libqt_list /* of double */ values) {
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> values_QVector;
    values_QVector.reserve(values.len);
    double* values_arr = static_cast<double*>(values.data);
    for (size_t i = 0; i < values.len; ++i) {
        values_QVector.push_back(static_cast<double>(values_arr[i]));
    }
    self->setData(keys_QVector, values_QVector);
}

void QCPPolarGraph_SetLineStyle(QCPPolarGraph* self, int ls) {
    self->setLineStyle(static_cast<QCPPolarGraph::LineStyle>(ls));
}

void QCPPolarGraph_SetScatterStyle(QCPPolarGraph* self, const QCPScatterStyle* style) {
    self->setScatterStyle(*style);
}

void QCPPolarGraph_AddData(QCPPolarGraph* self, const libqt_list /* of double */ keys, const libqt_list /* of double */ values) {
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> values_QVector;
    values_QVector.reserve(values.len);
    double* values_arr = static_cast<double*>(values.data);
    for (size_t i = 0; i < values.len; ++i) {
        values_QVector.push_back(static_cast<double>(values_arr[i]));
    }
    self->addData(keys_QVector, values_QVector);
}

void QCPPolarGraph_AddData2(QCPPolarGraph* self, double key, double value) {
    self->addData(static_cast<double>(key), static_cast<double>(value));
}

void QCPPolarGraph_CoordsToPixels(const QCPPolarGraph* self, double key, double value, double* x, double* y) {
    self->coordsToPixels(static_cast<double>(key), static_cast<double>(value), static_cast<double&>(*x), static_cast<double&>(*y));
}

QPointF* QCPPolarGraph_CoordsToPixels2(const QCPPolarGraph* self, double key, double value) {
    return new QPointF(self->coordsToPixels(static_cast<double>(key), static_cast<double>(value)));
}

void QCPPolarGraph_PixelsToCoords(const QCPPolarGraph* self, double x, double y, double* key, double* value) {
    self->pixelsToCoords(static_cast<double>(x), static_cast<double>(y), static_cast<double&>(*key), static_cast<double&>(*value));
}

void QCPPolarGraph_PixelsToCoords2(const QCPPolarGraph* self, const QPointF* pixelPos, double* key, double* value) {
    self->pixelsToCoords(*pixelPos, static_cast<double&>(*key), static_cast<double&>(*value));
}

void QCPPolarGraph_RescaleAxes(const QCPPolarGraph* self) {
    self->rescaleAxes();
}

void QCPPolarGraph_RescaleKeyAxis(const QCPPolarGraph* self) {
    self->rescaleKeyAxis();
}

void QCPPolarGraph_RescaleValueAxis(const QCPPolarGraph* self) {
    self->rescaleValueAxis();
}

bool QCPPolarGraph_AddToLegend(QCPPolarGraph* self, QCPLegend* legend) {
    return self->addToLegend(legend);
}

bool QCPPolarGraph_AddToLegend2(QCPPolarGraph* self) {
    return self->addToLegend();
}

bool QCPPolarGraph_RemoveFromLegend(const QCPPolarGraph* self, QCPLegend* legend) {
    return self->removeFromLegend(legend);
}

bool QCPPolarGraph_RemoveFromLegend2(const QCPPolarGraph* self) {
    return self->removeFromLegend();
}

double QCPPolarGraph_SelectTest(const QCPPolarGraph* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcppolargraph = dynamic_cast<const VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        return self->selectTest(*pos, onlySelectable, details);
    } else {
        return ((VirtualQCPPolarGraph*)self)->selectTest(*pos, onlySelectable, details);
    }
}

QCPPlottableInterface1D* QCPPolarGraph_Interface1D(QCPPolarGraph* self) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        return self->interface1D();
    } else {
        return ((VirtualQCPPolarGraph*)self)->interface1D();
    }
}

QCPRange* QCPPolarGraph_GetKeyRange(const QCPPolarGraph* self, bool* foundRange, int inSignDomain) {
    auto* vqcppolargraph = dynamic_cast<const VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        return new QCPRange(self->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    } else {
        return new QCPRange(((VirtualQCPPolarGraph*)self)->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    }
}

QCPRange* QCPPolarGraph_GetValueRange(const QCPPolarGraph* self, bool* foundRange, int inSignDomain, const QCPRange* inKeyRange) {
    auto* vqcppolargraph = dynamic_cast<const VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        return new QCPRange(self->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    } else {
        return new QCPRange(((VirtualQCPPolarGraph*)self)->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    }
}

void QCPPolarGraph_SelectionChanged(QCPPolarGraph* self, bool selected) {
    self->selectionChanged(selected);
}

void QCPPolarGraph_SelectionChanged2(QCPPolarGraph* self, const QCPDataSelection* selection) {
    self->selectionChanged(*selection);
}

void QCPPolarGraph_SelectableChanged(QCPPolarGraph* self, int selectable) {
    self->selectableChanged(static_cast<QCP::SelectionType>(selectable));
}

QRect* QCPPolarGraph_ClipRect(const QCPPolarGraph* self) {
    auto* vqcppolargraph = dynamic_cast<const VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        return new QRect(vqcppolargraph->clipRect());
    }
    return {};
}

void QCPPolarGraph_Draw(QCPPolarGraph* self, QCPPainter* painter) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->draw(painter);
    }
}

int QCPPolarGraph_SelectionCategory(const QCPPolarGraph* self) {
    auto* vqcppolargraph = dynamic_cast<const VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        return static_cast<int>(vqcppolargraph->selectionCategory());
    }
    return {};
}

void QCPPolarGraph_SelectEvent(QCPPolarGraph* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

void QCPPolarGraph_DeselectEvent(QCPPolarGraph* self, bool* selectionStateChanged) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->deselectEvent(selectionStateChanged);
    }
}

void QCPPolarGraph_DrawLinePlot(const QCPPolarGraph* self, QCPPainter* painter, const libqt_list /* of QPointF* */ lines) {
    QVector<QPointF> lines_QVector;
    lines_QVector.reserve(lines.len);
    QPointF** lines_arr = static_cast<QPointF**>(lines.data);
    for (size_t i = 0; i < lines.len; ++i) {
        lines_QVector.push_back(*(lines_arr[i]));
    }
    auto* vqcppolargraph = dynamic_cast<const VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->drawLinePlot(painter, lines_QVector);
    }
}

void QCPPolarGraph_DrawFill(const QCPPolarGraph* self, QCPPainter* painter, libqt_list /* of QPointF* */ lines) {
    QVector<QPointF> lines_QVector;
    lines_QVector.reserve(lines.len);
    QPointF** lines_arr = static_cast<QPointF**>(lines.data);
    for (size_t i = 0; i < lines.len; ++i) {
        lines_QVector.push_back(*(lines_arr[i]));
    }
    auto* vqcppolargraph = dynamic_cast<const VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->drawFill(painter, &lines_QVector);
    }
}

void QCPPolarGraph_DrawScatterPlot(const QCPPolarGraph* self, QCPPainter* painter, const libqt_list /* of QPointF* */ scatters, const QCPScatterStyle* style) {
    QVector<QPointF> scatters_QVector;
    scatters_QVector.reserve(scatters.len);
    QPointF** scatters_arr = static_cast<QPointF**>(scatters.data);
    for (size_t i = 0; i < scatters.len; ++i) {
        scatters_QVector.push_back(*(scatters_arr[i]));
    }
    auto* vqcppolargraph = dynamic_cast<const VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->drawScatterPlot(painter, scatters_QVector, *style);
    }
}

void QCPPolarGraph_DrawLegendIcon(const QCPPolarGraph* self, QCPPainter* painter, const QRectF* rect) {
    auto* vqcppolargraph = dynamic_cast<const VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->drawLegendIcon(painter, *rect);
    }
}

int QCPPolarGraph_DataCount(const QCPPolarGraph* self) {
    auto* vqcppolargraph = dynamic_cast<const VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        return vqcppolargraph->dataCount();
    }
    return {};
}

libqt_string QCPPolarGraph_Tr2(const char* s, const char* c) {
    QString _ret = QCPPolarGraph::tr(s, c);
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

libqt_string QCPPolarGraph_Tr3(const char* s, const char* c, int n) {
    QString _ret = QCPPolarGraph::tr(s, c, static_cast<int>(n));
    // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
    QByteArray _b = _ret.toUtf8();
    libqt_string _str;
    _str.len = _b.length();
    _str.data = static_cast<const char*>(malloc(_str.len + 1));
    memcpy((void*)_str.data, _b.data(), _str.len);
    ((char*)_str.data)[_str.len] = '\0';
    return _str;
}

void QCPPolarGraph_SetData3(QCPPolarGraph* self, const libqt_list /* of double */ keys, const libqt_list /* of double */ values, bool alreadySorted) {
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> values_QVector;
    values_QVector.reserve(values.len);
    double* values_arr = static_cast<double*>(values.data);
    for (size_t i = 0; i < values.len; ++i) {
        values_QVector.push_back(static_cast<double>(values_arr[i]));
    }
    self->setData(keys_QVector, values_QVector, alreadySorted);
}

void QCPPolarGraph_AddData3(QCPPolarGraph* self, const libqt_list /* of double */ keys, const libqt_list /* of double */ values, bool alreadySorted) {
    QVector<double> keys_QVector;
    keys_QVector.reserve(keys.len);
    double* keys_arr = static_cast<double*>(keys.data);
    for (size_t i = 0; i < keys.len; ++i) {
        keys_QVector.push_back(static_cast<double>(keys_arr[i]));
    }
    QVector<double> values_QVector;
    values_QVector.reserve(values.len);
    double* values_arr = static_cast<double*>(values.data);
    for (size_t i = 0; i < values.len; ++i) {
        values_QVector.push_back(static_cast<double>(values_arr[i]));
    }
    self->addData(keys_QVector, values_QVector, alreadySorted);
}

void QCPPolarGraph_RescaleAxes1(const QCPPolarGraph* self, bool onlyEnlarge) {
    self->rescaleAxes(onlyEnlarge);
}

void QCPPolarGraph_RescaleKeyAxis1(const QCPPolarGraph* self, bool onlyEnlarge) {
    self->rescaleKeyAxis(onlyEnlarge);
}

void QCPPolarGraph_RescaleValueAxis1(const QCPPolarGraph* self, bool onlyEnlarge) {
    self->rescaleValueAxis(onlyEnlarge);
}

void QCPPolarGraph_RescaleValueAxis2(const QCPPolarGraph* self, bool onlyEnlarge, bool inKeyRange) {
    self->rescaleValueAxis(onlyEnlarge, inKeyRange);
}

// Base class handler implementation
int QCPPolarGraph_QBaseMetacall(QCPPolarGraph* self, int param1, int param2, void** param3) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_Metacall_IsBase(true);
        return vqcppolargraph->qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    } else {
        return self->QCPPolarGraph::qt_metacall(static_cast<QMetaObject::Call>(param1), static_cast<int>(param2), param3);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnMetacall(QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_Metacall_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_Metacall_Callback>(slot));
    }
}

// Base class handler implementation
double QCPPolarGraph_QBaseSelectTest(const QCPPolarGraph* self, const QPointF* pos, bool onlySelectable, QVariant* details) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_SelectTest_IsBase(true);
        return vqcppolargraph->selectTest(*pos, onlySelectable, details);
    } else {
        return self->QCPPolarGraph::selectTest(*pos, onlySelectable, details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnSelectTest(const QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_SelectTest_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_SelectTest_Callback>(slot));
    }
}

// Base class handler implementation
QCPPlottableInterface1D* QCPPolarGraph_QBaseInterface1D(QCPPolarGraph* self) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_Interface1D_IsBase(true);
        return vqcppolargraph->interface1D();
    } else {
        return self->QCPPolarGraph::interface1D();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnInterface1D(QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_Interface1D_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_Interface1D_Callback>(slot));
    }
}

// Base class handler implementation
QCPRange* QCPPolarGraph_QBaseGetKeyRange(const QCPPolarGraph* self, bool* foundRange, int inSignDomain) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_GetKeyRange_IsBase(true);
        return new QCPRange(vqcppolargraph->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    } else {
        return new QCPRange(((VirtualQCPPolarGraph*)self)->getKeyRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain)));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnGetKeyRange(const QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_GetKeyRange_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_GetKeyRange_Callback>(slot));
    }
}

// Base class handler implementation
QCPRange* QCPPolarGraph_QBaseGetValueRange(const QCPPolarGraph* self, bool* foundRange, int inSignDomain, const QCPRange* inKeyRange) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_GetValueRange_IsBase(true);
        return new QCPRange(vqcppolargraph->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    } else {
        return new QCPRange(((VirtualQCPPolarGraph*)self)->getValueRange(*foundRange, static_cast<QCP::SignDomain>(inSignDomain), *inKeyRange));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnGetValueRange(const QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_GetValueRange_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_GetValueRange_Callback>(slot));
    }
}

// Base class handler implementation
QRect* QCPPolarGraph_QBaseClipRect(const QCPPolarGraph* self) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_ClipRect_IsBase(true);
        return new QRect(vqcppolargraph->clipRect());
    }
    return {};
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnClipRect(const QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_ClipRect_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_ClipRect_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseDraw(QCPPolarGraph* self, QCPPainter* painter) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_Draw_IsBase(true);
        vqcppolargraph->draw(painter);
    } else {
        ((VirtualQCPPolarGraph*)self)->draw(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnDraw(QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_Draw_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_Draw_Callback>(slot));
    }
}

// Base class handler implementation
int QCPPolarGraph_QBaseSelectionCategory(const QCPPolarGraph* self) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_SelectionCategory_IsBase(true);
        return static_cast<int>(vqcppolargraph->selectionCategory());
    } else {
        return static_cast<int>(((VirtualQCPPolarGraph*)self)->selectionCategory());
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnSelectionCategory(const QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_SelectionCategory_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_SelectionCategory_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseSelectEvent(QCPPolarGraph* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_SelectEvent_IsBase(true);
        vqcppolargraph->selectEvent(event, additive, *details, selectionStateChanged);
    } else {
        ((VirtualQCPPolarGraph*)self)->selectEvent(event, additive, *details, selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnSelectEvent(QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_SelectEvent_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_SelectEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseDeselectEvent(QCPPolarGraph* self, bool* selectionStateChanged) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_DeselectEvent_IsBase(true);
        vqcppolargraph->deselectEvent(selectionStateChanged);
    } else {
        ((VirtualQCPPolarGraph*)self)->deselectEvent(selectionStateChanged);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnDeselectEvent(QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_DeselectEvent_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_DeselectEvent_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseDrawLinePlot(const QCPPolarGraph* self, QCPPainter* painter, const libqt_list /* of QPointF* */ lines) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    QVector<QPointF> lines_QVector;
    lines_QVector.reserve(lines.len);
    QPointF** lines_arr = static_cast<QPointF**>(lines.data);
    for (size_t i = 0; i < lines.len; ++i) {
        lines_QVector.push_back(*(lines_arr[i]));
    }
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_DrawLinePlot_IsBase(true);
        vqcppolargraph->drawLinePlot(painter, lines_QVector);
    } else {
        ((VirtualQCPPolarGraph*)self)->drawLinePlot(painter, lines_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnDrawLinePlot(const QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_DrawLinePlot_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_DrawLinePlot_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseDrawFill(const QCPPolarGraph* self, QCPPainter* painter, libqt_list /* of QPointF* */ lines) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    QVector<QPointF> lines_QVector;
    lines_QVector.reserve(lines.len);
    QPointF** lines_arr = static_cast<QPointF**>(lines.data);
    for (size_t i = 0; i < lines.len; ++i) {
        lines_QVector.push_back(*(lines_arr[i]));
    }
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_DrawFill_IsBase(true);
        vqcppolargraph->drawFill(painter, &lines_QVector);
    } else {
        ((VirtualQCPPolarGraph*)self)->drawFill(painter, &lines_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnDrawFill(const QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_DrawFill_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_DrawFill_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseDrawScatterPlot(const QCPPolarGraph* self, QCPPainter* painter, const libqt_list /* of QPointF* */ scatters, const QCPScatterStyle* style) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    QVector<QPointF> scatters_QVector;
    scatters_QVector.reserve(scatters.len);
    QPointF** scatters_arr = static_cast<QPointF**>(scatters.data);
    for (size_t i = 0; i < scatters.len; ++i) {
        scatters_QVector.push_back(*(scatters_arr[i]));
    }
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_DrawScatterPlot_IsBase(true);
        vqcppolargraph->drawScatterPlot(painter, scatters_QVector, *style);
    } else {
        ((VirtualQCPPolarGraph*)self)->drawScatterPlot(painter, scatters_QVector, *style);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnDrawScatterPlot(const QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_DrawScatterPlot_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_DrawScatterPlot_Callback>(slot));
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseDrawLegendIcon(const QCPPolarGraph* self, QCPPainter* painter, const QRectF* rect) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_DrawLegendIcon_IsBase(true);
        vqcppolargraph->drawLegendIcon(painter, *rect);
    } else {
        ((VirtualQCPPolarGraph*)self)->drawLegendIcon(painter, *rect);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnDrawLegendIcon(const QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_DrawLegendIcon_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_DrawLegendIcon_Callback>(slot));
    }
}

// Base class handler implementation
int QCPPolarGraph_QBaseDataCount(const QCPPolarGraph* self) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_DataCount_IsBase(true);
        return vqcppolargraph->dataCount();
    } else {
        return ((VirtualQCPPolarGraph*)self)->dataCount();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnDataCount(const QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_DataCount_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_DataCount_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGraph_ParentPlotInitialized(QCPPolarGraph* self, QCustomPlot* parentPlot) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPPolarGraph*)self)->parentPlotInitialized(parentPlot);
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseParentPlotInitialized(QCPPolarGraph* self, QCustomPlot* parentPlot) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_ParentPlotInitialized_IsBase(true);
        vqcppolargraph->parentPlotInitialized(parentPlot);
    } else {
        ((VirtualQCPPolarGraph*)self)->parentPlotInitialized(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnParentPlotInitialized(QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_ParentPlotInitialized_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_ParentPlotInitialized_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGraph_ApplyDefaultAntialiasingHint(const QCPPolarGraph* self, QCPPainter* painter) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPPolarGraph*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseApplyDefaultAntialiasingHint(const QCPPolarGraph* self, QCPPainter* painter) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_ApplyDefaultAntialiasingHint_IsBase(true);
        vqcppolargraph->applyDefaultAntialiasingHint(painter);
    } else {
        ((VirtualQCPPolarGraph*)self)->applyDefaultAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnApplyDefaultAntialiasingHint(const QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_ApplyDefaultAntialiasingHint_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_ApplyDefaultAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGraph_MousePressEvent(QCPPolarGraph* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPPolarGraph*)self)->mousePressEvent(event, *details);
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseMousePressEvent(QCPPolarGraph* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_MousePressEvent_IsBase(true);
        vqcppolargraph->mousePressEvent(event, *details);
    } else {
        ((VirtualQCPPolarGraph*)self)->mousePressEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnMousePressEvent(QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_MousePressEvent_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_MousePressEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGraph_MouseMoveEvent(QCPPolarGraph* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPPolarGraph*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseMouseMoveEvent(QCPPolarGraph* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_MouseMoveEvent_IsBase(true);
        vqcppolargraph->mouseMoveEvent(event, *startPos);
    } else {
        ((VirtualQCPPolarGraph*)self)->mouseMoveEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnMouseMoveEvent(QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_MouseMoveEvent_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_MouseMoveEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGraph_MouseReleaseEvent(QCPPolarGraph* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPPolarGraph*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseMouseReleaseEvent(QCPPolarGraph* self, QMouseEvent* event, const QPointF* startPos) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_MouseReleaseEvent_IsBase(true);
        vqcppolargraph->mouseReleaseEvent(event, *startPos);
    } else {
        ((VirtualQCPPolarGraph*)self)->mouseReleaseEvent(event, *startPos);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnMouseReleaseEvent(QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_MouseReleaseEvent_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_MouseReleaseEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGraph_MouseDoubleClickEvent(QCPPolarGraph* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPPolarGraph*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseMouseDoubleClickEvent(QCPPolarGraph* self, QMouseEvent* event, const QVariant* details) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_MouseDoubleClickEvent_IsBase(true);
        vqcppolargraph->mouseDoubleClickEvent(event, *details);
    } else {
        ((VirtualQCPPolarGraph*)self)->mouseDoubleClickEvent(event, *details);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnMouseDoubleClickEvent(QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_MouseDoubleClickEvent_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_MouseDoubleClickEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGraph_WheelEvent(QCPPolarGraph* self, QWheelEvent* event) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->wheelEvent(event);
    } else {
        ((VirtualQCPPolarGraph*)self)->wheelEvent(event);
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseWheelEvent(QCPPolarGraph* self, QWheelEvent* event) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_WheelEvent_IsBase(true);
        vqcppolargraph->wheelEvent(event);
    } else {
        ((VirtualQCPPolarGraph*)self)->wheelEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnWheelEvent(QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_WheelEvent_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_WheelEvent_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPPolarGraph_Event(QCPPolarGraph* self, QEvent* event) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        return vqcppolargraph->event(event);
    } else {
        return self->QCPPolarGraph::event(event);
    }
}

// Base class handler implementation
bool QCPPolarGraph_QBaseEvent(QCPPolarGraph* self, QEvent* event) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_Event_IsBase(true);
        return vqcppolargraph->event(event);
    } else {
        return self->QCPPolarGraph::event(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnEvent(QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_Event_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_Event_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPPolarGraph_EventFilter(QCPPolarGraph* self, QObject* watched, QEvent* event) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        return vqcppolargraph->eventFilter(watched, event);
    } else {
        return self->QCPPolarGraph::eventFilter(watched, event);
    }
}

// Base class handler implementation
bool QCPPolarGraph_QBaseEventFilter(QCPPolarGraph* self, QObject* watched, QEvent* event) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_EventFilter_IsBase(true);
        return vqcppolargraph->eventFilter(watched, event);
    } else {
        return self->QCPPolarGraph::eventFilter(watched, event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnEventFilter(QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_EventFilter_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_EventFilter_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGraph_TimerEvent(QCPPolarGraph* self, QTimerEvent* event) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->timerEvent(event);
    } else {
        ((VirtualQCPPolarGraph*)self)->timerEvent(event);
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseTimerEvent(QCPPolarGraph* self, QTimerEvent* event) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_TimerEvent_IsBase(true);
        vqcppolargraph->timerEvent(event);
    } else {
        ((VirtualQCPPolarGraph*)self)->timerEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnTimerEvent(QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_TimerEvent_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_TimerEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGraph_ChildEvent(QCPPolarGraph* self, QChildEvent* event) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->childEvent(event);
    } else {
        ((VirtualQCPPolarGraph*)self)->childEvent(event);
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseChildEvent(QCPPolarGraph* self, QChildEvent* event) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_ChildEvent_IsBase(true);
        vqcppolargraph->childEvent(event);
    } else {
        ((VirtualQCPPolarGraph*)self)->childEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnChildEvent(QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_ChildEvent_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_ChildEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGraph_CustomEvent(QCPPolarGraph* self, QEvent* event) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->customEvent(event);
    } else {
        ((VirtualQCPPolarGraph*)self)->customEvent(event);
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseCustomEvent(QCPPolarGraph* self, QEvent* event) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_CustomEvent_IsBase(true);
        vqcppolargraph->customEvent(event);
    } else {
        ((VirtualQCPPolarGraph*)self)->customEvent(event);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnCustomEvent(QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_CustomEvent_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_CustomEvent_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGraph_ConnectNotify(QCPPolarGraph* self, const QMetaMethod* signal) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->connectNotify(*signal);
    } else {
        ((VirtualQCPPolarGraph*)self)->connectNotify(*signal);
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseConnectNotify(QCPPolarGraph* self, const QMetaMethod* signal) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_ConnectNotify_IsBase(true);
        vqcppolargraph->connectNotify(*signal);
    } else {
        ((VirtualQCPPolarGraph*)self)->connectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnConnectNotify(QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_ConnectNotify_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_ConnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGraph_DisconnectNotify(QCPPolarGraph* self, const QMetaMethod* signal) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->disconnectNotify(*signal);
    } else {
        ((VirtualQCPPolarGraph*)self)->disconnectNotify(*signal);
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseDisconnectNotify(QCPPolarGraph* self, const QMetaMethod* signal) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_DisconnectNotify_IsBase(true);
        vqcppolargraph->disconnectNotify(*signal);
    } else {
        ((VirtualQCPPolarGraph*)self)->disconnectNotify(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnDisconnectNotify(QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_DisconnectNotify_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_DisconnectNotify_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGraph_ApplyFillAntialiasingHint(const QCPPolarGraph* self, QCPPainter* painter) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->applyFillAntialiasingHint(painter);
    } else {
        ((VirtualQCPPolarGraph*)self)->applyFillAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseApplyFillAntialiasingHint(const QCPPolarGraph* self, QCPPainter* painter) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_ApplyFillAntialiasingHint_IsBase(true);
        vqcppolargraph->applyFillAntialiasingHint(painter);
    } else {
        ((VirtualQCPPolarGraph*)self)->applyFillAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnApplyFillAntialiasingHint(const QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_ApplyFillAntialiasingHint_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_ApplyFillAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGraph_ApplyScattersAntialiasingHint(const QCPPolarGraph* self, QCPPainter* painter) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->applyScattersAntialiasingHint(painter);
    } else {
        ((VirtualQCPPolarGraph*)self)->applyScattersAntialiasingHint(painter);
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseApplyScattersAntialiasingHint(const QCPPolarGraph* self, QCPPainter* painter) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_ApplyScattersAntialiasingHint_IsBase(true);
        vqcppolargraph->applyScattersAntialiasingHint(painter);
    } else {
        ((VirtualQCPPolarGraph*)self)->applyScattersAntialiasingHint(painter);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnApplyScattersAntialiasingHint(const QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_ApplyScattersAntialiasingHint_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_ApplyScattersAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGraph_GetDataSegments(const QCPPolarGraph* self, libqt_list /* of QCPDataRange* */ selectedSegments, libqt_list /* of QCPDataRange* */ unselectedSegments) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    QList<QCPDataRange> selectedSegments_QList;
    selectedSegments_QList.reserve(selectedSegments.len);
    QCPDataRange** selectedSegments_arr = static_cast<QCPDataRange**>(selectedSegments.data);
    for (size_t i = 0; i < selectedSegments.len; ++i) {
        selectedSegments_QList.push_back(*(selectedSegments_arr[i]));
    }
    QList<QCPDataRange> unselectedSegments_QList;
    unselectedSegments_QList.reserve(unselectedSegments.len);
    QCPDataRange** unselectedSegments_arr = static_cast<QCPDataRange**>(unselectedSegments.data);
    for (size_t i = 0; i < unselectedSegments.len; ++i) {
        unselectedSegments_QList.push_back(*(unselectedSegments_arr[i]));
    }
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->getDataSegments(selectedSegments_QList, unselectedSegments_QList);
    } else {
        ((VirtualQCPPolarGraph*)self)->getDataSegments(selectedSegments_QList, unselectedSegments_QList);
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseGetDataSegments(const QCPPolarGraph* self, libqt_list /* of QCPDataRange* */ selectedSegments, libqt_list /* of QCPDataRange* */ unselectedSegments) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    QList<QCPDataRange> selectedSegments_QList;
    selectedSegments_QList.reserve(selectedSegments.len);
    QCPDataRange** selectedSegments_arr = static_cast<QCPDataRange**>(selectedSegments.data);
    for (size_t i = 0; i < selectedSegments.len; ++i) {
        selectedSegments_QList.push_back(*(selectedSegments_arr[i]));
    }
    QList<QCPDataRange> unselectedSegments_QList;
    unselectedSegments_QList.reserve(unselectedSegments.len);
    QCPDataRange** unselectedSegments_arr = static_cast<QCPDataRange**>(unselectedSegments.data);
    for (size_t i = 0; i < unselectedSegments.len; ++i) {
        unselectedSegments_QList.push_back(*(unselectedSegments_arr[i]));
    }
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_GetDataSegments_IsBase(true);
        vqcppolargraph->getDataSegments(selectedSegments_QList, unselectedSegments_QList);
    } else {
        ((VirtualQCPPolarGraph*)self)->getDataSegments(selectedSegments_QList, unselectedSegments_QList);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnGetDataSegments(const QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_GetDataSegments_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_GetDataSegments_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGraph_DrawPolyline(const QCPPolarGraph* self, QCPPainter* painter, const libqt_list /* of QPointF* */ lineData) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    QVector<QPointF> lineData_QVector;
    lineData_QVector.reserve(lineData.len);
    QPointF** lineData_arr = static_cast<QPointF**>(lineData.data);
    for (size_t i = 0; i < lineData.len; ++i) {
        lineData_QVector.push_back(*(lineData_arr[i]));
    }
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->drawPolyline(painter, lineData_QVector);
    } else {
        ((VirtualQCPPolarGraph*)self)->drawPolyline(painter, lineData_QVector);
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseDrawPolyline(const QCPPolarGraph* self, QCPPainter* painter, const libqt_list /* of QPointF* */ lineData) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    QVector<QPointF> lineData_QVector;
    lineData_QVector.reserve(lineData.len);
    QPointF** lineData_arr = static_cast<QPointF**>(lineData.data);
    for (size_t i = 0; i < lineData.len; ++i) {
        lineData_QVector.push_back(*(lineData_arr[i]));
    }
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_DrawPolyline_IsBase(true);
        vqcppolargraph->drawPolyline(painter, lineData_QVector);
    } else {
        ((VirtualQCPPolarGraph*)self)->drawPolyline(painter, lineData_QVector);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnDrawPolyline(const QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_DrawPolyline_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_DrawPolyline_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGraph_GetLines(const QCPPolarGraph* self, libqt_list /* of QPointF* */ lines, const QCPDataRange* dataRange) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    QVector<QPointF> lines_QVector;
    lines_QVector.reserve(lines.len);
    QPointF** lines_arr = static_cast<QPointF**>(lines.data);
    for (size_t i = 0; i < lines.len; ++i) {
        lines_QVector.push_back(*(lines_arr[i]));
    }
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->getLines(&lines_QVector, *dataRange);
    } else {
        ((VirtualQCPPolarGraph*)self)->getLines(&lines_QVector, *dataRange);
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseGetLines(const QCPPolarGraph* self, libqt_list /* of QPointF* */ lines, const QCPDataRange* dataRange) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    QVector<QPointF> lines_QVector;
    lines_QVector.reserve(lines.len);
    QPointF** lines_arr = static_cast<QPointF**>(lines.data);
    for (size_t i = 0; i < lines.len; ++i) {
        lines_QVector.push_back(*(lines_arr[i]));
    }
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_GetLines_IsBase(true);
        vqcppolargraph->getLines(&lines_QVector, *dataRange);
    } else {
        ((VirtualQCPPolarGraph*)self)->getLines(&lines_QVector, *dataRange);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnGetLines(const QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_GetLines_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_GetLines_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGraph_GetScatters(const QCPPolarGraph* self, libqt_list /* of QPointF* */ scatters, const QCPDataRange* dataRange) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    QVector<QPointF> scatters_QVector;
    scatters_QVector.reserve(scatters.len);
    QPointF** scatters_arr = static_cast<QPointF**>(scatters.data);
    for (size_t i = 0; i < scatters.len; ++i) {
        scatters_QVector.push_back(*(scatters_arr[i]));
    }
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->getScatters(&scatters_QVector, *dataRange);
    } else {
        ((VirtualQCPPolarGraph*)self)->getScatters(&scatters_QVector, *dataRange);
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseGetScatters(const QCPPolarGraph* self, libqt_list /* of QPointF* */ scatters, const QCPDataRange* dataRange) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    QVector<QPointF> scatters_QVector;
    scatters_QVector.reserve(scatters.len);
    QPointF** scatters_arr = static_cast<QPointF**>(scatters.data);
    for (size_t i = 0; i < scatters.len; ++i) {
        scatters_QVector.push_back(*(scatters_arr[i]));
    }
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_GetScatters_IsBase(true);
        vqcppolargraph->getScatters(&scatters_QVector, *dataRange);
    } else {
        ((VirtualQCPPolarGraph*)self)->getScatters(&scatters_QVector, *dataRange);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnGetScatters(const QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_GetScatters_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_GetScatters_Callback>(slot));
    }
}

// Derived class handler implementation
libqt_list /* of QPointF* */ QCPPolarGraph_DataToLines(const QCPPolarGraph* self, const libqt_list /* of QCPGraphData* */ data) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    QVector<QCPGraphData> data_QVector;
    data_QVector.reserve(data.len);
    QCPGraphData** data_arr = static_cast<QCPGraphData**>(data.data);
    for (size_t i = 0; i < data.len; ++i) {
        data_QVector.push_back(*(data_arr[i]));
    }
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        QVector<QPointF> _ret = vqcppolargraph->dataToLines(data_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QPointF> _ret = ((VirtualQCPPolarGraph*)self)->dataToLines(data_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Base class handler implementation
libqt_list /* of QPointF* */ QCPPolarGraph_QBaseDataToLines(const QCPPolarGraph* self, const libqt_list /* of QCPGraphData* */ data) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    QVector<QCPGraphData> data_QVector;
    data_QVector.reserve(data.len);
    QCPGraphData** data_arr = static_cast<QCPGraphData**>(data.data);
    for (size_t i = 0; i < data.len; ++i) {
        data_QVector.push_back(*(data_arr[i]));
    }
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_DataToLines_IsBase(true);
        QVector<QPointF> _ret = vqcppolargraph->dataToLines(data_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    } else {
        QVector<QPointF> _ret = ((VirtualQCPPolarGraph*)self)->dataToLines(data_QVector);
        // Convert QVector<> from C++ memory to manually-managed C memory
        QPointF** _arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (_ret.size() + 1)));
        for (qsizetype i = 0; i < _ret.size(); ++i) {
            _arr[i] = new QPointF(_ret[i]);
        }
        libqt_list _out;
        _out.len = _ret.size();
        _out.data = static_cast<void*>(_arr);
        return _out;
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnDataToLines(const QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_DataToLines_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_DataToLines_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGraph_InitializeParentPlot(QCPPolarGraph* self, QCustomPlot* parentPlot) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPPolarGraph*)self)->initializeParentPlot(parentPlot);
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseInitializeParentPlot(QCPPolarGraph* self, QCustomPlot* parentPlot) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_InitializeParentPlot_IsBase(true);
        vqcppolargraph->initializeParentPlot(parentPlot);
    } else {
        ((VirtualQCPPolarGraph*)self)->initializeParentPlot(parentPlot);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnInitializeParentPlot(QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_InitializeParentPlot_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_InitializeParentPlot_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGraph_SetParentLayerable(QCPPolarGraph* self, QCPLayerable* parentLayerable) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPPolarGraph*)self)->setParentLayerable(parentLayerable);
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseSetParentLayerable(QCPPolarGraph* self, QCPLayerable* parentLayerable) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_SetParentLayerable_IsBase(true);
        vqcppolargraph->setParentLayerable(parentLayerable);
    } else {
        ((VirtualQCPPolarGraph*)self)->setParentLayerable(parentLayerable);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnSetParentLayerable(QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_SetParentLayerable_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_SetParentLayerable_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPPolarGraph_MoveToLayer(QCPPolarGraph* self, QCPLayer* layer, bool prepend) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        return vqcppolargraph->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPPolarGraph*)self)->moveToLayer(layer, prepend);
    }
}

// Base class handler implementation
bool QCPPolarGraph_QBaseMoveToLayer(QCPPolarGraph* self, QCPLayer* layer, bool prepend) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_MoveToLayer_IsBase(true);
        return vqcppolargraph->moveToLayer(layer, prepend);
    } else {
        return ((VirtualQCPPolarGraph*)self)->moveToLayer(layer, prepend);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnMoveToLayer(QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = dynamic_cast<VirtualQCPPolarGraph*>(self);
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_MoveToLayer_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_MoveToLayer_Callback>(slot));
    }
}

// Derived class handler implementation
void QCPPolarGraph_ApplyAntialiasingHint(const QCPPolarGraph* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPPolarGraph*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Base class handler implementation
void QCPPolarGraph_QBaseApplyAntialiasingHint(const QCPPolarGraph* self, QCPPainter* painter, bool localAntialiased, int overrideElement) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_ApplyAntialiasingHint_IsBase(true);
        vqcppolargraph->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    } else {
        ((VirtualQCPPolarGraph*)self)->applyAntialiasingHint(painter, localAntialiased, static_cast<QCP::AntialiasedElement>(overrideElement));
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnApplyAntialiasingHint(const QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_ApplyAntialiasingHint_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_ApplyAntialiasingHint_Callback>(slot));
    }
}

// Derived class handler implementation
QObject* QCPPolarGraph_Sender(const QCPPolarGraph* self) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        return vqcppolargraph->sender();
    } else {
        return ((VirtualQCPPolarGraph*)self)->sender();
    }
}

// Base class handler implementation
QObject* QCPPolarGraph_QBaseSender(const QCPPolarGraph* self) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_Sender_IsBase(true);
        return vqcppolargraph->sender();
    } else {
        return ((VirtualQCPPolarGraph*)self)->sender();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnSender(const QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_Sender_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_Sender_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPPolarGraph_SenderSignalIndex(const QCPPolarGraph* self) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        return vqcppolargraph->senderSignalIndex();
    } else {
        return ((VirtualQCPPolarGraph*)self)->senderSignalIndex();
    }
}

// Base class handler implementation
int QCPPolarGraph_QBaseSenderSignalIndex(const QCPPolarGraph* self) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_SenderSignalIndex_IsBase(true);
        return vqcppolargraph->senderSignalIndex();
    } else {
        return ((VirtualQCPPolarGraph*)self)->senderSignalIndex();
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnSenderSignalIndex(const QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_SenderSignalIndex_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_SenderSignalIndex_Callback>(slot));
    }
}

// Derived class handler implementation
int QCPPolarGraph_Receivers(const QCPPolarGraph* self, const char* signal) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        return vqcppolargraph->receivers(signal);
    } else {
        return ((VirtualQCPPolarGraph*)self)->receivers(signal);
    }
}

// Base class handler implementation
int QCPPolarGraph_QBaseReceivers(const QCPPolarGraph* self, const char* signal) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_Receivers_IsBase(true);
        return vqcppolargraph->receivers(signal);
    } else {
        return ((VirtualQCPPolarGraph*)self)->receivers(signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnReceivers(const QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_Receivers_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_Receivers_Callback>(slot));
    }
}

// Derived class handler implementation
bool QCPPolarGraph_IsSignalConnected(const QCPPolarGraph* self, const QMetaMethod* signal) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        return vqcppolargraph->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPPolarGraph*)self)->isSignalConnected(*signal);
    }
}

// Base class handler implementation
bool QCPPolarGraph_QBaseIsSignalConnected(const QCPPolarGraph* self, const QMetaMethod* signal) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_IsSignalConnected_IsBase(true);
        return vqcppolargraph->isSignalConnected(*signal);
    } else {
        return ((VirtualQCPPolarGraph*)self)->isSignalConnected(*signal);
    }
}

// Auxiliary method to allow providing re-implementation
void QCPPolarGraph_OnIsSignalConnected(const QCPPolarGraph* self, intptr_t slot) {
    auto* vqcppolargraph = const_cast<VirtualQCPPolarGraph*>(dynamic_cast<const VirtualQCPPolarGraph*>(self));
    if (vqcppolargraph && vqcppolargraph->isVirtualQCPPolarGraph) {
        vqcppolargraph->setQCPPolarGraph_IsSignalConnected_Callback(reinterpret_cast<VirtualQCPPolarGraph::QCPPolarGraph_IsSignalConnected_Callback>(slot));
    }
}

void QCPPolarGraph_Delete(QCPPolarGraph* self) {
    delete self;
}
