#pragma once
#ifndef SRC_RESTRICTED_EXTRAS_QCUSTOMPLOTC_LIBVIRTUALQCUSTOMPLOT_H
#define SRC_RESTRICTED_EXTRAS_QCUSTOMPLOTC_LIBVIRTUALQCUSTOMPLOT_H

#include <stdbool.h>
#include <stddef.h>

#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#include "../qtlibc.h"

// This class is a subclass of QCPAbstractPaintBuffer so that we can call protected methods
class VirtualQCPAbstractPaintBuffer : public QCPAbstractPaintBuffer {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPAbstractPaintBuffer = true;

    // Virtual class public types (including callbacks)
    using QCPAbstractPaintBuffer_StartPainting_Callback = QCPPainter* (*)();
    using QCPAbstractPaintBuffer_DonePainting_Callback = void (*)();
    using QCPAbstractPaintBuffer_Draw_Callback = void (*)(const QCPAbstractPaintBuffer*, QCPPainter*);
    using QCPAbstractPaintBuffer_Clear_Callback = void (*)(QCPAbstractPaintBuffer*, QColor*);
    using QCPAbstractPaintBuffer_ReallocateBuffer_Callback = void (*)();
    using QCPAbstractPaintBuffer_OperatorAssign_Callback = void (*)(QCPAbstractPaintBuffer*, QCPAbstractPaintBuffer*);

  protected:
    // Instance callback storage
    QCPAbstractPaintBuffer_StartPainting_Callback qcpabstractpaintbuffer_startpainting_callback = nullptr;
    QCPAbstractPaintBuffer_DonePainting_Callback qcpabstractpaintbuffer_donepainting_callback = nullptr;
    QCPAbstractPaintBuffer_Draw_Callback qcpabstractpaintbuffer_draw_callback = nullptr;
    QCPAbstractPaintBuffer_Clear_Callback qcpabstractpaintbuffer_clear_callback = nullptr;
    QCPAbstractPaintBuffer_ReallocateBuffer_Callback qcpabstractpaintbuffer_reallocatebuffer_callback = nullptr;
    QCPAbstractPaintBuffer_OperatorAssign_Callback qcpabstractpaintbuffer_operatorassign_callback = nullptr;

    // Instance base flags
    mutable bool qcpabstractpaintbuffer_startpainting_isbase = false;
    mutable bool qcpabstractpaintbuffer_donepainting_isbase = false;
    mutable bool qcpabstractpaintbuffer_draw_isbase = false;
    mutable bool qcpabstractpaintbuffer_clear_isbase = false;
    mutable bool qcpabstractpaintbuffer_reallocatebuffer_isbase = false;
    mutable bool qcpabstractpaintbuffer_operatorassign_isbase = false;

  public:
    VirtualQCPAbstractPaintBuffer(const QSize& size, double devicePixelRatio) : QCPAbstractPaintBuffer(size, devicePixelRatio) {};
    VirtualQCPAbstractPaintBuffer(const QCPAbstractPaintBuffer& param1) : QCPAbstractPaintBuffer(param1) {};

    ~VirtualQCPAbstractPaintBuffer() {
        qcpabstractpaintbuffer_startpainting_callback = nullptr;
        qcpabstractpaintbuffer_donepainting_callback = nullptr;
        qcpabstractpaintbuffer_draw_callback = nullptr;
        qcpabstractpaintbuffer_clear_callback = nullptr;
        qcpabstractpaintbuffer_reallocatebuffer_callback = nullptr;
        qcpabstractpaintbuffer_operatorassign_callback = nullptr;
    }

    // Callback setters
    inline void setQCPAbstractPaintBuffer_StartPainting_Callback(QCPAbstractPaintBuffer_StartPainting_Callback cb) { qcpabstractpaintbuffer_startpainting_callback = cb; }
    inline void setQCPAbstractPaintBuffer_DonePainting_Callback(QCPAbstractPaintBuffer_DonePainting_Callback cb) { qcpabstractpaintbuffer_donepainting_callback = cb; }
    inline void setQCPAbstractPaintBuffer_Draw_Callback(QCPAbstractPaintBuffer_Draw_Callback cb) { qcpabstractpaintbuffer_draw_callback = cb; }
    inline void setQCPAbstractPaintBuffer_Clear_Callback(QCPAbstractPaintBuffer_Clear_Callback cb) { qcpabstractpaintbuffer_clear_callback = cb; }
    inline void setQCPAbstractPaintBuffer_ReallocateBuffer_Callback(QCPAbstractPaintBuffer_ReallocateBuffer_Callback cb) { qcpabstractpaintbuffer_reallocatebuffer_callback = cb; }
    inline void setQCPAbstractPaintBuffer_OperatorAssign_Callback(QCPAbstractPaintBuffer_OperatorAssign_Callback cb) { qcpabstractpaintbuffer_operatorassign_callback = cb; }

    // Base flag setters
    inline void setQCPAbstractPaintBuffer_StartPainting_IsBase(bool value) const { qcpabstractpaintbuffer_startpainting_isbase = value; }
    inline void setQCPAbstractPaintBuffer_DonePainting_IsBase(bool value) const { qcpabstractpaintbuffer_donepainting_isbase = value; }
    inline void setQCPAbstractPaintBuffer_Draw_IsBase(bool value) const { qcpabstractpaintbuffer_draw_isbase = value; }
    inline void setQCPAbstractPaintBuffer_Clear_IsBase(bool value) const { qcpabstractpaintbuffer_clear_isbase = value; }
    inline void setQCPAbstractPaintBuffer_ReallocateBuffer_IsBase(bool value) const { qcpabstractpaintbuffer_reallocatebuffer_isbase = value; }
    inline void setQCPAbstractPaintBuffer_OperatorAssign_IsBase(bool value) const { qcpabstractpaintbuffer_operatorassign_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual QCPPainter* startPainting() override {
        if (qcpabstractpaintbuffer_startpainting_callback != nullptr) {
            QCPPainter* callback_ret = qcpabstractpaintbuffer_startpainting_callback();
            return callback_ret;
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void donePainting() override {
        if (qcpabstractpaintbuffer_donepainting_isbase) {
            qcpabstractpaintbuffer_donepainting_isbase = false;
            QCPAbstractPaintBuffer::donePainting();
        } else if (qcpabstractpaintbuffer_donepainting_callback != nullptr) {
            qcpabstractpaintbuffer_donepainting_callback();
        } else {
            QCPAbstractPaintBuffer::donePainting();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) const override {
        if (qcpabstractpaintbuffer_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpabstractpaintbuffer_draw_callback(this, cbval1);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void clear(const QColor& color) override {
        if (qcpabstractpaintbuffer_clear_callback != nullptr) {
            const QColor& color_ret = color;
            // Cast returned reference into pointer
            QColor* cbval1 = const_cast<QColor*>(&color_ret);

            qcpabstractpaintbuffer_clear_callback(this, cbval1);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void reallocateBuffer() override {
        if (qcpabstractpaintbuffer_reallocatebuffer_callback != nullptr) {
            qcpabstractpaintbuffer_reallocatebuffer_callback();
        }
    }

    // Virtual method for C ABI access and custom callback
    void operator=(const QCPAbstractPaintBuffer& param1) {
        if (qcpabstractpaintbuffer_operatorassign_isbase) {
            qcpabstractpaintbuffer_operatorassign_isbase = false;
            QCPAbstractPaintBuffer::operator=(param1);
        } else if (qcpabstractpaintbuffer_operatorassign_callback != nullptr) {
            const QCPAbstractPaintBuffer& param1_ret = param1;
            // Cast returned reference into pointer
            QCPAbstractPaintBuffer* cbval1 = const_cast<QCPAbstractPaintBuffer*>(&param1_ret);

            qcpabstractpaintbuffer_operatorassign_callback(this, cbval1);
        } else {
            QCPAbstractPaintBuffer::operator=(param1);
        }
    }

    // Friend functions
    friend void QCPAbstractPaintBuffer_ReallocateBuffer(QCPAbstractPaintBuffer* self);
    friend void QCPAbstractPaintBuffer_QBaseReallocateBuffer(QCPAbstractPaintBuffer* self);
    friend void QCPAbstractPaintBuffer_OperatorAssign(QCPAbstractPaintBuffer* self, const QCPAbstractPaintBuffer* param1);
    friend void QCPAbstractPaintBuffer_QBaseOperatorAssign(QCPAbstractPaintBuffer* self, const QCPAbstractPaintBuffer* param1);
};

// This class is a subclass of QCPPaintBufferPixmap so that we can call protected methods
class VirtualQCPPaintBufferPixmap final : public QCPPaintBufferPixmap {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPPaintBufferPixmap = true;

    // Virtual class public types (including callbacks)
    using QCPPaintBufferPixmap_StartPainting_Callback = QCPPainter* (*)();
    using QCPPaintBufferPixmap_Draw_Callback = void (*)(const QCPPaintBufferPixmap*, QCPPainter*);
    using QCPPaintBufferPixmap_Clear_Callback = void (*)(QCPPaintBufferPixmap*, QColor*);
    using QCPPaintBufferPixmap_ReallocateBuffer_Callback = void (*)();
    using QCPPaintBufferPixmap_DonePainting_Callback = void (*)();
    using QCPPaintBufferPixmap_OperatorAssign_Callback = void (*)(QCPPaintBufferPixmap*, QCPPaintBufferPixmap*);

  protected:
    // Instance callback storage
    QCPPaintBufferPixmap_StartPainting_Callback qcppaintbufferpixmap_startpainting_callback = nullptr;
    QCPPaintBufferPixmap_Draw_Callback qcppaintbufferpixmap_draw_callback = nullptr;
    QCPPaintBufferPixmap_Clear_Callback qcppaintbufferpixmap_clear_callback = nullptr;
    QCPPaintBufferPixmap_ReallocateBuffer_Callback qcppaintbufferpixmap_reallocatebuffer_callback = nullptr;
    QCPPaintBufferPixmap_DonePainting_Callback qcppaintbufferpixmap_donepainting_callback = nullptr;
    QCPPaintBufferPixmap_OperatorAssign_Callback qcppaintbufferpixmap_operatorassign_callback = nullptr;

    // Instance base flags
    mutable bool qcppaintbufferpixmap_startpainting_isbase = false;
    mutable bool qcppaintbufferpixmap_draw_isbase = false;
    mutable bool qcppaintbufferpixmap_clear_isbase = false;
    mutable bool qcppaintbufferpixmap_reallocatebuffer_isbase = false;
    mutable bool qcppaintbufferpixmap_donepainting_isbase = false;
    mutable bool qcppaintbufferpixmap_operatorassign_isbase = false;

  public:
    VirtualQCPPaintBufferPixmap(const QSize& size, double devicePixelRatio) : QCPPaintBufferPixmap(size, devicePixelRatio) {};
    VirtualQCPPaintBufferPixmap(const QCPPaintBufferPixmap& param1) : QCPPaintBufferPixmap(param1) {};

    ~VirtualQCPPaintBufferPixmap() {
        qcppaintbufferpixmap_startpainting_callback = nullptr;
        qcppaintbufferpixmap_draw_callback = nullptr;
        qcppaintbufferpixmap_clear_callback = nullptr;
        qcppaintbufferpixmap_reallocatebuffer_callback = nullptr;
        qcppaintbufferpixmap_donepainting_callback = nullptr;
        qcppaintbufferpixmap_operatorassign_callback = nullptr;
    }

    // Callback setters
    inline void setQCPPaintBufferPixmap_StartPainting_Callback(QCPPaintBufferPixmap_StartPainting_Callback cb) { qcppaintbufferpixmap_startpainting_callback = cb; }
    inline void setQCPPaintBufferPixmap_Draw_Callback(QCPPaintBufferPixmap_Draw_Callback cb) { qcppaintbufferpixmap_draw_callback = cb; }
    inline void setQCPPaintBufferPixmap_Clear_Callback(QCPPaintBufferPixmap_Clear_Callback cb) { qcppaintbufferpixmap_clear_callback = cb; }
    inline void setQCPPaintBufferPixmap_ReallocateBuffer_Callback(QCPPaintBufferPixmap_ReallocateBuffer_Callback cb) { qcppaintbufferpixmap_reallocatebuffer_callback = cb; }
    inline void setQCPPaintBufferPixmap_DonePainting_Callback(QCPPaintBufferPixmap_DonePainting_Callback cb) { qcppaintbufferpixmap_donepainting_callback = cb; }
    inline void setQCPPaintBufferPixmap_OperatorAssign_Callback(QCPPaintBufferPixmap_OperatorAssign_Callback cb) { qcppaintbufferpixmap_operatorassign_callback = cb; }

    // Base flag setters
    inline void setQCPPaintBufferPixmap_StartPainting_IsBase(bool value) const { qcppaintbufferpixmap_startpainting_isbase = value; }
    inline void setQCPPaintBufferPixmap_Draw_IsBase(bool value) const { qcppaintbufferpixmap_draw_isbase = value; }
    inline void setQCPPaintBufferPixmap_Clear_IsBase(bool value) const { qcppaintbufferpixmap_clear_isbase = value; }
    inline void setQCPPaintBufferPixmap_ReallocateBuffer_IsBase(bool value) const { qcppaintbufferpixmap_reallocatebuffer_isbase = value; }
    inline void setQCPPaintBufferPixmap_DonePainting_IsBase(bool value) const { qcppaintbufferpixmap_donepainting_isbase = value; }
    inline void setQCPPaintBufferPixmap_OperatorAssign_IsBase(bool value) const { qcppaintbufferpixmap_operatorassign_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual QCPPainter* startPainting() override {
        if (qcppaintbufferpixmap_startpainting_isbase) {
            qcppaintbufferpixmap_startpainting_isbase = false;
            return QCPPaintBufferPixmap::startPainting();
        } else if (qcppaintbufferpixmap_startpainting_callback != nullptr) {
            QCPPainter* callback_ret = qcppaintbufferpixmap_startpainting_callback();
            return callback_ret;
        } else {
            return QCPPaintBufferPixmap::startPainting();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) const override {
        if (qcppaintbufferpixmap_draw_isbase) {
            qcppaintbufferpixmap_draw_isbase = false;
            QCPPaintBufferPixmap::draw(painter);
        } else if (qcppaintbufferpixmap_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcppaintbufferpixmap_draw_callback(this, cbval1);
        } else {
            QCPPaintBufferPixmap::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void clear(const QColor& color) override {
        if (qcppaintbufferpixmap_clear_isbase) {
            qcppaintbufferpixmap_clear_isbase = false;
            QCPPaintBufferPixmap::clear(color);
        } else if (qcppaintbufferpixmap_clear_callback != nullptr) {
            const QColor& color_ret = color;
            // Cast returned reference into pointer
            QColor* cbval1 = const_cast<QColor*>(&color_ret);

            qcppaintbufferpixmap_clear_callback(this, cbval1);
        } else {
            QCPPaintBufferPixmap::clear(color);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void reallocateBuffer() override {
        if (qcppaintbufferpixmap_reallocatebuffer_isbase) {
            qcppaintbufferpixmap_reallocatebuffer_isbase = false;
            QCPPaintBufferPixmap::reallocateBuffer();
        } else if (qcppaintbufferpixmap_reallocatebuffer_callback != nullptr) {
            qcppaintbufferpixmap_reallocatebuffer_callback();
        } else {
            QCPPaintBufferPixmap::reallocateBuffer();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void donePainting() override {
        if (qcppaintbufferpixmap_donepainting_isbase) {
            qcppaintbufferpixmap_donepainting_isbase = false;
            QCPPaintBufferPixmap::donePainting();
        } else if (qcppaintbufferpixmap_donepainting_callback != nullptr) {
            qcppaintbufferpixmap_donepainting_callback();
        } else {
            QCPPaintBufferPixmap::donePainting();
        }
    }

    // Virtual method for C ABI access and custom callback
    void operator=(const QCPPaintBufferPixmap& param1) {
        if (qcppaintbufferpixmap_operatorassign_isbase) {
            qcppaintbufferpixmap_operatorassign_isbase = false;
            QCPPaintBufferPixmap::operator=(param1);
        } else if (qcppaintbufferpixmap_operatorassign_callback != nullptr) {
            const QCPPaintBufferPixmap& param1_ret = param1;
            // Cast returned reference into pointer
            QCPPaintBufferPixmap* cbval1 = const_cast<QCPPaintBufferPixmap*>(&param1_ret);

            qcppaintbufferpixmap_operatorassign_callback(this, cbval1);
        } else {
            QCPPaintBufferPixmap::operator=(param1);
        }
    }

    // Friend functions
    friend void QCPPaintBufferPixmap_ReallocateBuffer(QCPPaintBufferPixmap* self);
    friend void QCPPaintBufferPixmap_QBaseReallocateBuffer(QCPPaintBufferPixmap* self);
    friend void QCPPaintBufferPixmap_OperatorAssign(QCPPaintBufferPixmap* self, const QCPPaintBufferPixmap* param1);
    friend void QCPPaintBufferPixmap_QBaseOperatorAssign(QCPPaintBufferPixmap* self, const QCPPaintBufferPixmap* param1);
};

// This class is a subclass of QCPLayer so that we can call protected methods
class VirtualQCPLayer final : public QCPLayer {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPLayer = true;

    // Virtual class public types (including callbacks)
    using QCPLayer_Metacall_Callback = int (*)(QCPLayer*, int, int, void**);
    using QCPLayer_Event_Callback = bool (*)(QCPLayer*, QEvent*);
    using QCPLayer_EventFilter_Callback = bool (*)(QCPLayer*, QObject*, QEvent*);
    using QCPLayer_TimerEvent_Callback = void (*)(QCPLayer*, QTimerEvent*);
    using QCPLayer_ChildEvent_Callback = void (*)(QCPLayer*, QChildEvent*);
    using QCPLayer_CustomEvent_Callback = void (*)(QCPLayer*, QEvent*);
    using QCPLayer_ConnectNotify_Callback = void (*)(QCPLayer*, QMetaMethod*);
    using QCPLayer_DisconnectNotify_Callback = void (*)(QCPLayer*, QMetaMethod*);
    using QCPLayer_Draw_Callback = void (*)(QCPLayer*, QCPPainter*);
    using QCPLayer_DrawToPaintBuffer_Callback = void (*)();
    using QCPLayer_AddChild_Callback = void (*)(QCPLayer*, QCPLayerable*, bool);
    using QCPLayer_RemoveChild_Callback = void (*)(QCPLayer*, QCPLayerable*);
    using QCPLayer_Sender_Callback = QObject* (*)();
    using QCPLayer_SenderSignalIndex_Callback = int (*)();
    using QCPLayer_Receivers_Callback = int (*)(const QCPLayer*, const char*);
    using QCPLayer_IsSignalConnected_Callback = bool (*)(const QCPLayer*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPLayer_Metacall_Callback qcplayer_metacall_callback = nullptr;
    QCPLayer_Event_Callback qcplayer_event_callback = nullptr;
    QCPLayer_EventFilter_Callback qcplayer_eventfilter_callback = nullptr;
    QCPLayer_TimerEvent_Callback qcplayer_timerevent_callback = nullptr;
    QCPLayer_ChildEvent_Callback qcplayer_childevent_callback = nullptr;
    QCPLayer_CustomEvent_Callback qcplayer_customevent_callback = nullptr;
    QCPLayer_ConnectNotify_Callback qcplayer_connectnotify_callback = nullptr;
    QCPLayer_DisconnectNotify_Callback qcplayer_disconnectnotify_callback = nullptr;
    QCPLayer_Draw_Callback qcplayer_draw_callback = nullptr;
    QCPLayer_DrawToPaintBuffer_Callback qcplayer_drawtopaintbuffer_callback = nullptr;
    QCPLayer_AddChild_Callback qcplayer_addchild_callback = nullptr;
    QCPLayer_RemoveChild_Callback qcplayer_removechild_callback = nullptr;
    QCPLayer_Sender_Callback qcplayer_sender_callback = nullptr;
    QCPLayer_SenderSignalIndex_Callback qcplayer_sendersignalindex_callback = nullptr;
    QCPLayer_Receivers_Callback qcplayer_receivers_callback = nullptr;
    QCPLayer_IsSignalConnected_Callback qcplayer_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcplayer_metacall_isbase = false;
    mutable bool qcplayer_event_isbase = false;
    mutable bool qcplayer_eventfilter_isbase = false;
    mutable bool qcplayer_timerevent_isbase = false;
    mutable bool qcplayer_childevent_isbase = false;
    mutable bool qcplayer_customevent_isbase = false;
    mutable bool qcplayer_connectnotify_isbase = false;
    mutable bool qcplayer_disconnectnotify_isbase = false;
    mutable bool qcplayer_draw_isbase = false;
    mutable bool qcplayer_drawtopaintbuffer_isbase = false;
    mutable bool qcplayer_addchild_isbase = false;
    mutable bool qcplayer_removechild_isbase = false;
    mutable bool qcplayer_sender_isbase = false;
    mutable bool qcplayer_sendersignalindex_isbase = false;
    mutable bool qcplayer_receivers_isbase = false;
    mutable bool qcplayer_issignalconnected_isbase = false;

  public:
    VirtualQCPLayer(QCustomPlot* parentPlot, const QString& layerName) : QCPLayer(parentPlot, layerName) {};

    ~VirtualQCPLayer() {
        qcplayer_metacall_callback = nullptr;
        qcplayer_event_callback = nullptr;
        qcplayer_eventfilter_callback = nullptr;
        qcplayer_timerevent_callback = nullptr;
        qcplayer_childevent_callback = nullptr;
        qcplayer_customevent_callback = nullptr;
        qcplayer_connectnotify_callback = nullptr;
        qcplayer_disconnectnotify_callback = nullptr;
        qcplayer_draw_callback = nullptr;
        qcplayer_drawtopaintbuffer_callback = nullptr;
        qcplayer_addchild_callback = nullptr;
        qcplayer_removechild_callback = nullptr;
        qcplayer_sender_callback = nullptr;
        qcplayer_sendersignalindex_callback = nullptr;
        qcplayer_receivers_callback = nullptr;
        qcplayer_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPLayer_Metacall_Callback(QCPLayer_Metacall_Callback cb) { qcplayer_metacall_callback = cb; }
    inline void setQCPLayer_Event_Callback(QCPLayer_Event_Callback cb) { qcplayer_event_callback = cb; }
    inline void setQCPLayer_EventFilter_Callback(QCPLayer_EventFilter_Callback cb) { qcplayer_eventfilter_callback = cb; }
    inline void setQCPLayer_TimerEvent_Callback(QCPLayer_TimerEvent_Callback cb) { qcplayer_timerevent_callback = cb; }
    inline void setQCPLayer_ChildEvent_Callback(QCPLayer_ChildEvent_Callback cb) { qcplayer_childevent_callback = cb; }
    inline void setQCPLayer_CustomEvent_Callback(QCPLayer_CustomEvent_Callback cb) { qcplayer_customevent_callback = cb; }
    inline void setQCPLayer_ConnectNotify_Callback(QCPLayer_ConnectNotify_Callback cb) { qcplayer_connectnotify_callback = cb; }
    inline void setQCPLayer_DisconnectNotify_Callback(QCPLayer_DisconnectNotify_Callback cb) { qcplayer_disconnectnotify_callback = cb; }
    inline void setQCPLayer_Draw_Callback(QCPLayer_Draw_Callback cb) { qcplayer_draw_callback = cb; }
    inline void setQCPLayer_DrawToPaintBuffer_Callback(QCPLayer_DrawToPaintBuffer_Callback cb) { qcplayer_drawtopaintbuffer_callback = cb; }
    inline void setQCPLayer_AddChild_Callback(QCPLayer_AddChild_Callback cb) { qcplayer_addchild_callback = cb; }
    inline void setQCPLayer_RemoveChild_Callback(QCPLayer_RemoveChild_Callback cb) { qcplayer_removechild_callback = cb; }
    inline void setQCPLayer_Sender_Callback(QCPLayer_Sender_Callback cb) { qcplayer_sender_callback = cb; }
    inline void setQCPLayer_SenderSignalIndex_Callback(QCPLayer_SenderSignalIndex_Callback cb) { qcplayer_sendersignalindex_callback = cb; }
    inline void setQCPLayer_Receivers_Callback(QCPLayer_Receivers_Callback cb) { qcplayer_receivers_callback = cb; }
    inline void setQCPLayer_IsSignalConnected_Callback(QCPLayer_IsSignalConnected_Callback cb) { qcplayer_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPLayer_Metacall_IsBase(bool value) const { qcplayer_metacall_isbase = value; }
    inline void setQCPLayer_Event_IsBase(bool value) const { qcplayer_event_isbase = value; }
    inline void setQCPLayer_EventFilter_IsBase(bool value) const { qcplayer_eventfilter_isbase = value; }
    inline void setQCPLayer_TimerEvent_IsBase(bool value) const { qcplayer_timerevent_isbase = value; }
    inline void setQCPLayer_ChildEvent_IsBase(bool value) const { qcplayer_childevent_isbase = value; }
    inline void setQCPLayer_CustomEvent_IsBase(bool value) const { qcplayer_customevent_isbase = value; }
    inline void setQCPLayer_ConnectNotify_IsBase(bool value) const { qcplayer_connectnotify_isbase = value; }
    inline void setQCPLayer_DisconnectNotify_IsBase(bool value) const { qcplayer_disconnectnotify_isbase = value; }
    inline void setQCPLayer_Draw_IsBase(bool value) const { qcplayer_draw_isbase = value; }
    inline void setQCPLayer_DrawToPaintBuffer_IsBase(bool value) const { qcplayer_drawtopaintbuffer_isbase = value; }
    inline void setQCPLayer_AddChild_IsBase(bool value) const { qcplayer_addchild_isbase = value; }
    inline void setQCPLayer_RemoveChild_IsBase(bool value) const { qcplayer_removechild_isbase = value; }
    inline void setQCPLayer_Sender_IsBase(bool value) const { qcplayer_sender_isbase = value; }
    inline void setQCPLayer_SenderSignalIndex_IsBase(bool value) const { qcplayer_sendersignalindex_isbase = value; }
    inline void setQCPLayer_Receivers_IsBase(bool value) const { qcplayer_receivers_isbase = value; }
    inline void setQCPLayer_IsSignalConnected_IsBase(bool value) const { qcplayer_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcplayer_metacall_isbase) {
            qcplayer_metacall_isbase = false;
            return QCPLayer::qt_metacall(param1, param2, param3);
        } else if (qcplayer_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcplayer_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPLayer::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcplayer_event_isbase) {
            qcplayer_event_isbase = false;
            return QCPLayer::event(event);
        } else if (qcplayer_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcplayer_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPLayer::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcplayer_eventfilter_isbase) {
            qcplayer_eventfilter_isbase = false;
            return QCPLayer::eventFilter(watched, event);
        } else if (qcplayer_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcplayer_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPLayer::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcplayer_timerevent_isbase) {
            qcplayer_timerevent_isbase = false;
            QCPLayer::timerEvent(event);
        } else if (qcplayer_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcplayer_timerevent_callback(this, cbval1);
        } else {
            QCPLayer::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcplayer_childevent_isbase) {
            qcplayer_childevent_isbase = false;
            QCPLayer::childEvent(event);
        } else if (qcplayer_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcplayer_childevent_callback(this, cbval1);
        } else {
            QCPLayer::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcplayer_customevent_isbase) {
            qcplayer_customevent_isbase = false;
            QCPLayer::customEvent(event);
        } else if (qcplayer_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcplayer_customevent_callback(this, cbval1);
        } else {
            QCPLayer::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcplayer_connectnotify_isbase) {
            qcplayer_connectnotify_isbase = false;
            QCPLayer::connectNotify(signal);
        } else if (qcplayer_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcplayer_connectnotify_callback(this, cbval1);
        } else {
            QCPLayer::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcplayer_disconnectnotify_isbase) {
            qcplayer_disconnectnotify_isbase = false;
            QCPLayer::disconnectNotify(signal);
        } else if (qcplayer_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcplayer_disconnectnotify_callback(this, cbval1);
        } else {
            QCPLayer::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    void draw(QCPPainter* painter) {
        if (qcplayer_draw_isbase) {
            qcplayer_draw_isbase = false;
            QCPLayer::draw(painter);
        } else if (qcplayer_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcplayer_draw_callback(this, cbval1);
        } else {
            QCPLayer::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    void drawToPaintBuffer() {
        if (qcplayer_drawtopaintbuffer_isbase) {
            qcplayer_drawtopaintbuffer_isbase = false;
            QCPLayer::drawToPaintBuffer();
        } else if (qcplayer_drawtopaintbuffer_callback != nullptr) {
            qcplayer_drawtopaintbuffer_callback();
        } else {
            QCPLayer::drawToPaintBuffer();
        }
    }

    // Virtual method for C ABI access and custom callback
    void addChild(QCPLayerable* layerable, bool prepend) {
        if (qcplayer_addchild_isbase) {
            qcplayer_addchild_isbase = false;
            QCPLayer::addChild(layerable, prepend);
        } else if (qcplayer_addchild_callback != nullptr) {
            QCPLayerable* cbval1 = layerable;
            bool cbval2 = prepend;

            qcplayer_addchild_callback(this, cbval1, cbval2);
        } else {
            QCPLayer::addChild(layerable, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void removeChild(QCPLayerable* layerable) {
        if (qcplayer_removechild_isbase) {
            qcplayer_removechild_isbase = false;
            QCPLayer::removeChild(layerable);
        } else if (qcplayer_removechild_callback != nullptr) {
            QCPLayerable* cbval1 = layerable;

            qcplayer_removechild_callback(this, cbval1);
        } else {
            QCPLayer::removeChild(layerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcplayer_sender_isbase) {
            qcplayer_sender_isbase = false;
            return QCPLayer::sender();
        } else if (qcplayer_sender_callback != nullptr) {
            QObject* callback_ret = qcplayer_sender_callback();
            return callback_ret;
        } else {
            return QCPLayer::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcplayer_sendersignalindex_isbase) {
            qcplayer_sendersignalindex_isbase = false;
            return QCPLayer::senderSignalIndex();
        } else if (qcplayer_sendersignalindex_callback != nullptr) {
            int callback_ret = qcplayer_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPLayer::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcplayer_receivers_isbase) {
            qcplayer_receivers_isbase = false;
            return QCPLayer::receivers(signal);
        } else if (qcplayer_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcplayer_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPLayer::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcplayer_issignalconnected_isbase) {
            qcplayer_issignalconnected_isbase = false;
            return QCPLayer::isSignalConnected(signal);
        } else if (qcplayer_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcplayer_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPLayer::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPLayer_TimerEvent(QCPLayer* self, QTimerEvent* event);
    friend void QCPLayer_QBaseTimerEvent(QCPLayer* self, QTimerEvent* event);
    friend void QCPLayer_ChildEvent(QCPLayer* self, QChildEvent* event);
    friend void QCPLayer_QBaseChildEvent(QCPLayer* self, QChildEvent* event);
    friend void QCPLayer_CustomEvent(QCPLayer* self, QEvent* event);
    friend void QCPLayer_QBaseCustomEvent(QCPLayer* self, QEvent* event);
    friend void QCPLayer_ConnectNotify(QCPLayer* self, const QMetaMethod* signal);
    friend void QCPLayer_QBaseConnectNotify(QCPLayer* self, const QMetaMethod* signal);
    friend void QCPLayer_DisconnectNotify(QCPLayer* self, const QMetaMethod* signal);
    friend void QCPLayer_QBaseDisconnectNotify(QCPLayer* self, const QMetaMethod* signal);
    friend void QCPLayer_Draw(QCPLayer* self, QCPPainter* painter);
    friend void QCPLayer_QBaseDraw(QCPLayer* self, QCPPainter* painter);
    friend void QCPLayer_DrawToPaintBuffer(QCPLayer* self);
    friend void QCPLayer_QBaseDrawToPaintBuffer(QCPLayer* self);
    friend void QCPLayer_AddChild(QCPLayer* self, QCPLayerable* layerable, bool prepend);
    friend void QCPLayer_QBaseAddChild(QCPLayer* self, QCPLayerable* layerable, bool prepend);
    friend void QCPLayer_RemoveChild(QCPLayer* self, QCPLayerable* layerable);
    friend void QCPLayer_QBaseRemoveChild(QCPLayer* self, QCPLayerable* layerable);
    friend QObject* QCPLayer_Sender(const QCPLayer* self);
    friend QObject* QCPLayer_QBaseSender(const QCPLayer* self);
    friend int QCPLayer_SenderSignalIndex(const QCPLayer* self);
    friend int QCPLayer_QBaseSenderSignalIndex(const QCPLayer* self);
    friend int QCPLayer_Receivers(const QCPLayer* self, const char* signal);
    friend int QCPLayer_QBaseReceivers(const QCPLayer* self, const char* signal);
    friend bool QCPLayer_IsSignalConnected(const QCPLayer* self, const QMetaMethod* signal);
    friend bool QCPLayer_QBaseIsSignalConnected(const QCPLayer* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPLayerable so that we can call protected methods
class VirtualQCPLayerable : public QCPLayerable {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPLayerable = true;

    // Virtual class public types (including callbacks)
    using QCPLayerable_Metacall_Callback = int (*)(QCPLayerable*, int, int, void**);
    using QCPLayerable_SelectTest_Callback = double (*)(const QCPLayerable*, QPointF*, bool, QVariant*);
    using QCPLayerable_ParentPlotInitialized_Callback = void (*)(QCPLayerable*, QCustomPlot*);
    using QCPLayerable_SelectionCategory_Callback = int (*)();
    using QCPLayerable_ClipRect_Callback = QRect* (*)();
    using QCPLayerable_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPLayerable*, QCPPainter*);
    using QCPLayerable_Draw_Callback = void (*)(QCPLayerable*, QCPPainter*);
    using QCPLayerable_SelectEvent_Callback = void (*)(QCPLayerable*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPLayerable_DeselectEvent_Callback = void (*)(QCPLayerable*, bool*);
    using QCPLayerable_MousePressEvent_Callback = void (*)(QCPLayerable*, QMouseEvent*, QVariant*);
    using QCPLayerable_MouseMoveEvent_Callback = void (*)(QCPLayerable*, QMouseEvent*, QPointF*);
    using QCPLayerable_MouseReleaseEvent_Callback = void (*)(QCPLayerable*, QMouseEvent*, QPointF*);
    using QCPLayerable_MouseDoubleClickEvent_Callback = void (*)(QCPLayerable*, QMouseEvent*, QVariant*);
    using QCPLayerable_WheelEvent_Callback = void (*)(QCPLayerable*, QWheelEvent*);
    using QCPLayerable_Event_Callback = bool (*)(QCPLayerable*, QEvent*);
    using QCPLayerable_EventFilter_Callback = bool (*)(QCPLayerable*, QObject*, QEvent*);
    using QCPLayerable_TimerEvent_Callback = void (*)(QCPLayerable*, QTimerEvent*);
    using QCPLayerable_ChildEvent_Callback = void (*)(QCPLayerable*, QChildEvent*);
    using QCPLayerable_CustomEvent_Callback = void (*)(QCPLayerable*, QEvent*);
    using QCPLayerable_ConnectNotify_Callback = void (*)(QCPLayerable*, QMetaMethod*);
    using QCPLayerable_DisconnectNotify_Callback = void (*)(QCPLayerable*, QMetaMethod*);
    using QCPLayerable_InitializeParentPlot_Callback = void (*)(QCPLayerable*, QCustomPlot*);
    using QCPLayerable_SetParentLayerable_Callback = void (*)(QCPLayerable*, QCPLayerable*);
    using QCPLayerable_MoveToLayer_Callback = bool (*)(QCPLayerable*, QCPLayer*, bool);
    using QCPLayerable_ApplyAntialiasingHint_Callback = void (*)(const QCPLayerable*, QCPPainter*, bool, int);
    using QCPLayerable_Sender_Callback = QObject* (*)();
    using QCPLayerable_SenderSignalIndex_Callback = int (*)();
    using QCPLayerable_Receivers_Callback = int (*)(const QCPLayerable*, const char*);
    using QCPLayerable_IsSignalConnected_Callback = bool (*)(const QCPLayerable*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPLayerable_Metacall_Callback qcplayerable_metacall_callback = nullptr;
    QCPLayerable_SelectTest_Callback qcplayerable_selecttest_callback = nullptr;
    QCPLayerable_ParentPlotInitialized_Callback qcplayerable_parentplotinitialized_callback = nullptr;
    QCPLayerable_SelectionCategory_Callback qcplayerable_selectioncategory_callback = nullptr;
    QCPLayerable_ClipRect_Callback qcplayerable_cliprect_callback = nullptr;
    QCPLayerable_ApplyDefaultAntialiasingHint_Callback qcplayerable_applydefaultantialiasinghint_callback = nullptr;
    QCPLayerable_Draw_Callback qcplayerable_draw_callback = nullptr;
    QCPLayerable_SelectEvent_Callback qcplayerable_selectevent_callback = nullptr;
    QCPLayerable_DeselectEvent_Callback qcplayerable_deselectevent_callback = nullptr;
    QCPLayerable_MousePressEvent_Callback qcplayerable_mousepressevent_callback = nullptr;
    QCPLayerable_MouseMoveEvent_Callback qcplayerable_mousemoveevent_callback = nullptr;
    QCPLayerable_MouseReleaseEvent_Callback qcplayerable_mousereleaseevent_callback = nullptr;
    QCPLayerable_MouseDoubleClickEvent_Callback qcplayerable_mousedoubleclickevent_callback = nullptr;
    QCPLayerable_WheelEvent_Callback qcplayerable_wheelevent_callback = nullptr;
    QCPLayerable_Event_Callback qcplayerable_event_callback = nullptr;
    QCPLayerable_EventFilter_Callback qcplayerable_eventfilter_callback = nullptr;
    QCPLayerable_TimerEvent_Callback qcplayerable_timerevent_callback = nullptr;
    QCPLayerable_ChildEvent_Callback qcplayerable_childevent_callback = nullptr;
    QCPLayerable_CustomEvent_Callback qcplayerable_customevent_callback = nullptr;
    QCPLayerable_ConnectNotify_Callback qcplayerable_connectnotify_callback = nullptr;
    QCPLayerable_DisconnectNotify_Callback qcplayerable_disconnectnotify_callback = nullptr;
    QCPLayerable_InitializeParentPlot_Callback qcplayerable_initializeparentplot_callback = nullptr;
    QCPLayerable_SetParentLayerable_Callback qcplayerable_setparentlayerable_callback = nullptr;
    QCPLayerable_MoveToLayer_Callback qcplayerable_movetolayer_callback = nullptr;
    QCPLayerable_ApplyAntialiasingHint_Callback qcplayerable_applyantialiasinghint_callback = nullptr;
    QCPLayerable_Sender_Callback qcplayerable_sender_callback = nullptr;
    QCPLayerable_SenderSignalIndex_Callback qcplayerable_sendersignalindex_callback = nullptr;
    QCPLayerable_Receivers_Callback qcplayerable_receivers_callback = nullptr;
    QCPLayerable_IsSignalConnected_Callback qcplayerable_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcplayerable_metacall_isbase = false;
    mutable bool qcplayerable_selecttest_isbase = false;
    mutable bool qcplayerable_parentplotinitialized_isbase = false;
    mutable bool qcplayerable_selectioncategory_isbase = false;
    mutable bool qcplayerable_cliprect_isbase = false;
    mutable bool qcplayerable_applydefaultantialiasinghint_isbase = false;
    mutable bool qcplayerable_draw_isbase = false;
    mutable bool qcplayerable_selectevent_isbase = false;
    mutable bool qcplayerable_deselectevent_isbase = false;
    mutable bool qcplayerable_mousepressevent_isbase = false;
    mutable bool qcplayerable_mousemoveevent_isbase = false;
    mutable bool qcplayerable_mousereleaseevent_isbase = false;
    mutable bool qcplayerable_mousedoubleclickevent_isbase = false;
    mutable bool qcplayerable_wheelevent_isbase = false;
    mutable bool qcplayerable_event_isbase = false;
    mutable bool qcplayerable_eventfilter_isbase = false;
    mutable bool qcplayerable_timerevent_isbase = false;
    mutable bool qcplayerable_childevent_isbase = false;
    mutable bool qcplayerable_customevent_isbase = false;
    mutable bool qcplayerable_connectnotify_isbase = false;
    mutable bool qcplayerable_disconnectnotify_isbase = false;
    mutable bool qcplayerable_initializeparentplot_isbase = false;
    mutable bool qcplayerable_setparentlayerable_isbase = false;
    mutable bool qcplayerable_movetolayer_isbase = false;
    mutable bool qcplayerable_applyantialiasinghint_isbase = false;
    mutable bool qcplayerable_sender_isbase = false;
    mutable bool qcplayerable_sendersignalindex_isbase = false;
    mutable bool qcplayerable_receivers_isbase = false;
    mutable bool qcplayerable_issignalconnected_isbase = false;

  public:
    VirtualQCPLayerable(QCustomPlot* plot) : QCPLayerable(plot) {};
    VirtualQCPLayerable(QCustomPlot* plot, QString targetLayer) : QCPLayerable(plot, targetLayer) {};
    VirtualQCPLayerable(QCustomPlot* plot, QString targetLayer, QCPLayerable* parentLayerable) : QCPLayerable(plot, targetLayer, parentLayerable) {};

    ~VirtualQCPLayerable() {
        qcplayerable_metacall_callback = nullptr;
        qcplayerable_selecttest_callback = nullptr;
        qcplayerable_parentplotinitialized_callback = nullptr;
        qcplayerable_selectioncategory_callback = nullptr;
        qcplayerable_cliprect_callback = nullptr;
        qcplayerable_applydefaultantialiasinghint_callback = nullptr;
        qcplayerable_draw_callback = nullptr;
        qcplayerable_selectevent_callback = nullptr;
        qcplayerable_deselectevent_callback = nullptr;
        qcplayerable_mousepressevent_callback = nullptr;
        qcplayerable_mousemoveevent_callback = nullptr;
        qcplayerable_mousereleaseevent_callback = nullptr;
        qcplayerable_mousedoubleclickevent_callback = nullptr;
        qcplayerable_wheelevent_callback = nullptr;
        qcplayerable_event_callback = nullptr;
        qcplayerable_eventfilter_callback = nullptr;
        qcplayerable_timerevent_callback = nullptr;
        qcplayerable_childevent_callback = nullptr;
        qcplayerable_customevent_callback = nullptr;
        qcplayerable_connectnotify_callback = nullptr;
        qcplayerable_disconnectnotify_callback = nullptr;
        qcplayerable_initializeparentplot_callback = nullptr;
        qcplayerable_setparentlayerable_callback = nullptr;
        qcplayerable_movetolayer_callback = nullptr;
        qcplayerable_applyantialiasinghint_callback = nullptr;
        qcplayerable_sender_callback = nullptr;
        qcplayerable_sendersignalindex_callback = nullptr;
        qcplayerable_receivers_callback = nullptr;
        qcplayerable_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPLayerable_Metacall_Callback(QCPLayerable_Metacall_Callback cb) { qcplayerable_metacall_callback = cb; }
    inline void setQCPLayerable_SelectTest_Callback(QCPLayerable_SelectTest_Callback cb) { qcplayerable_selecttest_callback = cb; }
    inline void setQCPLayerable_ParentPlotInitialized_Callback(QCPLayerable_ParentPlotInitialized_Callback cb) { qcplayerable_parentplotinitialized_callback = cb; }
    inline void setQCPLayerable_SelectionCategory_Callback(QCPLayerable_SelectionCategory_Callback cb) { qcplayerable_selectioncategory_callback = cb; }
    inline void setQCPLayerable_ClipRect_Callback(QCPLayerable_ClipRect_Callback cb) { qcplayerable_cliprect_callback = cb; }
    inline void setQCPLayerable_ApplyDefaultAntialiasingHint_Callback(QCPLayerable_ApplyDefaultAntialiasingHint_Callback cb) { qcplayerable_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPLayerable_Draw_Callback(QCPLayerable_Draw_Callback cb) { qcplayerable_draw_callback = cb; }
    inline void setQCPLayerable_SelectEvent_Callback(QCPLayerable_SelectEvent_Callback cb) { qcplayerable_selectevent_callback = cb; }
    inline void setQCPLayerable_DeselectEvent_Callback(QCPLayerable_DeselectEvent_Callback cb) { qcplayerable_deselectevent_callback = cb; }
    inline void setQCPLayerable_MousePressEvent_Callback(QCPLayerable_MousePressEvent_Callback cb) { qcplayerable_mousepressevent_callback = cb; }
    inline void setQCPLayerable_MouseMoveEvent_Callback(QCPLayerable_MouseMoveEvent_Callback cb) { qcplayerable_mousemoveevent_callback = cb; }
    inline void setQCPLayerable_MouseReleaseEvent_Callback(QCPLayerable_MouseReleaseEvent_Callback cb) { qcplayerable_mousereleaseevent_callback = cb; }
    inline void setQCPLayerable_MouseDoubleClickEvent_Callback(QCPLayerable_MouseDoubleClickEvent_Callback cb) { qcplayerable_mousedoubleclickevent_callback = cb; }
    inline void setQCPLayerable_WheelEvent_Callback(QCPLayerable_WheelEvent_Callback cb) { qcplayerable_wheelevent_callback = cb; }
    inline void setQCPLayerable_Event_Callback(QCPLayerable_Event_Callback cb) { qcplayerable_event_callback = cb; }
    inline void setQCPLayerable_EventFilter_Callback(QCPLayerable_EventFilter_Callback cb) { qcplayerable_eventfilter_callback = cb; }
    inline void setQCPLayerable_TimerEvent_Callback(QCPLayerable_TimerEvent_Callback cb) { qcplayerable_timerevent_callback = cb; }
    inline void setQCPLayerable_ChildEvent_Callback(QCPLayerable_ChildEvent_Callback cb) { qcplayerable_childevent_callback = cb; }
    inline void setQCPLayerable_CustomEvent_Callback(QCPLayerable_CustomEvent_Callback cb) { qcplayerable_customevent_callback = cb; }
    inline void setQCPLayerable_ConnectNotify_Callback(QCPLayerable_ConnectNotify_Callback cb) { qcplayerable_connectnotify_callback = cb; }
    inline void setQCPLayerable_DisconnectNotify_Callback(QCPLayerable_DisconnectNotify_Callback cb) { qcplayerable_disconnectnotify_callback = cb; }
    inline void setQCPLayerable_InitializeParentPlot_Callback(QCPLayerable_InitializeParentPlot_Callback cb) { qcplayerable_initializeparentplot_callback = cb; }
    inline void setQCPLayerable_SetParentLayerable_Callback(QCPLayerable_SetParentLayerable_Callback cb) { qcplayerable_setparentlayerable_callback = cb; }
    inline void setQCPLayerable_MoveToLayer_Callback(QCPLayerable_MoveToLayer_Callback cb) { qcplayerable_movetolayer_callback = cb; }
    inline void setQCPLayerable_ApplyAntialiasingHint_Callback(QCPLayerable_ApplyAntialiasingHint_Callback cb) { qcplayerable_applyantialiasinghint_callback = cb; }
    inline void setQCPLayerable_Sender_Callback(QCPLayerable_Sender_Callback cb) { qcplayerable_sender_callback = cb; }
    inline void setQCPLayerable_SenderSignalIndex_Callback(QCPLayerable_SenderSignalIndex_Callback cb) { qcplayerable_sendersignalindex_callback = cb; }
    inline void setQCPLayerable_Receivers_Callback(QCPLayerable_Receivers_Callback cb) { qcplayerable_receivers_callback = cb; }
    inline void setQCPLayerable_IsSignalConnected_Callback(QCPLayerable_IsSignalConnected_Callback cb) { qcplayerable_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPLayerable_Metacall_IsBase(bool value) const { qcplayerable_metacall_isbase = value; }
    inline void setQCPLayerable_SelectTest_IsBase(bool value) const { qcplayerable_selecttest_isbase = value; }
    inline void setQCPLayerable_ParentPlotInitialized_IsBase(bool value) const { qcplayerable_parentplotinitialized_isbase = value; }
    inline void setQCPLayerable_SelectionCategory_IsBase(bool value) const { qcplayerable_selectioncategory_isbase = value; }
    inline void setQCPLayerable_ClipRect_IsBase(bool value) const { qcplayerable_cliprect_isbase = value; }
    inline void setQCPLayerable_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcplayerable_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPLayerable_Draw_IsBase(bool value) const { qcplayerable_draw_isbase = value; }
    inline void setQCPLayerable_SelectEvent_IsBase(bool value) const { qcplayerable_selectevent_isbase = value; }
    inline void setQCPLayerable_DeselectEvent_IsBase(bool value) const { qcplayerable_deselectevent_isbase = value; }
    inline void setQCPLayerable_MousePressEvent_IsBase(bool value) const { qcplayerable_mousepressevent_isbase = value; }
    inline void setQCPLayerable_MouseMoveEvent_IsBase(bool value) const { qcplayerable_mousemoveevent_isbase = value; }
    inline void setQCPLayerable_MouseReleaseEvent_IsBase(bool value) const { qcplayerable_mousereleaseevent_isbase = value; }
    inline void setQCPLayerable_MouseDoubleClickEvent_IsBase(bool value) const { qcplayerable_mousedoubleclickevent_isbase = value; }
    inline void setQCPLayerable_WheelEvent_IsBase(bool value) const { qcplayerable_wheelevent_isbase = value; }
    inline void setQCPLayerable_Event_IsBase(bool value) const { qcplayerable_event_isbase = value; }
    inline void setQCPLayerable_EventFilter_IsBase(bool value) const { qcplayerable_eventfilter_isbase = value; }
    inline void setQCPLayerable_TimerEvent_IsBase(bool value) const { qcplayerable_timerevent_isbase = value; }
    inline void setQCPLayerable_ChildEvent_IsBase(bool value) const { qcplayerable_childevent_isbase = value; }
    inline void setQCPLayerable_CustomEvent_IsBase(bool value) const { qcplayerable_customevent_isbase = value; }
    inline void setQCPLayerable_ConnectNotify_IsBase(bool value) const { qcplayerable_connectnotify_isbase = value; }
    inline void setQCPLayerable_DisconnectNotify_IsBase(bool value) const { qcplayerable_disconnectnotify_isbase = value; }
    inline void setQCPLayerable_InitializeParentPlot_IsBase(bool value) const { qcplayerable_initializeparentplot_isbase = value; }
    inline void setQCPLayerable_SetParentLayerable_IsBase(bool value) const { qcplayerable_setparentlayerable_isbase = value; }
    inline void setQCPLayerable_MoveToLayer_IsBase(bool value) const { qcplayerable_movetolayer_isbase = value; }
    inline void setQCPLayerable_ApplyAntialiasingHint_IsBase(bool value) const { qcplayerable_applyantialiasinghint_isbase = value; }
    inline void setQCPLayerable_Sender_IsBase(bool value) const { qcplayerable_sender_isbase = value; }
    inline void setQCPLayerable_SenderSignalIndex_IsBase(bool value) const { qcplayerable_sendersignalindex_isbase = value; }
    inline void setQCPLayerable_Receivers_IsBase(bool value) const { qcplayerable_receivers_isbase = value; }
    inline void setQCPLayerable_IsSignalConnected_IsBase(bool value) const { qcplayerable_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcplayerable_metacall_isbase) {
            qcplayerable_metacall_isbase = false;
            return QCPLayerable::qt_metacall(param1, param2, param3);
        } else if (qcplayerable_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcplayerable_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPLayerable::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcplayerable_selecttest_isbase) {
            qcplayerable_selecttest_isbase = false;
            return QCPLayerable::selectTest(pos, onlySelectable, details);
        } else if (qcplayerable_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcplayerable_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPLayerable::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcplayerable_parentplotinitialized_isbase) {
            qcplayerable_parentplotinitialized_isbase = false;
            QCPLayerable::parentPlotInitialized(parentPlot);
        } else if (qcplayerable_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcplayerable_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPLayerable::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcplayerable_selectioncategory_isbase) {
            qcplayerable_selectioncategory_isbase = false;
            return QCPLayerable::selectionCategory();
        } else if (qcplayerable_selectioncategory_callback != nullptr) {
            int callback_ret = qcplayerable_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPLayerable::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcplayerable_cliprect_isbase) {
            qcplayerable_cliprect_isbase = false;
            return QCPLayerable::clipRect();
        } else if (qcplayerable_cliprect_callback != nullptr) {
            QRect* callback_ret = qcplayerable_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPLayerable::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcplayerable_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcplayerable_applydefaultantialiasinghint_callback(this, cbval1);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcplayerable_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcplayerable_draw_callback(this, cbval1);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcplayerable_selectevent_isbase) {
            qcplayerable_selectevent_isbase = false;
            QCPLayerable::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcplayerable_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcplayerable_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPLayerable::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcplayerable_deselectevent_isbase) {
            qcplayerable_deselectevent_isbase = false;
            QCPLayerable::deselectEvent(selectionStateChanged);
        } else if (qcplayerable_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcplayerable_deselectevent_callback(this, cbval1);
        } else {
            QCPLayerable::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcplayerable_mousepressevent_isbase) {
            qcplayerable_mousepressevent_isbase = false;
            QCPLayerable::mousePressEvent(event, details);
        } else if (qcplayerable_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcplayerable_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPLayerable::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcplayerable_mousemoveevent_isbase) {
            qcplayerable_mousemoveevent_isbase = false;
            QCPLayerable::mouseMoveEvent(event, startPos);
        } else if (qcplayerable_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcplayerable_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPLayerable::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcplayerable_mousereleaseevent_isbase) {
            qcplayerable_mousereleaseevent_isbase = false;
            QCPLayerable::mouseReleaseEvent(event, startPos);
        } else if (qcplayerable_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcplayerable_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPLayerable::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcplayerable_mousedoubleclickevent_isbase) {
            qcplayerable_mousedoubleclickevent_isbase = false;
            QCPLayerable::mouseDoubleClickEvent(event, details);
        } else if (qcplayerable_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcplayerable_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPLayerable::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcplayerable_wheelevent_isbase) {
            qcplayerable_wheelevent_isbase = false;
            QCPLayerable::wheelEvent(event);
        } else if (qcplayerable_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcplayerable_wheelevent_callback(this, cbval1);
        } else {
            QCPLayerable::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcplayerable_event_isbase) {
            qcplayerable_event_isbase = false;
            return QCPLayerable::event(event);
        } else if (qcplayerable_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcplayerable_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPLayerable::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcplayerable_eventfilter_isbase) {
            qcplayerable_eventfilter_isbase = false;
            return QCPLayerable::eventFilter(watched, event);
        } else if (qcplayerable_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcplayerable_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPLayerable::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcplayerable_timerevent_isbase) {
            qcplayerable_timerevent_isbase = false;
            QCPLayerable::timerEvent(event);
        } else if (qcplayerable_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcplayerable_timerevent_callback(this, cbval1);
        } else {
            QCPLayerable::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcplayerable_childevent_isbase) {
            qcplayerable_childevent_isbase = false;
            QCPLayerable::childEvent(event);
        } else if (qcplayerable_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcplayerable_childevent_callback(this, cbval1);
        } else {
            QCPLayerable::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcplayerable_customevent_isbase) {
            qcplayerable_customevent_isbase = false;
            QCPLayerable::customEvent(event);
        } else if (qcplayerable_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcplayerable_customevent_callback(this, cbval1);
        } else {
            QCPLayerable::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcplayerable_connectnotify_isbase) {
            qcplayerable_connectnotify_isbase = false;
            QCPLayerable::connectNotify(signal);
        } else if (qcplayerable_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcplayerable_connectnotify_callback(this, cbval1);
        } else {
            QCPLayerable::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcplayerable_disconnectnotify_isbase) {
            qcplayerable_disconnectnotify_isbase = false;
            QCPLayerable::disconnectNotify(signal);
        } else if (qcplayerable_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcplayerable_disconnectnotify_callback(this, cbval1);
        } else {
            QCPLayerable::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcplayerable_initializeparentplot_isbase) {
            qcplayerable_initializeparentplot_isbase = false;
            QCPLayerable::initializeParentPlot(parentPlot);
        } else if (qcplayerable_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcplayerable_initializeparentplot_callback(this, cbval1);
        } else {
            QCPLayerable::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcplayerable_setparentlayerable_isbase) {
            qcplayerable_setparentlayerable_isbase = false;
            QCPLayerable::setParentLayerable(parentLayerable);
        } else if (qcplayerable_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcplayerable_setparentlayerable_callback(this, cbval1);
        } else {
            QCPLayerable::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcplayerable_movetolayer_isbase) {
            qcplayerable_movetolayer_isbase = false;
            return QCPLayerable::moveToLayer(layer, prepend);
        } else if (qcplayerable_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcplayerable_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPLayerable::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcplayerable_applyantialiasinghint_isbase) {
            qcplayerable_applyantialiasinghint_isbase = false;
            QCPLayerable::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcplayerable_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcplayerable_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPLayerable::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcplayerable_sender_isbase) {
            qcplayerable_sender_isbase = false;
            return QCPLayerable::sender();
        } else if (qcplayerable_sender_callback != nullptr) {
            QObject* callback_ret = qcplayerable_sender_callback();
            return callback_ret;
        } else {
            return QCPLayerable::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcplayerable_sendersignalindex_isbase) {
            qcplayerable_sendersignalindex_isbase = false;
            return QCPLayerable::senderSignalIndex();
        } else if (qcplayerable_sendersignalindex_callback != nullptr) {
            int callback_ret = qcplayerable_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPLayerable::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcplayerable_receivers_isbase) {
            qcplayerable_receivers_isbase = false;
            return QCPLayerable::receivers(signal);
        } else if (qcplayerable_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcplayerable_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPLayerable::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcplayerable_issignalconnected_isbase) {
            qcplayerable_issignalconnected_isbase = false;
            return QCPLayerable::isSignalConnected(signal);
        } else if (qcplayerable_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcplayerable_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPLayerable::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPLayerable_ParentPlotInitialized(QCPLayerable* self, QCustomPlot* parentPlot);
    friend void QCPLayerable_QBaseParentPlotInitialized(QCPLayerable* self, QCustomPlot* parentPlot);
    friend int QCPLayerable_SelectionCategory(const QCPLayerable* self);
    friend int QCPLayerable_QBaseSelectionCategory(const QCPLayerable* self);
    friend QRect* QCPLayerable_ClipRect(const QCPLayerable* self);
    friend QRect* QCPLayerable_QBaseClipRect(const QCPLayerable* self);
    friend void QCPLayerable_ApplyDefaultAntialiasingHint(const QCPLayerable* self, QCPPainter* painter);
    friend void QCPLayerable_QBaseApplyDefaultAntialiasingHint(const QCPLayerable* self, QCPPainter* painter);
    friend void QCPLayerable_Draw(QCPLayerable* self, QCPPainter* painter);
    friend void QCPLayerable_QBaseDraw(QCPLayerable* self, QCPPainter* painter);
    friend void QCPLayerable_SelectEvent(QCPLayerable* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPLayerable_QBaseSelectEvent(QCPLayerable* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPLayerable_DeselectEvent(QCPLayerable* self, bool* selectionStateChanged);
    friend void QCPLayerable_QBaseDeselectEvent(QCPLayerable* self, bool* selectionStateChanged);
    friend void QCPLayerable_MousePressEvent(QCPLayerable* self, QMouseEvent* event, const QVariant* details);
    friend void QCPLayerable_QBaseMousePressEvent(QCPLayerable* self, QMouseEvent* event, const QVariant* details);
    friend void QCPLayerable_MouseMoveEvent(QCPLayerable* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPLayerable_QBaseMouseMoveEvent(QCPLayerable* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPLayerable_MouseReleaseEvent(QCPLayerable* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPLayerable_QBaseMouseReleaseEvent(QCPLayerable* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPLayerable_MouseDoubleClickEvent(QCPLayerable* self, QMouseEvent* event, const QVariant* details);
    friend void QCPLayerable_QBaseMouseDoubleClickEvent(QCPLayerable* self, QMouseEvent* event, const QVariant* details);
    friend void QCPLayerable_WheelEvent(QCPLayerable* self, QWheelEvent* event);
    friend void QCPLayerable_QBaseWheelEvent(QCPLayerable* self, QWheelEvent* event);
    friend void QCPLayerable_TimerEvent(QCPLayerable* self, QTimerEvent* event);
    friend void QCPLayerable_QBaseTimerEvent(QCPLayerable* self, QTimerEvent* event);
    friend void QCPLayerable_ChildEvent(QCPLayerable* self, QChildEvent* event);
    friend void QCPLayerable_QBaseChildEvent(QCPLayerable* self, QChildEvent* event);
    friend void QCPLayerable_CustomEvent(QCPLayerable* self, QEvent* event);
    friend void QCPLayerable_QBaseCustomEvent(QCPLayerable* self, QEvent* event);
    friend void QCPLayerable_ConnectNotify(QCPLayerable* self, const QMetaMethod* signal);
    friend void QCPLayerable_QBaseConnectNotify(QCPLayerable* self, const QMetaMethod* signal);
    friend void QCPLayerable_DisconnectNotify(QCPLayerable* self, const QMetaMethod* signal);
    friend void QCPLayerable_QBaseDisconnectNotify(QCPLayerable* self, const QMetaMethod* signal);
    friend void QCPLayerable_InitializeParentPlot(QCPLayerable* self, QCustomPlot* parentPlot);
    friend void QCPLayerable_QBaseInitializeParentPlot(QCPLayerable* self, QCustomPlot* parentPlot);
    friend void QCPLayerable_SetParentLayerable(QCPLayerable* self, QCPLayerable* parentLayerable);
    friend void QCPLayerable_QBaseSetParentLayerable(QCPLayerable* self, QCPLayerable* parentLayerable);
    friend bool QCPLayerable_MoveToLayer(QCPLayerable* self, QCPLayer* layer, bool prepend);
    friend bool QCPLayerable_QBaseMoveToLayer(QCPLayerable* self, QCPLayer* layer, bool prepend);
    friend void QCPLayerable_ApplyAntialiasingHint(const QCPLayerable* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPLayerable_QBaseApplyAntialiasingHint(const QCPLayerable* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPLayerable_Sender(const QCPLayerable* self);
    friend QObject* QCPLayerable_QBaseSender(const QCPLayerable* self);
    friend int QCPLayerable_SenderSignalIndex(const QCPLayerable* self);
    friend int QCPLayerable_QBaseSenderSignalIndex(const QCPLayerable* self);
    friend int QCPLayerable_Receivers(const QCPLayerable* self, const char* signal);
    friend int QCPLayerable_QBaseReceivers(const QCPLayerable* self, const char* signal);
    friend bool QCPLayerable_IsSignalConnected(const QCPLayerable* self, const QMetaMethod* signal);
    friend bool QCPLayerable_QBaseIsSignalConnected(const QCPLayerable* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPSelectionRect so that we can call protected methods
class VirtualQCPSelectionRect final : public QCPSelectionRect {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPSelectionRect = true;

    // Virtual class public types (including callbacks)
    using QCPSelectionRect_Metacall_Callback = int (*)(QCPSelectionRect*, int, int, void**);
    using QCPSelectionRect_StartSelection_Callback = void (*)(QCPSelectionRect*, QMouseEvent*);
    using QCPSelectionRect_MoveSelection_Callback = void (*)(QCPSelectionRect*, QMouseEvent*);
    using QCPSelectionRect_EndSelection_Callback = void (*)(QCPSelectionRect*, QMouseEvent*);
    using QCPSelectionRect_KeyPressEvent_Callback = void (*)(QCPSelectionRect*, QKeyEvent*);
    using QCPSelectionRect_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPSelectionRect*, QCPPainter*);
    using QCPSelectionRect_Draw_Callback = void (*)(QCPSelectionRect*, QCPPainter*);
    using QCPSelectionRect_SelectTest_Callback = double (*)(const QCPSelectionRect*, QPointF*, bool, QVariant*);
    using QCPSelectionRect_ParentPlotInitialized_Callback = void (*)(QCPSelectionRect*, QCustomPlot*);
    using QCPSelectionRect_SelectionCategory_Callback = int (*)();
    using QCPSelectionRect_ClipRect_Callback = QRect* (*)();
    using QCPSelectionRect_SelectEvent_Callback = void (*)(QCPSelectionRect*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPSelectionRect_DeselectEvent_Callback = void (*)(QCPSelectionRect*, bool*);
    using QCPSelectionRect_MousePressEvent_Callback = void (*)(QCPSelectionRect*, QMouseEvent*, QVariant*);
    using QCPSelectionRect_MouseMoveEvent_Callback = void (*)(QCPSelectionRect*, QMouseEvent*, QPointF*);
    using QCPSelectionRect_MouseReleaseEvent_Callback = void (*)(QCPSelectionRect*, QMouseEvent*, QPointF*);
    using QCPSelectionRect_MouseDoubleClickEvent_Callback = void (*)(QCPSelectionRect*, QMouseEvent*, QVariant*);
    using QCPSelectionRect_WheelEvent_Callback = void (*)(QCPSelectionRect*, QWheelEvent*);
    using QCPSelectionRect_Event_Callback = bool (*)(QCPSelectionRect*, QEvent*);
    using QCPSelectionRect_EventFilter_Callback = bool (*)(QCPSelectionRect*, QObject*, QEvent*);
    using QCPSelectionRect_TimerEvent_Callback = void (*)(QCPSelectionRect*, QTimerEvent*);
    using QCPSelectionRect_ChildEvent_Callback = void (*)(QCPSelectionRect*, QChildEvent*);
    using QCPSelectionRect_CustomEvent_Callback = void (*)(QCPSelectionRect*, QEvent*);
    using QCPSelectionRect_ConnectNotify_Callback = void (*)(QCPSelectionRect*, QMetaMethod*);
    using QCPSelectionRect_DisconnectNotify_Callback = void (*)(QCPSelectionRect*, QMetaMethod*);
    using QCPSelectionRect_InitializeParentPlot_Callback = void (*)(QCPSelectionRect*, QCustomPlot*);
    using QCPSelectionRect_SetParentLayerable_Callback = void (*)(QCPSelectionRect*, QCPLayerable*);
    using QCPSelectionRect_MoveToLayer_Callback = bool (*)(QCPSelectionRect*, QCPLayer*, bool);
    using QCPSelectionRect_ApplyAntialiasingHint_Callback = void (*)(const QCPSelectionRect*, QCPPainter*, bool, int);
    using QCPSelectionRect_Sender_Callback = QObject* (*)();
    using QCPSelectionRect_SenderSignalIndex_Callback = int (*)();
    using QCPSelectionRect_Receivers_Callback = int (*)(const QCPSelectionRect*, const char*);
    using QCPSelectionRect_IsSignalConnected_Callback = bool (*)(const QCPSelectionRect*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPSelectionRect_Metacall_Callback qcpselectionrect_metacall_callback = nullptr;
    QCPSelectionRect_StartSelection_Callback qcpselectionrect_startselection_callback = nullptr;
    QCPSelectionRect_MoveSelection_Callback qcpselectionrect_moveselection_callback = nullptr;
    QCPSelectionRect_EndSelection_Callback qcpselectionrect_endselection_callback = nullptr;
    QCPSelectionRect_KeyPressEvent_Callback qcpselectionrect_keypressevent_callback = nullptr;
    QCPSelectionRect_ApplyDefaultAntialiasingHint_Callback qcpselectionrect_applydefaultantialiasinghint_callback = nullptr;
    QCPSelectionRect_Draw_Callback qcpselectionrect_draw_callback = nullptr;
    QCPSelectionRect_SelectTest_Callback qcpselectionrect_selecttest_callback = nullptr;
    QCPSelectionRect_ParentPlotInitialized_Callback qcpselectionrect_parentplotinitialized_callback = nullptr;
    QCPSelectionRect_SelectionCategory_Callback qcpselectionrect_selectioncategory_callback = nullptr;
    QCPSelectionRect_ClipRect_Callback qcpselectionrect_cliprect_callback = nullptr;
    QCPSelectionRect_SelectEvent_Callback qcpselectionrect_selectevent_callback = nullptr;
    QCPSelectionRect_DeselectEvent_Callback qcpselectionrect_deselectevent_callback = nullptr;
    QCPSelectionRect_MousePressEvent_Callback qcpselectionrect_mousepressevent_callback = nullptr;
    QCPSelectionRect_MouseMoveEvent_Callback qcpselectionrect_mousemoveevent_callback = nullptr;
    QCPSelectionRect_MouseReleaseEvent_Callback qcpselectionrect_mousereleaseevent_callback = nullptr;
    QCPSelectionRect_MouseDoubleClickEvent_Callback qcpselectionrect_mousedoubleclickevent_callback = nullptr;
    QCPSelectionRect_WheelEvent_Callback qcpselectionrect_wheelevent_callback = nullptr;
    QCPSelectionRect_Event_Callback qcpselectionrect_event_callback = nullptr;
    QCPSelectionRect_EventFilter_Callback qcpselectionrect_eventfilter_callback = nullptr;
    QCPSelectionRect_TimerEvent_Callback qcpselectionrect_timerevent_callback = nullptr;
    QCPSelectionRect_ChildEvent_Callback qcpselectionrect_childevent_callback = nullptr;
    QCPSelectionRect_CustomEvent_Callback qcpselectionrect_customevent_callback = nullptr;
    QCPSelectionRect_ConnectNotify_Callback qcpselectionrect_connectnotify_callback = nullptr;
    QCPSelectionRect_DisconnectNotify_Callback qcpselectionrect_disconnectnotify_callback = nullptr;
    QCPSelectionRect_InitializeParentPlot_Callback qcpselectionrect_initializeparentplot_callback = nullptr;
    QCPSelectionRect_SetParentLayerable_Callback qcpselectionrect_setparentlayerable_callback = nullptr;
    QCPSelectionRect_MoveToLayer_Callback qcpselectionrect_movetolayer_callback = nullptr;
    QCPSelectionRect_ApplyAntialiasingHint_Callback qcpselectionrect_applyantialiasinghint_callback = nullptr;
    QCPSelectionRect_Sender_Callback qcpselectionrect_sender_callback = nullptr;
    QCPSelectionRect_SenderSignalIndex_Callback qcpselectionrect_sendersignalindex_callback = nullptr;
    QCPSelectionRect_Receivers_Callback qcpselectionrect_receivers_callback = nullptr;
    QCPSelectionRect_IsSignalConnected_Callback qcpselectionrect_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpselectionrect_metacall_isbase = false;
    mutable bool qcpselectionrect_startselection_isbase = false;
    mutable bool qcpselectionrect_moveselection_isbase = false;
    mutable bool qcpselectionrect_endselection_isbase = false;
    mutable bool qcpselectionrect_keypressevent_isbase = false;
    mutable bool qcpselectionrect_applydefaultantialiasinghint_isbase = false;
    mutable bool qcpselectionrect_draw_isbase = false;
    mutable bool qcpselectionrect_selecttest_isbase = false;
    mutable bool qcpselectionrect_parentplotinitialized_isbase = false;
    mutable bool qcpselectionrect_selectioncategory_isbase = false;
    mutable bool qcpselectionrect_cliprect_isbase = false;
    mutable bool qcpselectionrect_selectevent_isbase = false;
    mutable bool qcpselectionrect_deselectevent_isbase = false;
    mutable bool qcpselectionrect_mousepressevent_isbase = false;
    mutable bool qcpselectionrect_mousemoveevent_isbase = false;
    mutable bool qcpselectionrect_mousereleaseevent_isbase = false;
    mutable bool qcpselectionrect_mousedoubleclickevent_isbase = false;
    mutable bool qcpselectionrect_wheelevent_isbase = false;
    mutable bool qcpselectionrect_event_isbase = false;
    mutable bool qcpselectionrect_eventfilter_isbase = false;
    mutable bool qcpselectionrect_timerevent_isbase = false;
    mutable bool qcpselectionrect_childevent_isbase = false;
    mutable bool qcpselectionrect_customevent_isbase = false;
    mutable bool qcpselectionrect_connectnotify_isbase = false;
    mutable bool qcpselectionrect_disconnectnotify_isbase = false;
    mutable bool qcpselectionrect_initializeparentplot_isbase = false;
    mutable bool qcpselectionrect_setparentlayerable_isbase = false;
    mutable bool qcpselectionrect_movetolayer_isbase = false;
    mutable bool qcpselectionrect_applyantialiasinghint_isbase = false;
    mutable bool qcpselectionrect_sender_isbase = false;
    mutable bool qcpselectionrect_sendersignalindex_isbase = false;
    mutable bool qcpselectionrect_receivers_isbase = false;
    mutable bool qcpselectionrect_issignalconnected_isbase = false;

  public:
    VirtualQCPSelectionRect(QCustomPlot* parentPlot) : QCPSelectionRect(parentPlot) {};

    ~VirtualQCPSelectionRect() {
        qcpselectionrect_metacall_callback = nullptr;
        qcpselectionrect_startselection_callback = nullptr;
        qcpselectionrect_moveselection_callback = nullptr;
        qcpselectionrect_endselection_callback = nullptr;
        qcpselectionrect_keypressevent_callback = nullptr;
        qcpselectionrect_applydefaultantialiasinghint_callback = nullptr;
        qcpselectionrect_draw_callback = nullptr;
        qcpselectionrect_selecttest_callback = nullptr;
        qcpselectionrect_parentplotinitialized_callback = nullptr;
        qcpselectionrect_selectioncategory_callback = nullptr;
        qcpselectionrect_cliprect_callback = nullptr;
        qcpselectionrect_selectevent_callback = nullptr;
        qcpselectionrect_deselectevent_callback = nullptr;
        qcpselectionrect_mousepressevent_callback = nullptr;
        qcpselectionrect_mousemoveevent_callback = nullptr;
        qcpselectionrect_mousereleaseevent_callback = nullptr;
        qcpselectionrect_mousedoubleclickevent_callback = nullptr;
        qcpselectionrect_wheelevent_callback = nullptr;
        qcpselectionrect_event_callback = nullptr;
        qcpselectionrect_eventfilter_callback = nullptr;
        qcpselectionrect_timerevent_callback = nullptr;
        qcpselectionrect_childevent_callback = nullptr;
        qcpselectionrect_customevent_callback = nullptr;
        qcpselectionrect_connectnotify_callback = nullptr;
        qcpselectionrect_disconnectnotify_callback = nullptr;
        qcpselectionrect_initializeparentplot_callback = nullptr;
        qcpselectionrect_setparentlayerable_callback = nullptr;
        qcpselectionrect_movetolayer_callback = nullptr;
        qcpselectionrect_applyantialiasinghint_callback = nullptr;
        qcpselectionrect_sender_callback = nullptr;
        qcpselectionrect_sendersignalindex_callback = nullptr;
        qcpselectionrect_receivers_callback = nullptr;
        qcpselectionrect_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPSelectionRect_Metacall_Callback(QCPSelectionRect_Metacall_Callback cb) { qcpselectionrect_metacall_callback = cb; }
    inline void setQCPSelectionRect_StartSelection_Callback(QCPSelectionRect_StartSelection_Callback cb) { qcpselectionrect_startselection_callback = cb; }
    inline void setQCPSelectionRect_MoveSelection_Callback(QCPSelectionRect_MoveSelection_Callback cb) { qcpselectionrect_moveselection_callback = cb; }
    inline void setQCPSelectionRect_EndSelection_Callback(QCPSelectionRect_EndSelection_Callback cb) { qcpselectionrect_endselection_callback = cb; }
    inline void setQCPSelectionRect_KeyPressEvent_Callback(QCPSelectionRect_KeyPressEvent_Callback cb) { qcpselectionrect_keypressevent_callback = cb; }
    inline void setQCPSelectionRect_ApplyDefaultAntialiasingHint_Callback(QCPSelectionRect_ApplyDefaultAntialiasingHint_Callback cb) { qcpselectionrect_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPSelectionRect_Draw_Callback(QCPSelectionRect_Draw_Callback cb) { qcpselectionrect_draw_callback = cb; }
    inline void setQCPSelectionRect_SelectTest_Callback(QCPSelectionRect_SelectTest_Callback cb) { qcpselectionrect_selecttest_callback = cb; }
    inline void setQCPSelectionRect_ParentPlotInitialized_Callback(QCPSelectionRect_ParentPlotInitialized_Callback cb) { qcpselectionrect_parentplotinitialized_callback = cb; }
    inline void setQCPSelectionRect_SelectionCategory_Callback(QCPSelectionRect_SelectionCategory_Callback cb) { qcpselectionrect_selectioncategory_callback = cb; }
    inline void setQCPSelectionRect_ClipRect_Callback(QCPSelectionRect_ClipRect_Callback cb) { qcpselectionrect_cliprect_callback = cb; }
    inline void setQCPSelectionRect_SelectEvent_Callback(QCPSelectionRect_SelectEvent_Callback cb) { qcpselectionrect_selectevent_callback = cb; }
    inline void setQCPSelectionRect_DeselectEvent_Callback(QCPSelectionRect_DeselectEvent_Callback cb) { qcpselectionrect_deselectevent_callback = cb; }
    inline void setQCPSelectionRect_MousePressEvent_Callback(QCPSelectionRect_MousePressEvent_Callback cb) { qcpselectionrect_mousepressevent_callback = cb; }
    inline void setQCPSelectionRect_MouseMoveEvent_Callback(QCPSelectionRect_MouseMoveEvent_Callback cb) { qcpselectionrect_mousemoveevent_callback = cb; }
    inline void setQCPSelectionRect_MouseReleaseEvent_Callback(QCPSelectionRect_MouseReleaseEvent_Callback cb) { qcpselectionrect_mousereleaseevent_callback = cb; }
    inline void setQCPSelectionRect_MouseDoubleClickEvent_Callback(QCPSelectionRect_MouseDoubleClickEvent_Callback cb) { qcpselectionrect_mousedoubleclickevent_callback = cb; }
    inline void setQCPSelectionRect_WheelEvent_Callback(QCPSelectionRect_WheelEvent_Callback cb) { qcpselectionrect_wheelevent_callback = cb; }
    inline void setQCPSelectionRect_Event_Callback(QCPSelectionRect_Event_Callback cb) { qcpselectionrect_event_callback = cb; }
    inline void setQCPSelectionRect_EventFilter_Callback(QCPSelectionRect_EventFilter_Callback cb) { qcpselectionrect_eventfilter_callback = cb; }
    inline void setQCPSelectionRect_TimerEvent_Callback(QCPSelectionRect_TimerEvent_Callback cb) { qcpselectionrect_timerevent_callback = cb; }
    inline void setQCPSelectionRect_ChildEvent_Callback(QCPSelectionRect_ChildEvent_Callback cb) { qcpselectionrect_childevent_callback = cb; }
    inline void setQCPSelectionRect_CustomEvent_Callback(QCPSelectionRect_CustomEvent_Callback cb) { qcpselectionrect_customevent_callback = cb; }
    inline void setQCPSelectionRect_ConnectNotify_Callback(QCPSelectionRect_ConnectNotify_Callback cb) { qcpselectionrect_connectnotify_callback = cb; }
    inline void setQCPSelectionRect_DisconnectNotify_Callback(QCPSelectionRect_DisconnectNotify_Callback cb) { qcpselectionrect_disconnectnotify_callback = cb; }
    inline void setQCPSelectionRect_InitializeParentPlot_Callback(QCPSelectionRect_InitializeParentPlot_Callback cb) { qcpselectionrect_initializeparentplot_callback = cb; }
    inline void setQCPSelectionRect_SetParentLayerable_Callback(QCPSelectionRect_SetParentLayerable_Callback cb) { qcpselectionrect_setparentlayerable_callback = cb; }
    inline void setQCPSelectionRect_MoveToLayer_Callback(QCPSelectionRect_MoveToLayer_Callback cb) { qcpselectionrect_movetolayer_callback = cb; }
    inline void setQCPSelectionRect_ApplyAntialiasingHint_Callback(QCPSelectionRect_ApplyAntialiasingHint_Callback cb) { qcpselectionrect_applyantialiasinghint_callback = cb; }
    inline void setQCPSelectionRect_Sender_Callback(QCPSelectionRect_Sender_Callback cb) { qcpselectionrect_sender_callback = cb; }
    inline void setQCPSelectionRect_SenderSignalIndex_Callback(QCPSelectionRect_SenderSignalIndex_Callback cb) { qcpselectionrect_sendersignalindex_callback = cb; }
    inline void setQCPSelectionRect_Receivers_Callback(QCPSelectionRect_Receivers_Callback cb) { qcpselectionrect_receivers_callback = cb; }
    inline void setQCPSelectionRect_IsSignalConnected_Callback(QCPSelectionRect_IsSignalConnected_Callback cb) { qcpselectionrect_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPSelectionRect_Metacall_IsBase(bool value) const { qcpselectionrect_metacall_isbase = value; }
    inline void setQCPSelectionRect_StartSelection_IsBase(bool value) const { qcpselectionrect_startselection_isbase = value; }
    inline void setQCPSelectionRect_MoveSelection_IsBase(bool value) const { qcpselectionrect_moveselection_isbase = value; }
    inline void setQCPSelectionRect_EndSelection_IsBase(bool value) const { qcpselectionrect_endselection_isbase = value; }
    inline void setQCPSelectionRect_KeyPressEvent_IsBase(bool value) const { qcpselectionrect_keypressevent_isbase = value; }
    inline void setQCPSelectionRect_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcpselectionrect_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPSelectionRect_Draw_IsBase(bool value) const { qcpselectionrect_draw_isbase = value; }
    inline void setQCPSelectionRect_SelectTest_IsBase(bool value) const { qcpselectionrect_selecttest_isbase = value; }
    inline void setQCPSelectionRect_ParentPlotInitialized_IsBase(bool value) const { qcpselectionrect_parentplotinitialized_isbase = value; }
    inline void setQCPSelectionRect_SelectionCategory_IsBase(bool value) const { qcpselectionrect_selectioncategory_isbase = value; }
    inline void setQCPSelectionRect_ClipRect_IsBase(bool value) const { qcpselectionrect_cliprect_isbase = value; }
    inline void setQCPSelectionRect_SelectEvent_IsBase(bool value) const { qcpselectionrect_selectevent_isbase = value; }
    inline void setQCPSelectionRect_DeselectEvent_IsBase(bool value) const { qcpselectionrect_deselectevent_isbase = value; }
    inline void setQCPSelectionRect_MousePressEvent_IsBase(bool value) const { qcpselectionrect_mousepressevent_isbase = value; }
    inline void setQCPSelectionRect_MouseMoveEvent_IsBase(bool value) const { qcpselectionrect_mousemoveevent_isbase = value; }
    inline void setQCPSelectionRect_MouseReleaseEvent_IsBase(bool value) const { qcpselectionrect_mousereleaseevent_isbase = value; }
    inline void setQCPSelectionRect_MouseDoubleClickEvent_IsBase(bool value) const { qcpselectionrect_mousedoubleclickevent_isbase = value; }
    inline void setQCPSelectionRect_WheelEvent_IsBase(bool value) const { qcpselectionrect_wheelevent_isbase = value; }
    inline void setQCPSelectionRect_Event_IsBase(bool value) const { qcpselectionrect_event_isbase = value; }
    inline void setQCPSelectionRect_EventFilter_IsBase(bool value) const { qcpselectionrect_eventfilter_isbase = value; }
    inline void setQCPSelectionRect_TimerEvent_IsBase(bool value) const { qcpselectionrect_timerevent_isbase = value; }
    inline void setQCPSelectionRect_ChildEvent_IsBase(bool value) const { qcpselectionrect_childevent_isbase = value; }
    inline void setQCPSelectionRect_CustomEvent_IsBase(bool value) const { qcpselectionrect_customevent_isbase = value; }
    inline void setQCPSelectionRect_ConnectNotify_IsBase(bool value) const { qcpselectionrect_connectnotify_isbase = value; }
    inline void setQCPSelectionRect_DisconnectNotify_IsBase(bool value) const { qcpselectionrect_disconnectnotify_isbase = value; }
    inline void setQCPSelectionRect_InitializeParentPlot_IsBase(bool value) const { qcpselectionrect_initializeparentplot_isbase = value; }
    inline void setQCPSelectionRect_SetParentLayerable_IsBase(bool value) const { qcpselectionrect_setparentlayerable_isbase = value; }
    inline void setQCPSelectionRect_MoveToLayer_IsBase(bool value) const { qcpselectionrect_movetolayer_isbase = value; }
    inline void setQCPSelectionRect_ApplyAntialiasingHint_IsBase(bool value) const { qcpselectionrect_applyantialiasinghint_isbase = value; }
    inline void setQCPSelectionRect_Sender_IsBase(bool value) const { qcpselectionrect_sender_isbase = value; }
    inline void setQCPSelectionRect_SenderSignalIndex_IsBase(bool value) const { qcpselectionrect_sendersignalindex_isbase = value; }
    inline void setQCPSelectionRect_Receivers_IsBase(bool value) const { qcpselectionrect_receivers_isbase = value; }
    inline void setQCPSelectionRect_IsSignalConnected_IsBase(bool value) const { qcpselectionrect_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpselectionrect_metacall_isbase) {
            qcpselectionrect_metacall_isbase = false;
            return QCPSelectionRect::qt_metacall(param1, param2, param3);
        } else if (qcpselectionrect_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpselectionrect_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPSelectionRect::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void startSelection(QMouseEvent* event) override {
        if (qcpselectionrect_startselection_isbase) {
            qcpselectionrect_startselection_isbase = false;
            QCPSelectionRect::startSelection(event);
        } else if (qcpselectionrect_startselection_callback != nullptr) {
            QMouseEvent* cbval1 = event;

            qcpselectionrect_startselection_callback(this, cbval1);
        } else {
            QCPSelectionRect::startSelection(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void moveSelection(QMouseEvent* event) override {
        if (qcpselectionrect_moveselection_isbase) {
            qcpselectionrect_moveselection_isbase = false;
            QCPSelectionRect::moveSelection(event);
        } else if (qcpselectionrect_moveselection_callback != nullptr) {
            QMouseEvent* cbval1 = event;

            qcpselectionrect_moveselection_callback(this, cbval1);
        } else {
            QCPSelectionRect::moveSelection(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void endSelection(QMouseEvent* event) override {
        if (qcpselectionrect_endselection_isbase) {
            qcpselectionrect_endselection_isbase = false;
            QCPSelectionRect::endSelection(event);
        } else if (qcpselectionrect_endselection_callback != nullptr) {
            QMouseEvent* cbval1 = event;

            qcpselectionrect_endselection_callback(this, cbval1);
        } else {
            QCPSelectionRect::endSelection(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void keyPressEvent(QKeyEvent* event) override {
        if (qcpselectionrect_keypressevent_isbase) {
            qcpselectionrect_keypressevent_isbase = false;
            QCPSelectionRect::keyPressEvent(event);
        } else if (qcpselectionrect_keypressevent_callback != nullptr) {
            QKeyEvent* cbval1 = event;

            qcpselectionrect_keypressevent_callback(this, cbval1);
        } else {
            QCPSelectionRect::keyPressEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcpselectionrect_applydefaultantialiasinghint_isbase) {
            qcpselectionrect_applydefaultantialiasinghint_isbase = false;
            QCPSelectionRect::applyDefaultAntialiasingHint(painter);
        } else if (qcpselectionrect_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpselectionrect_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPSelectionRect::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcpselectionrect_draw_isbase) {
            qcpselectionrect_draw_isbase = false;
            QCPSelectionRect::draw(painter);
        } else if (qcpselectionrect_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpselectionrect_draw_callback(this, cbval1);
        } else {
            QCPSelectionRect::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcpselectionrect_selecttest_isbase) {
            qcpselectionrect_selecttest_isbase = false;
            return QCPSelectionRect::selectTest(pos, onlySelectable, details);
        } else if (qcpselectionrect_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcpselectionrect_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPSelectionRect::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcpselectionrect_parentplotinitialized_isbase) {
            qcpselectionrect_parentplotinitialized_isbase = false;
            QCPSelectionRect::parentPlotInitialized(parentPlot);
        } else if (qcpselectionrect_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpselectionrect_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPSelectionRect::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcpselectionrect_selectioncategory_isbase) {
            qcpselectionrect_selectioncategory_isbase = false;
            return QCPSelectionRect::selectionCategory();
        } else if (qcpselectionrect_selectioncategory_callback != nullptr) {
            int callback_ret = qcpselectionrect_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPSelectionRect::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcpselectionrect_cliprect_isbase) {
            qcpselectionrect_cliprect_isbase = false;
            return QCPSelectionRect::clipRect();
        } else if (qcpselectionrect_cliprect_callback != nullptr) {
            QRect* callback_ret = qcpselectionrect_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPSelectionRect::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcpselectionrect_selectevent_isbase) {
            qcpselectionrect_selectevent_isbase = false;
            QCPSelectionRect::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcpselectionrect_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcpselectionrect_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPSelectionRect::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcpselectionrect_deselectevent_isbase) {
            qcpselectionrect_deselectevent_isbase = false;
            QCPSelectionRect::deselectEvent(selectionStateChanged);
        } else if (qcpselectionrect_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcpselectionrect_deselectevent_callback(this, cbval1);
        } else {
            QCPSelectionRect::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpselectionrect_mousepressevent_isbase) {
            qcpselectionrect_mousepressevent_isbase = false;
            QCPSelectionRect::mousePressEvent(event, details);
        } else if (qcpselectionrect_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpselectionrect_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPSelectionRect::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpselectionrect_mousemoveevent_isbase) {
            qcpselectionrect_mousemoveevent_isbase = false;
            QCPSelectionRect::mouseMoveEvent(event, startPos);
        } else if (qcpselectionrect_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpselectionrect_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPSelectionRect::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpselectionrect_mousereleaseevent_isbase) {
            qcpselectionrect_mousereleaseevent_isbase = false;
            QCPSelectionRect::mouseReleaseEvent(event, startPos);
        } else if (qcpselectionrect_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpselectionrect_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPSelectionRect::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpselectionrect_mousedoubleclickevent_isbase) {
            qcpselectionrect_mousedoubleclickevent_isbase = false;
            QCPSelectionRect::mouseDoubleClickEvent(event, details);
        } else if (qcpselectionrect_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpselectionrect_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPSelectionRect::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcpselectionrect_wheelevent_isbase) {
            qcpselectionrect_wheelevent_isbase = false;
            QCPSelectionRect::wheelEvent(event);
        } else if (qcpselectionrect_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcpselectionrect_wheelevent_callback(this, cbval1);
        } else {
            QCPSelectionRect::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpselectionrect_event_isbase) {
            qcpselectionrect_event_isbase = false;
            return QCPSelectionRect::event(event);
        } else if (qcpselectionrect_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpselectionrect_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPSelectionRect::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpselectionrect_eventfilter_isbase) {
            qcpselectionrect_eventfilter_isbase = false;
            return QCPSelectionRect::eventFilter(watched, event);
        } else if (qcpselectionrect_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpselectionrect_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPSelectionRect::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpselectionrect_timerevent_isbase) {
            qcpselectionrect_timerevent_isbase = false;
            QCPSelectionRect::timerEvent(event);
        } else if (qcpselectionrect_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpselectionrect_timerevent_callback(this, cbval1);
        } else {
            QCPSelectionRect::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpselectionrect_childevent_isbase) {
            qcpselectionrect_childevent_isbase = false;
            QCPSelectionRect::childEvent(event);
        } else if (qcpselectionrect_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpselectionrect_childevent_callback(this, cbval1);
        } else {
            QCPSelectionRect::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpselectionrect_customevent_isbase) {
            qcpselectionrect_customevent_isbase = false;
            QCPSelectionRect::customEvent(event);
        } else if (qcpselectionrect_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpselectionrect_customevent_callback(this, cbval1);
        } else {
            QCPSelectionRect::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpselectionrect_connectnotify_isbase) {
            qcpselectionrect_connectnotify_isbase = false;
            QCPSelectionRect::connectNotify(signal);
        } else if (qcpselectionrect_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpselectionrect_connectnotify_callback(this, cbval1);
        } else {
            QCPSelectionRect::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpselectionrect_disconnectnotify_isbase) {
            qcpselectionrect_disconnectnotify_isbase = false;
            QCPSelectionRect::disconnectNotify(signal);
        } else if (qcpselectionrect_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpselectionrect_disconnectnotify_callback(this, cbval1);
        } else {
            QCPSelectionRect::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcpselectionrect_initializeparentplot_isbase) {
            qcpselectionrect_initializeparentplot_isbase = false;
            QCPSelectionRect::initializeParentPlot(parentPlot);
        } else if (qcpselectionrect_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpselectionrect_initializeparentplot_callback(this, cbval1);
        } else {
            QCPSelectionRect::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcpselectionrect_setparentlayerable_isbase) {
            qcpselectionrect_setparentlayerable_isbase = false;
            QCPSelectionRect::setParentLayerable(parentLayerable);
        } else if (qcpselectionrect_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcpselectionrect_setparentlayerable_callback(this, cbval1);
        } else {
            QCPSelectionRect::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcpselectionrect_movetolayer_isbase) {
            qcpselectionrect_movetolayer_isbase = false;
            return QCPSelectionRect::moveToLayer(layer, prepend);
        } else if (qcpselectionrect_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcpselectionrect_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPSelectionRect::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcpselectionrect_applyantialiasinghint_isbase) {
            qcpselectionrect_applyantialiasinghint_isbase = false;
            QCPSelectionRect::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcpselectionrect_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcpselectionrect_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPSelectionRect::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpselectionrect_sender_isbase) {
            qcpselectionrect_sender_isbase = false;
            return QCPSelectionRect::sender();
        } else if (qcpselectionrect_sender_callback != nullptr) {
            QObject* callback_ret = qcpselectionrect_sender_callback();
            return callback_ret;
        } else {
            return QCPSelectionRect::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpselectionrect_sendersignalindex_isbase) {
            qcpselectionrect_sendersignalindex_isbase = false;
            return QCPSelectionRect::senderSignalIndex();
        } else if (qcpselectionrect_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpselectionrect_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPSelectionRect::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpselectionrect_receivers_isbase) {
            qcpselectionrect_receivers_isbase = false;
            return QCPSelectionRect::receivers(signal);
        } else if (qcpselectionrect_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpselectionrect_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPSelectionRect::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpselectionrect_issignalconnected_isbase) {
            qcpselectionrect_issignalconnected_isbase = false;
            return QCPSelectionRect::isSignalConnected(signal);
        } else if (qcpselectionrect_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpselectionrect_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPSelectionRect::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPSelectionRect_StartSelection(QCPSelectionRect* self, QMouseEvent* event);
    friend void QCPSelectionRect_QBaseStartSelection(QCPSelectionRect* self, QMouseEvent* event);
    friend void QCPSelectionRect_MoveSelection(QCPSelectionRect* self, QMouseEvent* event);
    friend void QCPSelectionRect_QBaseMoveSelection(QCPSelectionRect* self, QMouseEvent* event);
    friend void QCPSelectionRect_EndSelection(QCPSelectionRect* self, QMouseEvent* event);
    friend void QCPSelectionRect_QBaseEndSelection(QCPSelectionRect* self, QMouseEvent* event);
    friend void QCPSelectionRect_KeyPressEvent(QCPSelectionRect* self, QKeyEvent* event);
    friend void QCPSelectionRect_QBaseKeyPressEvent(QCPSelectionRect* self, QKeyEvent* event);
    friend void QCPSelectionRect_ApplyDefaultAntialiasingHint(const QCPSelectionRect* self, QCPPainter* painter);
    friend void QCPSelectionRect_QBaseApplyDefaultAntialiasingHint(const QCPSelectionRect* self, QCPPainter* painter);
    friend void QCPSelectionRect_Draw(QCPSelectionRect* self, QCPPainter* painter);
    friend void QCPSelectionRect_QBaseDraw(QCPSelectionRect* self, QCPPainter* painter);
    friend void QCPSelectionRect_ParentPlotInitialized(QCPSelectionRect* self, QCustomPlot* parentPlot);
    friend void QCPSelectionRect_QBaseParentPlotInitialized(QCPSelectionRect* self, QCustomPlot* parentPlot);
    friend int QCPSelectionRect_SelectionCategory(const QCPSelectionRect* self);
    friend int QCPSelectionRect_QBaseSelectionCategory(const QCPSelectionRect* self);
    friend QRect* QCPSelectionRect_ClipRect(const QCPSelectionRect* self);
    friend QRect* QCPSelectionRect_QBaseClipRect(const QCPSelectionRect* self);
    friend void QCPSelectionRect_SelectEvent(QCPSelectionRect* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPSelectionRect_QBaseSelectEvent(QCPSelectionRect* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPSelectionRect_DeselectEvent(QCPSelectionRect* self, bool* selectionStateChanged);
    friend void QCPSelectionRect_QBaseDeselectEvent(QCPSelectionRect* self, bool* selectionStateChanged);
    friend void QCPSelectionRect_MousePressEvent(QCPSelectionRect* self, QMouseEvent* event, const QVariant* details);
    friend void QCPSelectionRect_QBaseMousePressEvent(QCPSelectionRect* self, QMouseEvent* event, const QVariant* details);
    friend void QCPSelectionRect_MouseMoveEvent(QCPSelectionRect* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPSelectionRect_QBaseMouseMoveEvent(QCPSelectionRect* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPSelectionRect_MouseReleaseEvent(QCPSelectionRect* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPSelectionRect_QBaseMouseReleaseEvent(QCPSelectionRect* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPSelectionRect_MouseDoubleClickEvent(QCPSelectionRect* self, QMouseEvent* event, const QVariant* details);
    friend void QCPSelectionRect_QBaseMouseDoubleClickEvent(QCPSelectionRect* self, QMouseEvent* event, const QVariant* details);
    friend void QCPSelectionRect_WheelEvent(QCPSelectionRect* self, QWheelEvent* event);
    friend void QCPSelectionRect_QBaseWheelEvent(QCPSelectionRect* self, QWheelEvent* event);
    friend void QCPSelectionRect_TimerEvent(QCPSelectionRect* self, QTimerEvent* event);
    friend void QCPSelectionRect_QBaseTimerEvent(QCPSelectionRect* self, QTimerEvent* event);
    friend void QCPSelectionRect_ChildEvent(QCPSelectionRect* self, QChildEvent* event);
    friend void QCPSelectionRect_QBaseChildEvent(QCPSelectionRect* self, QChildEvent* event);
    friend void QCPSelectionRect_CustomEvent(QCPSelectionRect* self, QEvent* event);
    friend void QCPSelectionRect_QBaseCustomEvent(QCPSelectionRect* self, QEvent* event);
    friend void QCPSelectionRect_ConnectNotify(QCPSelectionRect* self, const QMetaMethod* signal);
    friend void QCPSelectionRect_QBaseConnectNotify(QCPSelectionRect* self, const QMetaMethod* signal);
    friend void QCPSelectionRect_DisconnectNotify(QCPSelectionRect* self, const QMetaMethod* signal);
    friend void QCPSelectionRect_QBaseDisconnectNotify(QCPSelectionRect* self, const QMetaMethod* signal);
    friend void QCPSelectionRect_InitializeParentPlot(QCPSelectionRect* self, QCustomPlot* parentPlot);
    friend void QCPSelectionRect_QBaseInitializeParentPlot(QCPSelectionRect* self, QCustomPlot* parentPlot);
    friend void QCPSelectionRect_SetParentLayerable(QCPSelectionRect* self, QCPLayerable* parentLayerable);
    friend void QCPSelectionRect_QBaseSetParentLayerable(QCPSelectionRect* self, QCPLayerable* parentLayerable);
    friend bool QCPSelectionRect_MoveToLayer(QCPSelectionRect* self, QCPLayer* layer, bool prepend);
    friend bool QCPSelectionRect_QBaseMoveToLayer(QCPSelectionRect* self, QCPLayer* layer, bool prepend);
    friend void QCPSelectionRect_ApplyAntialiasingHint(const QCPSelectionRect* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPSelectionRect_QBaseApplyAntialiasingHint(const QCPSelectionRect* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPSelectionRect_Sender(const QCPSelectionRect* self);
    friend QObject* QCPSelectionRect_QBaseSender(const QCPSelectionRect* self);
    friend int QCPSelectionRect_SenderSignalIndex(const QCPSelectionRect* self);
    friend int QCPSelectionRect_QBaseSenderSignalIndex(const QCPSelectionRect* self);
    friend int QCPSelectionRect_Receivers(const QCPSelectionRect* self, const char* signal);
    friend int QCPSelectionRect_QBaseReceivers(const QCPSelectionRect* self, const char* signal);
    friend bool QCPSelectionRect_IsSignalConnected(const QCPSelectionRect* self, const QMetaMethod* signal);
    friend bool QCPSelectionRect_QBaseIsSignalConnected(const QCPSelectionRect* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPMarginGroup so that we can call protected methods
class VirtualQCPMarginGroup final : public QCPMarginGroup {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPMarginGroup = true;

    // Virtual class public types (including callbacks)
    using QCPMarginGroup_Metacall_Callback = int (*)(QCPMarginGroup*, int, int, void**);
    using QCPMarginGroup_CommonMargin_Callback = int (*)(const QCPMarginGroup*, int);
    using QCPMarginGroup_Event_Callback = bool (*)(QCPMarginGroup*, QEvent*);
    using QCPMarginGroup_EventFilter_Callback = bool (*)(QCPMarginGroup*, QObject*, QEvent*);
    using QCPMarginGroup_TimerEvent_Callback = void (*)(QCPMarginGroup*, QTimerEvent*);
    using QCPMarginGroup_ChildEvent_Callback = void (*)(QCPMarginGroup*, QChildEvent*);
    using QCPMarginGroup_CustomEvent_Callback = void (*)(QCPMarginGroup*, QEvent*);
    using QCPMarginGroup_ConnectNotify_Callback = void (*)(QCPMarginGroup*, QMetaMethod*);
    using QCPMarginGroup_DisconnectNotify_Callback = void (*)(QCPMarginGroup*, QMetaMethod*);
    using QCPMarginGroup_AddChild_Callback = void (*)(QCPMarginGroup*, int, QCPLayoutElement*);
    using QCPMarginGroup_RemoveChild_Callback = void (*)(QCPMarginGroup*, int, QCPLayoutElement*);
    using QCPMarginGroup_Sender_Callback = QObject* (*)();
    using QCPMarginGroup_SenderSignalIndex_Callback = int (*)();
    using QCPMarginGroup_Receivers_Callback = int (*)(const QCPMarginGroup*, const char*);
    using QCPMarginGroup_IsSignalConnected_Callback = bool (*)(const QCPMarginGroup*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPMarginGroup_Metacall_Callback qcpmargingroup_metacall_callback = nullptr;
    QCPMarginGroup_CommonMargin_Callback qcpmargingroup_commonmargin_callback = nullptr;
    QCPMarginGroup_Event_Callback qcpmargingroup_event_callback = nullptr;
    QCPMarginGroup_EventFilter_Callback qcpmargingroup_eventfilter_callback = nullptr;
    QCPMarginGroup_TimerEvent_Callback qcpmargingroup_timerevent_callback = nullptr;
    QCPMarginGroup_ChildEvent_Callback qcpmargingroup_childevent_callback = nullptr;
    QCPMarginGroup_CustomEvent_Callback qcpmargingroup_customevent_callback = nullptr;
    QCPMarginGroup_ConnectNotify_Callback qcpmargingroup_connectnotify_callback = nullptr;
    QCPMarginGroup_DisconnectNotify_Callback qcpmargingroup_disconnectnotify_callback = nullptr;
    QCPMarginGroup_AddChild_Callback qcpmargingroup_addchild_callback = nullptr;
    QCPMarginGroup_RemoveChild_Callback qcpmargingroup_removechild_callback = nullptr;
    QCPMarginGroup_Sender_Callback qcpmargingroup_sender_callback = nullptr;
    QCPMarginGroup_SenderSignalIndex_Callback qcpmargingroup_sendersignalindex_callback = nullptr;
    QCPMarginGroup_Receivers_Callback qcpmargingroup_receivers_callback = nullptr;
    QCPMarginGroup_IsSignalConnected_Callback qcpmargingroup_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpmargingroup_metacall_isbase = false;
    mutable bool qcpmargingroup_commonmargin_isbase = false;
    mutable bool qcpmargingroup_event_isbase = false;
    mutable bool qcpmargingroup_eventfilter_isbase = false;
    mutable bool qcpmargingroup_timerevent_isbase = false;
    mutable bool qcpmargingroup_childevent_isbase = false;
    mutable bool qcpmargingroup_customevent_isbase = false;
    mutable bool qcpmargingroup_connectnotify_isbase = false;
    mutable bool qcpmargingroup_disconnectnotify_isbase = false;
    mutable bool qcpmargingroup_addchild_isbase = false;
    mutable bool qcpmargingroup_removechild_isbase = false;
    mutable bool qcpmargingroup_sender_isbase = false;
    mutable bool qcpmargingroup_sendersignalindex_isbase = false;
    mutable bool qcpmargingroup_receivers_isbase = false;
    mutable bool qcpmargingroup_issignalconnected_isbase = false;

  public:
    VirtualQCPMarginGroup(QCustomPlot* parentPlot) : QCPMarginGroup(parentPlot) {};

    ~VirtualQCPMarginGroup() {
        qcpmargingroup_metacall_callback = nullptr;
        qcpmargingroup_commonmargin_callback = nullptr;
        qcpmargingroup_event_callback = nullptr;
        qcpmargingroup_eventfilter_callback = nullptr;
        qcpmargingroup_timerevent_callback = nullptr;
        qcpmargingroup_childevent_callback = nullptr;
        qcpmargingroup_customevent_callback = nullptr;
        qcpmargingroup_connectnotify_callback = nullptr;
        qcpmargingroup_disconnectnotify_callback = nullptr;
        qcpmargingroup_addchild_callback = nullptr;
        qcpmargingroup_removechild_callback = nullptr;
        qcpmargingroup_sender_callback = nullptr;
        qcpmargingroup_sendersignalindex_callback = nullptr;
        qcpmargingroup_receivers_callback = nullptr;
        qcpmargingroup_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPMarginGroup_Metacall_Callback(QCPMarginGroup_Metacall_Callback cb) { qcpmargingroup_metacall_callback = cb; }
    inline void setQCPMarginGroup_CommonMargin_Callback(QCPMarginGroup_CommonMargin_Callback cb) { qcpmargingroup_commonmargin_callback = cb; }
    inline void setQCPMarginGroup_Event_Callback(QCPMarginGroup_Event_Callback cb) { qcpmargingroup_event_callback = cb; }
    inline void setQCPMarginGroup_EventFilter_Callback(QCPMarginGroup_EventFilter_Callback cb) { qcpmargingroup_eventfilter_callback = cb; }
    inline void setQCPMarginGroup_TimerEvent_Callback(QCPMarginGroup_TimerEvent_Callback cb) { qcpmargingroup_timerevent_callback = cb; }
    inline void setQCPMarginGroup_ChildEvent_Callback(QCPMarginGroup_ChildEvent_Callback cb) { qcpmargingroup_childevent_callback = cb; }
    inline void setQCPMarginGroup_CustomEvent_Callback(QCPMarginGroup_CustomEvent_Callback cb) { qcpmargingroup_customevent_callback = cb; }
    inline void setQCPMarginGroup_ConnectNotify_Callback(QCPMarginGroup_ConnectNotify_Callback cb) { qcpmargingroup_connectnotify_callback = cb; }
    inline void setQCPMarginGroup_DisconnectNotify_Callback(QCPMarginGroup_DisconnectNotify_Callback cb) { qcpmargingroup_disconnectnotify_callback = cb; }
    inline void setQCPMarginGroup_AddChild_Callback(QCPMarginGroup_AddChild_Callback cb) { qcpmargingroup_addchild_callback = cb; }
    inline void setQCPMarginGroup_RemoveChild_Callback(QCPMarginGroup_RemoveChild_Callback cb) { qcpmargingroup_removechild_callback = cb; }
    inline void setQCPMarginGroup_Sender_Callback(QCPMarginGroup_Sender_Callback cb) { qcpmargingroup_sender_callback = cb; }
    inline void setQCPMarginGroup_SenderSignalIndex_Callback(QCPMarginGroup_SenderSignalIndex_Callback cb) { qcpmargingroup_sendersignalindex_callback = cb; }
    inline void setQCPMarginGroup_Receivers_Callback(QCPMarginGroup_Receivers_Callback cb) { qcpmargingroup_receivers_callback = cb; }
    inline void setQCPMarginGroup_IsSignalConnected_Callback(QCPMarginGroup_IsSignalConnected_Callback cb) { qcpmargingroup_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPMarginGroup_Metacall_IsBase(bool value) const { qcpmargingroup_metacall_isbase = value; }
    inline void setQCPMarginGroup_CommonMargin_IsBase(bool value) const { qcpmargingroup_commonmargin_isbase = value; }
    inline void setQCPMarginGroup_Event_IsBase(bool value) const { qcpmargingroup_event_isbase = value; }
    inline void setQCPMarginGroup_EventFilter_IsBase(bool value) const { qcpmargingroup_eventfilter_isbase = value; }
    inline void setQCPMarginGroup_TimerEvent_IsBase(bool value) const { qcpmargingroup_timerevent_isbase = value; }
    inline void setQCPMarginGroup_ChildEvent_IsBase(bool value) const { qcpmargingroup_childevent_isbase = value; }
    inline void setQCPMarginGroup_CustomEvent_IsBase(bool value) const { qcpmargingroup_customevent_isbase = value; }
    inline void setQCPMarginGroup_ConnectNotify_IsBase(bool value) const { qcpmargingroup_connectnotify_isbase = value; }
    inline void setQCPMarginGroup_DisconnectNotify_IsBase(bool value) const { qcpmargingroup_disconnectnotify_isbase = value; }
    inline void setQCPMarginGroup_AddChild_IsBase(bool value) const { qcpmargingroup_addchild_isbase = value; }
    inline void setQCPMarginGroup_RemoveChild_IsBase(bool value) const { qcpmargingroup_removechild_isbase = value; }
    inline void setQCPMarginGroup_Sender_IsBase(bool value) const { qcpmargingroup_sender_isbase = value; }
    inline void setQCPMarginGroup_SenderSignalIndex_IsBase(bool value) const { qcpmargingroup_sendersignalindex_isbase = value; }
    inline void setQCPMarginGroup_Receivers_IsBase(bool value) const { qcpmargingroup_receivers_isbase = value; }
    inline void setQCPMarginGroup_IsSignalConnected_IsBase(bool value) const { qcpmargingroup_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpmargingroup_metacall_isbase) {
            qcpmargingroup_metacall_isbase = false;
            return QCPMarginGroup::qt_metacall(param1, param2, param3);
        } else if (qcpmargingroup_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpmargingroup_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPMarginGroup::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int commonMargin(QCP::MarginSide side) const override {
        if (qcpmargingroup_commonmargin_isbase) {
            qcpmargingroup_commonmargin_isbase = false;
            return QCPMarginGroup::commonMargin(side);
        } else if (qcpmargingroup_commonmargin_callback != nullptr) {
            int cbval1 = static_cast<int>(side);

            int callback_ret = qcpmargingroup_commonmargin_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPMarginGroup::commonMargin(side);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpmargingroup_event_isbase) {
            qcpmargingroup_event_isbase = false;
            return QCPMarginGroup::event(event);
        } else if (qcpmargingroup_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpmargingroup_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPMarginGroup::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpmargingroup_eventfilter_isbase) {
            qcpmargingroup_eventfilter_isbase = false;
            return QCPMarginGroup::eventFilter(watched, event);
        } else if (qcpmargingroup_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpmargingroup_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPMarginGroup::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpmargingroup_timerevent_isbase) {
            qcpmargingroup_timerevent_isbase = false;
            QCPMarginGroup::timerEvent(event);
        } else if (qcpmargingroup_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpmargingroup_timerevent_callback(this, cbval1);
        } else {
            QCPMarginGroup::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpmargingroup_childevent_isbase) {
            qcpmargingroup_childevent_isbase = false;
            QCPMarginGroup::childEvent(event);
        } else if (qcpmargingroup_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpmargingroup_childevent_callback(this, cbval1);
        } else {
            QCPMarginGroup::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpmargingroup_customevent_isbase) {
            qcpmargingroup_customevent_isbase = false;
            QCPMarginGroup::customEvent(event);
        } else if (qcpmargingroup_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpmargingroup_customevent_callback(this, cbval1);
        } else {
            QCPMarginGroup::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpmargingroup_connectnotify_isbase) {
            qcpmargingroup_connectnotify_isbase = false;
            QCPMarginGroup::connectNotify(signal);
        } else if (qcpmargingroup_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpmargingroup_connectnotify_callback(this, cbval1);
        } else {
            QCPMarginGroup::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpmargingroup_disconnectnotify_isbase) {
            qcpmargingroup_disconnectnotify_isbase = false;
            QCPMarginGroup::disconnectNotify(signal);
        } else if (qcpmargingroup_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpmargingroup_disconnectnotify_callback(this, cbval1);
        } else {
            QCPMarginGroup::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    void addChild(QCP::MarginSide side, QCPLayoutElement* element) {
        if (qcpmargingroup_addchild_isbase) {
            qcpmargingroup_addchild_isbase = false;
            QCPMarginGroup::addChild(side, element);
        } else if (qcpmargingroup_addchild_callback != nullptr) {
            int cbval1 = static_cast<int>(side);
            QCPLayoutElement* cbval2 = element;

            qcpmargingroup_addchild_callback(this, cbval1, cbval2);
        } else {
            QCPMarginGroup::addChild(side, element);
        }
    }

    // Virtual method for C ABI access and custom callback
    void removeChild(QCP::MarginSide side, QCPLayoutElement* element) {
        if (qcpmargingroup_removechild_isbase) {
            qcpmargingroup_removechild_isbase = false;
            QCPMarginGroup::removeChild(side, element);
        } else if (qcpmargingroup_removechild_callback != nullptr) {
            int cbval1 = static_cast<int>(side);
            QCPLayoutElement* cbval2 = element;

            qcpmargingroup_removechild_callback(this, cbval1, cbval2);
        } else {
            QCPMarginGroup::removeChild(side, element);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpmargingroup_sender_isbase) {
            qcpmargingroup_sender_isbase = false;
            return QCPMarginGroup::sender();
        } else if (qcpmargingroup_sender_callback != nullptr) {
            QObject* callback_ret = qcpmargingroup_sender_callback();
            return callback_ret;
        } else {
            return QCPMarginGroup::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpmargingroup_sendersignalindex_isbase) {
            qcpmargingroup_sendersignalindex_isbase = false;
            return QCPMarginGroup::senderSignalIndex();
        } else if (qcpmargingroup_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpmargingroup_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPMarginGroup::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpmargingroup_receivers_isbase) {
            qcpmargingroup_receivers_isbase = false;
            return QCPMarginGroup::receivers(signal);
        } else if (qcpmargingroup_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpmargingroup_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPMarginGroup::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpmargingroup_issignalconnected_isbase) {
            qcpmargingroup_issignalconnected_isbase = false;
            return QCPMarginGroup::isSignalConnected(signal);
        } else if (qcpmargingroup_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpmargingroup_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPMarginGroup::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend int QCPMarginGroup_CommonMargin(const QCPMarginGroup* self, int side);
    friend int QCPMarginGroup_QBaseCommonMargin(const QCPMarginGroup* self, int side);
    friend void QCPMarginGroup_TimerEvent(QCPMarginGroup* self, QTimerEvent* event);
    friend void QCPMarginGroup_QBaseTimerEvent(QCPMarginGroup* self, QTimerEvent* event);
    friend void QCPMarginGroup_ChildEvent(QCPMarginGroup* self, QChildEvent* event);
    friend void QCPMarginGroup_QBaseChildEvent(QCPMarginGroup* self, QChildEvent* event);
    friend void QCPMarginGroup_CustomEvent(QCPMarginGroup* self, QEvent* event);
    friend void QCPMarginGroup_QBaseCustomEvent(QCPMarginGroup* self, QEvent* event);
    friend void QCPMarginGroup_ConnectNotify(QCPMarginGroup* self, const QMetaMethod* signal);
    friend void QCPMarginGroup_QBaseConnectNotify(QCPMarginGroup* self, const QMetaMethod* signal);
    friend void QCPMarginGroup_DisconnectNotify(QCPMarginGroup* self, const QMetaMethod* signal);
    friend void QCPMarginGroup_QBaseDisconnectNotify(QCPMarginGroup* self, const QMetaMethod* signal);
    friend void QCPMarginGroup_AddChild(QCPMarginGroup* self, int side, QCPLayoutElement* element);
    friend void QCPMarginGroup_QBaseAddChild(QCPMarginGroup* self, int side, QCPLayoutElement* element);
    friend void QCPMarginGroup_RemoveChild(QCPMarginGroup* self, int side, QCPLayoutElement* element);
    friend void QCPMarginGroup_QBaseRemoveChild(QCPMarginGroup* self, int side, QCPLayoutElement* element);
    friend QObject* QCPMarginGroup_Sender(const QCPMarginGroup* self);
    friend QObject* QCPMarginGroup_QBaseSender(const QCPMarginGroup* self);
    friend int QCPMarginGroup_SenderSignalIndex(const QCPMarginGroup* self);
    friend int QCPMarginGroup_QBaseSenderSignalIndex(const QCPMarginGroup* self);
    friend int QCPMarginGroup_Receivers(const QCPMarginGroup* self, const char* signal);
    friend int QCPMarginGroup_QBaseReceivers(const QCPMarginGroup* self, const char* signal);
    friend bool QCPMarginGroup_IsSignalConnected(const QCPMarginGroup* self, const QMetaMethod* signal);
    friend bool QCPMarginGroup_QBaseIsSignalConnected(const QCPMarginGroup* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPLayoutElement so that we can call protected methods
class VirtualQCPLayoutElement final : public QCPLayoutElement {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPLayoutElement = true;

    // Virtual class public types (including callbacks)
    using QCPLayoutElement_Metacall_Callback = int (*)(QCPLayoutElement*, int, int, void**);
    using QCPLayoutElement_Update_Callback = void (*)(QCPLayoutElement*, int);
    using QCPLayoutElement_MinimumOuterSizeHint_Callback = QSize* (*)();
    using QCPLayoutElement_MaximumOuterSizeHint_Callback = QSize* (*)();
    using QCPLayoutElement_Elements_Callback = QCPLayoutElement** (*)(const QCPLayoutElement*, bool);
    using QCPLayoutElement_SelectTest_Callback = double (*)(const QCPLayoutElement*, QPointF*, bool, QVariant*);
    using QCPLayoutElement_CalculateAutoMargin_Callback = int (*)(QCPLayoutElement*, int);
    using QCPLayoutElement_LayoutChanged_Callback = void (*)();
    using QCPLayoutElement_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPLayoutElement*, QCPPainter*);
    using QCPLayoutElement_Draw_Callback = void (*)(QCPLayoutElement*, QCPPainter*);
    using QCPLayoutElement_ParentPlotInitialized_Callback = void (*)(QCPLayoutElement*, QCustomPlot*);
    using QCPLayoutElement_SelectionCategory_Callback = int (*)();
    using QCPLayoutElement_ClipRect_Callback = QRect* (*)();
    using QCPLayoutElement_SelectEvent_Callback = void (*)(QCPLayoutElement*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPLayoutElement_DeselectEvent_Callback = void (*)(QCPLayoutElement*, bool*);
    using QCPLayoutElement_MousePressEvent_Callback = void (*)(QCPLayoutElement*, QMouseEvent*, QVariant*);
    using QCPLayoutElement_MouseMoveEvent_Callback = void (*)(QCPLayoutElement*, QMouseEvent*, QPointF*);
    using QCPLayoutElement_MouseReleaseEvent_Callback = void (*)(QCPLayoutElement*, QMouseEvent*, QPointF*);
    using QCPLayoutElement_MouseDoubleClickEvent_Callback = void (*)(QCPLayoutElement*, QMouseEvent*, QVariant*);
    using QCPLayoutElement_WheelEvent_Callback = void (*)(QCPLayoutElement*, QWheelEvent*);
    using QCPLayoutElement_Event_Callback = bool (*)(QCPLayoutElement*, QEvent*);
    using QCPLayoutElement_EventFilter_Callback = bool (*)(QCPLayoutElement*, QObject*, QEvent*);
    using QCPLayoutElement_TimerEvent_Callback = void (*)(QCPLayoutElement*, QTimerEvent*);
    using QCPLayoutElement_ChildEvent_Callback = void (*)(QCPLayoutElement*, QChildEvent*);
    using QCPLayoutElement_CustomEvent_Callback = void (*)(QCPLayoutElement*, QEvent*);
    using QCPLayoutElement_ConnectNotify_Callback = void (*)(QCPLayoutElement*, QMetaMethod*);
    using QCPLayoutElement_DisconnectNotify_Callback = void (*)(QCPLayoutElement*, QMetaMethod*);
    using QCPLayoutElement_InitializeParentPlot_Callback = void (*)(QCPLayoutElement*, QCustomPlot*);
    using QCPLayoutElement_SetParentLayerable_Callback = void (*)(QCPLayoutElement*, QCPLayerable*);
    using QCPLayoutElement_MoveToLayer_Callback = bool (*)(QCPLayoutElement*, QCPLayer*, bool);
    using QCPLayoutElement_ApplyAntialiasingHint_Callback = void (*)(const QCPLayoutElement*, QCPPainter*, bool, int);
    using QCPLayoutElement_Sender_Callback = QObject* (*)();
    using QCPLayoutElement_SenderSignalIndex_Callback = int (*)();
    using QCPLayoutElement_Receivers_Callback = int (*)(const QCPLayoutElement*, const char*);
    using QCPLayoutElement_IsSignalConnected_Callback = bool (*)(const QCPLayoutElement*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPLayoutElement_Metacall_Callback qcplayoutelement_metacall_callback = nullptr;
    QCPLayoutElement_Update_Callback qcplayoutelement_update_callback = nullptr;
    QCPLayoutElement_MinimumOuterSizeHint_Callback qcplayoutelement_minimumoutersizehint_callback = nullptr;
    QCPLayoutElement_MaximumOuterSizeHint_Callback qcplayoutelement_maximumoutersizehint_callback = nullptr;
    QCPLayoutElement_Elements_Callback qcplayoutelement_elements_callback = nullptr;
    QCPLayoutElement_SelectTest_Callback qcplayoutelement_selecttest_callback = nullptr;
    QCPLayoutElement_CalculateAutoMargin_Callback qcplayoutelement_calculateautomargin_callback = nullptr;
    QCPLayoutElement_LayoutChanged_Callback qcplayoutelement_layoutchanged_callback = nullptr;
    QCPLayoutElement_ApplyDefaultAntialiasingHint_Callback qcplayoutelement_applydefaultantialiasinghint_callback = nullptr;
    QCPLayoutElement_Draw_Callback qcplayoutelement_draw_callback = nullptr;
    QCPLayoutElement_ParentPlotInitialized_Callback qcplayoutelement_parentplotinitialized_callback = nullptr;
    QCPLayoutElement_SelectionCategory_Callback qcplayoutelement_selectioncategory_callback = nullptr;
    QCPLayoutElement_ClipRect_Callback qcplayoutelement_cliprect_callback = nullptr;
    QCPLayoutElement_SelectEvent_Callback qcplayoutelement_selectevent_callback = nullptr;
    QCPLayoutElement_DeselectEvent_Callback qcplayoutelement_deselectevent_callback = nullptr;
    QCPLayoutElement_MousePressEvent_Callback qcplayoutelement_mousepressevent_callback = nullptr;
    QCPLayoutElement_MouseMoveEvent_Callback qcplayoutelement_mousemoveevent_callback = nullptr;
    QCPLayoutElement_MouseReleaseEvent_Callback qcplayoutelement_mousereleaseevent_callback = nullptr;
    QCPLayoutElement_MouseDoubleClickEvent_Callback qcplayoutelement_mousedoubleclickevent_callback = nullptr;
    QCPLayoutElement_WheelEvent_Callback qcplayoutelement_wheelevent_callback = nullptr;
    QCPLayoutElement_Event_Callback qcplayoutelement_event_callback = nullptr;
    QCPLayoutElement_EventFilter_Callback qcplayoutelement_eventfilter_callback = nullptr;
    QCPLayoutElement_TimerEvent_Callback qcplayoutelement_timerevent_callback = nullptr;
    QCPLayoutElement_ChildEvent_Callback qcplayoutelement_childevent_callback = nullptr;
    QCPLayoutElement_CustomEvent_Callback qcplayoutelement_customevent_callback = nullptr;
    QCPLayoutElement_ConnectNotify_Callback qcplayoutelement_connectnotify_callback = nullptr;
    QCPLayoutElement_DisconnectNotify_Callback qcplayoutelement_disconnectnotify_callback = nullptr;
    QCPLayoutElement_InitializeParentPlot_Callback qcplayoutelement_initializeparentplot_callback = nullptr;
    QCPLayoutElement_SetParentLayerable_Callback qcplayoutelement_setparentlayerable_callback = nullptr;
    QCPLayoutElement_MoveToLayer_Callback qcplayoutelement_movetolayer_callback = nullptr;
    QCPLayoutElement_ApplyAntialiasingHint_Callback qcplayoutelement_applyantialiasinghint_callback = nullptr;
    QCPLayoutElement_Sender_Callback qcplayoutelement_sender_callback = nullptr;
    QCPLayoutElement_SenderSignalIndex_Callback qcplayoutelement_sendersignalindex_callback = nullptr;
    QCPLayoutElement_Receivers_Callback qcplayoutelement_receivers_callback = nullptr;
    QCPLayoutElement_IsSignalConnected_Callback qcplayoutelement_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcplayoutelement_metacall_isbase = false;
    mutable bool qcplayoutelement_update_isbase = false;
    mutable bool qcplayoutelement_minimumoutersizehint_isbase = false;
    mutable bool qcplayoutelement_maximumoutersizehint_isbase = false;
    mutable bool qcplayoutelement_elements_isbase = false;
    mutable bool qcplayoutelement_selecttest_isbase = false;
    mutable bool qcplayoutelement_calculateautomargin_isbase = false;
    mutable bool qcplayoutelement_layoutchanged_isbase = false;
    mutable bool qcplayoutelement_applydefaultantialiasinghint_isbase = false;
    mutable bool qcplayoutelement_draw_isbase = false;
    mutable bool qcplayoutelement_parentplotinitialized_isbase = false;
    mutable bool qcplayoutelement_selectioncategory_isbase = false;
    mutable bool qcplayoutelement_cliprect_isbase = false;
    mutable bool qcplayoutelement_selectevent_isbase = false;
    mutable bool qcplayoutelement_deselectevent_isbase = false;
    mutable bool qcplayoutelement_mousepressevent_isbase = false;
    mutable bool qcplayoutelement_mousemoveevent_isbase = false;
    mutable bool qcplayoutelement_mousereleaseevent_isbase = false;
    mutable bool qcplayoutelement_mousedoubleclickevent_isbase = false;
    mutable bool qcplayoutelement_wheelevent_isbase = false;
    mutable bool qcplayoutelement_event_isbase = false;
    mutable bool qcplayoutelement_eventfilter_isbase = false;
    mutable bool qcplayoutelement_timerevent_isbase = false;
    mutable bool qcplayoutelement_childevent_isbase = false;
    mutable bool qcplayoutelement_customevent_isbase = false;
    mutable bool qcplayoutelement_connectnotify_isbase = false;
    mutable bool qcplayoutelement_disconnectnotify_isbase = false;
    mutable bool qcplayoutelement_initializeparentplot_isbase = false;
    mutable bool qcplayoutelement_setparentlayerable_isbase = false;
    mutable bool qcplayoutelement_movetolayer_isbase = false;
    mutable bool qcplayoutelement_applyantialiasinghint_isbase = false;
    mutable bool qcplayoutelement_sender_isbase = false;
    mutable bool qcplayoutelement_sendersignalindex_isbase = false;
    mutable bool qcplayoutelement_receivers_isbase = false;
    mutable bool qcplayoutelement_issignalconnected_isbase = false;

  public:
    VirtualQCPLayoutElement() : QCPLayoutElement() {};
    VirtualQCPLayoutElement(QCustomPlot* parentPlot) : QCPLayoutElement(parentPlot) {};

    ~VirtualQCPLayoutElement() {
        qcplayoutelement_metacall_callback = nullptr;
        qcplayoutelement_update_callback = nullptr;
        qcplayoutelement_minimumoutersizehint_callback = nullptr;
        qcplayoutelement_maximumoutersizehint_callback = nullptr;
        qcplayoutelement_elements_callback = nullptr;
        qcplayoutelement_selecttest_callback = nullptr;
        qcplayoutelement_calculateautomargin_callback = nullptr;
        qcplayoutelement_layoutchanged_callback = nullptr;
        qcplayoutelement_applydefaultantialiasinghint_callback = nullptr;
        qcplayoutelement_draw_callback = nullptr;
        qcplayoutelement_parentplotinitialized_callback = nullptr;
        qcplayoutelement_selectioncategory_callback = nullptr;
        qcplayoutelement_cliprect_callback = nullptr;
        qcplayoutelement_selectevent_callback = nullptr;
        qcplayoutelement_deselectevent_callback = nullptr;
        qcplayoutelement_mousepressevent_callback = nullptr;
        qcplayoutelement_mousemoveevent_callback = nullptr;
        qcplayoutelement_mousereleaseevent_callback = nullptr;
        qcplayoutelement_mousedoubleclickevent_callback = nullptr;
        qcplayoutelement_wheelevent_callback = nullptr;
        qcplayoutelement_event_callback = nullptr;
        qcplayoutelement_eventfilter_callback = nullptr;
        qcplayoutelement_timerevent_callback = nullptr;
        qcplayoutelement_childevent_callback = nullptr;
        qcplayoutelement_customevent_callback = nullptr;
        qcplayoutelement_connectnotify_callback = nullptr;
        qcplayoutelement_disconnectnotify_callback = nullptr;
        qcplayoutelement_initializeparentplot_callback = nullptr;
        qcplayoutelement_setparentlayerable_callback = nullptr;
        qcplayoutelement_movetolayer_callback = nullptr;
        qcplayoutelement_applyantialiasinghint_callback = nullptr;
        qcplayoutelement_sender_callback = nullptr;
        qcplayoutelement_sendersignalindex_callback = nullptr;
        qcplayoutelement_receivers_callback = nullptr;
        qcplayoutelement_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPLayoutElement_Metacall_Callback(QCPLayoutElement_Metacall_Callback cb) { qcplayoutelement_metacall_callback = cb; }
    inline void setQCPLayoutElement_Update_Callback(QCPLayoutElement_Update_Callback cb) { qcplayoutelement_update_callback = cb; }
    inline void setQCPLayoutElement_MinimumOuterSizeHint_Callback(QCPLayoutElement_MinimumOuterSizeHint_Callback cb) { qcplayoutelement_minimumoutersizehint_callback = cb; }
    inline void setQCPLayoutElement_MaximumOuterSizeHint_Callback(QCPLayoutElement_MaximumOuterSizeHint_Callback cb) { qcplayoutelement_maximumoutersizehint_callback = cb; }
    inline void setQCPLayoutElement_Elements_Callback(QCPLayoutElement_Elements_Callback cb) { qcplayoutelement_elements_callback = cb; }
    inline void setQCPLayoutElement_SelectTest_Callback(QCPLayoutElement_SelectTest_Callback cb) { qcplayoutelement_selecttest_callback = cb; }
    inline void setQCPLayoutElement_CalculateAutoMargin_Callback(QCPLayoutElement_CalculateAutoMargin_Callback cb) { qcplayoutelement_calculateautomargin_callback = cb; }
    inline void setQCPLayoutElement_LayoutChanged_Callback(QCPLayoutElement_LayoutChanged_Callback cb) { qcplayoutelement_layoutchanged_callback = cb; }
    inline void setQCPLayoutElement_ApplyDefaultAntialiasingHint_Callback(QCPLayoutElement_ApplyDefaultAntialiasingHint_Callback cb) { qcplayoutelement_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPLayoutElement_Draw_Callback(QCPLayoutElement_Draw_Callback cb) { qcplayoutelement_draw_callback = cb; }
    inline void setQCPLayoutElement_ParentPlotInitialized_Callback(QCPLayoutElement_ParentPlotInitialized_Callback cb) { qcplayoutelement_parentplotinitialized_callback = cb; }
    inline void setQCPLayoutElement_SelectionCategory_Callback(QCPLayoutElement_SelectionCategory_Callback cb) { qcplayoutelement_selectioncategory_callback = cb; }
    inline void setQCPLayoutElement_ClipRect_Callback(QCPLayoutElement_ClipRect_Callback cb) { qcplayoutelement_cliprect_callback = cb; }
    inline void setQCPLayoutElement_SelectEvent_Callback(QCPLayoutElement_SelectEvent_Callback cb) { qcplayoutelement_selectevent_callback = cb; }
    inline void setQCPLayoutElement_DeselectEvent_Callback(QCPLayoutElement_DeselectEvent_Callback cb) { qcplayoutelement_deselectevent_callback = cb; }
    inline void setQCPLayoutElement_MousePressEvent_Callback(QCPLayoutElement_MousePressEvent_Callback cb) { qcplayoutelement_mousepressevent_callback = cb; }
    inline void setQCPLayoutElement_MouseMoveEvent_Callback(QCPLayoutElement_MouseMoveEvent_Callback cb) { qcplayoutelement_mousemoveevent_callback = cb; }
    inline void setQCPLayoutElement_MouseReleaseEvent_Callback(QCPLayoutElement_MouseReleaseEvent_Callback cb) { qcplayoutelement_mousereleaseevent_callback = cb; }
    inline void setQCPLayoutElement_MouseDoubleClickEvent_Callback(QCPLayoutElement_MouseDoubleClickEvent_Callback cb) { qcplayoutelement_mousedoubleclickevent_callback = cb; }
    inline void setQCPLayoutElement_WheelEvent_Callback(QCPLayoutElement_WheelEvent_Callback cb) { qcplayoutelement_wheelevent_callback = cb; }
    inline void setQCPLayoutElement_Event_Callback(QCPLayoutElement_Event_Callback cb) { qcplayoutelement_event_callback = cb; }
    inline void setQCPLayoutElement_EventFilter_Callback(QCPLayoutElement_EventFilter_Callback cb) { qcplayoutelement_eventfilter_callback = cb; }
    inline void setQCPLayoutElement_TimerEvent_Callback(QCPLayoutElement_TimerEvent_Callback cb) { qcplayoutelement_timerevent_callback = cb; }
    inline void setQCPLayoutElement_ChildEvent_Callback(QCPLayoutElement_ChildEvent_Callback cb) { qcplayoutelement_childevent_callback = cb; }
    inline void setQCPLayoutElement_CustomEvent_Callback(QCPLayoutElement_CustomEvent_Callback cb) { qcplayoutelement_customevent_callback = cb; }
    inline void setQCPLayoutElement_ConnectNotify_Callback(QCPLayoutElement_ConnectNotify_Callback cb) { qcplayoutelement_connectnotify_callback = cb; }
    inline void setQCPLayoutElement_DisconnectNotify_Callback(QCPLayoutElement_DisconnectNotify_Callback cb) { qcplayoutelement_disconnectnotify_callback = cb; }
    inline void setQCPLayoutElement_InitializeParentPlot_Callback(QCPLayoutElement_InitializeParentPlot_Callback cb) { qcplayoutelement_initializeparentplot_callback = cb; }
    inline void setQCPLayoutElement_SetParentLayerable_Callback(QCPLayoutElement_SetParentLayerable_Callback cb) { qcplayoutelement_setparentlayerable_callback = cb; }
    inline void setQCPLayoutElement_MoveToLayer_Callback(QCPLayoutElement_MoveToLayer_Callback cb) { qcplayoutelement_movetolayer_callback = cb; }
    inline void setQCPLayoutElement_ApplyAntialiasingHint_Callback(QCPLayoutElement_ApplyAntialiasingHint_Callback cb) { qcplayoutelement_applyantialiasinghint_callback = cb; }
    inline void setQCPLayoutElement_Sender_Callback(QCPLayoutElement_Sender_Callback cb) { qcplayoutelement_sender_callback = cb; }
    inline void setQCPLayoutElement_SenderSignalIndex_Callback(QCPLayoutElement_SenderSignalIndex_Callback cb) { qcplayoutelement_sendersignalindex_callback = cb; }
    inline void setQCPLayoutElement_Receivers_Callback(QCPLayoutElement_Receivers_Callback cb) { qcplayoutelement_receivers_callback = cb; }
    inline void setQCPLayoutElement_IsSignalConnected_Callback(QCPLayoutElement_IsSignalConnected_Callback cb) { qcplayoutelement_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPLayoutElement_Metacall_IsBase(bool value) const { qcplayoutelement_metacall_isbase = value; }
    inline void setQCPLayoutElement_Update_IsBase(bool value) const { qcplayoutelement_update_isbase = value; }
    inline void setQCPLayoutElement_MinimumOuterSizeHint_IsBase(bool value) const { qcplayoutelement_minimumoutersizehint_isbase = value; }
    inline void setQCPLayoutElement_MaximumOuterSizeHint_IsBase(bool value) const { qcplayoutelement_maximumoutersizehint_isbase = value; }
    inline void setQCPLayoutElement_Elements_IsBase(bool value) const { qcplayoutelement_elements_isbase = value; }
    inline void setQCPLayoutElement_SelectTest_IsBase(bool value) const { qcplayoutelement_selecttest_isbase = value; }
    inline void setQCPLayoutElement_CalculateAutoMargin_IsBase(bool value) const { qcplayoutelement_calculateautomargin_isbase = value; }
    inline void setQCPLayoutElement_LayoutChanged_IsBase(bool value) const { qcplayoutelement_layoutchanged_isbase = value; }
    inline void setQCPLayoutElement_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcplayoutelement_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPLayoutElement_Draw_IsBase(bool value) const { qcplayoutelement_draw_isbase = value; }
    inline void setQCPLayoutElement_ParentPlotInitialized_IsBase(bool value) const { qcplayoutelement_parentplotinitialized_isbase = value; }
    inline void setQCPLayoutElement_SelectionCategory_IsBase(bool value) const { qcplayoutelement_selectioncategory_isbase = value; }
    inline void setQCPLayoutElement_ClipRect_IsBase(bool value) const { qcplayoutelement_cliprect_isbase = value; }
    inline void setQCPLayoutElement_SelectEvent_IsBase(bool value) const { qcplayoutelement_selectevent_isbase = value; }
    inline void setQCPLayoutElement_DeselectEvent_IsBase(bool value) const { qcplayoutelement_deselectevent_isbase = value; }
    inline void setQCPLayoutElement_MousePressEvent_IsBase(bool value) const { qcplayoutelement_mousepressevent_isbase = value; }
    inline void setQCPLayoutElement_MouseMoveEvent_IsBase(bool value) const { qcplayoutelement_mousemoveevent_isbase = value; }
    inline void setQCPLayoutElement_MouseReleaseEvent_IsBase(bool value) const { qcplayoutelement_mousereleaseevent_isbase = value; }
    inline void setQCPLayoutElement_MouseDoubleClickEvent_IsBase(bool value) const { qcplayoutelement_mousedoubleclickevent_isbase = value; }
    inline void setQCPLayoutElement_WheelEvent_IsBase(bool value) const { qcplayoutelement_wheelevent_isbase = value; }
    inline void setQCPLayoutElement_Event_IsBase(bool value) const { qcplayoutelement_event_isbase = value; }
    inline void setQCPLayoutElement_EventFilter_IsBase(bool value) const { qcplayoutelement_eventfilter_isbase = value; }
    inline void setQCPLayoutElement_TimerEvent_IsBase(bool value) const { qcplayoutelement_timerevent_isbase = value; }
    inline void setQCPLayoutElement_ChildEvent_IsBase(bool value) const { qcplayoutelement_childevent_isbase = value; }
    inline void setQCPLayoutElement_CustomEvent_IsBase(bool value) const { qcplayoutelement_customevent_isbase = value; }
    inline void setQCPLayoutElement_ConnectNotify_IsBase(bool value) const { qcplayoutelement_connectnotify_isbase = value; }
    inline void setQCPLayoutElement_DisconnectNotify_IsBase(bool value) const { qcplayoutelement_disconnectnotify_isbase = value; }
    inline void setQCPLayoutElement_InitializeParentPlot_IsBase(bool value) const { qcplayoutelement_initializeparentplot_isbase = value; }
    inline void setQCPLayoutElement_SetParentLayerable_IsBase(bool value) const { qcplayoutelement_setparentlayerable_isbase = value; }
    inline void setQCPLayoutElement_MoveToLayer_IsBase(bool value) const { qcplayoutelement_movetolayer_isbase = value; }
    inline void setQCPLayoutElement_ApplyAntialiasingHint_IsBase(bool value) const { qcplayoutelement_applyantialiasinghint_isbase = value; }
    inline void setQCPLayoutElement_Sender_IsBase(bool value) const { qcplayoutelement_sender_isbase = value; }
    inline void setQCPLayoutElement_SenderSignalIndex_IsBase(bool value) const { qcplayoutelement_sendersignalindex_isbase = value; }
    inline void setQCPLayoutElement_Receivers_IsBase(bool value) const { qcplayoutelement_receivers_isbase = value; }
    inline void setQCPLayoutElement_IsSignalConnected_IsBase(bool value) const { qcplayoutelement_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcplayoutelement_metacall_isbase) {
            qcplayoutelement_metacall_isbase = false;
            return QCPLayoutElement::qt_metacall(param1, param2, param3);
        } else if (qcplayoutelement_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcplayoutelement_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPLayoutElement::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void update(QCPLayoutElement::UpdatePhase phase) override {
        if (qcplayoutelement_update_isbase) {
            qcplayoutelement_update_isbase = false;
            QCPLayoutElement::update(phase);
        } else if (qcplayoutelement_update_callback != nullptr) {
            int cbval1 = static_cast<int>(phase);

            qcplayoutelement_update_callback(this, cbval1);
        } else {
            QCPLayoutElement::update(phase);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize minimumOuterSizeHint() const override {
        if (qcplayoutelement_minimumoutersizehint_isbase) {
            qcplayoutelement_minimumoutersizehint_isbase = false;
            return QCPLayoutElement::minimumOuterSizeHint();
        } else if (qcplayoutelement_minimumoutersizehint_callback != nullptr) {
            QSize* callback_ret = qcplayoutelement_minimumoutersizehint_callback();
            return *callback_ret;
        } else {
            return QCPLayoutElement::minimumOuterSizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize maximumOuterSizeHint() const override {
        if (qcplayoutelement_maximumoutersizehint_isbase) {
            qcplayoutelement_maximumoutersizehint_isbase = false;
            return QCPLayoutElement::maximumOuterSizeHint();
        } else if (qcplayoutelement_maximumoutersizehint_callback != nullptr) {
            QSize* callback_ret = qcplayoutelement_maximumoutersizehint_callback();
            return *callback_ret;
        } else {
            return QCPLayoutElement::maximumOuterSizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QList<QCPLayoutElement*> elements(bool recursive) const override {
        if (qcplayoutelement_elements_isbase) {
            qcplayoutelement_elements_isbase = false;
            return QCPLayoutElement::elements(recursive);
        } else if (qcplayoutelement_elements_callback != nullptr) {
            bool cbval1 = recursive;

            QCPLayoutElement** callback_ret = qcplayoutelement_elements_callback(this, cbval1);
            QList<QCPLayoutElement*> callback_ret_QList;
            // Iterate until null pointer sentinel
            for (QCPLayoutElement** ptridx = callback_ret; *ptridx != nullptr; ptridx++) {
                callback_ret_QList.push_back(*ptridx);
            }
            free(callback_ret);
            return callback_ret_QList;
        } else {
            return QCPLayoutElement::elements(recursive);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcplayoutelement_selecttest_isbase) {
            qcplayoutelement_selecttest_isbase = false;
            return QCPLayoutElement::selectTest(pos, onlySelectable, details);
        } else if (qcplayoutelement_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcplayoutelement_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPLayoutElement::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int calculateAutoMargin(QCP::MarginSide side) override {
        if (qcplayoutelement_calculateautomargin_isbase) {
            qcplayoutelement_calculateautomargin_isbase = false;
            return QCPLayoutElement::calculateAutoMargin(side);
        } else if (qcplayoutelement_calculateautomargin_callback != nullptr) {
            int cbval1 = static_cast<int>(side);

            int callback_ret = qcplayoutelement_calculateautomargin_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPLayoutElement::calculateAutoMargin(side);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void layoutChanged() override {
        if (qcplayoutelement_layoutchanged_isbase) {
            qcplayoutelement_layoutchanged_isbase = false;
            QCPLayoutElement::layoutChanged();
        } else if (qcplayoutelement_layoutchanged_callback != nullptr) {
            qcplayoutelement_layoutchanged_callback();
        } else {
            QCPLayoutElement::layoutChanged();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcplayoutelement_applydefaultantialiasinghint_isbase) {
            qcplayoutelement_applydefaultantialiasinghint_isbase = false;
            QCPLayoutElement::applyDefaultAntialiasingHint(painter);
        } else if (qcplayoutelement_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcplayoutelement_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPLayoutElement::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcplayoutelement_draw_isbase) {
            qcplayoutelement_draw_isbase = false;
            QCPLayoutElement::draw(painter);
        } else if (qcplayoutelement_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcplayoutelement_draw_callback(this, cbval1);
        } else {
            QCPLayoutElement::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcplayoutelement_parentplotinitialized_isbase) {
            qcplayoutelement_parentplotinitialized_isbase = false;
            QCPLayoutElement::parentPlotInitialized(parentPlot);
        } else if (qcplayoutelement_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcplayoutelement_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPLayoutElement::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcplayoutelement_selectioncategory_isbase) {
            qcplayoutelement_selectioncategory_isbase = false;
            return QCPLayoutElement::selectionCategory();
        } else if (qcplayoutelement_selectioncategory_callback != nullptr) {
            int callback_ret = qcplayoutelement_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPLayoutElement::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcplayoutelement_cliprect_isbase) {
            qcplayoutelement_cliprect_isbase = false;
            return QCPLayoutElement::clipRect();
        } else if (qcplayoutelement_cliprect_callback != nullptr) {
            QRect* callback_ret = qcplayoutelement_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPLayoutElement::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcplayoutelement_selectevent_isbase) {
            qcplayoutelement_selectevent_isbase = false;
            QCPLayoutElement::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcplayoutelement_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcplayoutelement_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPLayoutElement::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcplayoutelement_deselectevent_isbase) {
            qcplayoutelement_deselectevent_isbase = false;
            QCPLayoutElement::deselectEvent(selectionStateChanged);
        } else if (qcplayoutelement_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcplayoutelement_deselectevent_callback(this, cbval1);
        } else {
            QCPLayoutElement::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcplayoutelement_mousepressevent_isbase) {
            qcplayoutelement_mousepressevent_isbase = false;
            QCPLayoutElement::mousePressEvent(event, details);
        } else if (qcplayoutelement_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcplayoutelement_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPLayoutElement::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcplayoutelement_mousemoveevent_isbase) {
            qcplayoutelement_mousemoveevent_isbase = false;
            QCPLayoutElement::mouseMoveEvent(event, startPos);
        } else if (qcplayoutelement_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcplayoutelement_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPLayoutElement::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcplayoutelement_mousereleaseevent_isbase) {
            qcplayoutelement_mousereleaseevent_isbase = false;
            QCPLayoutElement::mouseReleaseEvent(event, startPos);
        } else if (qcplayoutelement_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcplayoutelement_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPLayoutElement::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcplayoutelement_mousedoubleclickevent_isbase) {
            qcplayoutelement_mousedoubleclickevent_isbase = false;
            QCPLayoutElement::mouseDoubleClickEvent(event, details);
        } else if (qcplayoutelement_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcplayoutelement_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPLayoutElement::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcplayoutelement_wheelevent_isbase) {
            qcplayoutelement_wheelevent_isbase = false;
            QCPLayoutElement::wheelEvent(event);
        } else if (qcplayoutelement_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcplayoutelement_wheelevent_callback(this, cbval1);
        } else {
            QCPLayoutElement::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcplayoutelement_event_isbase) {
            qcplayoutelement_event_isbase = false;
            return QCPLayoutElement::event(event);
        } else if (qcplayoutelement_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcplayoutelement_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPLayoutElement::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcplayoutelement_eventfilter_isbase) {
            qcplayoutelement_eventfilter_isbase = false;
            return QCPLayoutElement::eventFilter(watched, event);
        } else if (qcplayoutelement_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcplayoutelement_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPLayoutElement::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcplayoutelement_timerevent_isbase) {
            qcplayoutelement_timerevent_isbase = false;
            QCPLayoutElement::timerEvent(event);
        } else if (qcplayoutelement_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcplayoutelement_timerevent_callback(this, cbval1);
        } else {
            QCPLayoutElement::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcplayoutelement_childevent_isbase) {
            qcplayoutelement_childevent_isbase = false;
            QCPLayoutElement::childEvent(event);
        } else if (qcplayoutelement_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcplayoutelement_childevent_callback(this, cbval1);
        } else {
            QCPLayoutElement::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcplayoutelement_customevent_isbase) {
            qcplayoutelement_customevent_isbase = false;
            QCPLayoutElement::customEvent(event);
        } else if (qcplayoutelement_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcplayoutelement_customevent_callback(this, cbval1);
        } else {
            QCPLayoutElement::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcplayoutelement_connectnotify_isbase) {
            qcplayoutelement_connectnotify_isbase = false;
            QCPLayoutElement::connectNotify(signal);
        } else if (qcplayoutelement_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcplayoutelement_connectnotify_callback(this, cbval1);
        } else {
            QCPLayoutElement::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcplayoutelement_disconnectnotify_isbase) {
            qcplayoutelement_disconnectnotify_isbase = false;
            QCPLayoutElement::disconnectNotify(signal);
        } else if (qcplayoutelement_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcplayoutelement_disconnectnotify_callback(this, cbval1);
        } else {
            QCPLayoutElement::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcplayoutelement_initializeparentplot_isbase) {
            qcplayoutelement_initializeparentplot_isbase = false;
            QCPLayoutElement::initializeParentPlot(parentPlot);
        } else if (qcplayoutelement_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcplayoutelement_initializeparentplot_callback(this, cbval1);
        } else {
            QCPLayoutElement::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcplayoutelement_setparentlayerable_isbase) {
            qcplayoutelement_setparentlayerable_isbase = false;
            QCPLayoutElement::setParentLayerable(parentLayerable);
        } else if (qcplayoutelement_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcplayoutelement_setparentlayerable_callback(this, cbval1);
        } else {
            QCPLayoutElement::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcplayoutelement_movetolayer_isbase) {
            qcplayoutelement_movetolayer_isbase = false;
            return QCPLayoutElement::moveToLayer(layer, prepend);
        } else if (qcplayoutelement_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcplayoutelement_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPLayoutElement::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcplayoutelement_applyantialiasinghint_isbase) {
            qcplayoutelement_applyantialiasinghint_isbase = false;
            QCPLayoutElement::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcplayoutelement_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcplayoutelement_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPLayoutElement::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcplayoutelement_sender_isbase) {
            qcplayoutelement_sender_isbase = false;
            return QCPLayoutElement::sender();
        } else if (qcplayoutelement_sender_callback != nullptr) {
            QObject* callback_ret = qcplayoutelement_sender_callback();
            return callback_ret;
        } else {
            return QCPLayoutElement::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcplayoutelement_sendersignalindex_isbase) {
            qcplayoutelement_sendersignalindex_isbase = false;
            return QCPLayoutElement::senderSignalIndex();
        } else if (qcplayoutelement_sendersignalindex_callback != nullptr) {
            int callback_ret = qcplayoutelement_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPLayoutElement::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcplayoutelement_receivers_isbase) {
            qcplayoutelement_receivers_isbase = false;
            return QCPLayoutElement::receivers(signal);
        } else if (qcplayoutelement_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcplayoutelement_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPLayoutElement::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcplayoutelement_issignalconnected_isbase) {
            qcplayoutelement_issignalconnected_isbase = false;
            return QCPLayoutElement::isSignalConnected(signal);
        } else if (qcplayoutelement_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcplayoutelement_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPLayoutElement::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend int QCPLayoutElement_CalculateAutoMargin(QCPLayoutElement* self, int side);
    friend int QCPLayoutElement_QBaseCalculateAutoMargin(QCPLayoutElement* self, int side);
    friend void QCPLayoutElement_LayoutChanged(QCPLayoutElement* self);
    friend void QCPLayoutElement_QBaseLayoutChanged(QCPLayoutElement* self);
    friend void QCPLayoutElement_ApplyDefaultAntialiasingHint(const QCPLayoutElement* self, QCPPainter* painter);
    friend void QCPLayoutElement_QBaseApplyDefaultAntialiasingHint(const QCPLayoutElement* self, QCPPainter* painter);
    friend void QCPLayoutElement_Draw(QCPLayoutElement* self, QCPPainter* painter);
    friend void QCPLayoutElement_QBaseDraw(QCPLayoutElement* self, QCPPainter* painter);
    friend void QCPLayoutElement_ParentPlotInitialized(QCPLayoutElement* self, QCustomPlot* parentPlot);
    friend void QCPLayoutElement_QBaseParentPlotInitialized(QCPLayoutElement* self, QCustomPlot* parentPlot);
    friend int QCPLayoutElement_SelectionCategory(const QCPLayoutElement* self);
    friend int QCPLayoutElement_QBaseSelectionCategory(const QCPLayoutElement* self);
    friend QRect* QCPLayoutElement_ClipRect(const QCPLayoutElement* self);
    friend QRect* QCPLayoutElement_QBaseClipRect(const QCPLayoutElement* self);
    friend void QCPLayoutElement_SelectEvent(QCPLayoutElement* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPLayoutElement_QBaseSelectEvent(QCPLayoutElement* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPLayoutElement_DeselectEvent(QCPLayoutElement* self, bool* selectionStateChanged);
    friend void QCPLayoutElement_QBaseDeselectEvent(QCPLayoutElement* self, bool* selectionStateChanged);
    friend void QCPLayoutElement_MousePressEvent(QCPLayoutElement* self, QMouseEvent* event, const QVariant* details);
    friend void QCPLayoutElement_QBaseMousePressEvent(QCPLayoutElement* self, QMouseEvent* event, const QVariant* details);
    friend void QCPLayoutElement_MouseMoveEvent(QCPLayoutElement* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPLayoutElement_QBaseMouseMoveEvent(QCPLayoutElement* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPLayoutElement_MouseReleaseEvent(QCPLayoutElement* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPLayoutElement_QBaseMouseReleaseEvent(QCPLayoutElement* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPLayoutElement_MouseDoubleClickEvent(QCPLayoutElement* self, QMouseEvent* event, const QVariant* details);
    friend void QCPLayoutElement_QBaseMouseDoubleClickEvent(QCPLayoutElement* self, QMouseEvent* event, const QVariant* details);
    friend void QCPLayoutElement_WheelEvent(QCPLayoutElement* self, QWheelEvent* event);
    friend void QCPLayoutElement_QBaseWheelEvent(QCPLayoutElement* self, QWheelEvent* event);
    friend void QCPLayoutElement_TimerEvent(QCPLayoutElement* self, QTimerEvent* event);
    friend void QCPLayoutElement_QBaseTimerEvent(QCPLayoutElement* self, QTimerEvent* event);
    friend void QCPLayoutElement_ChildEvent(QCPLayoutElement* self, QChildEvent* event);
    friend void QCPLayoutElement_QBaseChildEvent(QCPLayoutElement* self, QChildEvent* event);
    friend void QCPLayoutElement_CustomEvent(QCPLayoutElement* self, QEvent* event);
    friend void QCPLayoutElement_QBaseCustomEvent(QCPLayoutElement* self, QEvent* event);
    friend void QCPLayoutElement_ConnectNotify(QCPLayoutElement* self, const QMetaMethod* signal);
    friend void QCPLayoutElement_QBaseConnectNotify(QCPLayoutElement* self, const QMetaMethod* signal);
    friend void QCPLayoutElement_DisconnectNotify(QCPLayoutElement* self, const QMetaMethod* signal);
    friend void QCPLayoutElement_QBaseDisconnectNotify(QCPLayoutElement* self, const QMetaMethod* signal);
    friend void QCPLayoutElement_InitializeParentPlot(QCPLayoutElement* self, QCustomPlot* parentPlot);
    friend void QCPLayoutElement_QBaseInitializeParentPlot(QCPLayoutElement* self, QCustomPlot* parentPlot);
    friend void QCPLayoutElement_SetParentLayerable(QCPLayoutElement* self, QCPLayerable* parentLayerable);
    friend void QCPLayoutElement_QBaseSetParentLayerable(QCPLayoutElement* self, QCPLayerable* parentLayerable);
    friend bool QCPLayoutElement_MoveToLayer(QCPLayoutElement* self, QCPLayer* layer, bool prepend);
    friend bool QCPLayoutElement_QBaseMoveToLayer(QCPLayoutElement* self, QCPLayer* layer, bool prepend);
    friend void QCPLayoutElement_ApplyAntialiasingHint(const QCPLayoutElement* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPLayoutElement_QBaseApplyAntialiasingHint(const QCPLayoutElement* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPLayoutElement_Sender(const QCPLayoutElement* self);
    friend QObject* QCPLayoutElement_QBaseSender(const QCPLayoutElement* self);
    friend int QCPLayoutElement_SenderSignalIndex(const QCPLayoutElement* self);
    friend int QCPLayoutElement_QBaseSenderSignalIndex(const QCPLayoutElement* self);
    friend int QCPLayoutElement_Receivers(const QCPLayoutElement* self, const char* signal);
    friend int QCPLayoutElement_QBaseReceivers(const QCPLayoutElement* self, const char* signal);
    friend bool QCPLayoutElement_IsSignalConnected(const QCPLayoutElement* self, const QMetaMethod* signal);
    friend bool QCPLayoutElement_QBaseIsSignalConnected(const QCPLayoutElement* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPLayout so that we can call protected methods
class VirtualQCPLayout : public QCPLayout {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPLayout = true;

    // Virtual class public types (including callbacks)
    using QCPLayout_Metacall_Callback = int (*)(QCPLayout*, int, int, void**);
    using QCPLayout_Update_Callback = void (*)(QCPLayout*, int);
    using QCPLayout_Elements_Callback = QCPLayoutElement** (*)(const QCPLayout*, bool);
    using QCPLayout_ElementCount_Callback = int (*)();
    using QCPLayout_ElementAt_Callback = QCPLayoutElement* (*)(const QCPLayout*, int);
    using QCPLayout_TakeAt_Callback = QCPLayoutElement* (*)(QCPLayout*, int);
    using QCPLayout_Take_Callback = bool (*)(QCPLayout*, QCPLayoutElement*);
    using QCPLayout_Simplify_Callback = void (*)();
    using QCPLayout_UpdateLayout_Callback = void (*)();
    using QCPLayout_MinimumOuterSizeHint_Callback = QSize* (*)();
    using QCPLayout_MaximumOuterSizeHint_Callback = QSize* (*)();
    using QCPLayout_SelectTest_Callback = double (*)(const QCPLayout*, QPointF*, bool, QVariant*);
    using QCPLayout_CalculateAutoMargin_Callback = int (*)(QCPLayout*, int);
    using QCPLayout_LayoutChanged_Callback = void (*)();
    using QCPLayout_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPLayout*, QCPPainter*);
    using QCPLayout_Draw_Callback = void (*)(QCPLayout*, QCPPainter*);
    using QCPLayout_ParentPlotInitialized_Callback = void (*)(QCPLayout*, QCustomPlot*);
    using QCPLayout_SelectionCategory_Callback = int (*)();
    using QCPLayout_ClipRect_Callback = QRect* (*)();
    using QCPLayout_SelectEvent_Callback = void (*)(QCPLayout*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPLayout_DeselectEvent_Callback = void (*)(QCPLayout*, bool*);
    using QCPLayout_MousePressEvent_Callback = void (*)(QCPLayout*, QMouseEvent*, QVariant*);
    using QCPLayout_MouseMoveEvent_Callback = void (*)(QCPLayout*, QMouseEvent*, QPointF*);
    using QCPLayout_MouseReleaseEvent_Callback = void (*)(QCPLayout*, QMouseEvent*, QPointF*);
    using QCPLayout_MouseDoubleClickEvent_Callback = void (*)(QCPLayout*, QMouseEvent*, QVariant*);
    using QCPLayout_WheelEvent_Callback = void (*)(QCPLayout*, QWheelEvent*);
    using QCPLayout_Event_Callback = bool (*)(QCPLayout*, QEvent*);
    using QCPLayout_EventFilter_Callback = bool (*)(QCPLayout*, QObject*, QEvent*);
    using QCPLayout_TimerEvent_Callback = void (*)(QCPLayout*, QTimerEvent*);
    using QCPLayout_ChildEvent_Callback = void (*)(QCPLayout*, QChildEvent*);
    using QCPLayout_CustomEvent_Callback = void (*)(QCPLayout*, QEvent*);
    using QCPLayout_ConnectNotify_Callback = void (*)(QCPLayout*, QMetaMethod*);
    using QCPLayout_DisconnectNotify_Callback = void (*)(QCPLayout*, QMetaMethod*);
    using QCPLayout_SizeConstraintsChanged_Callback = void (*)();
    using QCPLayout_AdoptElement_Callback = void (*)(QCPLayout*, QCPLayoutElement*);
    using QCPLayout_ReleaseElement_Callback = void (*)(QCPLayout*, QCPLayoutElement*);
    using QCPLayout_GetSectionSizes_Callback = int* (*)(const QCPLayout*, libqt_list /* of int */, libqt_list /* of int */, libqt_list /* of double */, int);
    using QCPLayout_InitializeParentPlot_Callback = void (*)(QCPLayout*, QCustomPlot*);
    using QCPLayout_SetParentLayerable_Callback = void (*)(QCPLayout*, QCPLayerable*);
    using QCPLayout_MoveToLayer_Callback = bool (*)(QCPLayout*, QCPLayer*, bool);
    using QCPLayout_ApplyAntialiasingHint_Callback = void (*)(const QCPLayout*, QCPPainter*, bool, int);
    using QCPLayout_Sender_Callback = QObject* (*)();
    using QCPLayout_SenderSignalIndex_Callback = int (*)();
    using QCPLayout_Receivers_Callback = int (*)(const QCPLayout*, const char*);
    using QCPLayout_IsSignalConnected_Callback = bool (*)(const QCPLayout*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPLayout_Metacall_Callback qcplayout_metacall_callback = nullptr;
    QCPLayout_Update_Callback qcplayout_update_callback = nullptr;
    QCPLayout_Elements_Callback qcplayout_elements_callback = nullptr;
    QCPLayout_ElementCount_Callback qcplayout_elementcount_callback = nullptr;
    QCPLayout_ElementAt_Callback qcplayout_elementat_callback = nullptr;
    QCPLayout_TakeAt_Callback qcplayout_takeat_callback = nullptr;
    QCPLayout_Take_Callback qcplayout_take_callback = nullptr;
    QCPLayout_Simplify_Callback qcplayout_simplify_callback = nullptr;
    QCPLayout_UpdateLayout_Callback qcplayout_updatelayout_callback = nullptr;
    QCPLayout_MinimumOuterSizeHint_Callback qcplayout_minimumoutersizehint_callback = nullptr;
    QCPLayout_MaximumOuterSizeHint_Callback qcplayout_maximumoutersizehint_callback = nullptr;
    QCPLayout_SelectTest_Callback qcplayout_selecttest_callback = nullptr;
    QCPLayout_CalculateAutoMargin_Callback qcplayout_calculateautomargin_callback = nullptr;
    QCPLayout_LayoutChanged_Callback qcplayout_layoutchanged_callback = nullptr;
    QCPLayout_ApplyDefaultAntialiasingHint_Callback qcplayout_applydefaultantialiasinghint_callback = nullptr;
    QCPLayout_Draw_Callback qcplayout_draw_callback = nullptr;
    QCPLayout_ParentPlotInitialized_Callback qcplayout_parentplotinitialized_callback = nullptr;
    QCPLayout_SelectionCategory_Callback qcplayout_selectioncategory_callback = nullptr;
    QCPLayout_ClipRect_Callback qcplayout_cliprect_callback = nullptr;
    QCPLayout_SelectEvent_Callback qcplayout_selectevent_callback = nullptr;
    QCPLayout_DeselectEvent_Callback qcplayout_deselectevent_callback = nullptr;
    QCPLayout_MousePressEvent_Callback qcplayout_mousepressevent_callback = nullptr;
    QCPLayout_MouseMoveEvent_Callback qcplayout_mousemoveevent_callback = nullptr;
    QCPLayout_MouseReleaseEvent_Callback qcplayout_mousereleaseevent_callback = nullptr;
    QCPLayout_MouseDoubleClickEvent_Callback qcplayout_mousedoubleclickevent_callback = nullptr;
    QCPLayout_WheelEvent_Callback qcplayout_wheelevent_callback = nullptr;
    QCPLayout_Event_Callback qcplayout_event_callback = nullptr;
    QCPLayout_EventFilter_Callback qcplayout_eventfilter_callback = nullptr;
    QCPLayout_TimerEvent_Callback qcplayout_timerevent_callback = nullptr;
    QCPLayout_ChildEvent_Callback qcplayout_childevent_callback = nullptr;
    QCPLayout_CustomEvent_Callback qcplayout_customevent_callback = nullptr;
    QCPLayout_ConnectNotify_Callback qcplayout_connectnotify_callback = nullptr;
    QCPLayout_DisconnectNotify_Callback qcplayout_disconnectnotify_callback = nullptr;
    QCPLayout_SizeConstraintsChanged_Callback qcplayout_sizeconstraintschanged_callback = nullptr;
    QCPLayout_AdoptElement_Callback qcplayout_adoptelement_callback = nullptr;
    QCPLayout_ReleaseElement_Callback qcplayout_releaseelement_callback = nullptr;
    QCPLayout_GetSectionSizes_Callback qcplayout_getsectionsizes_callback = nullptr;
    QCPLayout_InitializeParentPlot_Callback qcplayout_initializeparentplot_callback = nullptr;
    QCPLayout_SetParentLayerable_Callback qcplayout_setparentlayerable_callback = nullptr;
    QCPLayout_MoveToLayer_Callback qcplayout_movetolayer_callback = nullptr;
    QCPLayout_ApplyAntialiasingHint_Callback qcplayout_applyantialiasinghint_callback = nullptr;
    QCPLayout_Sender_Callback qcplayout_sender_callback = nullptr;
    QCPLayout_SenderSignalIndex_Callback qcplayout_sendersignalindex_callback = nullptr;
    QCPLayout_Receivers_Callback qcplayout_receivers_callback = nullptr;
    QCPLayout_IsSignalConnected_Callback qcplayout_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcplayout_metacall_isbase = false;
    mutable bool qcplayout_update_isbase = false;
    mutable bool qcplayout_elements_isbase = false;
    mutable bool qcplayout_elementcount_isbase = false;
    mutable bool qcplayout_elementat_isbase = false;
    mutable bool qcplayout_takeat_isbase = false;
    mutable bool qcplayout_take_isbase = false;
    mutable bool qcplayout_simplify_isbase = false;
    mutable bool qcplayout_updatelayout_isbase = false;
    mutable bool qcplayout_minimumoutersizehint_isbase = false;
    mutable bool qcplayout_maximumoutersizehint_isbase = false;
    mutable bool qcplayout_selecttest_isbase = false;
    mutable bool qcplayout_calculateautomargin_isbase = false;
    mutable bool qcplayout_layoutchanged_isbase = false;
    mutable bool qcplayout_applydefaultantialiasinghint_isbase = false;
    mutable bool qcplayout_draw_isbase = false;
    mutable bool qcplayout_parentplotinitialized_isbase = false;
    mutable bool qcplayout_selectioncategory_isbase = false;
    mutable bool qcplayout_cliprect_isbase = false;
    mutable bool qcplayout_selectevent_isbase = false;
    mutable bool qcplayout_deselectevent_isbase = false;
    mutable bool qcplayout_mousepressevent_isbase = false;
    mutable bool qcplayout_mousemoveevent_isbase = false;
    mutable bool qcplayout_mousereleaseevent_isbase = false;
    mutable bool qcplayout_mousedoubleclickevent_isbase = false;
    mutable bool qcplayout_wheelevent_isbase = false;
    mutable bool qcplayout_event_isbase = false;
    mutable bool qcplayout_eventfilter_isbase = false;
    mutable bool qcplayout_timerevent_isbase = false;
    mutable bool qcplayout_childevent_isbase = false;
    mutable bool qcplayout_customevent_isbase = false;
    mutable bool qcplayout_connectnotify_isbase = false;
    mutable bool qcplayout_disconnectnotify_isbase = false;
    mutable bool qcplayout_sizeconstraintschanged_isbase = false;
    mutable bool qcplayout_adoptelement_isbase = false;
    mutable bool qcplayout_releaseelement_isbase = false;
    mutable bool qcplayout_getsectionsizes_isbase = false;
    mutable bool qcplayout_initializeparentplot_isbase = false;
    mutable bool qcplayout_setparentlayerable_isbase = false;
    mutable bool qcplayout_movetolayer_isbase = false;
    mutable bool qcplayout_applyantialiasinghint_isbase = false;
    mutable bool qcplayout_sender_isbase = false;
    mutable bool qcplayout_sendersignalindex_isbase = false;
    mutable bool qcplayout_receivers_isbase = false;
    mutable bool qcplayout_issignalconnected_isbase = false;

  public:
    VirtualQCPLayout() : QCPLayout() {};

    ~VirtualQCPLayout() {
        qcplayout_metacall_callback = nullptr;
        qcplayout_update_callback = nullptr;
        qcplayout_elements_callback = nullptr;
        qcplayout_elementcount_callback = nullptr;
        qcplayout_elementat_callback = nullptr;
        qcplayout_takeat_callback = nullptr;
        qcplayout_take_callback = nullptr;
        qcplayout_simplify_callback = nullptr;
        qcplayout_updatelayout_callback = nullptr;
        qcplayout_minimumoutersizehint_callback = nullptr;
        qcplayout_maximumoutersizehint_callback = nullptr;
        qcplayout_selecttest_callback = nullptr;
        qcplayout_calculateautomargin_callback = nullptr;
        qcplayout_layoutchanged_callback = nullptr;
        qcplayout_applydefaultantialiasinghint_callback = nullptr;
        qcplayout_draw_callback = nullptr;
        qcplayout_parentplotinitialized_callback = nullptr;
        qcplayout_selectioncategory_callback = nullptr;
        qcplayout_cliprect_callback = nullptr;
        qcplayout_selectevent_callback = nullptr;
        qcplayout_deselectevent_callback = nullptr;
        qcplayout_mousepressevent_callback = nullptr;
        qcplayout_mousemoveevent_callback = nullptr;
        qcplayout_mousereleaseevent_callback = nullptr;
        qcplayout_mousedoubleclickevent_callback = nullptr;
        qcplayout_wheelevent_callback = nullptr;
        qcplayout_event_callback = nullptr;
        qcplayout_eventfilter_callback = nullptr;
        qcplayout_timerevent_callback = nullptr;
        qcplayout_childevent_callback = nullptr;
        qcplayout_customevent_callback = nullptr;
        qcplayout_connectnotify_callback = nullptr;
        qcplayout_disconnectnotify_callback = nullptr;
        qcplayout_sizeconstraintschanged_callback = nullptr;
        qcplayout_adoptelement_callback = nullptr;
        qcplayout_releaseelement_callback = nullptr;
        qcplayout_getsectionsizes_callback = nullptr;
        qcplayout_initializeparentplot_callback = nullptr;
        qcplayout_setparentlayerable_callback = nullptr;
        qcplayout_movetolayer_callback = nullptr;
        qcplayout_applyantialiasinghint_callback = nullptr;
        qcplayout_sender_callback = nullptr;
        qcplayout_sendersignalindex_callback = nullptr;
        qcplayout_receivers_callback = nullptr;
        qcplayout_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPLayout_Metacall_Callback(QCPLayout_Metacall_Callback cb) { qcplayout_metacall_callback = cb; }
    inline void setQCPLayout_Update_Callback(QCPLayout_Update_Callback cb) { qcplayout_update_callback = cb; }
    inline void setQCPLayout_Elements_Callback(QCPLayout_Elements_Callback cb) { qcplayout_elements_callback = cb; }
    inline void setQCPLayout_ElementCount_Callback(QCPLayout_ElementCount_Callback cb) { qcplayout_elementcount_callback = cb; }
    inline void setQCPLayout_ElementAt_Callback(QCPLayout_ElementAt_Callback cb) { qcplayout_elementat_callback = cb; }
    inline void setQCPLayout_TakeAt_Callback(QCPLayout_TakeAt_Callback cb) { qcplayout_takeat_callback = cb; }
    inline void setQCPLayout_Take_Callback(QCPLayout_Take_Callback cb) { qcplayout_take_callback = cb; }
    inline void setQCPLayout_Simplify_Callback(QCPLayout_Simplify_Callback cb) { qcplayout_simplify_callback = cb; }
    inline void setQCPLayout_UpdateLayout_Callback(QCPLayout_UpdateLayout_Callback cb) { qcplayout_updatelayout_callback = cb; }
    inline void setQCPLayout_MinimumOuterSizeHint_Callback(QCPLayout_MinimumOuterSizeHint_Callback cb) { qcplayout_minimumoutersizehint_callback = cb; }
    inline void setQCPLayout_MaximumOuterSizeHint_Callback(QCPLayout_MaximumOuterSizeHint_Callback cb) { qcplayout_maximumoutersizehint_callback = cb; }
    inline void setQCPLayout_SelectTest_Callback(QCPLayout_SelectTest_Callback cb) { qcplayout_selecttest_callback = cb; }
    inline void setQCPLayout_CalculateAutoMargin_Callback(QCPLayout_CalculateAutoMargin_Callback cb) { qcplayout_calculateautomargin_callback = cb; }
    inline void setQCPLayout_LayoutChanged_Callback(QCPLayout_LayoutChanged_Callback cb) { qcplayout_layoutchanged_callback = cb; }
    inline void setQCPLayout_ApplyDefaultAntialiasingHint_Callback(QCPLayout_ApplyDefaultAntialiasingHint_Callback cb) { qcplayout_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPLayout_Draw_Callback(QCPLayout_Draw_Callback cb) { qcplayout_draw_callback = cb; }
    inline void setQCPLayout_ParentPlotInitialized_Callback(QCPLayout_ParentPlotInitialized_Callback cb) { qcplayout_parentplotinitialized_callback = cb; }
    inline void setQCPLayout_SelectionCategory_Callback(QCPLayout_SelectionCategory_Callback cb) { qcplayout_selectioncategory_callback = cb; }
    inline void setQCPLayout_ClipRect_Callback(QCPLayout_ClipRect_Callback cb) { qcplayout_cliprect_callback = cb; }
    inline void setQCPLayout_SelectEvent_Callback(QCPLayout_SelectEvent_Callback cb) { qcplayout_selectevent_callback = cb; }
    inline void setQCPLayout_DeselectEvent_Callback(QCPLayout_DeselectEvent_Callback cb) { qcplayout_deselectevent_callback = cb; }
    inline void setQCPLayout_MousePressEvent_Callback(QCPLayout_MousePressEvent_Callback cb) { qcplayout_mousepressevent_callback = cb; }
    inline void setQCPLayout_MouseMoveEvent_Callback(QCPLayout_MouseMoveEvent_Callback cb) { qcplayout_mousemoveevent_callback = cb; }
    inline void setQCPLayout_MouseReleaseEvent_Callback(QCPLayout_MouseReleaseEvent_Callback cb) { qcplayout_mousereleaseevent_callback = cb; }
    inline void setQCPLayout_MouseDoubleClickEvent_Callback(QCPLayout_MouseDoubleClickEvent_Callback cb) { qcplayout_mousedoubleclickevent_callback = cb; }
    inline void setQCPLayout_WheelEvent_Callback(QCPLayout_WheelEvent_Callback cb) { qcplayout_wheelevent_callback = cb; }
    inline void setQCPLayout_Event_Callback(QCPLayout_Event_Callback cb) { qcplayout_event_callback = cb; }
    inline void setQCPLayout_EventFilter_Callback(QCPLayout_EventFilter_Callback cb) { qcplayout_eventfilter_callback = cb; }
    inline void setQCPLayout_TimerEvent_Callback(QCPLayout_TimerEvent_Callback cb) { qcplayout_timerevent_callback = cb; }
    inline void setQCPLayout_ChildEvent_Callback(QCPLayout_ChildEvent_Callback cb) { qcplayout_childevent_callback = cb; }
    inline void setQCPLayout_CustomEvent_Callback(QCPLayout_CustomEvent_Callback cb) { qcplayout_customevent_callback = cb; }
    inline void setQCPLayout_ConnectNotify_Callback(QCPLayout_ConnectNotify_Callback cb) { qcplayout_connectnotify_callback = cb; }
    inline void setQCPLayout_DisconnectNotify_Callback(QCPLayout_DisconnectNotify_Callback cb) { qcplayout_disconnectnotify_callback = cb; }
    inline void setQCPLayout_SizeConstraintsChanged_Callback(QCPLayout_SizeConstraintsChanged_Callback cb) { qcplayout_sizeconstraintschanged_callback = cb; }
    inline void setQCPLayout_AdoptElement_Callback(QCPLayout_AdoptElement_Callback cb) { qcplayout_adoptelement_callback = cb; }
    inline void setQCPLayout_ReleaseElement_Callback(QCPLayout_ReleaseElement_Callback cb) { qcplayout_releaseelement_callback = cb; }
    inline void setQCPLayout_GetSectionSizes_Callback(QCPLayout_GetSectionSizes_Callback cb) { qcplayout_getsectionsizes_callback = cb; }
    inline void setQCPLayout_InitializeParentPlot_Callback(QCPLayout_InitializeParentPlot_Callback cb) { qcplayout_initializeparentplot_callback = cb; }
    inline void setQCPLayout_SetParentLayerable_Callback(QCPLayout_SetParentLayerable_Callback cb) { qcplayout_setparentlayerable_callback = cb; }
    inline void setQCPLayout_MoveToLayer_Callback(QCPLayout_MoveToLayer_Callback cb) { qcplayout_movetolayer_callback = cb; }
    inline void setQCPLayout_ApplyAntialiasingHint_Callback(QCPLayout_ApplyAntialiasingHint_Callback cb) { qcplayout_applyantialiasinghint_callback = cb; }
    inline void setQCPLayout_Sender_Callback(QCPLayout_Sender_Callback cb) { qcplayout_sender_callback = cb; }
    inline void setQCPLayout_SenderSignalIndex_Callback(QCPLayout_SenderSignalIndex_Callback cb) { qcplayout_sendersignalindex_callback = cb; }
    inline void setQCPLayout_Receivers_Callback(QCPLayout_Receivers_Callback cb) { qcplayout_receivers_callback = cb; }
    inline void setQCPLayout_IsSignalConnected_Callback(QCPLayout_IsSignalConnected_Callback cb) { qcplayout_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPLayout_Metacall_IsBase(bool value) const { qcplayout_metacall_isbase = value; }
    inline void setQCPLayout_Update_IsBase(bool value) const { qcplayout_update_isbase = value; }
    inline void setQCPLayout_Elements_IsBase(bool value) const { qcplayout_elements_isbase = value; }
    inline void setQCPLayout_ElementCount_IsBase(bool value) const { qcplayout_elementcount_isbase = value; }
    inline void setQCPLayout_ElementAt_IsBase(bool value) const { qcplayout_elementat_isbase = value; }
    inline void setQCPLayout_TakeAt_IsBase(bool value) const { qcplayout_takeat_isbase = value; }
    inline void setQCPLayout_Take_IsBase(bool value) const { qcplayout_take_isbase = value; }
    inline void setQCPLayout_Simplify_IsBase(bool value) const { qcplayout_simplify_isbase = value; }
    inline void setQCPLayout_UpdateLayout_IsBase(bool value) const { qcplayout_updatelayout_isbase = value; }
    inline void setQCPLayout_MinimumOuterSizeHint_IsBase(bool value) const { qcplayout_minimumoutersizehint_isbase = value; }
    inline void setQCPLayout_MaximumOuterSizeHint_IsBase(bool value) const { qcplayout_maximumoutersizehint_isbase = value; }
    inline void setQCPLayout_SelectTest_IsBase(bool value) const { qcplayout_selecttest_isbase = value; }
    inline void setQCPLayout_CalculateAutoMargin_IsBase(bool value) const { qcplayout_calculateautomargin_isbase = value; }
    inline void setQCPLayout_LayoutChanged_IsBase(bool value) const { qcplayout_layoutchanged_isbase = value; }
    inline void setQCPLayout_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcplayout_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPLayout_Draw_IsBase(bool value) const { qcplayout_draw_isbase = value; }
    inline void setQCPLayout_ParentPlotInitialized_IsBase(bool value) const { qcplayout_parentplotinitialized_isbase = value; }
    inline void setQCPLayout_SelectionCategory_IsBase(bool value) const { qcplayout_selectioncategory_isbase = value; }
    inline void setQCPLayout_ClipRect_IsBase(bool value) const { qcplayout_cliprect_isbase = value; }
    inline void setQCPLayout_SelectEvent_IsBase(bool value) const { qcplayout_selectevent_isbase = value; }
    inline void setQCPLayout_DeselectEvent_IsBase(bool value) const { qcplayout_deselectevent_isbase = value; }
    inline void setQCPLayout_MousePressEvent_IsBase(bool value) const { qcplayout_mousepressevent_isbase = value; }
    inline void setQCPLayout_MouseMoveEvent_IsBase(bool value) const { qcplayout_mousemoveevent_isbase = value; }
    inline void setQCPLayout_MouseReleaseEvent_IsBase(bool value) const { qcplayout_mousereleaseevent_isbase = value; }
    inline void setQCPLayout_MouseDoubleClickEvent_IsBase(bool value) const { qcplayout_mousedoubleclickevent_isbase = value; }
    inline void setQCPLayout_WheelEvent_IsBase(bool value) const { qcplayout_wheelevent_isbase = value; }
    inline void setQCPLayout_Event_IsBase(bool value) const { qcplayout_event_isbase = value; }
    inline void setQCPLayout_EventFilter_IsBase(bool value) const { qcplayout_eventfilter_isbase = value; }
    inline void setQCPLayout_TimerEvent_IsBase(bool value) const { qcplayout_timerevent_isbase = value; }
    inline void setQCPLayout_ChildEvent_IsBase(bool value) const { qcplayout_childevent_isbase = value; }
    inline void setQCPLayout_CustomEvent_IsBase(bool value) const { qcplayout_customevent_isbase = value; }
    inline void setQCPLayout_ConnectNotify_IsBase(bool value) const { qcplayout_connectnotify_isbase = value; }
    inline void setQCPLayout_DisconnectNotify_IsBase(bool value) const { qcplayout_disconnectnotify_isbase = value; }
    inline void setQCPLayout_SizeConstraintsChanged_IsBase(bool value) const { qcplayout_sizeconstraintschanged_isbase = value; }
    inline void setQCPLayout_AdoptElement_IsBase(bool value) const { qcplayout_adoptelement_isbase = value; }
    inline void setQCPLayout_ReleaseElement_IsBase(bool value) const { qcplayout_releaseelement_isbase = value; }
    inline void setQCPLayout_GetSectionSizes_IsBase(bool value) const { qcplayout_getsectionsizes_isbase = value; }
    inline void setQCPLayout_InitializeParentPlot_IsBase(bool value) const { qcplayout_initializeparentplot_isbase = value; }
    inline void setQCPLayout_SetParentLayerable_IsBase(bool value) const { qcplayout_setparentlayerable_isbase = value; }
    inline void setQCPLayout_MoveToLayer_IsBase(bool value) const { qcplayout_movetolayer_isbase = value; }
    inline void setQCPLayout_ApplyAntialiasingHint_IsBase(bool value) const { qcplayout_applyantialiasinghint_isbase = value; }
    inline void setQCPLayout_Sender_IsBase(bool value) const { qcplayout_sender_isbase = value; }
    inline void setQCPLayout_SenderSignalIndex_IsBase(bool value) const { qcplayout_sendersignalindex_isbase = value; }
    inline void setQCPLayout_Receivers_IsBase(bool value) const { qcplayout_receivers_isbase = value; }
    inline void setQCPLayout_IsSignalConnected_IsBase(bool value) const { qcplayout_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcplayout_metacall_isbase) {
            qcplayout_metacall_isbase = false;
            return QCPLayout::qt_metacall(param1, param2, param3);
        } else if (qcplayout_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcplayout_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPLayout::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void update(QCPLayoutElement::UpdatePhase phase) override {
        if (qcplayout_update_isbase) {
            qcplayout_update_isbase = false;
            QCPLayout::update(phase);
        } else if (qcplayout_update_callback != nullptr) {
            int cbval1 = static_cast<int>(phase);

            qcplayout_update_callback(this, cbval1);
        } else {
            QCPLayout::update(phase);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QList<QCPLayoutElement*> elements(bool recursive) const override {
        if (qcplayout_elements_isbase) {
            qcplayout_elements_isbase = false;
            return QCPLayout::elements(recursive);
        } else if (qcplayout_elements_callback != nullptr) {
            bool cbval1 = recursive;

            QCPLayoutElement** callback_ret = qcplayout_elements_callback(this, cbval1);
            QList<QCPLayoutElement*> callback_ret_QList;
            // Iterate until null pointer sentinel
            for (QCPLayoutElement** ptridx = callback_ret; *ptridx != nullptr; ptridx++) {
                callback_ret_QList.push_back(*ptridx);
            }
            free(callback_ret);
            return callback_ret_QList;
        } else {
            return QCPLayout::elements(recursive);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int elementCount() const override {
        if (qcplayout_elementcount_callback != nullptr) {
            int callback_ret = qcplayout_elementcount_callback();
            return static_cast<int>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPLayoutElement* elementAt(int index) const override {
        if (qcplayout_elementat_callback != nullptr) {
            int cbval1 = index;

            QCPLayoutElement* callback_ret = qcplayout_elementat_callback(this, cbval1);
            return callback_ret;
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPLayoutElement* takeAt(int index) override {
        if (qcplayout_takeat_callback != nullptr) {
            int cbval1 = index;

            QCPLayoutElement* callback_ret = qcplayout_takeat_callback(this, cbval1);
            return callback_ret;
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool take(QCPLayoutElement* element) override {
        if (qcplayout_take_callback != nullptr) {
            QCPLayoutElement* cbval1 = element;

            bool callback_ret = qcplayout_take_callback(this, cbval1);
            return callback_ret;
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void simplify() override {
        if (qcplayout_simplify_isbase) {
            qcplayout_simplify_isbase = false;
            QCPLayout::simplify();
        } else if (qcplayout_simplify_callback != nullptr) {
            qcplayout_simplify_callback();
        } else {
            QCPLayout::simplify();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void updateLayout() override {
        if (qcplayout_updatelayout_isbase) {
            qcplayout_updatelayout_isbase = false;
            QCPLayout::updateLayout();
        } else if (qcplayout_updatelayout_callback != nullptr) {
            qcplayout_updatelayout_callback();
        } else {
            QCPLayout::updateLayout();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize minimumOuterSizeHint() const override {
        if (qcplayout_minimumoutersizehint_isbase) {
            qcplayout_minimumoutersizehint_isbase = false;
            return QCPLayout::minimumOuterSizeHint();
        } else if (qcplayout_minimumoutersizehint_callback != nullptr) {
            QSize* callback_ret = qcplayout_minimumoutersizehint_callback();
            return *callback_ret;
        } else {
            return QCPLayout::minimumOuterSizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize maximumOuterSizeHint() const override {
        if (qcplayout_maximumoutersizehint_isbase) {
            qcplayout_maximumoutersizehint_isbase = false;
            return QCPLayout::maximumOuterSizeHint();
        } else if (qcplayout_maximumoutersizehint_callback != nullptr) {
            QSize* callback_ret = qcplayout_maximumoutersizehint_callback();
            return *callback_ret;
        } else {
            return QCPLayout::maximumOuterSizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcplayout_selecttest_isbase) {
            qcplayout_selecttest_isbase = false;
            return QCPLayout::selectTest(pos, onlySelectable, details);
        } else if (qcplayout_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcplayout_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPLayout::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int calculateAutoMargin(QCP::MarginSide side) override {
        if (qcplayout_calculateautomargin_isbase) {
            qcplayout_calculateautomargin_isbase = false;
            return QCPLayout::calculateAutoMargin(side);
        } else if (qcplayout_calculateautomargin_callback != nullptr) {
            int cbval1 = static_cast<int>(side);

            int callback_ret = qcplayout_calculateautomargin_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPLayout::calculateAutoMargin(side);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void layoutChanged() override {
        if (qcplayout_layoutchanged_isbase) {
            qcplayout_layoutchanged_isbase = false;
            QCPLayout::layoutChanged();
        } else if (qcplayout_layoutchanged_callback != nullptr) {
            qcplayout_layoutchanged_callback();
        } else {
            QCPLayout::layoutChanged();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcplayout_applydefaultantialiasinghint_isbase) {
            qcplayout_applydefaultantialiasinghint_isbase = false;
            QCPLayout::applyDefaultAntialiasingHint(painter);
        } else if (qcplayout_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcplayout_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPLayout::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcplayout_draw_isbase) {
            qcplayout_draw_isbase = false;
            QCPLayout::draw(painter);
        } else if (qcplayout_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcplayout_draw_callback(this, cbval1);
        } else {
            QCPLayout::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcplayout_parentplotinitialized_isbase) {
            qcplayout_parentplotinitialized_isbase = false;
            QCPLayout::parentPlotInitialized(parentPlot);
        } else if (qcplayout_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcplayout_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPLayout::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcplayout_selectioncategory_isbase) {
            qcplayout_selectioncategory_isbase = false;
            return QCPLayout::selectionCategory();
        } else if (qcplayout_selectioncategory_callback != nullptr) {
            int callback_ret = qcplayout_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPLayout::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcplayout_cliprect_isbase) {
            qcplayout_cliprect_isbase = false;
            return QCPLayout::clipRect();
        } else if (qcplayout_cliprect_callback != nullptr) {
            QRect* callback_ret = qcplayout_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPLayout::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcplayout_selectevent_isbase) {
            qcplayout_selectevent_isbase = false;
            QCPLayout::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcplayout_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcplayout_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPLayout::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcplayout_deselectevent_isbase) {
            qcplayout_deselectevent_isbase = false;
            QCPLayout::deselectEvent(selectionStateChanged);
        } else if (qcplayout_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcplayout_deselectevent_callback(this, cbval1);
        } else {
            QCPLayout::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcplayout_mousepressevent_isbase) {
            qcplayout_mousepressevent_isbase = false;
            QCPLayout::mousePressEvent(event, details);
        } else if (qcplayout_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcplayout_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPLayout::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcplayout_mousemoveevent_isbase) {
            qcplayout_mousemoveevent_isbase = false;
            QCPLayout::mouseMoveEvent(event, startPos);
        } else if (qcplayout_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcplayout_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPLayout::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcplayout_mousereleaseevent_isbase) {
            qcplayout_mousereleaseevent_isbase = false;
            QCPLayout::mouseReleaseEvent(event, startPos);
        } else if (qcplayout_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcplayout_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPLayout::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcplayout_mousedoubleclickevent_isbase) {
            qcplayout_mousedoubleclickevent_isbase = false;
            QCPLayout::mouseDoubleClickEvent(event, details);
        } else if (qcplayout_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcplayout_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPLayout::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcplayout_wheelevent_isbase) {
            qcplayout_wheelevent_isbase = false;
            QCPLayout::wheelEvent(event);
        } else if (qcplayout_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcplayout_wheelevent_callback(this, cbval1);
        } else {
            QCPLayout::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcplayout_event_isbase) {
            qcplayout_event_isbase = false;
            return QCPLayout::event(event);
        } else if (qcplayout_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcplayout_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPLayout::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcplayout_eventfilter_isbase) {
            qcplayout_eventfilter_isbase = false;
            return QCPLayout::eventFilter(watched, event);
        } else if (qcplayout_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcplayout_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPLayout::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcplayout_timerevent_isbase) {
            qcplayout_timerevent_isbase = false;
            QCPLayout::timerEvent(event);
        } else if (qcplayout_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcplayout_timerevent_callback(this, cbval1);
        } else {
            QCPLayout::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcplayout_childevent_isbase) {
            qcplayout_childevent_isbase = false;
            QCPLayout::childEvent(event);
        } else if (qcplayout_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcplayout_childevent_callback(this, cbval1);
        } else {
            QCPLayout::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcplayout_customevent_isbase) {
            qcplayout_customevent_isbase = false;
            QCPLayout::customEvent(event);
        } else if (qcplayout_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcplayout_customevent_callback(this, cbval1);
        } else {
            QCPLayout::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcplayout_connectnotify_isbase) {
            qcplayout_connectnotify_isbase = false;
            QCPLayout::connectNotify(signal);
        } else if (qcplayout_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcplayout_connectnotify_callback(this, cbval1);
        } else {
            QCPLayout::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcplayout_disconnectnotify_isbase) {
            qcplayout_disconnectnotify_isbase = false;
            QCPLayout::disconnectNotify(signal);
        } else if (qcplayout_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcplayout_disconnectnotify_callback(this, cbval1);
        } else {
            QCPLayout::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    void sizeConstraintsChanged() const {
        if (qcplayout_sizeconstraintschanged_isbase) {
            qcplayout_sizeconstraintschanged_isbase = false;
            QCPLayout::sizeConstraintsChanged();
        } else if (qcplayout_sizeconstraintschanged_callback != nullptr) {
            qcplayout_sizeconstraintschanged_callback();
        } else {
            QCPLayout::sizeConstraintsChanged();
        }
    }

    // Virtual method for C ABI access and custom callback
    void adoptElement(QCPLayoutElement* el) {
        if (qcplayout_adoptelement_isbase) {
            qcplayout_adoptelement_isbase = false;
            QCPLayout::adoptElement(el);
        } else if (qcplayout_adoptelement_callback != nullptr) {
            QCPLayoutElement* cbval1 = el;

            qcplayout_adoptelement_callback(this, cbval1);
        } else {
            QCPLayout::adoptElement(el);
        }
    }

    // Virtual method for C ABI access and custom callback
    void releaseElement(QCPLayoutElement* el) {
        if (qcplayout_releaseelement_isbase) {
            qcplayout_releaseelement_isbase = false;
            QCPLayout::releaseElement(el);
        } else if (qcplayout_releaseelement_callback != nullptr) {
            QCPLayoutElement* cbval1 = el;

            qcplayout_releaseelement_callback(this, cbval1);
        } else {
            QCPLayout::releaseElement(el);
        }
    }

    // Virtual method for C ABI access and custom callback
    QVector<int> getSectionSizes(QVector<int> maxSizes, QVector<int> minSizes, QVector<double> stretchFactors, int totalSize) const {
        if (qcplayout_getsectionsizes_isbase) {
            qcplayout_getsectionsizes_isbase = false;
            return QCPLayout::getSectionSizes(maxSizes, minSizes, stretchFactors, totalSize);
        } else if (qcplayout_getsectionsizes_callback != nullptr) {
            QVector<int> maxSizes_ret = maxSizes;
            // Convert QVector<> from C++ memory to manually-managed C memory
            int* maxSizes_arr = static_cast<int*>(malloc(sizeof(int) * (maxSizes_ret.size() + 1)));
            for (qsizetype i = 0; i < maxSizes_ret.size(); ++i) {
                maxSizes_arr[i] = maxSizes_ret[i];
            }
            libqt_list maxSizes_out;
            maxSizes_out.len = maxSizes_ret.size();
            maxSizes_out.data = static_cast<void*>(maxSizes_arr);
            libqt_list /* of int */ cbval1 = maxSizes_out;
            QVector<int> minSizes_ret = minSizes;
            // Convert QVector<> from C++ memory to manually-managed C memory
            int* minSizes_arr = static_cast<int*>(malloc(sizeof(int) * (minSizes_ret.size() + 1)));
            for (qsizetype i = 0; i < minSizes_ret.size(); ++i) {
                minSizes_arr[i] = minSizes_ret[i];
            }
            libqt_list minSizes_out;
            minSizes_out.len = minSizes_ret.size();
            minSizes_out.data = static_cast<void*>(minSizes_arr);
            libqt_list /* of int */ cbval2 = minSizes_out;
            QVector<double> stretchFactors_ret = stretchFactors;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* stretchFactors_arr = static_cast<double*>(malloc(sizeof(double) * (stretchFactors_ret.size() + 1)));
            for (qsizetype i = 0; i < stretchFactors_ret.size(); ++i) {
                stretchFactors_arr[i] = stretchFactors_ret[i];
            }
            libqt_list stretchFactors_out;
            stretchFactors_out.len = stretchFactors_ret.size();
            stretchFactors_out.data = static_cast<void*>(stretchFactors_arr);
            libqt_list /* of double */ cbval3 = stretchFactors_out;
            int cbval4 = totalSize;

            int* callback_ret = qcplayout_getsectionsizes_callback(this, cbval1, cbval2, cbval3, cbval4);
            QVector<int> callback_ret_QVector;
            for (int* ptr = callback_ret; *ptr != -1; ++ptr) {
                callback_ret_QVector.push_back(*ptr);
            }
            return callback_ret_QVector;
        } else {
            return QCPLayout::getSectionSizes(maxSizes, minSizes, stretchFactors, totalSize);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcplayout_initializeparentplot_isbase) {
            qcplayout_initializeparentplot_isbase = false;
            QCPLayout::initializeParentPlot(parentPlot);
        } else if (qcplayout_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcplayout_initializeparentplot_callback(this, cbval1);
        } else {
            QCPLayout::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcplayout_setparentlayerable_isbase) {
            qcplayout_setparentlayerable_isbase = false;
            QCPLayout::setParentLayerable(parentLayerable);
        } else if (qcplayout_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcplayout_setparentlayerable_callback(this, cbval1);
        } else {
            QCPLayout::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcplayout_movetolayer_isbase) {
            qcplayout_movetolayer_isbase = false;
            return QCPLayout::moveToLayer(layer, prepend);
        } else if (qcplayout_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcplayout_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPLayout::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcplayout_applyantialiasinghint_isbase) {
            qcplayout_applyantialiasinghint_isbase = false;
            QCPLayout::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcplayout_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcplayout_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPLayout::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcplayout_sender_isbase) {
            qcplayout_sender_isbase = false;
            return QCPLayout::sender();
        } else if (qcplayout_sender_callback != nullptr) {
            QObject* callback_ret = qcplayout_sender_callback();
            return callback_ret;
        } else {
            return QCPLayout::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcplayout_sendersignalindex_isbase) {
            qcplayout_sendersignalindex_isbase = false;
            return QCPLayout::senderSignalIndex();
        } else if (qcplayout_sendersignalindex_callback != nullptr) {
            int callback_ret = qcplayout_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPLayout::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcplayout_receivers_isbase) {
            qcplayout_receivers_isbase = false;
            return QCPLayout::receivers(signal);
        } else if (qcplayout_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcplayout_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPLayout::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcplayout_issignalconnected_isbase) {
            qcplayout_issignalconnected_isbase = false;
            return QCPLayout::isSignalConnected(signal);
        } else if (qcplayout_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcplayout_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPLayout::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPLayout_UpdateLayout(QCPLayout* self);
    friend void QCPLayout_QBaseUpdateLayout(QCPLayout* self);
    friend int QCPLayout_CalculateAutoMargin(QCPLayout* self, int side);
    friend int QCPLayout_QBaseCalculateAutoMargin(QCPLayout* self, int side);
    friend void QCPLayout_LayoutChanged(QCPLayout* self);
    friend void QCPLayout_QBaseLayoutChanged(QCPLayout* self);
    friend void QCPLayout_ApplyDefaultAntialiasingHint(const QCPLayout* self, QCPPainter* painter);
    friend void QCPLayout_QBaseApplyDefaultAntialiasingHint(const QCPLayout* self, QCPPainter* painter);
    friend void QCPLayout_Draw(QCPLayout* self, QCPPainter* painter);
    friend void QCPLayout_QBaseDraw(QCPLayout* self, QCPPainter* painter);
    friend void QCPLayout_ParentPlotInitialized(QCPLayout* self, QCustomPlot* parentPlot);
    friend void QCPLayout_QBaseParentPlotInitialized(QCPLayout* self, QCustomPlot* parentPlot);
    friend int QCPLayout_SelectionCategory(const QCPLayout* self);
    friend int QCPLayout_QBaseSelectionCategory(const QCPLayout* self);
    friend QRect* QCPLayout_ClipRect(const QCPLayout* self);
    friend QRect* QCPLayout_QBaseClipRect(const QCPLayout* self);
    friend void QCPLayout_SelectEvent(QCPLayout* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPLayout_QBaseSelectEvent(QCPLayout* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPLayout_DeselectEvent(QCPLayout* self, bool* selectionStateChanged);
    friend void QCPLayout_QBaseDeselectEvent(QCPLayout* self, bool* selectionStateChanged);
    friend void QCPLayout_MousePressEvent(QCPLayout* self, QMouseEvent* event, const QVariant* details);
    friend void QCPLayout_QBaseMousePressEvent(QCPLayout* self, QMouseEvent* event, const QVariant* details);
    friend void QCPLayout_MouseMoveEvent(QCPLayout* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPLayout_QBaseMouseMoveEvent(QCPLayout* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPLayout_MouseReleaseEvent(QCPLayout* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPLayout_QBaseMouseReleaseEvent(QCPLayout* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPLayout_MouseDoubleClickEvent(QCPLayout* self, QMouseEvent* event, const QVariant* details);
    friend void QCPLayout_QBaseMouseDoubleClickEvent(QCPLayout* self, QMouseEvent* event, const QVariant* details);
    friend void QCPLayout_WheelEvent(QCPLayout* self, QWheelEvent* event);
    friend void QCPLayout_QBaseWheelEvent(QCPLayout* self, QWheelEvent* event);
    friend void QCPLayout_TimerEvent(QCPLayout* self, QTimerEvent* event);
    friend void QCPLayout_QBaseTimerEvent(QCPLayout* self, QTimerEvent* event);
    friend void QCPLayout_ChildEvent(QCPLayout* self, QChildEvent* event);
    friend void QCPLayout_QBaseChildEvent(QCPLayout* self, QChildEvent* event);
    friend void QCPLayout_CustomEvent(QCPLayout* self, QEvent* event);
    friend void QCPLayout_QBaseCustomEvent(QCPLayout* self, QEvent* event);
    friend void QCPLayout_ConnectNotify(QCPLayout* self, const QMetaMethod* signal);
    friend void QCPLayout_QBaseConnectNotify(QCPLayout* self, const QMetaMethod* signal);
    friend void QCPLayout_DisconnectNotify(QCPLayout* self, const QMetaMethod* signal);
    friend void QCPLayout_QBaseDisconnectNotify(QCPLayout* self, const QMetaMethod* signal);
    friend void QCPLayout_SizeConstraintsChanged(const QCPLayout* self);
    friend void QCPLayout_QBaseSizeConstraintsChanged(const QCPLayout* self);
    friend void QCPLayout_AdoptElement(QCPLayout* self, QCPLayoutElement* el);
    friend void QCPLayout_QBaseAdoptElement(QCPLayout* self, QCPLayoutElement* el);
    friend void QCPLayout_ReleaseElement(QCPLayout* self, QCPLayoutElement* el);
    friend void QCPLayout_QBaseReleaseElement(QCPLayout* self, QCPLayoutElement* el);
    friend libqt_list /* of int */ QCPLayout_GetSectionSizes(const QCPLayout* self, libqt_list /* of int */ maxSizes, libqt_list /* of int */ minSizes, libqt_list /* of double */ stretchFactors, int totalSize);
    friend libqt_list /* of int */ QCPLayout_QBaseGetSectionSizes(const QCPLayout* self, libqt_list /* of int */ maxSizes, libqt_list /* of int */ minSizes, libqt_list /* of double */ stretchFactors, int totalSize);
    friend void QCPLayout_InitializeParentPlot(QCPLayout* self, QCustomPlot* parentPlot);
    friend void QCPLayout_QBaseInitializeParentPlot(QCPLayout* self, QCustomPlot* parentPlot);
    friend void QCPLayout_SetParentLayerable(QCPLayout* self, QCPLayerable* parentLayerable);
    friend void QCPLayout_QBaseSetParentLayerable(QCPLayout* self, QCPLayerable* parentLayerable);
    friend bool QCPLayout_MoveToLayer(QCPLayout* self, QCPLayer* layer, bool prepend);
    friend bool QCPLayout_QBaseMoveToLayer(QCPLayout* self, QCPLayer* layer, bool prepend);
    friend void QCPLayout_ApplyAntialiasingHint(const QCPLayout* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPLayout_QBaseApplyAntialiasingHint(const QCPLayout* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPLayout_Sender(const QCPLayout* self);
    friend QObject* QCPLayout_QBaseSender(const QCPLayout* self);
    friend int QCPLayout_SenderSignalIndex(const QCPLayout* self);
    friend int QCPLayout_QBaseSenderSignalIndex(const QCPLayout* self);
    friend int QCPLayout_Receivers(const QCPLayout* self, const char* signal);
    friend int QCPLayout_QBaseReceivers(const QCPLayout* self, const char* signal);
    friend bool QCPLayout_IsSignalConnected(const QCPLayout* self, const QMetaMethod* signal);
    friend bool QCPLayout_QBaseIsSignalConnected(const QCPLayout* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPLayoutGrid so that we can call protected methods
class VirtualQCPLayoutGrid final : public QCPLayoutGrid {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPLayoutGrid = true;

    // Virtual class public types (including callbacks)
    using QCPLayoutGrid_Metacall_Callback = int (*)(QCPLayoutGrid*, int, int, void**);
    using QCPLayoutGrid_UpdateLayout_Callback = void (*)();
    using QCPLayoutGrid_ElementCount_Callback = int (*)();
    using QCPLayoutGrid_ElementAt_Callback = QCPLayoutElement* (*)(const QCPLayoutGrid*, int);
    using QCPLayoutGrid_TakeAt_Callback = QCPLayoutElement* (*)(QCPLayoutGrid*, int);
    using QCPLayoutGrid_Take_Callback = bool (*)(QCPLayoutGrid*, QCPLayoutElement*);
    using QCPLayoutGrid_Elements_Callback = QCPLayoutElement** (*)(const QCPLayoutGrid*, bool);
    using QCPLayoutGrid_Simplify_Callback = void (*)();
    using QCPLayoutGrid_MinimumOuterSizeHint_Callback = QSize* (*)();
    using QCPLayoutGrid_MaximumOuterSizeHint_Callback = QSize* (*)();
    using QCPLayoutGrid_Update_Callback = void (*)(QCPLayoutGrid*, int);
    using QCPLayoutGrid_SelectTest_Callback = double (*)(const QCPLayoutGrid*, QPointF*, bool, QVariant*);
    using QCPLayoutGrid_CalculateAutoMargin_Callback = int (*)(QCPLayoutGrid*, int);
    using QCPLayoutGrid_LayoutChanged_Callback = void (*)();
    using QCPLayoutGrid_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPLayoutGrid*, QCPPainter*);
    using QCPLayoutGrid_Draw_Callback = void (*)(QCPLayoutGrid*, QCPPainter*);
    using QCPLayoutGrid_ParentPlotInitialized_Callback = void (*)(QCPLayoutGrid*, QCustomPlot*);
    using QCPLayoutGrid_SelectionCategory_Callback = int (*)();
    using QCPLayoutGrid_ClipRect_Callback = QRect* (*)();
    using QCPLayoutGrid_SelectEvent_Callback = void (*)(QCPLayoutGrid*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPLayoutGrid_DeselectEvent_Callback = void (*)(QCPLayoutGrid*, bool*);
    using QCPLayoutGrid_MousePressEvent_Callback = void (*)(QCPLayoutGrid*, QMouseEvent*, QVariant*);
    using QCPLayoutGrid_MouseMoveEvent_Callback = void (*)(QCPLayoutGrid*, QMouseEvent*, QPointF*);
    using QCPLayoutGrid_MouseReleaseEvent_Callback = void (*)(QCPLayoutGrid*, QMouseEvent*, QPointF*);
    using QCPLayoutGrid_MouseDoubleClickEvent_Callback = void (*)(QCPLayoutGrid*, QMouseEvent*, QVariant*);
    using QCPLayoutGrid_WheelEvent_Callback = void (*)(QCPLayoutGrid*, QWheelEvent*);
    using QCPLayoutGrid_Event_Callback = bool (*)(QCPLayoutGrid*, QEvent*);
    using QCPLayoutGrid_EventFilter_Callback = bool (*)(QCPLayoutGrid*, QObject*, QEvent*);
    using QCPLayoutGrid_TimerEvent_Callback = void (*)(QCPLayoutGrid*, QTimerEvent*);
    using QCPLayoutGrid_ChildEvent_Callback = void (*)(QCPLayoutGrid*, QChildEvent*);
    using QCPLayoutGrid_CustomEvent_Callback = void (*)(QCPLayoutGrid*, QEvent*);
    using QCPLayoutGrid_ConnectNotify_Callback = void (*)(QCPLayoutGrid*, QMetaMethod*);
    using QCPLayoutGrid_DisconnectNotify_Callback = void (*)(QCPLayoutGrid*, QMetaMethod*);
    using QCPLayoutGrid_GetMinimumRowColSizes_Callback = void (*)(const QCPLayoutGrid*, libqt_list /* of int */, libqt_list /* of int */);
    using QCPLayoutGrid_GetMaximumRowColSizes_Callback = void (*)(const QCPLayoutGrid*, libqt_list /* of int */, libqt_list /* of int */);
    using QCPLayoutGrid_SizeConstraintsChanged_Callback = void (*)();
    using QCPLayoutGrid_AdoptElement_Callback = void (*)(QCPLayoutGrid*, QCPLayoutElement*);
    using QCPLayoutGrid_ReleaseElement_Callback = void (*)(QCPLayoutGrid*, QCPLayoutElement*);
    using QCPLayoutGrid_GetSectionSizes_Callback = int* (*)(const QCPLayoutGrid*, libqt_list /* of int */, libqt_list /* of int */, libqt_list /* of double */, int);
    using QCPLayoutGrid_InitializeParentPlot_Callback = void (*)(QCPLayoutGrid*, QCustomPlot*);
    using QCPLayoutGrid_SetParentLayerable_Callback = void (*)(QCPLayoutGrid*, QCPLayerable*);
    using QCPLayoutGrid_MoveToLayer_Callback = bool (*)(QCPLayoutGrid*, QCPLayer*, bool);
    using QCPLayoutGrid_ApplyAntialiasingHint_Callback = void (*)(const QCPLayoutGrid*, QCPPainter*, bool, int);
    using QCPLayoutGrid_Sender_Callback = QObject* (*)();
    using QCPLayoutGrid_SenderSignalIndex_Callback = int (*)();
    using QCPLayoutGrid_Receivers_Callback = int (*)(const QCPLayoutGrid*, const char*);
    using QCPLayoutGrid_IsSignalConnected_Callback = bool (*)(const QCPLayoutGrid*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPLayoutGrid_Metacall_Callback qcplayoutgrid_metacall_callback = nullptr;
    QCPLayoutGrid_UpdateLayout_Callback qcplayoutgrid_updatelayout_callback = nullptr;
    QCPLayoutGrid_ElementCount_Callback qcplayoutgrid_elementcount_callback = nullptr;
    QCPLayoutGrid_ElementAt_Callback qcplayoutgrid_elementat_callback = nullptr;
    QCPLayoutGrid_TakeAt_Callback qcplayoutgrid_takeat_callback = nullptr;
    QCPLayoutGrid_Take_Callback qcplayoutgrid_take_callback = nullptr;
    QCPLayoutGrid_Elements_Callback qcplayoutgrid_elements_callback = nullptr;
    QCPLayoutGrid_Simplify_Callback qcplayoutgrid_simplify_callback = nullptr;
    QCPLayoutGrid_MinimumOuterSizeHint_Callback qcplayoutgrid_minimumoutersizehint_callback = nullptr;
    QCPLayoutGrid_MaximumOuterSizeHint_Callback qcplayoutgrid_maximumoutersizehint_callback = nullptr;
    QCPLayoutGrid_Update_Callback qcplayoutgrid_update_callback = nullptr;
    QCPLayoutGrid_SelectTest_Callback qcplayoutgrid_selecttest_callback = nullptr;
    QCPLayoutGrid_CalculateAutoMargin_Callback qcplayoutgrid_calculateautomargin_callback = nullptr;
    QCPLayoutGrid_LayoutChanged_Callback qcplayoutgrid_layoutchanged_callback = nullptr;
    QCPLayoutGrid_ApplyDefaultAntialiasingHint_Callback qcplayoutgrid_applydefaultantialiasinghint_callback = nullptr;
    QCPLayoutGrid_Draw_Callback qcplayoutgrid_draw_callback = nullptr;
    QCPLayoutGrid_ParentPlotInitialized_Callback qcplayoutgrid_parentplotinitialized_callback = nullptr;
    QCPLayoutGrid_SelectionCategory_Callback qcplayoutgrid_selectioncategory_callback = nullptr;
    QCPLayoutGrid_ClipRect_Callback qcplayoutgrid_cliprect_callback = nullptr;
    QCPLayoutGrid_SelectEvent_Callback qcplayoutgrid_selectevent_callback = nullptr;
    QCPLayoutGrid_DeselectEvent_Callback qcplayoutgrid_deselectevent_callback = nullptr;
    QCPLayoutGrid_MousePressEvent_Callback qcplayoutgrid_mousepressevent_callback = nullptr;
    QCPLayoutGrid_MouseMoveEvent_Callback qcplayoutgrid_mousemoveevent_callback = nullptr;
    QCPLayoutGrid_MouseReleaseEvent_Callback qcplayoutgrid_mousereleaseevent_callback = nullptr;
    QCPLayoutGrid_MouseDoubleClickEvent_Callback qcplayoutgrid_mousedoubleclickevent_callback = nullptr;
    QCPLayoutGrid_WheelEvent_Callback qcplayoutgrid_wheelevent_callback = nullptr;
    QCPLayoutGrid_Event_Callback qcplayoutgrid_event_callback = nullptr;
    QCPLayoutGrid_EventFilter_Callback qcplayoutgrid_eventfilter_callback = nullptr;
    QCPLayoutGrid_TimerEvent_Callback qcplayoutgrid_timerevent_callback = nullptr;
    QCPLayoutGrid_ChildEvent_Callback qcplayoutgrid_childevent_callback = nullptr;
    QCPLayoutGrid_CustomEvent_Callback qcplayoutgrid_customevent_callback = nullptr;
    QCPLayoutGrid_ConnectNotify_Callback qcplayoutgrid_connectnotify_callback = nullptr;
    QCPLayoutGrid_DisconnectNotify_Callback qcplayoutgrid_disconnectnotify_callback = nullptr;
    QCPLayoutGrid_GetMinimumRowColSizes_Callback qcplayoutgrid_getminimumrowcolsizes_callback = nullptr;
    QCPLayoutGrid_GetMaximumRowColSizes_Callback qcplayoutgrid_getmaximumrowcolsizes_callback = nullptr;
    QCPLayoutGrid_SizeConstraintsChanged_Callback qcplayoutgrid_sizeconstraintschanged_callback = nullptr;
    QCPLayoutGrid_AdoptElement_Callback qcplayoutgrid_adoptelement_callback = nullptr;
    QCPLayoutGrid_ReleaseElement_Callback qcplayoutgrid_releaseelement_callback = nullptr;
    QCPLayoutGrid_GetSectionSizes_Callback qcplayoutgrid_getsectionsizes_callback = nullptr;
    QCPLayoutGrid_InitializeParentPlot_Callback qcplayoutgrid_initializeparentplot_callback = nullptr;
    QCPLayoutGrid_SetParentLayerable_Callback qcplayoutgrid_setparentlayerable_callback = nullptr;
    QCPLayoutGrid_MoveToLayer_Callback qcplayoutgrid_movetolayer_callback = nullptr;
    QCPLayoutGrid_ApplyAntialiasingHint_Callback qcplayoutgrid_applyantialiasinghint_callback = nullptr;
    QCPLayoutGrid_Sender_Callback qcplayoutgrid_sender_callback = nullptr;
    QCPLayoutGrid_SenderSignalIndex_Callback qcplayoutgrid_sendersignalindex_callback = nullptr;
    QCPLayoutGrid_Receivers_Callback qcplayoutgrid_receivers_callback = nullptr;
    QCPLayoutGrid_IsSignalConnected_Callback qcplayoutgrid_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcplayoutgrid_metacall_isbase = false;
    mutable bool qcplayoutgrid_updatelayout_isbase = false;
    mutable bool qcplayoutgrid_elementcount_isbase = false;
    mutable bool qcplayoutgrid_elementat_isbase = false;
    mutable bool qcplayoutgrid_takeat_isbase = false;
    mutable bool qcplayoutgrid_take_isbase = false;
    mutable bool qcplayoutgrid_elements_isbase = false;
    mutable bool qcplayoutgrid_simplify_isbase = false;
    mutable bool qcplayoutgrid_minimumoutersizehint_isbase = false;
    mutable bool qcplayoutgrid_maximumoutersizehint_isbase = false;
    mutable bool qcplayoutgrid_update_isbase = false;
    mutable bool qcplayoutgrid_selecttest_isbase = false;
    mutable bool qcplayoutgrid_calculateautomargin_isbase = false;
    mutable bool qcplayoutgrid_layoutchanged_isbase = false;
    mutable bool qcplayoutgrid_applydefaultantialiasinghint_isbase = false;
    mutable bool qcplayoutgrid_draw_isbase = false;
    mutable bool qcplayoutgrid_parentplotinitialized_isbase = false;
    mutable bool qcplayoutgrid_selectioncategory_isbase = false;
    mutable bool qcplayoutgrid_cliprect_isbase = false;
    mutable bool qcplayoutgrid_selectevent_isbase = false;
    mutable bool qcplayoutgrid_deselectevent_isbase = false;
    mutable bool qcplayoutgrid_mousepressevent_isbase = false;
    mutable bool qcplayoutgrid_mousemoveevent_isbase = false;
    mutable bool qcplayoutgrid_mousereleaseevent_isbase = false;
    mutable bool qcplayoutgrid_mousedoubleclickevent_isbase = false;
    mutable bool qcplayoutgrid_wheelevent_isbase = false;
    mutable bool qcplayoutgrid_event_isbase = false;
    mutable bool qcplayoutgrid_eventfilter_isbase = false;
    mutable bool qcplayoutgrid_timerevent_isbase = false;
    mutable bool qcplayoutgrid_childevent_isbase = false;
    mutable bool qcplayoutgrid_customevent_isbase = false;
    mutable bool qcplayoutgrid_connectnotify_isbase = false;
    mutable bool qcplayoutgrid_disconnectnotify_isbase = false;
    mutable bool qcplayoutgrid_getminimumrowcolsizes_isbase = false;
    mutable bool qcplayoutgrid_getmaximumrowcolsizes_isbase = false;
    mutable bool qcplayoutgrid_sizeconstraintschanged_isbase = false;
    mutable bool qcplayoutgrid_adoptelement_isbase = false;
    mutable bool qcplayoutgrid_releaseelement_isbase = false;
    mutable bool qcplayoutgrid_getsectionsizes_isbase = false;
    mutable bool qcplayoutgrid_initializeparentplot_isbase = false;
    mutable bool qcplayoutgrid_setparentlayerable_isbase = false;
    mutable bool qcplayoutgrid_movetolayer_isbase = false;
    mutable bool qcplayoutgrid_applyantialiasinghint_isbase = false;
    mutable bool qcplayoutgrid_sender_isbase = false;
    mutable bool qcplayoutgrid_sendersignalindex_isbase = false;
    mutable bool qcplayoutgrid_receivers_isbase = false;
    mutable bool qcplayoutgrid_issignalconnected_isbase = false;

  public:
    VirtualQCPLayoutGrid() : QCPLayoutGrid() {};

    ~VirtualQCPLayoutGrid() {
        qcplayoutgrid_metacall_callback = nullptr;
        qcplayoutgrid_updatelayout_callback = nullptr;
        qcplayoutgrid_elementcount_callback = nullptr;
        qcplayoutgrid_elementat_callback = nullptr;
        qcplayoutgrid_takeat_callback = nullptr;
        qcplayoutgrid_take_callback = nullptr;
        qcplayoutgrid_elements_callback = nullptr;
        qcplayoutgrid_simplify_callback = nullptr;
        qcplayoutgrid_minimumoutersizehint_callback = nullptr;
        qcplayoutgrid_maximumoutersizehint_callback = nullptr;
        qcplayoutgrid_update_callback = nullptr;
        qcplayoutgrid_selecttest_callback = nullptr;
        qcplayoutgrid_calculateautomargin_callback = nullptr;
        qcplayoutgrid_layoutchanged_callback = nullptr;
        qcplayoutgrid_applydefaultantialiasinghint_callback = nullptr;
        qcplayoutgrid_draw_callback = nullptr;
        qcplayoutgrid_parentplotinitialized_callback = nullptr;
        qcplayoutgrid_selectioncategory_callback = nullptr;
        qcplayoutgrid_cliprect_callback = nullptr;
        qcplayoutgrid_selectevent_callback = nullptr;
        qcplayoutgrid_deselectevent_callback = nullptr;
        qcplayoutgrid_mousepressevent_callback = nullptr;
        qcplayoutgrid_mousemoveevent_callback = nullptr;
        qcplayoutgrid_mousereleaseevent_callback = nullptr;
        qcplayoutgrid_mousedoubleclickevent_callback = nullptr;
        qcplayoutgrid_wheelevent_callback = nullptr;
        qcplayoutgrid_event_callback = nullptr;
        qcplayoutgrid_eventfilter_callback = nullptr;
        qcplayoutgrid_timerevent_callback = nullptr;
        qcplayoutgrid_childevent_callback = nullptr;
        qcplayoutgrid_customevent_callback = nullptr;
        qcplayoutgrid_connectnotify_callback = nullptr;
        qcplayoutgrid_disconnectnotify_callback = nullptr;
        qcplayoutgrid_getminimumrowcolsizes_callback = nullptr;
        qcplayoutgrid_getmaximumrowcolsizes_callback = nullptr;
        qcplayoutgrid_sizeconstraintschanged_callback = nullptr;
        qcplayoutgrid_adoptelement_callback = nullptr;
        qcplayoutgrid_releaseelement_callback = nullptr;
        qcplayoutgrid_getsectionsizes_callback = nullptr;
        qcplayoutgrid_initializeparentplot_callback = nullptr;
        qcplayoutgrid_setparentlayerable_callback = nullptr;
        qcplayoutgrid_movetolayer_callback = nullptr;
        qcplayoutgrid_applyantialiasinghint_callback = nullptr;
        qcplayoutgrid_sender_callback = nullptr;
        qcplayoutgrid_sendersignalindex_callback = nullptr;
        qcplayoutgrid_receivers_callback = nullptr;
        qcplayoutgrid_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPLayoutGrid_Metacall_Callback(QCPLayoutGrid_Metacall_Callback cb) { qcplayoutgrid_metacall_callback = cb; }
    inline void setQCPLayoutGrid_UpdateLayout_Callback(QCPLayoutGrid_UpdateLayout_Callback cb) { qcplayoutgrid_updatelayout_callback = cb; }
    inline void setQCPLayoutGrid_ElementCount_Callback(QCPLayoutGrid_ElementCount_Callback cb) { qcplayoutgrid_elementcount_callback = cb; }
    inline void setQCPLayoutGrid_ElementAt_Callback(QCPLayoutGrid_ElementAt_Callback cb) { qcplayoutgrid_elementat_callback = cb; }
    inline void setQCPLayoutGrid_TakeAt_Callback(QCPLayoutGrid_TakeAt_Callback cb) { qcplayoutgrid_takeat_callback = cb; }
    inline void setQCPLayoutGrid_Take_Callback(QCPLayoutGrid_Take_Callback cb) { qcplayoutgrid_take_callback = cb; }
    inline void setQCPLayoutGrid_Elements_Callback(QCPLayoutGrid_Elements_Callback cb) { qcplayoutgrid_elements_callback = cb; }
    inline void setQCPLayoutGrid_Simplify_Callback(QCPLayoutGrid_Simplify_Callback cb) { qcplayoutgrid_simplify_callback = cb; }
    inline void setQCPLayoutGrid_MinimumOuterSizeHint_Callback(QCPLayoutGrid_MinimumOuterSizeHint_Callback cb) { qcplayoutgrid_minimumoutersizehint_callback = cb; }
    inline void setQCPLayoutGrid_MaximumOuterSizeHint_Callback(QCPLayoutGrid_MaximumOuterSizeHint_Callback cb) { qcplayoutgrid_maximumoutersizehint_callback = cb; }
    inline void setQCPLayoutGrid_Update_Callback(QCPLayoutGrid_Update_Callback cb) { qcplayoutgrid_update_callback = cb; }
    inline void setQCPLayoutGrid_SelectTest_Callback(QCPLayoutGrid_SelectTest_Callback cb) { qcplayoutgrid_selecttest_callback = cb; }
    inline void setQCPLayoutGrid_CalculateAutoMargin_Callback(QCPLayoutGrid_CalculateAutoMargin_Callback cb) { qcplayoutgrid_calculateautomargin_callback = cb; }
    inline void setQCPLayoutGrid_LayoutChanged_Callback(QCPLayoutGrid_LayoutChanged_Callback cb) { qcplayoutgrid_layoutchanged_callback = cb; }
    inline void setQCPLayoutGrid_ApplyDefaultAntialiasingHint_Callback(QCPLayoutGrid_ApplyDefaultAntialiasingHint_Callback cb) { qcplayoutgrid_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPLayoutGrid_Draw_Callback(QCPLayoutGrid_Draw_Callback cb) { qcplayoutgrid_draw_callback = cb; }
    inline void setQCPLayoutGrid_ParentPlotInitialized_Callback(QCPLayoutGrid_ParentPlotInitialized_Callback cb) { qcplayoutgrid_parentplotinitialized_callback = cb; }
    inline void setQCPLayoutGrid_SelectionCategory_Callback(QCPLayoutGrid_SelectionCategory_Callback cb) { qcplayoutgrid_selectioncategory_callback = cb; }
    inline void setQCPLayoutGrid_ClipRect_Callback(QCPLayoutGrid_ClipRect_Callback cb) { qcplayoutgrid_cliprect_callback = cb; }
    inline void setQCPLayoutGrid_SelectEvent_Callback(QCPLayoutGrid_SelectEvent_Callback cb) { qcplayoutgrid_selectevent_callback = cb; }
    inline void setQCPLayoutGrid_DeselectEvent_Callback(QCPLayoutGrid_DeselectEvent_Callback cb) { qcplayoutgrid_deselectevent_callback = cb; }
    inline void setQCPLayoutGrid_MousePressEvent_Callback(QCPLayoutGrid_MousePressEvent_Callback cb) { qcplayoutgrid_mousepressevent_callback = cb; }
    inline void setQCPLayoutGrid_MouseMoveEvent_Callback(QCPLayoutGrid_MouseMoveEvent_Callback cb) { qcplayoutgrid_mousemoveevent_callback = cb; }
    inline void setQCPLayoutGrid_MouseReleaseEvent_Callback(QCPLayoutGrid_MouseReleaseEvent_Callback cb) { qcplayoutgrid_mousereleaseevent_callback = cb; }
    inline void setQCPLayoutGrid_MouseDoubleClickEvent_Callback(QCPLayoutGrid_MouseDoubleClickEvent_Callback cb) { qcplayoutgrid_mousedoubleclickevent_callback = cb; }
    inline void setQCPLayoutGrid_WheelEvent_Callback(QCPLayoutGrid_WheelEvent_Callback cb) { qcplayoutgrid_wheelevent_callback = cb; }
    inline void setQCPLayoutGrid_Event_Callback(QCPLayoutGrid_Event_Callback cb) { qcplayoutgrid_event_callback = cb; }
    inline void setQCPLayoutGrid_EventFilter_Callback(QCPLayoutGrid_EventFilter_Callback cb) { qcplayoutgrid_eventfilter_callback = cb; }
    inline void setQCPLayoutGrid_TimerEvent_Callback(QCPLayoutGrid_TimerEvent_Callback cb) { qcplayoutgrid_timerevent_callback = cb; }
    inline void setQCPLayoutGrid_ChildEvent_Callback(QCPLayoutGrid_ChildEvent_Callback cb) { qcplayoutgrid_childevent_callback = cb; }
    inline void setQCPLayoutGrid_CustomEvent_Callback(QCPLayoutGrid_CustomEvent_Callback cb) { qcplayoutgrid_customevent_callback = cb; }
    inline void setQCPLayoutGrid_ConnectNotify_Callback(QCPLayoutGrid_ConnectNotify_Callback cb) { qcplayoutgrid_connectnotify_callback = cb; }
    inline void setQCPLayoutGrid_DisconnectNotify_Callback(QCPLayoutGrid_DisconnectNotify_Callback cb) { qcplayoutgrid_disconnectnotify_callback = cb; }
    inline void setQCPLayoutGrid_GetMinimumRowColSizes_Callback(QCPLayoutGrid_GetMinimumRowColSizes_Callback cb) { qcplayoutgrid_getminimumrowcolsizes_callback = cb; }
    inline void setQCPLayoutGrid_GetMaximumRowColSizes_Callback(QCPLayoutGrid_GetMaximumRowColSizes_Callback cb) { qcplayoutgrid_getmaximumrowcolsizes_callback = cb; }
    inline void setQCPLayoutGrid_SizeConstraintsChanged_Callback(QCPLayoutGrid_SizeConstraintsChanged_Callback cb) { qcplayoutgrid_sizeconstraintschanged_callback = cb; }
    inline void setQCPLayoutGrid_AdoptElement_Callback(QCPLayoutGrid_AdoptElement_Callback cb) { qcplayoutgrid_adoptelement_callback = cb; }
    inline void setQCPLayoutGrid_ReleaseElement_Callback(QCPLayoutGrid_ReleaseElement_Callback cb) { qcplayoutgrid_releaseelement_callback = cb; }
    inline void setQCPLayoutGrid_GetSectionSizes_Callback(QCPLayoutGrid_GetSectionSizes_Callback cb) { qcplayoutgrid_getsectionsizes_callback = cb; }
    inline void setQCPLayoutGrid_InitializeParentPlot_Callback(QCPLayoutGrid_InitializeParentPlot_Callback cb) { qcplayoutgrid_initializeparentplot_callback = cb; }
    inline void setQCPLayoutGrid_SetParentLayerable_Callback(QCPLayoutGrid_SetParentLayerable_Callback cb) { qcplayoutgrid_setparentlayerable_callback = cb; }
    inline void setQCPLayoutGrid_MoveToLayer_Callback(QCPLayoutGrid_MoveToLayer_Callback cb) { qcplayoutgrid_movetolayer_callback = cb; }
    inline void setQCPLayoutGrid_ApplyAntialiasingHint_Callback(QCPLayoutGrid_ApplyAntialiasingHint_Callback cb) { qcplayoutgrid_applyantialiasinghint_callback = cb; }
    inline void setQCPLayoutGrid_Sender_Callback(QCPLayoutGrid_Sender_Callback cb) { qcplayoutgrid_sender_callback = cb; }
    inline void setQCPLayoutGrid_SenderSignalIndex_Callback(QCPLayoutGrid_SenderSignalIndex_Callback cb) { qcplayoutgrid_sendersignalindex_callback = cb; }
    inline void setQCPLayoutGrid_Receivers_Callback(QCPLayoutGrid_Receivers_Callback cb) { qcplayoutgrid_receivers_callback = cb; }
    inline void setQCPLayoutGrid_IsSignalConnected_Callback(QCPLayoutGrid_IsSignalConnected_Callback cb) { qcplayoutgrid_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPLayoutGrid_Metacall_IsBase(bool value) const { qcplayoutgrid_metacall_isbase = value; }
    inline void setQCPLayoutGrid_UpdateLayout_IsBase(bool value) const { qcplayoutgrid_updatelayout_isbase = value; }
    inline void setQCPLayoutGrid_ElementCount_IsBase(bool value) const { qcplayoutgrid_elementcount_isbase = value; }
    inline void setQCPLayoutGrid_ElementAt_IsBase(bool value) const { qcplayoutgrid_elementat_isbase = value; }
    inline void setQCPLayoutGrid_TakeAt_IsBase(bool value) const { qcplayoutgrid_takeat_isbase = value; }
    inline void setQCPLayoutGrid_Take_IsBase(bool value) const { qcplayoutgrid_take_isbase = value; }
    inline void setQCPLayoutGrid_Elements_IsBase(bool value) const { qcplayoutgrid_elements_isbase = value; }
    inline void setQCPLayoutGrid_Simplify_IsBase(bool value) const { qcplayoutgrid_simplify_isbase = value; }
    inline void setQCPLayoutGrid_MinimumOuterSizeHint_IsBase(bool value) const { qcplayoutgrid_minimumoutersizehint_isbase = value; }
    inline void setQCPLayoutGrid_MaximumOuterSizeHint_IsBase(bool value) const { qcplayoutgrid_maximumoutersizehint_isbase = value; }
    inline void setQCPLayoutGrid_Update_IsBase(bool value) const { qcplayoutgrid_update_isbase = value; }
    inline void setQCPLayoutGrid_SelectTest_IsBase(bool value) const { qcplayoutgrid_selecttest_isbase = value; }
    inline void setQCPLayoutGrid_CalculateAutoMargin_IsBase(bool value) const { qcplayoutgrid_calculateautomargin_isbase = value; }
    inline void setQCPLayoutGrid_LayoutChanged_IsBase(bool value) const { qcplayoutgrid_layoutchanged_isbase = value; }
    inline void setQCPLayoutGrid_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcplayoutgrid_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPLayoutGrid_Draw_IsBase(bool value) const { qcplayoutgrid_draw_isbase = value; }
    inline void setQCPLayoutGrid_ParentPlotInitialized_IsBase(bool value) const { qcplayoutgrid_parentplotinitialized_isbase = value; }
    inline void setQCPLayoutGrid_SelectionCategory_IsBase(bool value) const { qcplayoutgrid_selectioncategory_isbase = value; }
    inline void setQCPLayoutGrid_ClipRect_IsBase(bool value) const { qcplayoutgrid_cliprect_isbase = value; }
    inline void setQCPLayoutGrid_SelectEvent_IsBase(bool value) const { qcplayoutgrid_selectevent_isbase = value; }
    inline void setQCPLayoutGrid_DeselectEvent_IsBase(bool value) const { qcplayoutgrid_deselectevent_isbase = value; }
    inline void setQCPLayoutGrid_MousePressEvent_IsBase(bool value) const { qcplayoutgrid_mousepressevent_isbase = value; }
    inline void setQCPLayoutGrid_MouseMoveEvent_IsBase(bool value) const { qcplayoutgrid_mousemoveevent_isbase = value; }
    inline void setQCPLayoutGrid_MouseReleaseEvent_IsBase(bool value) const { qcplayoutgrid_mousereleaseevent_isbase = value; }
    inline void setQCPLayoutGrid_MouseDoubleClickEvent_IsBase(bool value) const { qcplayoutgrid_mousedoubleclickevent_isbase = value; }
    inline void setQCPLayoutGrid_WheelEvent_IsBase(bool value) const { qcplayoutgrid_wheelevent_isbase = value; }
    inline void setQCPLayoutGrid_Event_IsBase(bool value) const { qcplayoutgrid_event_isbase = value; }
    inline void setQCPLayoutGrid_EventFilter_IsBase(bool value) const { qcplayoutgrid_eventfilter_isbase = value; }
    inline void setQCPLayoutGrid_TimerEvent_IsBase(bool value) const { qcplayoutgrid_timerevent_isbase = value; }
    inline void setQCPLayoutGrid_ChildEvent_IsBase(bool value) const { qcplayoutgrid_childevent_isbase = value; }
    inline void setQCPLayoutGrid_CustomEvent_IsBase(bool value) const { qcplayoutgrid_customevent_isbase = value; }
    inline void setQCPLayoutGrid_ConnectNotify_IsBase(bool value) const { qcplayoutgrid_connectnotify_isbase = value; }
    inline void setQCPLayoutGrid_DisconnectNotify_IsBase(bool value) const { qcplayoutgrid_disconnectnotify_isbase = value; }
    inline void setQCPLayoutGrid_GetMinimumRowColSizes_IsBase(bool value) const { qcplayoutgrid_getminimumrowcolsizes_isbase = value; }
    inline void setQCPLayoutGrid_GetMaximumRowColSizes_IsBase(bool value) const { qcplayoutgrid_getmaximumrowcolsizes_isbase = value; }
    inline void setQCPLayoutGrid_SizeConstraintsChanged_IsBase(bool value) const { qcplayoutgrid_sizeconstraintschanged_isbase = value; }
    inline void setQCPLayoutGrid_AdoptElement_IsBase(bool value) const { qcplayoutgrid_adoptelement_isbase = value; }
    inline void setQCPLayoutGrid_ReleaseElement_IsBase(bool value) const { qcplayoutgrid_releaseelement_isbase = value; }
    inline void setQCPLayoutGrid_GetSectionSizes_IsBase(bool value) const { qcplayoutgrid_getsectionsizes_isbase = value; }
    inline void setQCPLayoutGrid_InitializeParentPlot_IsBase(bool value) const { qcplayoutgrid_initializeparentplot_isbase = value; }
    inline void setQCPLayoutGrid_SetParentLayerable_IsBase(bool value) const { qcplayoutgrid_setparentlayerable_isbase = value; }
    inline void setQCPLayoutGrid_MoveToLayer_IsBase(bool value) const { qcplayoutgrid_movetolayer_isbase = value; }
    inline void setQCPLayoutGrid_ApplyAntialiasingHint_IsBase(bool value) const { qcplayoutgrid_applyantialiasinghint_isbase = value; }
    inline void setQCPLayoutGrid_Sender_IsBase(bool value) const { qcplayoutgrid_sender_isbase = value; }
    inline void setQCPLayoutGrid_SenderSignalIndex_IsBase(bool value) const { qcplayoutgrid_sendersignalindex_isbase = value; }
    inline void setQCPLayoutGrid_Receivers_IsBase(bool value) const { qcplayoutgrid_receivers_isbase = value; }
    inline void setQCPLayoutGrid_IsSignalConnected_IsBase(bool value) const { qcplayoutgrid_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcplayoutgrid_metacall_isbase) {
            qcplayoutgrid_metacall_isbase = false;
            return QCPLayoutGrid::qt_metacall(param1, param2, param3);
        } else if (qcplayoutgrid_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcplayoutgrid_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPLayoutGrid::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void updateLayout() override {
        if (qcplayoutgrid_updatelayout_isbase) {
            qcplayoutgrid_updatelayout_isbase = false;
            QCPLayoutGrid::updateLayout();
        } else if (qcplayoutgrid_updatelayout_callback != nullptr) {
            qcplayoutgrid_updatelayout_callback();
        } else {
            QCPLayoutGrid::updateLayout();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int elementCount() const override {
        if (qcplayoutgrid_elementcount_isbase) {
            qcplayoutgrid_elementcount_isbase = false;
            return QCPLayoutGrid::elementCount();
        } else if (qcplayoutgrid_elementcount_callback != nullptr) {
            int callback_ret = qcplayoutgrid_elementcount_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPLayoutGrid::elementCount();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPLayoutElement* elementAt(int index) const override {
        if (qcplayoutgrid_elementat_isbase) {
            qcplayoutgrid_elementat_isbase = false;
            return QCPLayoutGrid::elementAt(index);
        } else if (qcplayoutgrid_elementat_callback != nullptr) {
            int cbval1 = index;

            QCPLayoutElement* callback_ret = qcplayoutgrid_elementat_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPLayoutGrid::elementAt(index);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPLayoutElement* takeAt(int index) override {
        if (qcplayoutgrid_takeat_isbase) {
            qcplayoutgrid_takeat_isbase = false;
            return QCPLayoutGrid::takeAt(index);
        } else if (qcplayoutgrid_takeat_callback != nullptr) {
            int cbval1 = index;

            QCPLayoutElement* callback_ret = qcplayoutgrid_takeat_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPLayoutGrid::takeAt(index);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool take(QCPLayoutElement* element) override {
        if (qcplayoutgrid_take_isbase) {
            qcplayoutgrid_take_isbase = false;
            return QCPLayoutGrid::take(element);
        } else if (qcplayoutgrid_take_callback != nullptr) {
            QCPLayoutElement* cbval1 = element;

            bool callback_ret = qcplayoutgrid_take_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPLayoutGrid::take(element);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QList<QCPLayoutElement*> elements(bool recursive) const override {
        if (qcplayoutgrid_elements_isbase) {
            qcplayoutgrid_elements_isbase = false;
            return QCPLayoutGrid::elements(recursive);
        } else if (qcplayoutgrid_elements_callback != nullptr) {
            bool cbval1 = recursive;

            QCPLayoutElement** callback_ret = qcplayoutgrid_elements_callback(this, cbval1);
            QList<QCPLayoutElement*> callback_ret_QList;
            // Iterate until null pointer sentinel
            for (QCPLayoutElement** ptridx = callback_ret; *ptridx != nullptr; ptridx++) {
                callback_ret_QList.push_back(*ptridx);
            }
            free(callback_ret);
            return callback_ret_QList;
        } else {
            return QCPLayoutGrid::elements(recursive);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void simplify() override {
        if (qcplayoutgrid_simplify_isbase) {
            qcplayoutgrid_simplify_isbase = false;
            QCPLayoutGrid::simplify();
        } else if (qcplayoutgrid_simplify_callback != nullptr) {
            qcplayoutgrid_simplify_callback();
        } else {
            QCPLayoutGrid::simplify();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize minimumOuterSizeHint() const override {
        if (qcplayoutgrid_minimumoutersizehint_isbase) {
            qcplayoutgrid_minimumoutersizehint_isbase = false;
            return QCPLayoutGrid::minimumOuterSizeHint();
        } else if (qcplayoutgrid_minimumoutersizehint_callback != nullptr) {
            QSize* callback_ret = qcplayoutgrid_minimumoutersizehint_callback();
            return *callback_ret;
        } else {
            return QCPLayoutGrid::minimumOuterSizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize maximumOuterSizeHint() const override {
        if (qcplayoutgrid_maximumoutersizehint_isbase) {
            qcplayoutgrid_maximumoutersizehint_isbase = false;
            return QCPLayoutGrid::maximumOuterSizeHint();
        } else if (qcplayoutgrid_maximumoutersizehint_callback != nullptr) {
            QSize* callback_ret = qcplayoutgrid_maximumoutersizehint_callback();
            return *callback_ret;
        } else {
            return QCPLayoutGrid::maximumOuterSizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void update(QCPLayoutElement::UpdatePhase phase) override {
        if (qcplayoutgrid_update_isbase) {
            qcplayoutgrid_update_isbase = false;
            QCPLayoutGrid::update(phase);
        } else if (qcplayoutgrid_update_callback != nullptr) {
            int cbval1 = static_cast<int>(phase);

            qcplayoutgrid_update_callback(this, cbval1);
        } else {
            QCPLayoutGrid::update(phase);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcplayoutgrid_selecttest_isbase) {
            qcplayoutgrid_selecttest_isbase = false;
            return QCPLayoutGrid::selectTest(pos, onlySelectable, details);
        } else if (qcplayoutgrid_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcplayoutgrid_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPLayoutGrid::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int calculateAutoMargin(QCP::MarginSide side) override {
        if (qcplayoutgrid_calculateautomargin_isbase) {
            qcplayoutgrid_calculateautomargin_isbase = false;
            return QCPLayoutGrid::calculateAutoMargin(side);
        } else if (qcplayoutgrid_calculateautomargin_callback != nullptr) {
            int cbval1 = static_cast<int>(side);

            int callback_ret = qcplayoutgrid_calculateautomargin_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPLayoutGrid::calculateAutoMargin(side);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void layoutChanged() override {
        if (qcplayoutgrid_layoutchanged_isbase) {
            qcplayoutgrid_layoutchanged_isbase = false;
            QCPLayoutGrid::layoutChanged();
        } else if (qcplayoutgrid_layoutchanged_callback != nullptr) {
            qcplayoutgrid_layoutchanged_callback();
        } else {
            QCPLayoutGrid::layoutChanged();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcplayoutgrid_applydefaultantialiasinghint_isbase) {
            qcplayoutgrid_applydefaultantialiasinghint_isbase = false;
            QCPLayoutGrid::applyDefaultAntialiasingHint(painter);
        } else if (qcplayoutgrid_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcplayoutgrid_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPLayoutGrid::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcplayoutgrid_draw_isbase) {
            qcplayoutgrid_draw_isbase = false;
            QCPLayoutGrid::draw(painter);
        } else if (qcplayoutgrid_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcplayoutgrid_draw_callback(this, cbval1);
        } else {
            QCPLayoutGrid::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcplayoutgrid_parentplotinitialized_isbase) {
            qcplayoutgrid_parentplotinitialized_isbase = false;
            QCPLayoutGrid::parentPlotInitialized(parentPlot);
        } else if (qcplayoutgrid_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcplayoutgrid_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPLayoutGrid::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcplayoutgrid_selectioncategory_isbase) {
            qcplayoutgrid_selectioncategory_isbase = false;
            return QCPLayoutGrid::selectionCategory();
        } else if (qcplayoutgrid_selectioncategory_callback != nullptr) {
            int callback_ret = qcplayoutgrid_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPLayoutGrid::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcplayoutgrid_cliprect_isbase) {
            qcplayoutgrid_cliprect_isbase = false;
            return QCPLayoutGrid::clipRect();
        } else if (qcplayoutgrid_cliprect_callback != nullptr) {
            QRect* callback_ret = qcplayoutgrid_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPLayoutGrid::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcplayoutgrid_selectevent_isbase) {
            qcplayoutgrid_selectevent_isbase = false;
            QCPLayoutGrid::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcplayoutgrid_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcplayoutgrid_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPLayoutGrid::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcplayoutgrid_deselectevent_isbase) {
            qcplayoutgrid_deselectevent_isbase = false;
            QCPLayoutGrid::deselectEvent(selectionStateChanged);
        } else if (qcplayoutgrid_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcplayoutgrid_deselectevent_callback(this, cbval1);
        } else {
            QCPLayoutGrid::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcplayoutgrid_mousepressevent_isbase) {
            qcplayoutgrid_mousepressevent_isbase = false;
            QCPLayoutGrid::mousePressEvent(event, details);
        } else if (qcplayoutgrid_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcplayoutgrid_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPLayoutGrid::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcplayoutgrid_mousemoveevent_isbase) {
            qcplayoutgrid_mousemoveevent_isbase = false;
            QCPLayoutGrid::mouseMoveEvent(event, startPos);
        } else if (qcplayoutgrid_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcplayoutgrid_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPLayoutGrid::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcplayoutgrid_mousereleaseevent_isbase) {
            qcplayoutgrid_mousereleaseevent_isbase = false;
            QCPLayoutGrid::mouseReleaseEvent(event, startPos);
        } else if (qcplayoutgrid_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcplayoutgrid_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPLayoutGrid::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcplayoutgrid_mousedoubleclickevent_isbase) {
            qcplayoutgrid_mousedoubleclickevent_isbase = false;
            QCPLayoutGrid::mouseDoubleClickEvent(event, details);
        } else if (qcplayoutgrid_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcplayoutgrid_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPLayoutGrid::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcplayoutgrid_wheelevent_isbase) {
            qcplayoutgrid_wheelevent_isbase = false;
            QCPLayoutGrid::wheelEvent(event);
        } else if (qcplayoutgrid_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcplayoutgrid_wheelevent_callback(this, cbval1);
        } else {
            QCPLayoutGrid::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcplayoutgrid_event_isbase) {
            qcplayoutgrid_event_isbase = false;
            return QCPLayoutGrid::event(event);
        } else if (qcplayoutgrid_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcplayoutgrid_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPLayoutGrid::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcplayoutgrid_eventfilter_isbase) {
            qcplayoutgrid_eventfilter_isbase = false;
            return QCPLayoutGrid::eventFilter(watched, event);
        } else if (qcplayoutgrid_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcplayoutgrid_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPLayoutGrid::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcplayoutgrid_timerevent_isbase) {
            qcplayoutgrid_timerevent_isbase = false;
            QCPLayoutGrid::timerEvent(event);
        } else if (qcplayoutgrid_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcplayoutgrid_timerevent_callback(this, cbval1);
        } else {
            QCPLayoutGrid::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcplayoutgrid_childevent_isbase) {
            qcplayoutgrid_childevent_isbase = false;
            QCPLayoutGrid::childEvent(event);
        } else if (qcplayoutgrid_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcplayoutgrid_childevent_callback(this, cbval1);
        } else {
            QCPLayoutGrid::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcplayoutgrid_customevent_isbase) {
            qcplayoutgrid_customevent_isbase = false;
            QCPLayoutGrid::customEvent(event);
        } else if (qcplayoutgrid_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcplayoutgrid_customevent_callback(this, cbval1);
        } else {
            QCPLayoutGrid::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcplayoutgrid_connectnotify_isbase) {
            qcplayoutgrid_connectnotify_isbase = false;
            QCPLayoutGrid::connectNotify(signal);
        } else if (qcplayoutgrid_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcplayoutgrid_connectnotify_callback(this, cbval1);
        } else {
            QCPLayoutGrid::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcplayoutgrid_disconnectnotify_isbase) {
            qcplayoutgrid_disconnectnotify_isbase = false;
            QCPLayoutGrid::disconnectNotify(signal);
        } else if (qcplayoutgrid_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcplayoutgrid_disconnectnotify_callback(this, cbval1);
        } else {
            QCPLayoutGrid::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    void getMinimumRowColSizes(QVector<int>* minColWidths, QVector<int>* minRowHeights) const {
        if (qcplayoutgrid_getminimumrowcolsizes_isbase) {
            qcplayoutgrid_getminimumrowcolsizes_isbase = false;
            QCPLayoutGrid::getMinimumRowColSizes(minColWidths, minRowHeights);
        } else if (qcplayoutgrid_getminimumrowcolsizes_callback != nullptr) {
            QVector<int>* minColWidths_ret = minColWidths;
            // Convert QVector<> from C++ memory to manually-managed C memory
            int* minColWidths_arr = static_cast<int*>(malloc(sizeof(int) * (minColWidths_ret->size() + 1)));
            for (qsizetype i = 0; i < minColWidths_ret->size(); ++i) {
                minColWidths_arr[i] = (*minColWidths_ret)[i];
            }
            libqt_list minColWidths_out;
            minColWidths_out.len = minColWidths_ret->size();
            minColWidths_out.data = static_cast<void*>(minColWidths_arr);
            libqt_list /* of int */ cbval1 = minColWidths_out;
            QVector<int>* minRowHeights_ret = minRowHeights;
            // Convert QVector<> from C++ memory to manually-managed C memory
            int* minRowHeights_arr = static_cast<int*>(malloc(sizeof(int) * (minRowHeights_ret->size() + 1)));
            for (qsizetype i = 0; i < minRowHeights_ret->size(); ++i) {
                minRowHeights_arr[i] = (*minRowHeights_ret)[i];
            }
            libqt_list minRowHeights_out;
            minRowHeights_out.len = minRowHeights_ret->size();
            minRowHeights_out.data = static_cast<void*>(minRowHeights_arr);
            libqt_list /* of int */ cbval2 = minRowHeights_out;

            qcplayoutgrid_getminimumrowcolsizes_callback(this, cbval1, cbval2);
        } else {
            QCPLayoutGrid::getMinimumRowColSizes(minColWidths, minRowHeights);
        }
    }

    // Virtual method for C ABI access and custom callback
    void getMaximumRowColSizes(QVector<int>* maxColWidths, QVector<int>* maxRowHeights) const {
        if (qcplayoutgrid_getmaximumrowcolsizes_isbase) {
            qcplayoutgrid_getmaximumrowcolsizes_isbase = false;
            QCPLayoutGrid::getMaximumRowColSizes(maxColWidths, maxRowHeights);
        } else if (qcplayoutgrid_getmaximumrowcolsizes_callback != nullptr) {
            QVector<int>* maxColWidths_ret = maxColWidths;
            // Convert QVector<> from C++ memory to manually-managed C memory
            int* maxColWidths_arr = static_cast<int*>(malloc(sizeof(int) * (maxColWidths_ret->size() + 1)));
            for (qsizetype i = 0; i < maxColWidths_ret->size(); ++i) {
                maxColWidths_arr[i] = (*maxColWidths_ret)[i];
            }
            libqt_list maxColWidths_out;
            maxColWidths_out.len = maxColWidths_ret->size();
            maxColWidths_out.data = static_cast<void*>(maxColWidths_arr);
            libqt_list /* of int */ cbval1 = maxColWidths_out;
            QVector<int>* maxRowHeights_ret = maxRowHeights;
            // Convert QVector<> from C++ memory to manually-managed C memory
            int* maxRowHeights_arr = static_cast<int*>(malloc(sizeof(int) * (maxRowHeights_ret->size() + 1)));
            for (qsizetype i = 0; i < maxRowHeights_ret->size(); ++i) {
                maxRowHeights_arr[i] = (*maxRowHeights_ret)[i];
            }
            libqt_list maxRowHeights_out;
            maxRowHeights_out.len = maxRowHeights_ret->size();
            maxRowHeights_out.data = static_cast<void*>(maxRowHeights_arr);
            libqt_list /* of int */ cbval2 = maxRowHeights_out;

            qcplayoutgrid_getmaximumrowcolsizes_callback(this, cbval1, cbval2);
        } else {
            QCPLayoutGrid::getMaximumRowColSizes(maxColWidths, maxRowHeights);
        }
    }

    // Virtual method for C ABI access and custom callback
    void sizeConstraintsChanged() const {
        if (qcplayoutgrid_sizeconstraintschanged_isbase) {
            qcplayoutgrid_sizeconstraintschanged_isbase = false;
            QCPLayoutGrid::sizeConstraintsChanged();
        } else if (qcplayoutgrid_sizeconstraintschanged_callback != nullptr) {
            qcplayoutgrid_sizeconstraintschanged_callback();
        } else {
            QCPLayoutGrid::sizeConstraintsChanged();
        }
    }

    // Virtual method for C ABI access and custom callback
    void adoptElement(QCPLayoutElement* el) {
        if (qcplayoutgrid_adoptelement_isbase) {
            qcplayoutgrid_adoptelement_isbase = false;
            QCPLayoutGrid::adoptElement(el);
        } else if (qcplayoutgrid_adoptelement_callback != nullptr) {
            QCPLayoutElement* cbval1 = el;

            qcplayoutgrid_adoptelement_callback(this, cbval1);
        } else {
            QCPLayoutGrid::adoptElement(el);
        }
    }

    // Virtual method for C ABI access and custom callback
    void releaseElement(QCPLayoutElement* el) {
        if (qcplayoutgrid_releaseelement_isbase) {
            qcplayoutgrid_releaseelement_isbase = false;
            QCPLayoutGrid::releaseElement(el);
        } else if (qcplayoutgrid_releaseelement_callback != nullptr) {
            QCPLayoutElement* cbval1 = el;

            qcplayoutgrid_releaseelement_callback(this, cbval1);
        } else {
            QCPLayoutGrid::releaseElement(el);
        }
    }

    // Virtual method for C ABI access and custom callback
    QVector<int> getSectionSizes(QVector<int> maxSizes, QVector<int> minSizes, QVector<double> stretchFactors, int totalSize) const {
        if (qcplayoutgrid_getsectionsizes_isbase) {
            qcplayoutgrid_getsectionsizes_isbase = false;
            return QCPLayoutGrid::getSectionSizes(maxSizes, minSizes, stretchFactors, totalSize);
        } else if (qcplayoutgrid_getsectionsizes_callback != nullptr) {
            QVector<int> maxSizes_ret = maxSizes;
            // Convert QVector<> from C++ memory to manually-managed C memory
            int* maxSizes_arr = static_cast<int*>(malloc(sizeof(int) * (maxSizes_ret.size() + 1)));
            for (qsizetype i = 0; i < maxSizes_ret.size(); ++i) {
                maxSizes_arr[i] = maxSizes_ret[i];
            }
            libqt_list maxSizes_out;
            maxSizes_out.len = maxSizes_ret.size();
            maxSizes_out.data = static_cast<void*>(maxSizes_arr);
            libqt_list /* of int */ cbval1 = maxSizes_out;
            QVector<int> minSizes_ret = minSizes;
            // Convert QVector<> from C++ memory to manually-managed C memory
            int* minSizes_arr = static_cast<int*>(malloc(sizeof(int) * (minSizes_ret.size() + 1)));
            for (qsizetype i = 0; i < minSizes_ret.size(); ++i) {
                minSizes_arr[i] = minSizes_ret[i];
            }
            libqt_list minSizes_out;
            minSizes_out.len = minSizes_ret.size();
            minSizes_out.data = static_cast<void*>(minSizes_arr);
            libqt_list /* of int */ cbval2 = minSizes_out;
            QVector<double> stretchFactors_ret = stretchFactors;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* stretchFactors_arr = static_cast<double*>(malloc(sizeof(double) * (stretchFactors_ret.size() + 1)));
            for (qsizetype i = 0; i < stretchFactors_ret.size(); ++i) {
                stretchFactors_arr[i] = stretchFactors_ret[i];
            }
            libqt_list stretchFactors_out;
            stretchFactors_out.len = stretchFactors_ret.size();
            stretchFactors_out.data = static_cast<void*>(stretchFactors_arr);
            libqt_list /* of double */ cbval3 = stretchFactors_out;
            int cbval4 = totalSize;

            int* callback_ret = qcplayoutgrid_getsectionsizes_callback(this, cbval1, cbval2, cbval3, cbval4);
            QVector<int> callback_ret_QVector;
            for (int* ptr = callback_ret; *ptr != -1; ++ptr) {
                callback_ret_QVector.push_back(*ptr);
            }
            return callback_ret_QVector;
        } else {
            return QCPLayoutGrid::getSectionSizes(maxSizes, minSizes, stretchFactors, totalSize);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcplayoutgrid_initializeparentplot_isbase) {
            qcplayoutgrid_initializeparentplot_isbase = false;
            QCPLayoutGrid::initializeParentPlot(parentPlot);
        } else if (qcplayoutgrid_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcplayoutgrid_initializeparentplot_callback(this, cbval1);
        } else {
            QCPLayoutGrid::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcplayoutgrid_setparentlayerable_isbase) {
            qcplayoutgrid_setparentlayerable_isbase = false;
            QCPLayoutGrid::setParentLayerable(parentLayerable);
        } else if (qcplayoutgrid_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcplayoutgrid_setparentlayerable_callback(this, cbval1);
        } else {
            QCPLayoutGrid::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcplayoutgrid_movetolayer_isbase) {
            qcplayoutgrid_movetolayer_isbase = false;
            return QCPLayoutGrid::moveToLayer(layer, prepend);
        } else if (qcplayoutgrid_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcplayoutgrid_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPLayoutGrid::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcplayoutgrid_applyantialiasinghint_isbase) {
            qcplayoutgrid_applyantialiasinghint_isbase = false;
            QCPLayoutGrid::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcplayoutgrid_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcplayoutgrid_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPLayoutGrid::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcplayoutgrid_sender_isbase) {
            qcplayoutgrid_sender_isbase = false;
            return QCPLayoutGrid::sender();
        } else if (qcplayoutgrid_sender_callback != nullptr) {
            QObject* callback_ret = qcplayoutgrid_sender_callback();
            return callback_ret;
        } else {
            return QCPLayoutGrid::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcplayoutgrid_sendersignalindex_isbase) {
            qcplayoutgrid_sendersignalindex_isbase = false;
            return QCPLayoutGrid::senderSignalIndex();
        } else if (qcplayoutgrid_sendersignalindex_callback != nullptr) {
            int callback_ret = qcplayoutgrid_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPLayoutGrid::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcplayoutgrid_receivers_isbase) {
            qcplayoutgrid_receivers_isbase = false;
            return QCPLayoutGrid::receivers(signal);
        } else if (qcplayoutgrid_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcplayoutgrid_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPLayoutGrid::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcplayoutgrid_issignalconnected_isbase) {
            qcplayoutgrid_issignalconnected_isbase = false;
            return QCPLayoutGrid::isSignalConnected(signal);
        } else if (qcplayoutgrid_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcplayoutgrid_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPLayoutGrid::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend int QCPLayoutGrid_CalculateAutoMargin(QCPLayoutGrid* self, int side);
    friend int QCPLayoutGrid_QBaseCalculateAutoMargin(QCPLayoutGrid* self, int side);
    friend void QCPLayoutGrid_LayoutChanged(QCPLayoutGrid* self);
    friend void QCPLayoutGrid_QBaseLayoutChanged(QCPLayoutGrid* self);
    friend void QCPLayoutGrid_ApplyDefaultAntialiasingHint(const QCPLayoutGrid* self, QCPPainter* painter);
    friend void QCPLayoutGrid_QBaseApplyDefaultAntialiasingHint(const QCPLayoutGrid* self, QCPPainter* painter);
    friend void QCPLayoutGrid_Draw(QCPLayoutGrid* self, QCPPainter* painter);
    friend void QCPLayoutGrid_QBaseDraw(QCPLayoutGrid* self, QCPPainter* painter);
    friend void QCPLayoutGrid_ParentPlotInitialized(QCPLayoutGrid* self, QCustomPlot* parentPlot);
    friend void QCPLayoutGrid_QBaseParentPlotInitialized(QCPLayoutGrid* self, QCustomPlot* parentPlot);
    friend int QCPLayoutGrid_SelectionCategory(const QCPLayoutGrid* self);
    friend int QCPLayoutGrid_QBaseSelectionCategory(const QCPLayoutGrid* self);
    friend QRect* QCPLayoutGrid_ClipRect(const QCPLayoutGrid* self);
    friend QRect* QCPLayoutGrid_QBaseClipRect(const QCPLayoutGrid* self);
    friend void QCPLayoutGrid_SelectEvent(QCPLayoutGrid* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPLayoutGrid_QBaseSelectEvent(QCPLayoutGrid* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPLayoutGrid_DeselectEvent(QCPLayoutGrid* self, bool* selectionStateChanged);
    friend void QCPLayoutGrid_QBaseDeselectEvent(QCPLayoutGrid* self, bool* selectionStateChanged);
    friend void QCPLayoutGrid_MousePressEvent(QCPLayoutGrid* self, QMouseEvent* event, const QVariant* details);
    friend void QCPLayoutGrid_QBaseMousePressEvent(QCPLayoutGrid* self, QMouseEvent* event, const QVariant* details);
    friend void QCPLayoutGrid_MouseMoveEvent(QCPLayoutGrid* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPLayoutGrid_QBaseMouseMoveEvent(QCPLayoutGrid* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPLayoutGrid_MouseReleaseEvent(QCPLayoutGrid* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPLayoutGrid_QBaseMouseReleaseEvent(QCPLayoutGrid* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPLayoutGrid_MouseDoubleClickEvent(QCPLayoutGrid* self, QMouseEvent* event, const QVariant* details);
    friend void QCPLayoutGrid_QBaseMouseDoubleClickEvent(QCPLayoutGrid* self, QMouseEvent* event, const QVariant* details);
    friend void QCPLayoutGrid_WheelEvent(QCPLayoutGrid* self, QWheelEvent* event);
    friend void QCPLayoutGrid_QBaseWheelEvent(QCPLayoutGrid* self, QWheelEvent* event);
    friend void QCPLayoutGrid_TimerEvent(QCPLayoutGrid* self, QTimerEvent* event);
    friend void QCPLayoutGrid_QBaseTimerEvent(QCPLayoutGrid* self, QTimerEvent* event);
    friend void QCPLayoutGrid_ChildEvent(QCPLayoutGrid* self, QChildEvent* event);
    friend void QCPLayoutGrid_QBaseChildEvent(QCPLayoutGrid* self, QChildEvent* event);
    friend void QCPLayoutGrid_CustomEvent(QCPLayoutGrid* self, QEvent* event);
    friend void QCPLayoutGrid_QBaseCustomEvent(QCPLayoutGrid* self, QEvent* event);
    friend void QCPLayoutGrid_ConnectNotify(QCPLayoutGrid* self, const QMetaMethod* signal);
    friend void QCPLayoutGrid_QBaseConnectNotify(QCPLayoutGrid* self, const QMetaMethod* signal);
    friend void QCPLayoutGrid_DisconnectNotify(QCPLayoutGrid* self, const QMetaMethod* signal);
    friend void QCPLayoutGrid_QBaseDisconnectNotify(QCPLayoutGrid* self, const QMetaMethod* signal);
    friend void QCPLayoutGrid_GetMinimumRowColSizes(const QCPLayoutGrid* self, libqt_list /* of int */ minColWidths, libqt_list /* of int */ minRowHeights);
    friend void QCPLayoutGrid_QBaseGetMinimumRowColSizes(const QCPLayoutGrid* self, libqt_list /* of int */ minColWidths, libqt_list /* of int */ minRowHeights);
    friend void QCPLayoutGrid_GetMaximumRowColSizes(const QCPLayoutGrid* self, libqt_list /* of int */ maxColWidths, libqt_list /* of int */ maxRowHeights);
    friend void QCPLayoutGrid_QBaseGetMaximumRowColSizes(const QCPLayoutGrid* self, libqt_list /* of int */ maxColWidths, libqt_list /* of int */ maxRowHeights);
    friend void QCPLayoutGrid_SizeConstraintsChanged(const QCPLayoutGrid* self);
    friend void QCPLayoutGrid_QBaseSizeConstraintsChanged(const QCPLayoutGrid* self);
    friend void QCPLayoutGrid_AdoptElement(QCPLayoutGrid* self, QCPLayoutElement* el);
    friend void QCPLayoutGrid_QBaseAdoptElement(QCPLayoutGrid* self, QCPLayoutElement* el);
    friend void QCPLayoutGrid_ReleaseElement(QCPLayoutGrid* self, QCPLayoutElement* el);
    friend void QCPLayoutGrid_QBaseReleaseElement(QCPLayoutGrid* self, QCPLayoutElement* el);
    friend libqt_list /* of int */ QCPLayoutGrid_GetSectionSizes(const QCPLayoutGrid* self, libqt_list /* of int */ maxSizes, libqt_list /* of int */ minSizes, libqt_list /* of double */ stretchFactors, int totalSize);
    friend libqt_list /* of int */ QCPLayoutGrid_QBaseGetSectionSizes(const QCPLayoutGrid* self, libqt_list /* of int */ maxSizes, libqt_list /* of int */ minSizes, libqt_list /* of double */ stretchFactors, int totalSize);
    friend void QCPLayoutGrid_InitializeParentPlot(QCPLayoutGrid* self, QCustomPlot* parentPlot);
    friend void QCPLayoutGrid_QBaseInitializeParentPlot(QCPLayoutGrid* self, QCustomPlot* parentPlot);
    friend void QCPLayoutGrid_SetParentLayerable(QCPLayoutGrid* self, QCPLayerable* parentLayerable);
    friend void QCPLayoutGrid_QBaseSetParentLayerable(QCPLayoutGrid* self, QCPLayerable* parentLayerable);
    friend bool QCPLayoutGrid_MoveToLayer(QCPLayoutGrid* self, QCPLayer* layer, bool prepend);
    friend bool QCPLayoutGrid_QBaseMoveToLayer(QCPLayoutGrid* self, QCPLayer* layer, bool prepend);
    friend void QCPLayoutGrid_ApplyAntialiasingHint(const QCPLayoutGrid* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPLayoutGrid_QBaseApplyAntialiasingHint(const QCPLayoutGrid* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPLayoutGrid_Sender(const QCPLayoutGrid* self);
    friend QObject* QCPLayoutGrid_QBaseSender(const QCPLayoutGrid* self);
    friend int QCPLayoutGrid_SenderSignalIndex(const QCPLayoutGrid* self);
    friend int QCPLayoutGrid_QBaseSenderSignalIndex(const QCPLayoutGrid* self);
    friend int QCPLayoutGrid_Receivers(const QCPLayoutGrid* self, const char* signal);
    friend int QCPLayoutGrid_QBaseReceivers(const QCPLayoutGrid* self, const char* signal);
    friend bool QCPLayoutGrid_IsSignalConnected(const QCPLayoutGrid* self, const QMetaMethod* signal);
    friend bool QCPLayoutGrid_QBaseIsSignalConnected(const QCPLayoutGrid* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPLayoutInset so that we can call protected methods
class VirtualQCPLayoutInset final : public QCPLayoutInset {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPLayoutInset = true;

    // Virtual class public types (including callbacks)
    using QCPLayoutInset_Metacall_Callback = int (*)(QCPLayoutInset*, int, int, void**);
    using QCPLayoutInset_UpdateLayout_Callback = void (*)();
    using QCPLayoutInset_ElementCount_Callback = int (*)();
    using QCPLayoutInset_ElementAt_Callback = QCPLayoutElement* (*)(const QCPLayoutInset*, int);
    using QCPLayoutInset_TakeAt_Callback = QCPLayoutElement* (*)(QCPLayoutInset*, int);
    using QCPLayoutInset_Take_Callback = bool (*)(QCPLayoutInset*, QCPLayoutElement*);
    using QCPLayoutInset_Simplify_Callback = void (*)();
    using QCPLayoutInset_SelectTest_Callback = double (*)(const QCPLayoutInset*, QPointF*, bool, QVariant*);
    using QCPLayoutInset_Update_Callback = void (*)(QCPLayoutInset*, int);
    using QCPLayoutInset_Elements_Callback = QCPLayoutElement** (*)(const QCPLayoutInset*, bool);
    using QCPLayoutInset_MinimumOuterSizeHint_Callback = QSize* (*)();
    using QCPLayoutInset_MaximumOuterSizeHint_Callback = QSize* (*)();
    using QCPLayoutInset_CalculateAutoMargin_Callback = int (*)(QCPLayoutInset*, int);
    using QCPLayoutInset_LayoutChanged_Callback = void (*)();
    using QCPLayoutInset_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPLayoutInset*, QCPPainter*);
    using QCPLayoutInset_Draw_Callback = void (*)(QCPLayoutInset*, QCPPainter*);
    using QCPLayoutInset_ParentPlotInitialized_Callback = void (*)(QCPLayoutInset*, QCustomPlot*);
    using QCPLayoutInset_SelectionCategory_Callback = int (*)();
    using QCPLayoutInset_ClipRect_Callback = QRect* (*)();
    using QCPLayoutInset_SelectEvent_Callback = void (*)(QCPLayoutInset*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPLayoutInset_DeselectEvent_Callback = void (*)(QCPLayoutInset*, bool*);
    using QCPLayoutInset_MousePressEvent_Callback = void (*)(QCPLayoutInset*, QMouseEvent*, QVariant*);
    using QCPLayoutInset_MouseMoveEvent_Callback = void (*)(QCPLayoutInset*, QMouseEvent*, QPointF*);
    using QCPLayoutInset_MouseReleaseEvent_Callback = void (*)(QCPLayoutInset*, QMouseEvent*, QPointF*);
    using QCPLayoutInset_MouseDoubleClickEvent_Callback = void (*)(QCPLayoutInset*, QMouseEvent*, QVariant*);
    using QCPLayoutInset_WheelEvent_Callback = void (*)(QCPLayoutInset*, QWheelEvent*);
    using QCPLayoutInset_Event_Callback = bool (*)(QCPLayoutInset*, QEvent*);
    using QCPLayoutInset_EventFilter_Callback = bool (*)(QCPLayoutInset*, QObject*, QEvent*);
    using QCPLayoutInset_TimerEvent_Callback = void (*)(QCPLayoutInset*, QTimerEvent*);
    using QCPLayoutInset_ChildEvent_Callback = void (*)(QCPLayoutInset*, QChildEvent*);
    using QCPLayoutInset_CustomEvent_Callback = void (*)(QCPLayoutInset*, QEvent*);
    using QCPLayoutInset_ConnectNotify_Callback = void (*)(QCPLayoutInset*, QMetaMethod*);
    using QCPLayoutInset_DisconnectNotify_Callback = void (*)(QCPLayoutInset*, QMetaMethod*);
    using QCPLayoutInset_SizeConstraintsChanged_Callback = void (*)();
    using QCPLayoutInset_AdoptElement_Callback = void (*)(QCPLayoutInset*, QCPLayoutElement*);
    using QCPLayoutInset_ReleaseElement_Callback = void (*)(QCPLayoutInset*, QCPLayoutElement*);
    using QCPLayoutInset_GetSectionSizes_Callback = int* (*)(const QCPLayoutInset*, libqt_list /* of int */, libqt_list /* of int */, libqt_list /* of double */, int);
    using QCPLayoutInset_InitializeParentPlot_Callback = void (*)(QCPLayoutInset*, QCustomPlot*);
    using QCPLayoutInset_SetParentLayerable_Callback = void (*)(QCPLayoutInset*, QCPLayerable*);
    using QCPLayoutInset_MoveToLayer_Callback = bool (*)(QCPLayoutInset*, QCPLayer*, bool);
    using QCPLayoutInset_ApplyAntialiasingHint_Callback = void (*)(const QCPLayoutInset*, QCPPainter*, bool, int);
    using QCPLayoutInset_Sender_Callback = QObject* (*)();
    using QCPLayoutInset_SenderSignalIndex_Callback = int (*)();
    using QCPLayoutInset_Receivers_Callback = int (*)(const QCPLayoutInset*, const char*);
    using QCPLayoutInset_IsSignalConnected_Callback = bool (*)(const QCPLayoutInset*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPLayoutInset_Metacall_Callback qcplayoutinset_metacall_callback = nullptr;
    QCPLayoutInset_UpdateLayout_Callback qcplayoutinset_updatelayout_callback = nullptr;
    QCPLayoutInset_ElementCount_Callback qcplayoutinset_elementcount_callback = nullptr;
    QCPLayoutInset_ElementAt_Callback qcplayoutinset_elementat_callback = nullptr;
    QCPLayoutInset_TakeAt_Callback qcplayoutinset_takeat_callback = nullptr;
    QCPLayoutInset_Take_Callback qcplayoutinset_take_callback = nullptr;
    QCPLayoutInset_Simplify_Callback qcplayoutinset_simplify_callback = nullptr;
    QCPLayoutInset_SelectTest_Callback qcplayoutinset_selecttest_callback = nullptr;
    QCPLayoutInset_Update_Callback qcplayoutinset_update_callback = nullptr;
    QCPLayoutInset_Elements_Callback qcplayoutinset_elements_callback = nullptr;
    QCPLayoutInset_MinimumOuterSizeHint_Callback qcplayoutinset_minimumoutersizehint_callback = nullptr;
    QCPLayoutInset_MaximumOuterSizeHint_Callback qcplayoutinset_maximumoutersizehint_callback = nullptr;
    QCPLayoutInset_CalculateAutoMargin_Callback qcplayoutinset_calculateautomargin_callback = nullptr;
    QCPLayoutInset_LayoutChanged_Callback qcplayoutinset_layoutchanged_callback = nullptr;
    QCPLayoutInset_ApplyDefaultAntialiasingHint_Callback qcplayoutinset_applydefaultantialiasinghint_callback = nullptr;
    QCPLayoutInset_Draw_Callback qcplayoutinset_draw_callback = nullptr;
    QCPLayoutInset_ParentPlotInitialized_Callback qcplayoutinset_parentplotinitialized_callback = nullptr;
    QCPLayoutInset_SelectionCategory_Callback qcplayoutinset_selectioncategory_callback = nullptr;
    QCPLayoutInset_ClipRect_Callback qcplayoutinset_cliprect_callback = nullptr;
    QCPLayoutInset_SelectEvent_Callback qcplayoutinset_selectevent_callback = nullptr;
    QCPLayoutInset_DeselectEvent_Callback qcplayoutinset_deselectevent_callback = nullptr;
    QCPLayoutInset_MousePressEvent_Callback qcplayoutinset_mousepressevent_callback = nullptr;
    QCPLayoutInset_MouseMoveEvent_Callback qcplayoutinset_mousemoveevent_callback = nullptr;
    QCPLayoutInset_MouseReleaseEvent_Callback qcplayoutinset_mousereleaseevent_callback = nullptr;
    QCPLayoutInset_MouseDoubleClickEvent_Callback qcplayoutinset_mousedoubleclickevent_callback = nullptr;
    QCPLayoutInset_WheelEvent_Callback qcplayoutinset_wheelevent_callback = nullptr;
    QCPLayoutInset_Event_Callback qcplayoutinset_event_callback = nullptr;
    QCPLayoutInset_EventFilter_Callback qcplayoutinset_eventfilter_callback = nullptr;
    QCPLayoutInset_TimerEvent_Callback qcplayoutinset_timerevent_callback = nullptr;
    QCPLayoutInset_ChildEvent_Callback qcplayoutinset_childevent_callback = nullptr;
    QCPLayoutInset_CustomEvent_Callback qcplayoutinset_customevent_callback = nullptr;
    QCPLayoutInset_ConnectNotify_Callback qcplayoutinset_connectnotify_callback = nullptr;
    QCPLayoutInset_DisconnectNotify_Callback qcplayoutinset_disconnectnotify_callback = nullptr;
    QCPLayoutInset_SizeConstraintsChanged_Callback qcplayoutinset_sizeconstraintschanged_callback = nullptr;
    QCPLayoutInset_AdoptElement_Callback qcplayoutinset_adoptelement_callback = nullptr;
    QCPLayoutInset_ReleaseElement_Callback qcplayoutinset_releaseelement_callback = nullptr;
    QCPLayoutInset_GetSectionSizes_Callback qcplayoutinset_getsectionsizes_callback = nullptr;
    QCPLayoutInset_InitializeParentPlot_Callback qcplayoutinset_initializeparentplot_callback = nullptr;
    QCPLayoutInset_SetParentLayerable_Callback qcplayoutinset_setparentlayerable_callback = nullptr;
    QCPLayoutInset_MoveToLayer_Callback qcplayoutinset_movetolayer_callback = nullptr;
    QCPLayoutInset_ApplyAntialiasingHint_Callback qcplayoutinset_applyantialiasinghint_callback = nullptr;
    QCPLayoutInset_Sender_Callback qcplayoutinset_sender_callback = nullptr;
    QCPLayoutInset_SenderSignalIndex_Callback qcplayoutinset_sendersignalindex_callback = nullptr;
    QCPLayoutInset_Receivers_Callback qcplayoutinset_receivers_callback = nullptr;
    QCPLayoutInset_IsSignalConnected_Callback qcplayoutinset_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcplayoutinset_metacall_isbase = false;
    mutable bool qcplayoutinset_updatelayout_isbase = false;
    mutable bool qcplayoutinset_elementcount_isbase = false;
    mutable bool qcplayoutinset_elementat_isbase = false;
    mutable bool qcplayoutinset_takeat_isbase = false;
    mutable bool qcplayoutinset_take_isbase = false;
    mutable bool qcplayoutinset_simplify_isbase = false;
    mutable bool qcplayoutinset_selecttest_isbase = false;
    mutable bool qcplayoutinset_update_isbase = false;
    mutable bool qcplayoutinset_elements_isbase = false;
    mutable bool qcplayoutinset_minimumoutersizehint_isbase = false;
    mutable bool qcplayoutinset_maximumoutersizehint_isbase = false;
    mutable bool qcplayoutinset_calculateautomargin_isbase = false;
    mutable bool qcplayoutinset_layoutchanged_isbase = false;
    mutable bool qcplayoutinset_applydefaultantialiasinghint_isbase = false;
    mutable bool qcplayoutinset_draw_isbase = false;
    mutable bool qcplayoutinset_parentplotinitialized_isbase = false;
    mutable bool qcplayoutinset_selectioncategory_isbase = false;
    mutable bool qcplayoutinset_cliprect_isbase = false;
    mutable bool qcplayoutinset_selectevent_isbase = false;
    mutable bool qcplayoutinset_deselectevent_isbase = false;
    mutable bool qcplayoutinset_mousepressevent_isbase = false;
    mutable bool qcplayoutinset_mousemoveevent_isbase = false;
    mutable bool qcplayoutinset_mousereleaseevent_isbase = false;
    mutable bool qcplayoutinset_mousedoubleclickevent_isbase = false;
    mutable bool qcplayoutinset_wheelevent_isbase = false;
    mutable bool qcplayoutinset_event_isbase = false;
    mutable bool qcplayoutinset_eventfilter_isbase = false;
    mutable bool qcplayoutinset_timerevent_isbase = false;
    mutable bool qcplayoutinset_childevent_isbase = false;
    mutable bool qcplayoutinset_customevent_isbase = false;
    mutable bool qcplayoutinset_connectnotify_isbase = false;
    mutable bool qcplayoutinset_disconnectnotify_isbase = false;
    mutable bool qcplayoutinset_sizeconstraintschanged_isbase = false;
    mutable bool qcplayoutinset_adoptelement_isbase = false;
    mutable bool qcplayoutinset_releaseelement_isbase = false;
    mutable bool qcplayoutinset_getsectionsizes_isbase = false;
    mutable bool qcplayoutinset_initializeparentplot_isbase = false;
    mutable bool qcplayoutinset_setparentlayerable_isbase = false;
    mutable bool qcplayoutinset_movetolayer_isbase = false;
    mutable bool qcplayoutinset_applyantialiasinghint_isbase = false;
    mutable bool qcplayoutinset_sender_isbase = false;
    mutable bool qcplayoutinset_sendersignalindex_isbase = false;
    mutable bool qcplayoutinset_receivers_isbase = false;
    mutable bool qcplayoutinset_issignalconnected_isbase = false;

  public:
    VirtualQCPLayoutInset() : QCPLayoutInset() {};

    ~VirtualQCPLayoutInset() {
        qcplayoutinset_metacall_callback = nullptr;
        qcplayoutinset_updatelayout_callback = nullptr;
        qcplayoutinset_elementcount_callback = nullptr;
        qcplayoutinset_elementat_callback = nullptr;
        qcplayoutinset_takeat_callback = nullptr;
        qcplayoutinset_take_callback = nullptr;
        qcplayoutinset_simplify_callback = nullptr;
        qcplayoutinset_selecttest_callback = nullptr;
        qcplayoutinset_update_callback = nullptr;
        qcplayoutinset_elements_callback = nullptr;
        qcplayoutinset_minimumoutersizehint_callback = nullptr;
        qcplayoutinset_maximumoutersizehint_callback = nullptr;
        qcplayoutinset_calculateautomargin_callback = nullptr;
        qcplayoutinset_layoutchanged_callback = nullptr;
        qcplayoutinset_applydefaultantialiasinghint_callback = nullptr;
        qcplayoutinset_draw_callback = nullptr;
        qcplayoutinset_parentplotinitialized_callback = nullptr;
        qcplayoutinset_selectioncategory_callback = nullptr;
        qcplayoutinset_cliprect_callback = nullptr;
        qcplayoutinset_selectevent_callback = nullptr;
        qcplayoutinset_deselectevent_callback = nullptr;
        qcplayoutinset_mousepressevent_callback = nullptr;
        qcplayoutinset_mousemoveevent_callback = nullptr;
        qcplayoutinset_mousereleaseevent_callback = nullptr;
        qcplayoutinset_mousedoubleclickevent_callback = nullptr;
        qcplayoutinset_wheelevent_callback = nullptr;
        qcplayoutinset_event_callback = nullptr;
        qcplayoutinset_eventfilter_callback = nullptr;
        qcplayoutinset_timerevent_callback = nullptr;
        qcplayoutinset_childevent_callback = nullptr;
        qcplayoutinset_customevent_callback = nullptr;
        qcplayoutinset_connectnotify_callback = nullptr;
        qcplayoutinset_disconnectnotify_callback = nullptr;
        qcplayoutinset_sizeconstraintschanged_callback = nullptr;
        qcplayoutinset_adoptelement_callback = nullptr;
        qcplayoutinset_releaseelement_callback = nullptr;
        qcplayoutinset_getsectionsizes_callback = nullptr;
        qcplayoutinset_initializeparentplot_callback = nullptr;
        qcplayoutinset_setparentlayerable_callback = nullptr;
        qcplayoutinset_movetolayer_callback = nullptr;
        qcplayoutinset_applyantialiasinghint_callback = nullptr;
        qcplayoutinset_sender_callback = nullptr;
        qcplayoutinset_sendersignalindex_callback = nullptr;
        qcplayoutinset_receivers_callback = nullptr;
        qcplayoutinset_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPLayoutInset_Metacall_Callback(QCPLayoutInset_Metacall_Callback cb) { qcplayoutinset_metacall_callback = cb; }
    inline void setQCPLayoutInset_UpdateLayout_Callback(QCPLayoutInset_UpdateLayout_Callback cb) { qcplayoutinset_updatelayout_callback = cb; }
    inline void setQCPLayoutInset_ElementCount_Callback(QCPLayoutInset_ElementCount_Callback cb) { qcplayoutinset_elementcount_callback = cb; }
    inline void setQCPLayoutInset_ElementAt_Callback(QCPLayoutInset_ElementAt_Callback cb) { qcplayoutinset_elementat_callback = cb; }
    inline void setQCPLayoutInset_TakeAt_Callback(QCPLayoutInset_TakeAt_Callback cb) { qcplayoutinset_takeat_callback = cb; }
    inline void setQCPLayoutInset_Take_Callback(QCPLayoutInset_Take_Callback cb) { qcplayoutinset_take_callback = cb; }
    inline void setQCPLayoutInset_Simplify_Callback(QCPLayoutInset_Simplify_Callback cb) { qcplayoutinset_simplify_callback = cb; }
    inline void setQCPLayoutInset_SelectTest_Callback(QCPLayoutInset_SelectTest_Callback cb) { qcplayoutinset_selecttest_callback = cb; }
    inline void setQCPLayoutInset_Update_Callback(QCPLayoutInset_Update_Callback cb) { qcplayoutinset_update_callback = cb; }
    inline void setQCPLayoutInset_Elements_Callback(QCPLayoutInset_Elements_Callback cb) { qcplayoutinset_elements_callback = cb; }
    inline void setQCPLayoutInset_MinimumOuterSizeHint_Callback(QCPLayoutInset_MinimumOuterSizeHint_Callback cb) { qcplayoutinset_minimumoutersizehint_callback = cb; }
    inline void setQCPLayoutInset_MaximumOuterSizeHint_Callback(QCPLayoutInset_MaximumOuterSizeHint_Callback cb) { qcplayoutinset_maximumoutersizehint_callback = cb; }
    inline void setQCPLayoutInset_CalculateAutoMargin_Callback(QCPLayoutInset_CalculateAutoMargin_Callback cb) { qcplayoutinset_calculateautomargin_callback = cb; }
    inline void setQCPLayoutInset_LayoutChanged_Callback(QCPLayoutInset_LayoutChanged_Callback cb) { qcplayoutinset_layoutchanged_callback = cb; }
    inline void setQCPLayoutInset_ApplyDefaultAntialiasingHint_Callback(QCPLayoutInset_ApplyDefaultAntialiasingHint_Callback cb) { qcplayoutinset_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPLayoutInset_Draw_Callback(QCPLayoutInset_Draw_Callback cb) { qcplayoutinset_draw_callback = cb; }
    inline void setQCPLayoutInset_ParentPlotInitialized_Callback(QCPLayoutInset_ParentPlotInitialized_Callback cb) { qcplayoutinset_parentplotinitialized_callback = cb; }
    inline void setQCPLayoutInset_SelectionCategory_Callback(QCPLayoutInset_SelectionCategory_Callback cb) { qcplayoutinset_selectioncategory_callback = cb; }
    inline void setQCPLayoutInset_ClipRect_Callback(QCPLayoutInset_ClipRect_Callback cb) { qcplayoutinset_cliprect_callback = cb; }
    inline void setQCPLayoutInset_SelectEvent_Callback(QCPLayoutInset_SelectEvent_Callback cb) { qcplayoutinset_selectevent_callback = cb; }
    inline void setQCPLayoutInset_DeselectEvent_Callback(QCPLayoutInset_DeselectEvent_Callback cb) { qcplayoutinset_deselectevent_callback = cb; }
    inline void setQCPLayoutInset_MousePressEvent_Callback(QCPLayoutInset_MousePressEvent_Callback cb) { qcplayoutinset_mousepressevent_callback = cb; }
    inline void setQCPLayoutInset_MouseMoveEvent_Callback(QCPLayoutInset_MouseMoveEvent_Callback cb) { qcplayoutinset_mousemoveevent_callback = cb; }
    inline void setQCPLayoutInset_MouseReleaseEvent_Callback(QCPLayoutInset_MouseReleaseEvent_Callback cb) { qcplayoutinset_mousereleaseevent_callback = cb; }
    inline void setQCPLayoutInset_MouseDoubleClickEvent_Callback(QCPLayoutInset_MouseDoubleClickEvent_Callback cb) { qcplayoutinset_mousedoubleclickevent_callback = cb; }
    inline void setQCPLayoutInset_WheelEvent_Callback(QCPLayoutInset_WheelEvent_Callback cb) { qcplayoutinset_wheelevent_callback = cb; }
    inline void setQCPLayoutInset_Event_Callback(QCPLayoutInset_Event_Callback cb) { qcplayoutinset_event_callback = cb; }
    inline void setQCPLayoutInset_EventFilter_Callback(QCPLayoutInset_EventFilter_Callback cb) { qcplayoutinset_eventfilter_callback = cb; }
    inline void setQCPLayoutInset_TimerEvent_Callback(QCPLayoutInset_TimerEvent_Callback cb) { qcplayoutinset_timerevent_callback = cb; }
    inline void setQCPLayoutInset_ChildEvent_Callback(QCPLayoutInset_ChildEvent_Callback cb) { qcplayoutinset_childevent_callback = cb; }
    inline void setQCPLayoutInset_CustomEvent_Callback(QCPLayoutInset_CustomEvent_Callback cb) { qcplayoutinset_customevent_callback = cb; }
    inline void setQCPLayoutInset_ConnectNotify_Callback(QCPLayoutInset_ConnectNotify_Callback cb) { qcplayoutinset_connectnotify_callback = cb; }
    inline void setQCPLayoutInset_DisconnectNotify_Callback(QCPLayoutInset_DisconnectNotify_Callback cb) { qcplayoutinset_disconnectnotify_callback = cb; }
    inline void setQCPLayoutInset_SizeConstraintsChanged_Callback(QCPLayoutInset_SizeConstraintsChanged_Callback cb) { qcplayoutinset_sizeconstraintschanged_callback = cb; }
    inline void setQCPLayoutInset_AdoptElement_Callback(QCPLayoutInset_AdoptElement_Callback cb) { qcplayoutinset_adoptelement_callback = cb; }
    inline void setQCPLayoutInset_ReleaseElement_Callback(QCPLayoutInset_ReleaseElement_Callback cb) { qcplayoutinset_releaseelement_callback = cb; }
    inline void setQCPLayoutInset_GetSectionSizes_Callback(QCPLayoutInset_GetSectionSizes_Callback cb) { qcplayoutinset_getsectionsizes_callback = cb; }
    inline void setQCPLayoutInset_InitializeParentPlot_Callback(QCPLayoutInset_InitializeParentPlot_Callback cb) { qcplayoutinset_initializeparentplot_callback = cb; }
    inline void setQCPLayoutInset_SetParentLayerable_Callback(QCPLayoutInset_SetParentLayerable_Callback cb) { qcplayoutinset_setparentlayerable_callback = cb; }
    inline void setQCPLayoutInset_MoveToLayer_Callback(QCPLayoutInset_MoveToLayer_Callback cb) { qcplayoutinset_movetolayer_callback = cb; }
    inline void setQCPLayoutInset_ApplyAntialiasingHint_Callback(QCPLayoutInset_ApplyAntialiasingHint_Callback cb) { qcplayoutinset_applyantialiasinghint_callback = cb; }
    inline void setQCPLayoutInset_Sender_Callback(QCPLayoutInset_Sender_Callback cb) { qcplayoutinset_sender_callback = cb; }
    inline void setQCPLayoutInset_SenderSignalIndex_Callback(QCPLayoutInset_SenderSignalIndex_Callback cb) { qcplayoutinset_sendersignalindex_callback = cb; }
    inline void setQCPLayoutInset_Receivers_Callback(QCPLayoutInset_Receivers_Callback cb) { qcplayoutinset_receivers_callback = cb; }
    inline void setQCPLayoutInset_IsSignalConnected_Callback(QCPLayoutInset_IsSignalConnected_Callback cb) { qcplayoutinset_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPLayoutInset_Metacall_IsBase(bool value) const { qcplayoutinset_metacall_isbase = value; }
    inline void setQCPLayoutInset_UpdateLayout_IsBase(bool value) const { qcplayoutinset_updatelayout_isbase = value; }
    inline void setQCPLayoutInset_ElementCount_IsBase(bool value) const { qcplayoutinset_elementcount_isbase = value; }
    inline void setQCPLayoutInset_ElementAt_IsBase(bool value) const { qcplayoutinset_elementat_isbase = value; }
    inline void setQCPLayoutInset_TakeAt_IsBase(bool value) const { qcplayoutinset_takeat_isbase = value; }
    inline void setQCPLayoutInset_Take_IsBase(bool value) const { qcplayoutinset_take_isbase = value; }
    inline void setQCPLayoutInset_Simplify_IsBase(bool value) const { qcplayoutinset_simplify_isbase = value; }
    inline void setQCPLayoutInset_SelectTest_IsBase(bool value) const { qcplayoutinset_selecttest_isbase = value; }
    inline void setQCPLayoutInset_Update_IsBase(bool value) const { qcplayoutinset_update_isbase = value; }
    inline void setQCPLayoutInset_Elements_IsBase(bool value) const { qcplayoutinset_elements_isbase = value; }
    inline void setQCPLayoutInset_MinimumOuterSizeHint_IsBase(bool value) const { qcplayoutinset_minimumoutersizehint_isbase = value; }
    inline void setQCPLayoutInset_MaximumOuterSizeHint_IsBase(bool value) const { qcplayoutinset_maximumoutersizehint_isbase = value; }
    inline void setQCPLayoutInset_CalculateAutoMargin_IsBase(bool value) const { qcplayoutinset_calculateautomargin_isbase = value; }
    inline void setQCPLayoutInset_LayoutChanged_IsBase(bool value) const { qcplayoutinset_layoutchanged_isbase = value; }
    inline void setQCPLayoutInset_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcplayoutinset_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPLayoutInset_Draw_IsBase(bool value) const { qcplayoutinset_draw_isbase = value; }
    inline void setQCPLayoutInset_ParentPlotInitialized_IsBase(bool value) const { qcplayoutinset_parentplotinitialized_isbase = value; }
    inline void setQCPLayoutInset_SelectionCategory_IsBase(bool value) const { qcplayoutinset_selectioncategory_isbase = value; }
    inline void setQCPLayoutInset_ClipRect_IsBase(bool value) const { qcplayoutinset_cliprect_isbase = value; }
    inline void setQCPLayoutInset_SelectEvent_IsBase(bool value) const { qcplayoutinset_selectevent_isbase = value; }
    inline void setQCPLayoutInset_DeselectEvent_IsBase(bool value) const { qcplayoutinset_deselectevent_isbase = value; }
    inline void setQCPLayoutInset_MousePressEvent_IsBase(bool value) const { qcplayoutinset_mousepressevent_isbase = value; }
    inline void setQCPLayoutInset_MouseMoveEvent_IsBase(bool value) const { qcplayoutinset_mousemoveevent_isbase = value; }
    inline void setQCPLayoutInset_MouseReleaseEvent_IsBase(bool value) const { qcplayoutinset_mousereleaseevent_isbase = value; }
    inline void setQCPLayoutInset_MouseDoubleClickEvent_IsBase(bool value) const { qcplayoutinset_mousedoubleclickevent_isbase = value; }
    inline void setQCPLayoutInset_WheelEvent_IsBase(bool value) const { qcplayoutinset_wheelevent_isbase = value; }
    inline void setQCPLayoutInset_Event_IsBase(bool value) const { qcplayoutinset_event_isbase = value; }
    inline void setQCPLayoutInset_EventFilter_IsBase(bool value) const { qcplayoutinset_eventfilter_isbase = value; }
    inline void setQCPLayoutInset_TimerEvent_IsBase(bool value) const { qcplayoutinset_timerevent_isbase = value; }
    inline void setQCPLayoutInset_ChildEvent_IsBase(bool value) const { qcplayoutinset_childevent_isbase = value; }
    inline void setQCPLayoutInset_CustomEvent_IsBase(bool value) const { qcplayoutinset_customevent_isbase = value; }
    inline void setQCPLayoutInset_ConnectNotify_IsBase(bool value) const { qcplayoutinset_connectnotify_isbase = value; }
    inline void setQCPLayoutInset_DisconnectNotify_IsBase(bool value) const { qcplayoutinset_disconnectnotify_isbase = value; }
    inline void setQCPLayoutInset_SizeConstraintsChanged_IsBase(bool value) const { qcplayoutinset_sizeconstraintschanged_isbase = value; }
    inline void setQCPLayoutInset_AdoptElement_IsBase(bool value) const { qcplayoutinset_adoptelement_isbase = value; }
    inline void setQCPLayoutInset_ReleaseElement_IsBase(bool value) const { qcplayoutinset_releaseelement_isbase = value; }
    inline void setQCPLayoutInset_GetSectionSizes_IsBase(bool value) const { qcplayoutinset_getsectionsizes_isbase = value; }
    inline void setQCPLayoutInset_InitializeParentPlot_IsBase(bool value) const { qcplayoutinset_initializeparentplot_isbase = value; }
    inline void setQCPLayoutInset_SetParentLayerable_IsBase(bool value) const { qcplayoutinset_setparentlayerable_isbase = value; }
    inline void setQCPLayoutInset_MoveToLayer_IsBase(bool value) const { qcplayoutinset_movetolayer_isbase = value; }
    inline void setQCPLayoutInset_ApplyAntialiasingHint_IsBase(bool value) const { qcplayoutinset_applyantialiasinghint_isbase = value; }
    inline void setQCPLayoutInset_Sender_IsBase(bool value) const { qcplayoutinset_sender_isbase = value; }
    inline void setQCPLayoutInset_SenderSignalIndex_IsBase(bool value) const { qcplayoutinset_sendersignalindex_isbase = value; }
    inline void setQCPLayoutInset_Receivers_IsBase(bool value) const { qcplayoutinset_receivers_isbase = value; }
    inline void setQCPLayoutInset_IsSignalConnected_IsBase(bool value) const { qcplayoutinset_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcplayoutinset_metacall_isbase) {
            qcplayoutinset_metacall_isbase = false;
            return QCPLayoutInset::qt_metacall(param1, param2, param3);
        } else if (qcplayoutinset_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcplayoutinset_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPLayoutInset::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void updateLayout() override {
        if (qcplayoutinset_updatelayout_isbase) {
            qcplayoutinset_updatelayout_isbase = false;
            QCPLayoutInset::updateLayout();
        } else if (qcplayoutinset_updatelayout_callback != nullptr) {
            qcplayoutinset_updatelayout_callback();
        } else {
            QCPLayoutInset::updateLayout();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int elementCount() const override {
        if (qcplayoutinset_elementcount_isbase) {
            qcplayoutinset_elementcount_isbase = false;
            return QCPLayoutInset::elementCount();
        } else if (qcplayoutinset_elementcount_callback != nullptr) {
            int callback_ret = qcplayoutinset_elementcount_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPLayoutInset::elementCount();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPLayoutElement* elementAt(int index) const override {
        if (qcplayoutinset_elementat_isbase) {
            qcplayoutinset_elementat_isbase = false;
            return QCPLayoutInset::elementAt(index);
        } else if (qcplayoutinset_elementat_callback != nullptr) {
            int cbval1 = index;

            QCPLayoutElement* callback_ret = qcplayoutinset_elementat_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPLayoutInset::elementAt(index);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPLayoutElement* takeAt(int index) override {
        if (qcplayoutinset_takeat_isbase) {
            qcplayoutinset_takeat_isbase = false;
            return QCPLayoutInset::takeAt(index);
        } else if (qcplayoutinset_takeat_callback != nullptr) {
            int cbval1 = index;

            QCPLayoutElement* callback_ret = qcplayoutinset_takeat_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPLayoutInset::takeAt(index);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool take(QCPLayoutElement* element) override {
        if (qcplayoutinset_take_isbase) {
            qcplayoutinset_take_isbase = false;
            return QCPLayoutInset::take(element);
        } else if (qcplayoutinset_take_callback != nullptr) {
            QCPLayoutElement* cbval1 = element;

            bool callback_ret = qcplayoutinset_take_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPLayoutInset::take(element);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void simplify() override {
        if (qcplayoutinset_simplify_isbase) {
            qcplayoutinset_simplify_isbase = false;
            QCPLayoutInset::simplify();
        } else if (qcplayoutinset_simplify_callback != nullptr) {
            qcplayoutinset_simplify_callback();
        } else {
            QCPLayoutInset::simplify();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcplayoutinset_selecttest_isbase) {
            qcplayoutinset_selecttest_isbase = false;
            return QCPLayoutInset::selectTest(pos, onlySelectable, details);
        } else if (qcplayoutinset_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcplayoutinset_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPLayoutInset::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void update(QCPLayoutElement::UpdatePhase phase) override {
        if (qcplayoutinset_update_isbase) {
            qcplayoutinset_update_isbase = false;
            QCPLayoutInset::update(phase);
        } else if (qcplayoutinset_update_callback != nullptr) {
            int cbval1 = static_cast<int>(phase);

            qcplayoutinset_update_callback(this, cbval1);
        } else {
            QCPLayoutInset::update(phase);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QList<QCPLayoutElement*> elements(bool recursive) const override {
        if (qcplayoutinset_elements_isbase) {
            qcplayoutinset_elements_isbase = false;
            return QCPLayoutInset::elements(recursive);
        } else if (qcplayoutinset_elements_callback != nullptr) {
            bool cbval1 = recursive;

            QCPLayoutElement** callback_ret = qcplayoutinset_elements_callback(this, cbval1);
            QList<QCPLayoutElement*> callback_ret_QList;
            // Iterate until null pointer sentinel
            for (QCPLayoutElement** ptridx = callback_ret; *ptridx != nullptr; ptridx++) {
                callback_ret_QList.push_back(*ptridx);
            }
            free(callback_ret);
            return callback_ret_QList;
        } else {
            return QCPLayoutInset::elements(recursive);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize minimumOuterSizeHint() const override {
        if (qcplayoutinset_minimumoutersizehint_isbase) {
            qcplayoutinset_minimumoutersizehint_isbase = false;
            return QCPLayoutInset::minimumOuterSizeHint();
        } else if (qcplayoutinset_minimumoutersizehint_callback != nullptr) {
            QSize* callback_ret = qcplayoutinset_minimumoutersizehint_callback();
            return *callback_ret;
        } else {
            return QCPLayoutInset::minimumOuterSizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize maximumOuterSizeHint() const override {
        if (qcplayoutinset_maximumoutersizehint_isbase) {
            qcplayoutinset_maximumoutersizehint_isbase = false;
            return QCPLayoutInset::maximumOuterSizeHint();
        } else if (qcplayoutinset_maximumoutersizehint_callback != nullptr) {
            QSize* callback_ret = qcplayoutinset_maximumoutersizehint_callback();
            return *callback_ret;
        } else {
            return QCPLayoutInset::maximumOuterSizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int calculateAutoMargin(QCP::MarginSide side) override {
        if (qcplayoutinset_calculateautomargin_isbase) {
            qcplayoutinset_calculateautomargin_isbase = false;
            return QCPLayoutInset::calculateAutoMargin(side);
        } else if (qcplayoutinset_calculateautomargin_callback != nullptr) {
            int cbval1 = static_cast<int>(side);

            int callback_ret = qcplayoutinset_calculateautomargin_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPLayoutInset::calculateAutoMargin(side);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void layoutChanged() override {
        if (qcplayoutinset_layoutchanged_isbase) {
            qcplayoutinset_layoutchanged_isbase = false;
            QCPLayoutInset::layoutChanged();
        } else if (qcplayoutinset_layoutchanged_callback != nullptr) {
            qcplayoutinset_layoutchanged_callback();
        } else {
            QCPLayoutInset::layoutChanged();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcplayoutinset_applydefaultantialiasinghint_isbase) {
            qcplayoutinset_applydefaultantialiasinghint_isbase = false;
            QCPLayoutInset::applyDefaultAntialiasingHint(painter);
        } else if (qcplayoutinset_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcplayoutinset_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPLayoutInset::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcplayoutinset_draw_isbase) {
            qcplayoutinset_draw_isbase = false;
            QCPLayoutInset::draw(painter);
        } else if (qcplayoutinset_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcplayoutinset_draw_callback(this, cbval1);
        } else {
            QCPLayoutInset::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcplayoutinset_parentplotinitialized_isbase) {
            qcplayoutinset_parentplotinitialized_isbase = false;
            QCPLayoutInset::parentPlotInitialized(parentPlot);
        } else if (qcplayoutinset_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcplayoutinset_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPLayoutInset::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcplayoutinset_selectioncategory_isbase) {
            qcplayoutinset_selectioncategory_isbase = false;
            return QCPLayoutInset::selectionCategory();
        } else if (qcplayoutinset_selectioncategory_callback != nullptr) {
            int callback_ret = qcplayoutinset_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPLayoutInset::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcplayoutinset_cliprect_isbase) {
            qcplayoutinset_cliprect_isbase = false;
            return QCPLayoutInset::clipRect();
        } else if (qcplayoutinset_cliprect_callback != nullptr) {
            QRect* callback_ret = qcplayoutinset_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPLayoutInset::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcplayoutinset_selectevent_isbase) {
            qcplayoutinset_selectevent_isbase = false;
            QCPLayoutInset::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcplayoutinset_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcplayoutinset_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPLayoutInset::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcplayoutinset_deselectevent_isbase) {
            qcplayoutinset_deselectevent_isbase = false;
            QCPLayoutInset::deselectEvent(selectionStateChanged);
        } else if (qcplayoutinset_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcplayoutinset_deselectevent_callback(this, cbval1);
        } else {
            QCPLayoutInset::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcplayoutinset_mousepressevent_isbase) {
            qcplayoutinset_mousepressevent_isbase = false;
            QCPLayoutInset::mousePressEvent(event, details);
        } else if (qcplayoutinset_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcplayoutinset_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPLayoutInset::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcplayoutinset_mousemoveevent_isbase) {
            qcplayoutinset_mousemoveevent_isbase = false;
            QCPLayoutInset::mouseMoveEvent(event, startPos);
        } else if (qcplayoutinset_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcplayoutinset_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPLayoutInset::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcplayoutinset_mousereleaseevent_isbase) {
            qcplayoutinset_mousereleaseevent_isbase = false;
            QCPLayoutInset::mouseReleaseEvent(event, startPos);
        } else if (qcplayoutinset_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcplayoutinset_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPLayoutInset::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcplayoutinset_mousedoubleclickevent_isbase) {
            qcplayoutinset_mousedoubleclickevent_isbase = false;
            QCPLayoutInset::mouseDoubleClickEvent(event, details);
        } else if (qcplayoutinset_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcplayoutinset_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPLayoutInset::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcplayoutinset_wheelevent_isbase) {
            qcplayoutinset_wheelevent_isbase = false;
            QCPLayoutInset::wheelEvent(event);
        } else if (qcplayoutinset_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcplayoutinset_wheelevent_callback(this, cbval1);
        } else {
            QCPLayoutInset::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcplayoutinset_event_isbase) {
            qcplayoutinset_event_isbase = false;
            return QCPLayoutInset::event(event);
        } else if (qcplayoutinset_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcplayoutinset_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPLayoutInset::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcplayoutinset_eventfilter_isbase) {
            qcplayoutinset_eventfilter_isbase = false;
            return QCPLayoutInset::eventFilter(watched, event);
        } else if (qcplayoutinset_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcplayoutinset_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPLayoutInset::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcplayoutinset_timerevent_isbase) {
            qcplayoutinset_timerevent_isbase = false;
            QCPLayoutInset::timerEvent(event);
        } else if (qcplayoutinset_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcplayoutinset_timerevent_callback(this, cbval1);
        } else {
            QCPLayoutInset::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcplayoutinset_childevent_isbase) {
            qcplayoutinset_childevent_isbase = false;
            QCPLayoutInset::childEvent(event);
        } else if (qcplayoutinset_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcplayoutinset_childevent_callback(this, cbval1);
        } else {
            QCPLayoutInset::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcplayoutinset_customevent_isbase) {
            qcplayoutinset_customevent_isbase = false;
            QCPLayoutInset::customEvent(event);
        } else if (qcplayoutinset_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcplayoutinset_customevent_callback(this, cbval1);
        } else {
            QCPLayoutInset::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcplayoutinset_connectnotify_isbase) {
            qcplayoutinset_connectnotify_isbase = false;
            QCPLayoutInset::connectNotify(signal);
        } else if (qcplayoutinset_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcplayoutinset_connectnotify_callback(this, cbval1);
        } else {
            QCPLayoutInset::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcplayoutinset_disconnectnotify_isbase) {
            qcplayoutinset_disconnectnotify_isbase = false;
            QCPLayoutInset::disconnectNotify(signal);
        } else if (qcplayoutinset_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcplayoutinset_disconnectnotify_callback(this, cbval1);
        } else {
            QCPLayoutInset::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    void sizeConstraintsChanged() const {
        if (qcplayoutinset_sizeconstraintschanged_isbase) {
            qcplayoutinset_sizeconstraintschanged_isbase = false;
            QCPLayoutInset::sizeConstraintsChanged();
        } else if (qcplayoutinset_sizeconstraintschanged_callback != nullptr) {
            qcplayoutinset_sizeconstraintschanged_callback();
        } else {
            QCPLayoutInset::sizeConstraintsChanged();
        }
    }

    // Virtual method for C ABI access and custom callback
    void adoptElement(QCPLayoutElement* el) {
        if (qcplayoutinset_adoptelement_isbase) {
            qcplayoutinset_adoptelement_isbase = false;
            QCPLayoutInset::adoptElement(el);
        } else if (qcplayoutinset_adoptelement_callback != nullptr) {
            QCPLayoutElement* cbval1 = el;

            qcplayoutinset_adoptelement_callback(this, cbval1);
        } else {
            QCPLayoutInset::adoptElement(el);
        }
    }

    // Virtual method for C ABI access and custom callback
    void releaseElement(QCPLayoutElement* el) {
        if (qcplayoutinset_releaseelement_isbase) {
            qcplayoutinset_releaseelement_isbase = false;
            QCPLayoutInset::releaseElement(el);
        } else if (qcplayoutinset_releaseelement_callback != nullptr) {
            QCPLayoutElement* cbval1 = el;

            qcplayoutinset_releaseelement_callback(this, cbval1);
        } else {
            QCPLayoutInset::releaseElement(el);
        }
    }

    // Virtual method for C ABI access and custom callback
    QVector<int> getSectionSizes(QVector<int> maxSizes, QVector<int> minSizes, QVector<double> stretchFactors, int totalSize) const {
        if (qcplayoutinset_getsectionsizes_isbase) {
            qcplayoutinset_getsectionsizes_isbase = false;
            return QCPLayoutInset::getSectionSizes(maxSizes, minSizes, stretchFactors, totalSize);
        } else if (qcplayoutinset_getsectionsizes_callback != nullptr) {
            QVector<int> maxSizes_ret = maxSizes;
            // Convert QVector<> from C++ memory to manually-managed C memory
            int* maxSizes_arr = static_cast<int*>(malloc(sizeof(int) * (maxSizes_ret.size() + 1)));
            for (qsizetype i = 0; i < maxSizes_ret.size(); ++i) {
                maxSizes_arr[i] = maxSizes_ret[i];
            }
            libqt_list maxSizes_out;
            maxSizes_out.len = maxSizes_ret.size();
            maxSizes_out.data = static_cast<void*>(maxSizes_arr);
            libqt_list /* of int */ cbval1 = maxSizes_out;
            QVector<int> minSizes_ret = minSizes;
            // Convert QVector<> from C++ memory to manually-managed C memory
            int* minSizes_arr = static_cast<int*>(malloc(sizeof(int) * (minSizes_ret.size() + 1)));
            for (qsizetype i = 0; i < minSizes_ret.size(); ++i) {
                minSizes_arr[i] = minSizes_ret[i];
            }
            libqt_list minSizes_out;
            minSizes_out.len = minSizes_ret.size();
            minSizes_out.data = static_cast<void*>(minSizes_arr);
            libqt_list /* of int */ cbval2 = minSizes_out;
            QVector<double> stretchFactors_ret = stretchFactors;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* stretchFactors_arr = static_cast<double*>(malloc(sizeof(double) * (stretchFactors_ret.size() + 1)));
            for (qsizetype i = 0; i < stretchFactors_ret.size(); ++i) {
                stretchFactors_arr[i] = stretchFactors_ret[i];
            }
            libqt_list stretchFactors_out;
            stretchFactors_out.len = stretchFactors_ret.size();
            stretchFactors_out.data = static_cast<void*>(stretchFactors_arr);
            libqt_list /* of double */ cbval3 = stretchFactors_out;
            int cbval4 = totalSize;

            int* callback_ret = qcplayoutinset_getsectionsizes_callback(this, cbval1, cbval2, cbval3, cbval4);
            QVector<int> callback_ret_QVector;
            for (int* ptr = callback_ret; *ptr != -1; ++ptr) {
                callback_ret_QVector.push_back(*ptr);
            }
            return callback_ret_QVector;
        } else {
            return QCPLayoutInset::getSectionSizes(maxSizes, minSizes, stretchFactors, totalSize);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcplayoutinset_initializeparentplot_isbase) {
            qcplayoutinset_initializeparentplot_isbase = false;
            QCPLayoutInset::initializeParentPlot(parentPlot);
        } else if (qcplayoutinset_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcplayoutinset_initializeparentplot_callback(this, cbval1);
        } else {
            QCPLayoutInset::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcplayoutinset_setparentlayerable_isbase) {
            qcplayoutinset_setparentlayerable_isbase = false;
            QCPLayoutInset::setParentLayerable(parentLayerable);
        } else if (qcplayoutinset_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcplayoutinset_setparentlayerable_callback(this, cbval1);
        } else {
            QCPLayoutInset::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcplayoutinset_movetolayer_isbase) {
            qcplayoutinset_movetolayer_isbase = false;
            return QCPLayoutInset::moveToLayer(layer, prepend);
        } else if (qcplayoutinset_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcplayoutinset_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPLayoutInset::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcplayoutinset_applyantialiasinghint_isbase) {
            qcplayoutinset_applyantialiasinghint_isbase = false;
            QCPLayoutInset::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcplayoutinset_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcplayoutinset_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPLayoutInset::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcplayoutinset_sender_isbase) {
            qcplayoutinset_sender_isbase = false;
            return QCPLayoutInset::sender();
        } else if (qcplayoutinset_sender_callback != nullptr) {
            QObject* callback_ret = qcplayoutinset_sender_callback();
            return callback_ret;
        } else {
            return QCPLayoutInset::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcplayoutinset_sendersignalindex_isbase) {
            qcplayoutinset_sendersignalindex_isbase = false;
            return QCPLayoutInset::senderSignalIndex();
        } else if (qcplayoutinset_sendersignalindex_callback != nullptr) {
            int callback_ret = qcplayoutinset_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPLayoutInset::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcplayoutinset_receivers_isbase) {
            qcplayoutinset_receivers_isbase = false;
            return QCPLayoutInset::receivers(signal);
        } else if (qcplayoutinset_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcplayoutinset_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPLayoutInset::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcplayoutinset_issignalconnected_isbase) {
            qcplayoutinset_issignalconnected_isbase = false;
            return QCPLayoutInset::isSignalConnected(signal);
        } else if (qcplayoutinset_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcplayoutinset_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPLayoutInset::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend int QCPLayoutInset_CalculateAutoMargin(QCPLayoutInset* self, int side);
    friend int QCPLayoutInset_QBaseCalculateAutoMargin(QCPLayoutInset* self, int side);
    friend void QCPLayoutInset_LayoutChanged(QCPLayoutInset* self);
    friend void QCPLayoutInset_QBaseLayoutChanged(QCPLayoutInset* self);
    friend void QCPLayoutInset_ApplyDefaultAntialiasingHint(const QCPLayoutInset* self, QCPPainter* painter);
    friend void QCPLayoutInset_QBaseApplyDefaultAntialiasingHint(const QCPLayoutInset* self, QCPPainter* painter);
    friend void QCPLayoutInset_Draw(QCPLayoutInset* self, QCPPainter* painter);
    friend void QCPLayoutInset_QBaseDraw(QCPLayoutInset* self, QCPPainter* painter);
    friend void QCPLayoutInset_ParentPlotInitialized(QCPLayoutInset* self, QCustomPlot* parentPlot);
    friend void QCPLayoutInset_QBaseParentPlotInitialized(QCPLayoutInset* self, QCustomPlot* parentPlot);
    friend int QCPLayoutInset_SelectionCategory(const QCPLayoutInset* self);
    friend int QCPLayoutInset_QBaseSelectionCategory(const QCPLayoutInset* self);
    friend QRect* QCPLayoutInset_ClipRect(const QCPLayoutInset* self);
    friend QRect* QCPLayoutInset_QBaseClipRect(const QCPLayoutInset* self);
    friend void QCPLayoutInset_SelectEvent(QCPLayoutInset* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPLayoutInset_QBaseSelectEvent(QCPLayoutInset* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPLayoutInset_DeselectEvent(QCPLayoutInset* self, bool* selectionStateChanged);
    friend void QCPLayoutInset_QBaseDeselectEvent(QCPLayoutInset* self, bool* selectionStateChanged);
    friend void QCPLayoutInset_MousePressEvent(QCPLayoutInset* self, QMouseEvent* event, const QVariant* details);
    friend void QCPLayoutInset_QBaseMousePressEvent(QCPLayoutInset* self, QMouseEvent* event, const QVariant* details);
    friend void QCPLayoutInset_MouseMoveEvent(QCPLayoutInset* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPLayoutInset_QBaseMouseMoveEvent(QCPLayoutInset* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPLayoutInset_MouseReleaseEvent(QCPLayoutInset* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPLayoutInset_QBaseMouseReleaseEvent(QCPLayoutInset* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPLayoutInset_MouseDoubleClickEvent(QCPLayoutInset* self, QMouseEvent* event, const QVariant* details);
    friend void QCPLayoutInset_QBaseMouseDoubleClickEvent(QCPLayoutInset* self, QMouseEvent* event, const QVariant* details);
    friend void QCPLayoutInset_WheelEvent(QCPLayoutInset* self, QWheelEvent* event);
    friend void QCPLayoutInset_QBaseWheelEvent(QCPLayoutInset* self, QWheelEvent* event);
    friend void QCPLayoutInset_TimerEvent(QCPLayoutInset* self, QTimerEvent* event);
    friend void QCPLayoutInset_QBaseTimerEvent(QCPLayoutInset* self, QTimerEvent* event);
    friend void QCPLayoutInset_ChildEvent(QCPLayoutInset* self, QChildEvent* event);
    friend void QCPLayoutInset_QBaseChildEvent(QCPLayoutInset* self, QChildEvent* event);
    friend void QCPLayoutInset_CustomEvent(QCPLayoutInset* self, QEvent* event);
    friend void QCPLayoutInset_QBaseCustomEvent(QCPLayoutInset* self, QEvent* event);
    friend void QCPLayoutInset_ConnectNotify(QCPLayoutInset* self, const QMetaMethod* signal);
    friend void QCPLayoutInset_QBaseConnectNotify(QCPLayoutInset* self, const QMetaMethod* signal);
    friend void QCPLayoutInset_DisconnectNotify(QCPLayoutInset* self, const QMetaMethod* signal);
    friend void QCPLayoutInset_QBaseDisconnectNotify(QCPLayoutInset* self, const QMetaMethod* signal);
    friend void QCPLayoutInset_SizeConstraintsChanged(const QCPLayoutInset* self);
    friend void QCPLayoutInset_QBaseSizeConstraintsChanged(const QCPLayoutInset* self);
    friend void QCPLayoutInset_AdoptElement(QCPLayoutInset* self, QCPLayoutElement* el);
    friend void QCPLayoutInset_QBaseAdoptElement(QCPLayoutInset* self, QCPLayoutElement* el);
    friend void QCPLayoutInset_ReleaseElement(QCPLayoutInset* self, QCPLayoutElement* el);
    friend void QCPLayoutInset_QBaseReleaseElement(QCPLayoutInset* self, QCPLayoutElement* el);
    friend libqt_list /* of int */ QCPLayoutInset_GetSectionSizes(const QCPLayoutInset* self, libqt_list /* of int */ maxSizes, libqt_list /* of int */ minSizes, libqt_list /* of double */ stretchFactors, int totalSize);
    friend libqt_list /* of int */ QCPLayoutInset_QBaseGetSectionSizes(const QCPLayoutInset* self, libqt_list /* of int */ maxSizes, libqt_list /* of int */ minSizes, libqt_list /* of double */ stretchFactors, int totalSize);
    friend void QCPLayoutInset_InitializeParentPlot(QCPLayoutInset* self, QCustomPlot* parentPlot);
    friend void QCPLayoutInset_QBaseInitializeParentPlot(QCPLayoutInset* self, QCustomPlot* parentPlot);
    friend void QCPLayoutInset_SetParentLayerable(QCPLayoutInset* self, QCPLayerable* parentLayerable);
    friend void QCPLayoutInset_QBaseSetParentLayerable(QCPLayoutInset* self, QCPLayerable* parentLayerable);
    friend bool QCPLayoutInset_MoveToLayer(QCPLayoutInset* self, QCPLayer* layer, bool prepend);
    friend bool QCPLayoutInset_QBaseMoveToLayer(QCPLayoutInset* self, QCPLayer* layer, bool prepend);
    friend void QCPLayoutInset_ApplyAntialiasingHint(const QCPLayoutInset* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPLayoutInset_QBaseApplyAntialiasingHint(const QCPLayoutInset* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPLayoutInset_Sender(const QCPLayoutInset* self);
    friend QObject* QCPLayoutInset_QBaseSender(const QCPLayoutInset* self);
    friend int QCPLayoutInset_SenderSignalIndex(const QCPLayoutInset* self);
    friend int QCPLayoutInset_QBaseSenderSignalIndex(const QCPLayoutInset* self);
    friend int QCPLayoutInset_Receivers(const QCPLayoutInset* self, const char* signal);
    friend int QCPLayoutInset_QBaseReceivers(const QCPLayoutInset* self, const char* signal);
    friend bool QCPLayoutInset_IsSignalConnected(const QCPLayoutInset* self, const QMetaMethod* signal);
    friend bool QCPLayoutInset_QBaseIsSignalConnected(const QCPLayoutInset* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPAxisTicker so that we can call protected methods
class VirtualQCPAxisTicker final : public QCPAxisTicker {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPAxisTicker = true;

    // Virtual class public types (including callbacks)
    using QCPAxisTicker_Generate_Callback = void (*)(QCPAxisTicker*, QCPRange*, QLocale*, QChar*, int, libqt_list /* of double */, libqt_list /* of double */, libqt_list /* of libqt_string */);
    using QCPAxisTicker_GetTickStep_Callback = double (*)(QCPAxisTicker*, QCPRange*);
    using QCPAxisTicker_GetSubTickCount_Callback = int (*)(QCPAxisTicker*, double);
    using QCPAxisTicker_GetTickLabel_Callback = const char* (*)(QCPAxisTicker*, double, QLocale*, QChar*, int);
    using QCPAxisTicker_CreateTickVector_Callback = libqt_list /* of double */ (*)(QCPAxisTicker*, double, QCPRange*);
    using QCPAxisTicker_CreateSubTickVector_Callback = libqt_list /* of double */ (*)(QCPAxisTicker*, int, libqt_list /* of double */);
    using QCPAxisTicker_CreateLabelVector_Callback = const char** (*)(QCPAxisTicker*, libqt_list /* of double */, QLocale*, QChar*, int);
    using QCPAxisTicker_TrimTicks_Callback = void (*)(const QCPAxisTicker*, QCPRange*, libqt_list /* of double */, bool);
    using QCPAxisTicker_PickClosest_Callback = double (*)(const QCPAxisTicker*, double, libqt_list /* of double */);
    using QCPAxisTicker_GetMantissa_Callback = double (*)(const QCPAxisTicker*, double);
    using QCPAxisTicker_CleanMantissa_Callback = double (*)(const QCPAxisTicker*, double);
    using QCPAxisTicker_GetMantissa2_Callback = double (*)(const QCPAxisTicker*, double, double*);

  protected:
    // Instance callback storage
    QCPAxisTicker_Generate_Callback qcpaxisticker_generate_callback = nullptr;
    QCPAxisTicker_GetTickStep_Callback qcpaxisticker_gettickstep_callback = nullptr;
    QCPAxisTicker_GetSubTickCount_Callback qcpaxisticker_getsubtickcount_callback = nullptr;
    QCPAxisTicker_GetTickLabel_Callback qcpaxisticker_getticklabel_callback = nullptr;
    QCPAxisTicker_CreateTickVector_Callback qcpaxisticker_createtickvector_callback = nullptr;
    QCPAxisTicker_CreateSubTickVector_Callback qcpaxisticker_createsubtickvector_callback = nullptr;
    QCPAxisTicker_CreateLabelVector_Callback qcpaxisticker_createlabelvector_callback = nullptr;
    QCPAxisTicker_TrimTicks_Callback qcpaxisticker_trimticks_callback = nullptr;
    QCPAxisTicker_PickClosest_Callback qcpaxisticker_pickclosest_callback = nullptr;
    QCPAxisTicker_GetMantissa_Callback qcpaxisticker_getmantissa_callback = nullptr;
    QCPAxisTicker_CleanMantissa_Callback qcpaxisticker_cleanmantissa_callback = nullptr;
    QCPAxisTicker_GetMantissa2_Callback qcpaxisticker_getmantissa2_callback = nullptr;

    // Instance base flags
    mutable bool qcpaxisticker_generate_isbase = false;
    mutable bool qcpaxisticker_gettickstep_isbase = false;
    mutable bool qcpaxisticker_getsubtickcount_isbase = false;
    mutable bool qcpaxisticker_getticklabel_isbase = false;
    mutable bool qcpaxisticker_createtickvector_isbase = false;
    mutable bool qcpaxisticker_createsubtickvector_isbase = false;
    mutable bool qcpaxisticker_createlabelvector_isbase = false;
    mutable bool qcpaxisticker_trimticks_isbase = false;
    mutable bool qcpaxisticker_pickclosest_isbase = false;
    mutable bool qcpaxisticker_getmantissa_isbase = false;
    mutable bool qcpaxisticker_cleanmantissa_isbase = false;
    mutable bool qcpaxisticker_getmantissa2_isbase = false;

  public:
    VirtualQCPAxisTicker() : QCPAxisTicker() {};

    ~VirtualQCPAxisTicker() {
        qcpaxisticker_generate_callback = nullptr;
        qcpaxisticker_gettickstep_callback = nullptr;
        qcpaxisticker_getsubtickcount_callback = nullptr;
        qcpaxisticker_getticklabel_callback = nullptr;
        qcpaxisticker_createtickvector_callback = nullptr;
        qcpaxisticker_createsubtickvector_callback = nullptr;
        qcpaxisticker_createlabelvector_callback = nullptr;
        qcpaxisticker_trimticks_callback = nullptr;
        qcpaxisticker_pickclosest_callback = nullptr;
        qcpaxisticker_getmantissa_callback = nullptr;
        qcpaxisticker_cleanmantissa_callback = nullptr;
        qcpaxisticker_getmantissa2_callback = nullptr;
    }

    // Callback setters
    inline void setQCPAxisTicker_Generate_Callback(QCPAxisTicker_Generate_Callback cb) { qcpaxisticker_generate_callback = cb; }
    inline void setQCPAxisTicker_GetTickStep_Callback(QCPAxisTicker_GetTickStep_Callback cb) { qcpaxisticker_gettickstep_callback = cb; }
    inline void setQCPAxisTicker_GetSubTickCount_Callback(QCPAxisTicker_GetSubTickCount_Callback cb) { qcpaxisticker_getsubtickcount_callback = cb; }
    inline void setQCPAxisTicker_GetTickLabel_Callback(QCPAxisTicker_GetTickLabel_Callback cb) { qcpaxisticker_getticklabel_callback = cb; }
    inline void setQCPAxisTicker_CreateTickVector_Callback(QCPAxisTicker_CreateTickVector_Callback cb) { qcpaxisticker_createtickvector_callback = cb; }
    inline void setQCPAxisTicker_CreateSubTickVector_Callback(QCPAxisTicker_CreateSubTickVector_Callback cb) { qcpaxisticker_createsubtickvector_callback = cb; }
    inline void setQCPAxisTicker_CreateLabelVector_Callback(QCPAxisTicker_CreateLabelVector_Callback cb) { qcpaxisticker_createlabelvector_callback = cb; }
    inline void setQCPAxisTicker_TrimTicks_Callback(QCPAxisTicker_TrimTicks_Callback cb) { qcpaxisticker_trimticks_callback = cb; }
    inline void setQCPAxisTicker_PickClosest_Callback(QCPAxisTicker_PickClosest_Callback cb) { qcpaxisticker_pickclosest_callback = cb; }
    inline void setQCPAxisTicker_GetMantissa_Callback(QCPAxisTicker_GetMantissa_Callback cb) { qcpaxisticker_getmantissa_callback = cb; }
    inline void setQCPAxisTicker_CleanMantissa_Callback(QCPAxisTicker_CleanMantissa_Callback cb) { qcpaxisticker_cleanmantissa_callback = cb; }
    inline void setQCPAxisTicker_GetMantissa2_Callback(QCPAxisTicker_GetMantissa2_Callback cb) { qcpaxisticker_getmantissa2_callback = cb; }

    // Base flag setters
    inline void setQCPAxisTicker_Generate_IsBase(bool value) const { qcpaxisticker_generate_isbase = value; }
    inline void setQCPAxisTicker_GetTickStep_IsBase(bool value) const { qcpaxisticker_gettickstep_isbase = value; }
    inline void setQCPAxisTicker_GetSubTickCount_IsBase(bool value) const { qcpaxisticker_getsubtickcount_isbase = value; }
    inline void setQCPAxisTicker_GetTickLabel_IsBase(bool value) const { qcpaxisticker_getticklabel_isbase = value; }
    inline void setQCPAxisTicker_CreateTickVector_IsBase(bool value) const { qcpaxisticker_createtickvector_isbase = value; }
    inline void setQCPAxisTicker_CreateSubTickVector_IsBase(bool value) const { qcpaxisticker_createsubtickvector_isbase = value; }
    inline void setQCPAxisTicker_CreateLabelVector_IsBase(bool value) const { qcpaxisticker_createlabelvector_isbase = value; }
    inline void setQCPAxisTicker_TrimTicks_IsBase(bool value) const { qcpaxisticker_trimticks_isbase = value; }
    inline void setQCPAxisTicker_PickClosest_IsBase(bool value) const { qcpaxisticker_pickclosest_isbase = value; }
    inline void setQCPAxisTicker_GetMantissa_IsBase(bool value) const { qcpaxisticker_getmantissa_isbase = value; }
    inline void setQCPAxisTicker_CleanMantissa_IsBase(bool value) const { qcpaxisticker_cleanmantissa_isbase = value; }
    inline void setQCPAxisTicker_GetMantissa2_IsBase(bool value) const { qcpaxisticker_getmantissa2_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual void generate(const QCPRange& range, const QLocale& locale, QChar formatChar, int precision, QVector<double>& ticks, QVector<double>* subTicks, QVector<QString>* tickLabels) override {
        if (qcpaxisticker_generate_isbase) {
            qcpaxisticker_generate_isbase = false;
            QCPAxisTicker::generate(range, locale, formatChar, precision, ticks, subTicks, tickLabels);
        } else if (qcpaxisticker_generate_callback != nullptr) {
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval1 = const_cast<QCPRange*>(&range_ret);
            const QLocale& locale_ret = locale;
            // Cast returned reference into pointer
            QLocale* cbval2 = const_cast<QLocale*>(&locale_ret);
            QChar* cbval3 = new QChar(formatChar);
            int cbval4 = precision;
            QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval5 = ticks_out;
            QVector<double>* subTicks_ret = subTicks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* subTicks_arr = static_cast<double*>(malloc(sizeof(double) * (subTicks_ret->size() + 1)));
            for (qsizetype i = 0; i < subTicks_ret->size(); ++i) {
                subTicks_arr[i] = (*subTicks_ret)[i];
            }
            libqt_list subTicks_out;
            subTicks_out.len = subTicks_ret->size();
            subTicks_out.data = static_cast<void*>(subTicks_arr);
            libqt_list /* of double */ cbval6 = subTicks_out;
            QVector<QString>* tickLabels_ret = tickLabels;
            // Convert QVector<> from C++ memory to manually-managed C memory
            libqt_string* tickLabels_arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (tickLabels_ret->size() + 1)));
            for (qsizetype i = 0; i < tickLabels_ret->size(); ++i) {
                QString tickLabels_vv_ret = (*tickLabels_ret)[i];
                // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
                QByteArray tickLabels_vv_b = tickLabels_vv_ret.toUtf8();
                libqt_string tickLabels_vv_str;
                tickLabels_vv_str.len = tickLabels_vv_b.length();
                tickLabels_vv_str.data = static_cast<const char*>(malloc(tickLabels_vv_str.len + 1));
                memcpy((void*)tickLabels_vv_str.data, tickLabels_vv_b.data(), tickLabels_vv_str.len);
                ((char*)tickLabels_vv_str.data)[tickLabels_vv_str.len] = '\0';
                tickLabels_arr[i] = tickLabels_vv_str;
            }
            libqt_list tickLabels_out;
            tickLabels_out.len = tickLabels_ret->size();
            tickLabels_out.data = static_cast<void*>(tickLabels_arr);
            libqt_list /* of libqt_string */ cbval7 = tickLabels_out;

            qcpaxisticker_generate_callback(this, cbval1, cbval2, cbval3, cbval4, cbval5, cbval6, cbval7);
        } else {
            QCPAxisTicker::generate(range, locale, formatChar, precision, ticks, subTicks, tickLabels);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double getTickStep(const QCPRange& range) override {
        if (qcpaxisticker_gettickstep_isbase) {
            qcpaxisticker_gettickstep_isbase = false;
            return QCPAxisTicker::getTickStep(range);
        } else if (qcpaxisticker_gettickstep_callback != nullptr) {
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval1 = const_cast<QCPRange*>(&range_ret);

            double callback_ret = qcpaxisticker_gettickstep_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTicker::getTickStep(range);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int getSubTickCount(double tickStep) override {
        if (qcpaxisticker_getsubtickcount_isbase) {
            qcpaxisticker_getsubtickcount_isbase = false;
            return QCPAxisTicker::getSubTickCount(tickStep);
        } else if (qcpaxisticker_getsubtickcount_callback != nullptr) {
            double cbval1 = tickStep;

            int callback_ret = qcpaxisticker_getsubtickcount_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPAxisTicker::getSubTickCount(tickStep);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QString getTickLabel(double tick, const QLocale& locale, QChar formatChar, int precision) override {
        if (qcpaxisticker_getticklabel_isbase) {
            qcpaxisticker_getticklabel_isbase = false;
            return QCPAxisTicker::getTickLabel(tick, locale, formatChar, precision);
        } else if (qcpaxisticker_getticklabel_callback != nullptr) {
            double cbval1 = tick;
            const QLocale& locale_ret = locale;
            // Cast returned reference into pointer
            QLocale* cbval2 = const_cast<QLocale*>(&locale_ret);
            QChar* cbval3 = new QChar(formatChar);
            int cbval4 = precision;

            const char* callback_ret = qcpaxisticker_getticklabel_callback(this, cbval1, cbval2, cbval3, cbval4);
            QString callback_ret_QString = QString::fromUtf8(callback_ret);
            return callback_ret_QString;
        } else {
            return QCPAxisTicker::getTickLabel(tick, locale, formatChar, precision);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QVector<double> createTickVector(double tickStep, const QCPRange& range) override {
        if (qcpaxisticker_createtickvector_isbase) {
            qcpaxisticker_createtickvector_isbase = false;
            return QCPAxisTicker::createTickVector(tickStep, range);
        } else if (qcpaxisticker_createtickvector_callback != nullptr) {
            double cbval1 = tickStep;
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval2 = const_cast<QCPRange*>(&range_ret);

            libqt_list /* of double */ callback_ret = qcpaxisticker_createtickvector_callback(this, cbval1, cbval2);
            QVector<double> callback_ret_QVector;
            callback_ret_QVector.reserve(callback_ret.len);
            double* callback_ret_arr = static_cast<double*>(callback_ret.data);
            for (size_t i = 0; i < callback_ret.len; ++i) {
                callback_ret_QVector.push_back(static_cast<double>(callback_ret_arr[i]));
            }
            return callback_ret_QVector;
        } else {
            return QCPAxisTicker::createTickVector(tickStep, range);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QVector<double> createSubTickVector(int subTickCount, const QVector<double>& ticks) override {
        if (qcpaxisticker_createsubtickvector_isbase) {
            qcpaxisticker_createsubtickvector_isbase = false;
            return QCPAxisTicker::createSubTickVector(subTickCount, ticks);
        } else if (qcpaxisticker_createsubtickvector_callback != nullptr) {
            int cbval1 = subTickCount;
            const QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval2 = ticks_out;

            libqt_list /* of double */ callback_ret = qcpaxisticker_createsubtickvector_callback(this, cbval1, cbval2);
            QVector<double> callback_ret_QVector;
            callback_ret_QVector.reserve(callback_ret.len);
            double* callback_ret_arr = static_cast<double*>(callback_ret.data);
            for (size_t i = 0; i < callback_ret.len; ++i) {
                callback_ret_QVector.push_back(static_cast<double>(callback_ret_arr[i]));
            }
            return callback_ret_QVector;
        } else {
            return QCPAxisTicker::createSubTickVector(subTickCount, ticks);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QVector<QString> createLabelVector(const QVector<double>& ticks, const QLocale& locale, QChar formatChar, int precision) override {
        if (qcpaxisticker_createlabelvector_isbase) {
            qcpaxisticker_createlabelvector_isbase = false;
            return QCPAxisTicker::createLabelVector(ticks, locale, formatChar, precision);
        } else if (qcpaxisticker_createlabelvector_callback != nullptr) {
            const QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval1 = ticks_out;
            const QLocale& locale_ret = locale;
            // Cast returned reference into pointer
            QLocale* cbval2 = const_cast<QLocale*>(&locale_ret);
            QChar* cbval3 = new QChar(formatChar);
            int cbval4 = precision;

            const char** callback_ret = qcpaxisticker_createlabelvector_callback(this, cbval1, cbval2, cbval3, cbval4);
            QVector<QString> callback_ret_QVector;
            size_t callback_ret_len = libqt_strv_length(callback_ret);
            callback_ret_QVector.reserve(callback_ret_len);
            const char** callback_ret_arr = static_cast<const char**>(callback_ret);
            for (size_t i = 0; i < callback_ret_len; ++i) {
                QString callback_ret_arr_i_QString = QString::fromUtf8(callback_ret_arr[i]);
                callback_ret_QVector.push_back(callback_ret_arr_i_QString);
            }
            return callback_ret_QVector;
        } else {
            return QCPAxisTicker::createLabelVector(ticks, locale, formatChar, precision);
        }
    }

    // Virtual method for C ABI access and custom callback
    void trimTicks(const QCPRange& range, QVector<double>& ticks, bool keepOneOutlier) const {
        if (qcpaxisticker_trimticks_isbase) {
            qcpaxisticker_trimticks_isbase = false;
            QCPAxisTicker::trimTicks(range, ticks, keepOneOutlier);
        } else if (qcpaxisticker_trimticks_callback != nullptr) {
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval1 = const_cast<QCPRange*>(&range_ret);
            QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval2 = ticks_out;
            bool cbval3 = keepOneOutlier;

            qcpaxisticker_trimticks_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPAxisTicker::trimTicks(range, ticks, keepOneOutlier);
        }
    }

    // Virtual method for C ABI access and custom callback
    double pickClosest(double target, const QVector<double>& candidates) const {
        if (qcpaxisticker_pickclosest_isbase) {
            qcpaxisticker_pickclosest_isbase = false;
            return QCPAxisTicker::pickClosest(target, candidates);
        } else if (qcpaxisticker_pickclosest_callback != nullptr) {
            double cbval1 = target;
            const QVector<double>& candidates_ret = candidates;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* candidates_arr = static_cast<double*>(malloc(sizeof(double) * (candidates_ret.size() + 1)));
            for (qsizetype i = 0; i < candidates_ret.size(); ++i) {
                candidates_arr[i] = candidates_ret[i];
            }
            libqt_list candidates_out;
            candidates_out.len = candidates_ret.size();
            candidates_out.data = static_cast<void*>(candidates_arr);
            libqt_list /* of double */ cbval2 = candidates_out;

            double callback_ret = qcpaxisticker_pickclosest_callback(this, cbval1, cbval2);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTicker::pickClosest(target, candidates);
        }
    }

    // Virtual method for C ABI access and custom callback
    double getMantissa(double input) const {
        if (qcpaxisticker_getmantissa_isbase) {
            qcpaxisticker_getmantissa_isbase = false;
            return QCPAxisTicker::getMantissa(input);
        } else if (qcpaxisticker_getmantissa_callback != nullptr) {
            double cbval1 = input;

            double callback_ret = qcpaxisticker_getmantissa_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTicker::getMantissa(input);
        }
    }

    // Virtual method for C ABI access and custom callback
    double cleanMantissa(double input) const {
        if (qcpaxisticker_cleanmantissa_isbase) {
            qcpaxisticker_cleanmantissa_isbase = false;
            return QCPAxisTicker::cleanMantissa(input);
        } else if (qcpaxisticker_cleanmantissa_callback != nullptr) {
            double cbval1 = input;

            double callback_ret = qcpaxisticker_cleanmantissa_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTicker::cleanMantissa(input);
        }
    }

    // Virtual method for C ABI access and custom callback
    double getMantissa(double input, double* magnitude) const {
        if (qcpaxisticker_getmantissa2_isbase) {
            qcpaxisticker_getmantissa2_isbase = false;
            return QCPAxisTicker::getMantissa(input, magnitude);
        } else if (qcpaxisticker_getmantissa2_callback != nullptr) {
            double cbval1 = input;
            double* cbval2 = magnitude;

            double callback_ret = qcpaxisticker_getmantissa2_callback(this, cbval1, cbval2);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTicker::getMantissa(input, magnitude);
        }
    }

    // Friend functions
    friend double QCPAxisTicker_GetTickStep(QCPAxisTicker* self, const QCPRange* range);
    friend double QCPAxisTicker_QBaseGetTickStep(QCPAxisTicker* self, const QCPRange* range);
    friend int QCPAxisTicker_GetSubTickCount(QCPAxisTicker* self, double tickStep);
    friend int QCPAxisTicker_QBaseGetSubTickCount(QCPAxisTicker* self, double tickStep);
    friend libqt_string QCPAxisTicker_GetTickLabel(QCPAxisTicker* self, double tick, const QLocale* locale, QChar* formatChar, int precision);
    friend libqt_string QCPAxisTicker_QBaseGetTickLabel(QCPAxisTicker* self, double tick, const QLocale* locale, QChar* formatChar, int precision);
    friend libqt_list /* of double */ QCPAxisTicker_CreateTickVector(QCPAxisTicker* self, double tickStep, const QCPRange* range);
    friend libqt_list /* of double */ QCPAxisTicker_QBaseCreateTickVector(QCPAxisTicker* self, double tickStep, const QCPRange* range);
    friend libqt_list /* of double */ QCPAxisTicker_CreateSubTickVector(QCPAxisTicker* self, int subTickCount, const libqt_list /* of double */ ticks);
    friend libqt_list /* of double */ QCPAxisTicker_QBaseCreateSubTickVector(QCPAxisTicker* self, int subTickCount, const libqt_list /* of double */ ticks);
    friend libqt_list /* of libqt_string */ QCPAxisTicker_CreateLabelVector(QCPAxisTicker* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision);
    friend libqt_list /* of libqt_string */ QCPAxisTicker_QBaseCreateLabelVector(QCPAxisTicker* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision);
    friend void QCPAxisTicker_TrimTicks(const QCPAxisTicker* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier);
    friend void QCPAxisTicker_QBaseTrimTicks(const QCPAxisTicker* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier);
    friend double QCPAxisTicker_PickClosest(const QCPAxisTicker* self, double target, const libqt_list /* of double */ candidates);
    friend double QCPAxisTicker_QBasePickClosest(const QCPAxisTicker* self, double target, const libqt_list /* of double */ candidates);
    friend double QCPAxisTicker_GetMantissa(const QCPAxisTicker* self, double input);
    friend double QCPAxisTicker_QBaseGetMantissa(const QCPAxisTicker* self, double input);
    friend double QCPAxisTicker_CleanMantissa(const QCPAxisTicker* self, double input);
    friend double QCPAxisTicker_QBaseCleanMantissa(const QCPAxisTicker* self, double input);
    friend double QCPAxisTicker_GetMantissa2(const QCPAxisTicker* self, double input, double* magnitude);
    friend double QCPAxisTicker_QBaseGetMantissa2(const QCPAxisTicker* self, double input, double* magnitude);
};

// This class is a subclass of QCPAxisTickerDateTime so that we can call protected methods
class VirtualQCPAxisTickerDateTime final : public QCPAxisTickerDateTime {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPAxisTickerDateTime = true;

    // Virtual class public types (including callbacks)
    using QCPAxisTickerDateTime::DateStrategy;
    using QCPAxisTickerDateTime_GetTickStep_Callback = double (*)(QCPAxisTickerDateTime*, QCPRange*);
    using QCPAxisTickerDateTime_GetSubTickCount_Callback = int (*)(QCPAxisTickerDateTime*, double);
    using QCPAxisTickerDateTime_GetTickLabel_Callback = const char* (*)(QCPAxisTickerDateTime*, double, QLocale*, QChar*, int);
    using QCPAxisTickerDateTime_CreateTickVector_Callback = libqt_list /* of double */ (*)(QCPAxisTickerDateTime*, double, QCPRange*);
    using QCPAxisTickerDateTime_Generate_Callback = void (*)(QCPAxisTickerDateTime*, QCPRange*, QLocale*, QChar*, int, libqt_list /* of double */, libqt_list /* of double */, libqt_list /* of libqt_string */);
    using QCPAxisTickerDateTime_CreateSubTickVector_Callback = libqt_list /* of double */ (*)(QCPAxisTickerDateTime*, int, libqt_list /* of double */);
    using QCPAxisTickerDateTime_CreateLabelVector_Callback = const char** (*)(QCPAxisTickerDateTime*, libqt_list /* of double */, QLocale*, QChar*, int);
    using QCPAxisTickerDateTime_TrimTicks_Callback = void (*)(const QCPAxisTickerDateTime*, QCPRange*, libqt_list /* of double */, bool);
    using QCPAxisTickerDateTime_PickClosest_Callback = double (*)(const QCPAxisTickerDateTime*, double, libqt_list /* of double */);
    using QCPAxisTickerDateTime_GetMantissa_Callback = double (*)(const QCPAxisTickerDateTime*, double);
    using QCPAxisTickerDateTime_CleanMantissa_Callback = double (*)(const QCPAxisTickerDateTime*, double);

  protected:
    // Instance callback storage
    QCPAxisTickerDateTime_GetTickStep_Callback qcpaxistickerdatetime_gettickstep_callback = nullptr;
    QCPAxisTickerDateTime_GetSubTickCount_Callback qcpaxistickerdatetime_getsubtickcount_callback = nullptr;
    QCPAxisTickerDateTime_GetTickLabel_Callback qcpaxistickerdatetime_getticklabel_callback = nullptr;
    QCPAxisTickerDateTime_CreateTickVector_Callback qcpaxistickerdatetime_createtickvector_callback = nullptr;
    QCPAxisTickerDateTime_Generate_Callback qcpaxistickerdatetime_generate_callback = nullptr;
    QCPAxisTickerDateTime_CreateSubTickVector_Callback qcpaxistickerdatetime_createsubtickvector_callback = nullptr;
    QCPAxisTickerDateTime_CreateLabelVector_Callback qcpaxistickerdatetime_createlabelvector_callback = nullptr;
    QCPAxisTickerDateTime_TrimTicks_Callback qcpaxistickerdatetime_trimticks_callback = nullptr;
    QCPAxisTickerDateTime_PickClosest_Callback qcpaxistickerdatetime_pickclosest_callback = nullptr;
    QCPAxisTickerDateTime_GetMantissa_Callback qcpaxistickerdatetime_getmantissa_callback = nullptr;
    QCPAxisTickerDateTime_CleanMantissa_Callback qcpaxistickerdatetime_cleanmantissa_callback = nullptr;

    // Instance base flags
    mutable bool qcpaxistickerdatetime_gettickstep_isbase = false;
    mutable bool qcpaxistickerdatetime_getsubtickcount_isbase = false;
    mutable bool qcpaxistickerdatetime_getticklabel_isbase = false;
    mutable bool qcpaxistickerdatetime_createtickvector_isbase = false;
    mutable bool qcpaxistickerdatetime_generate_isbase = false;
    mutable bool qcpaxistickerdatetime_createsubtickvector_isbase = false;
    mutable bool qcpaxistickerdatetime_createlabelvector_isbase = false;
    mutable bool qcpaxistickerdatetime_trimticks_isbase = false;
    mutable bool qcpaxistickerdatetime_pickclosest_isbase = false;
    mutable bool qcpaxistickerdatetime_getmantissa_isbase = false;
    mutable bool qcpaxistickerdatetime_cleanmantissa_isbase = false;

  public:
    VirtualQCPAxisTickerDateTime() : QCPAxisTickerDateTime() {};

    ~VirtualQCPAxisTickerDateTime() {
        qcpaxistickerdatetime_gettickstep_callback = nullptr;
        qcpaxistickerdatetime_getsubtickcount_callback = nullptr;
        qcpaxistickerdatetime_getticklabel_callback = nullptr;
        qcpaxistickerdatetime_createtickvector_callback = nullptr;
        qcpaxistickerdatetime_generate_callback = nullptr;
        qcpaxistickerdatetime_createsubtickvector_callback = nullptr;
        qcpaxistickerdatetime_createlabelvector_callback = nullptr;
        qcpaxistickerdatetime_trimticks_callback = nullptr;
        qcpaxistickerdatetime_pickclosest_callback = nullptr;
        qcpaxistickerdatetime_getmantissa_callback = nullptr;
        qcpaxistickerdatetime_cleanmantissa_callback = nullptr;
    }

    // Callback setters
    inline void setQCPAxisTickerDateTime_GetTickStep_Callback(QCPAxisTickerDateTime_GetTickStep_Callback cb) { qcpaxistickerdatetime_gettickstep_callback = cb; }
    inline void setQCPAxisTickerDateTime_GetSubTickCount_Callback(QCPAxisTickerDateTime_GetSubTickCount_Callback cb) { qcpaxistickerdatetime_getsubtickcount_callback = cb; }
    inline void setQCPAxisTickerDateTime_GetTickLabel_Callback(QCPAxisTickerDateTime_GetTickLabel_Callback cb) { qcpaxistickerdatetime_getticklabel_callback = cb; }
    inline void setQCPAxisTickerDateTime_CreateTickVector_Callback(QCPAxisTickerDateTime_CreateTickVector_Callback cb) { qcpaxistickerdatetime_createtickvector_callback = cb; }
    inline void setQCPAxisTickerDateTime_Generate_Callback(QCPAxisTickerDateTime_Generate_Callback cb) { qcpaxistickerdatetime_generate_callback = cb; }
    inline void setQCPAxisTickerDateTime_CreateSubTickVector_Callback(QCPAxisTickerDateTime_CreateSubTickVector_Callback cb) { qcpaxistickerdatetime_createsubtickvector_callback = cb; }
    inline void setQCPAxisTickerDateTime_CreateLabelVector_Callback(QCPAxisTickerDateTime_CreateLabelVector_Callback cb) { qcpaxistickerdatetime_createlabelvector_callback = cb; }
    inline void setQCPAxisTickerDateTime_TrimTicks_Callback(QCPAxisTickerDateTime_TrimTicks_Callback cb) { qcpaxistickerdatetime_trimticks_callback = cb; }
    inline void setQCPAxisTickerDateTime_PickClosest_Callback(QCPAxisTickerDateTime_PickClosest_Callback cb) { qcpaxistickerdatetime_pickclosest_callback = cb; }
    inline void setQCPAxisTickerDateTime_GetMantissa_Callback(QCPAxisTickerDateTime_GetMantissa_Callback cb) { qcpaxistickerdatetime_getmantissa_callback = cb; }
    inline void setQCPAxisTickerDateTime_CleanMantissa_Callback(QCPAxisTickerDateTime_CleanMantissa_Callback cb) { qcpaxistickerdatetime_cleanmantissa_callback = cb; }

    // Base flag setters
    inline void setQCPAxisTickerDateTime_GetTickStep_IsBase(bool value) const { qcpaxistickerdatetime_gettickstep_isbase = value; }
    inline void setQCPAxisTickerDateTime_GetSubTickCount_IsBase(bool value) const { qcpaxistickerdatetime_getsubtickcount_isbase = value; }
    inline void setQCPAxisTickerDateTime_GetTickLabel_IsBase(bool value) const { qcpaxistickerdatetime_getticklabel_isbase = value; }
    inline void setQCPAxisTickerDateTime_CreateTickVector_IsBase(bool value) const { qcpaxistickerdatetime_createtickvector_isbase = value; }
    inline void setQCPAxisTickerDateTime_Generate_IsBase(bool value) const { qcpaxistickerdatetime_generate_isbase = value; }
    inline void setQCPAxisTickerDateTime_CreateSubTickVector_IsBase(bool value) const { qcpaxistickerdatetime_createsubtickvector_isbase = value; }
    inline void setQCPAxisTickerDateTime_CreateLabelVector_IsBase(bool value) const { qcpaxistickerdatetime_createlabelvector_isbase = value; }
    inline void setQCPAxisTickerDateTime_TrimTicks_IsBase(bool value) const { qcpaxistickerdatetime_trimticks_isbase = value; }
    inline void setQCPAxisTickerDateTime_PickClosest_IsBase(bool value) const { qcpaxistickerdatetime_pickclosest_isbase = value; }
    inline void setQCPAxisTickerDateTime_GetMantissa_IsBase(bool value) const { qcpaxistickerdatetime_getmantissa_isbase = value; }
    inline void setQCPAxisTickerDateTime_CleanMantissa_IsBase(bool value) const { qcpaxistickerdatetime_cleanmantissa_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual double getTickStep(const QCPRange& range) override {
        if (qcpaxistickerdatetime_gettickstep_isbase) {
            qcpaxistickerdatetime_gettickstep_isbase = false;
            return QCPAxisTickerDateTime::getTickStep(range);
        } else if (qcpaxistickerdatetime_gettickstep_callback != nullptr) {
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval1 = const_cast<QCPRange*>(&range_ret);

            double callback_ret = qcpaxistickerdatetime_gettickstep_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTickerDateTime::getTickStep(range);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int getSubTickCount(double tickStep) override {
        if (qcpaxistickerdatetime_getsubtickcount_isbase) {
            qcpaxistickerdatetime_getsubtickcount_isbase = false;
            return QCPAxisTickerDateTime::getSubTickCount(tickStep);
        } else if (qcpaxistickerdatetime_getsubtickcount_callback != nullptr) {
            double cbval1 = tickStep;

            int callback_ret = qcpaxistickerdatetime_getsubtickcount_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPAxisTickerDateTime::getSubTickCount(tickStep);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QString getTickLabel(double tick, const QLocale& locale, QChar formatChar, int precision) override {
        if (qcpaxistickerdatetime_getticklabel_isbase) {
            qcpaxistickerdatetime_getticklabel_isbase = false;
            return QCPAxisTickerDateTime::getTickLabel(tick, locale, formatChar, precision);
        } else if (qcpaxistickerdatetime_getticklabel_callback != nullptr) {
            double cbval1 = tick;
            const QLocale& locale_ret = locale;
            // Cast returned reference into pointer
            QLocale* cbval2 = const_cast<QLocale*>(&locale_ret);
            QChar* cbval3 = new QChar(formatChar);
            int cbval4 = precision;

            const char* callback_ret = qcpaxistickerdatetime_getticklabel_callback(this, cbval1, cbval2, cbval3, cbval4);
            QString callback_ret_QString = QString::fromUtf8(callback_ret);
            return callback_ret_QString;
        } else {
            return QCPAxisTickerDateTime::getTickLabel(tick, locale, formatChar, precision);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QVector<double> createTickVector(double tickStep, const QCPRange& range) override {
        if (qcpaxistickerdatetime_createtickvector_isbase) {
            qcpaxistickerdatetime_createtickvector_isbase = false;
            return QCPAxisTickerDateTime::createTickVector(tickStep, range);
        } else if (qcpaxistickerdatetime_createtickvector_callback != nullptr) {
            double cbval1 = tickStep;
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval2 = const_cast<QCPRange*>(&range_ret);

            libqt_list /* of double */ callback_ret = qcpaxistickerdatetime_createtickvector_callback(this, cbval1, cbval2);
            QVector<double> callback_ret_QVector;
            callback_ret_QVector.reserve(callback_ret.len);
            double* callback_ret_arr = static_cast<double*>(callback_ret.data);
            for (size_t i = 0; i < callback_ret.len; ++i) {
                callback_ret_QVector.push_back(static_cast<double>(callback_ret_arr[i]));
            }
            return callback_ret_QVector;
        } else {
            return QCPAxisTickerDateTime::createTickVector(tickStep, range);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void generate(const QCPRange& range, const QLocale& locale, QChar formatChar, int precision, QVector<double>& ticks, QVector<double>* subTicks, QVector<QString>* tickLabels) override {
        if (qcpaxistickerdatetime_generate_isbase) {
            qcpaxistickerdatetime_generate_isbase = false;
            QCPAxisTickerDateTime::generate(range, locale, formatChar, precision, ticks, subTicks, tickLabels);
        } else if (qcpaxistickerdatetime_generate_callback != nullptr) {
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval1 = const_cast<QCPRange*>(&range_ret);
            const QLocale& locale_ret = locale;
            // Cast returned reference into pointer
            QLocale* cbval2 = const_cast<QLocale*>(&locale_ret);
            QChar* cbval3 = new QChar(formatChar);
            int cbval4 = precision;
            QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval5 = ticks_out;
            QVector<double>* subTicks_ret = subTicks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* subTicks_arr = static_cast<double*>(malloc(sizeof(double) * (subTicks_ret->size() + 1)));
            for (qsizetype i = 0; i < subTicks_ret->size(); ++i) {
                subTicks_arr[i] = (*subTicks_ret)[i];
            }
            libqt_list subTicks_out;
            subTicks_out.len = subTicks_ret->size();
            subTicks_out.data = static_cast<void*>(subTicks_arr);
            libqt_list /* of double */ cbval6 = subTicks_out;
            QVector<QString>* tickLabels_ret = tickLabels;
            // Convert QVector<> from C++ memory to manually-managed C memory
            libqt_string* tickLabels_arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (tickLabels_ret->size() + 1)));
            for (qsizetype i = 0; i < tickLabels_ret->size(); ++i) {
                QString tickLabels_vv_ret = (*tickLabels_ret)[i];
                // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
                QByteArray tickLabels_vv_b = tickLabels_vv_ret.toUtf8();
                libqt_string tickLabels_vv_str;
                tickLabels_vv_str.len = tickLabels_vv_b.length();
                tickLabels_vv_str.data = static_cast<const char*>(malloc(tickLabels_vv_str.len + 1));
                memcpy((void*)tickLabels_vv_str.data, tickLabels_vv_b.data(), tickLabels_vv_str.len);
                ((char*)tickLabels_vv_str.data)[tickLabels_vv_str.len] = '\0';
                tickLabels_arr[i] = tickLabels_vv_str;
            }
            libqt_list tickLabels_out;
            tickLabels_out.len = tickLabels_ret->size();
            tickLabels_out.data = static_cast<void*>(tickLabels_arr);
            libqt_list /* of libqt_string */ cbval7 = tickLabels_out;

            qcpaxistickerdatetime_generate_callback(this, cbval1, cbval2, cbval3, cbval4, cbval5, cbval6, cbval7);
        } else {
            QCPAxisTickerDateTime::generate(range, locale, formatChar, precision, ticks, subTicks, tickLabels);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QVector<double> createSubTickVector(int subTickCount, const QVector<double>& ticks) override {
        if (qcpaxistickerdatetime_createsubtickvector_isbase) {
            qcpaxistickerdatetime_createsubtickvector_isbase = false;
            return QCPAxisTickerDateTime::createSubTickVector(subTickCount, ticks);
        } else if (qcpaxistickerdatetime_createsubtickvector_callback != nullptr) {
            int cbval1 = subTickCount;
            const QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval2 = ticks_out;

            libqt_list /* of double */ callback_ret = qcpaxistickerdatetime_createsubtickvector_callback(this, cbval1, cbval2);
            QVector<double> callback_ret_QVector;
            callback_ret_QVector.reserve(callback_ret.len);
            double* callback_ret_arr = static_cast<double*>(callback_ret.data);
            for (size_t i = 0; i < callback_ret.len; ++i) {
                callback_ret_QVector.push_back(static_cast<double>(callback_ret_arr[i]));
            }
            return callback_ret_QVector;
        } else {
            return QCPAxisTickerDateTime::createSubTickVector(subTickCount, ticks);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QVector<QString> createLabelVector(const QVector<double>& ticks, const QLocale& locale, QChar formatChar, int precision) override {
        if (qcpaxistickerdatetime_createlabelvector_isbase) {
            qcpaxistickerdatetime_createlabelvector_isbase = false;
            return QCPAxisTickerDateTime::createLabelVector(ticks, locale, formatChar, precision);
        } else if (qcpaxistickerdatetime_createlabelvector_callback != nullptr) {
            const QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval1 = ticks_out;
            const QLocale& locale_ret = locale;
            // Cast returned reference into pointer
            QLocale* cbval2 = const_cast<QLocale*>(&locale_ret);
            QChar* cbval3 = new QChar(formatChar);
            int cbval4 = precision;

            const char** callback_ret = qcpaxistickerdatetime_createlabelvector_callback(this, cbval1, cbval2, cbval3, cbval4);
            QVector<QString> callback_ret_QVector;
            size_t callback_ret_len = libqt_strv_length(callback_ret);
            callback_ret_QVector.reserve(callback_ret_len);
            const char** callback_ret_arr = static_cast<const char**>(callback_ret);
            for (size_t i = 0; i < callback_ret_len; ++i) {
                QString callback_ret_arr_i_QString = QString::fromUtf8(callback_ret_arr[i]);
                callback_ret_QVector.push_back(callback_ret_arr_i_QString);
            }
            return callback_ret_QVector;
        } else {
            return QCPAxisTickerDateTime::createLabelVector(ticks, locale, formatChar, precision);
        }
    }

    // Virtual method for C ABI access and custom callback
    void trimTicks(const QCPRange& range, QVector<double>& ticks, bool keepOneOutlier) const {
        if (qcpaxistickerdatetime_trimticks_isbase) {
            qcpaxistickerdatetime_trimticks_isbase = false;
            QCPAxisTickerDateTime::trimTicks(range, ticks, keepOneOutlier);
        } else if (qcpaxistickerdatetime_trimticks_callback != nullptr) {
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval1 = const_cast<QCPRange*>(&range_ret);
            QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval2 = ticks_out;
            bool cbval3 = keepOneOutlier;

            qcpaxistickerdatetime_trimticks_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPAxisTickerDateTime::trimTicks(range, ticks, keepOneOutlier);
        }
    }

    // Virtual method for C ABI access and custom callback
    double pickClosest(double target, const QVector<double>& candidates) const {
        if (qcpaxistickerdatetime_pickclosest_isbase) {
            qcpaxistickerdatetime_pickclosest_isbase = false;
            return QCPAxisTickerDateTime::pickClosest(target, candidates);
        } else if (qcpaxistickerdatetime_pickclosest_callback != nullptr) {
            double cbval1 = target;
            const QVector<double>& candidates_ret = candidates;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* candidates_arr = static_cast<double*>(malloc(sizeof(double) * (candidates_ret.size() + 1)));
            for (qsizetype i = 0; i < candidates_ret.size(); ++i) {
                candidates_arr[i] = candidates_ret[i];
            }
            libqt_list candidates_out;
            candidates_out.len = candidates_ret.size();
            candidates_out.data = static_cast<void*>(candidates_arr);
            libqt_list /* of double */ cbval2 = candidates_out;

            double callback_ret = qcpaxistickerdatetime_pickclosest_callback(this, cbval1, cbval2);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTickerDateTime::pickClosest(target, candidates);
        }
    }

    // Virtual method for C ABI access and custom callback
    double getMantissa(double input) const {
        if (qcpaxistickerdatetime_getmantissa_isbase) {
            qcpaxistickerdatetime_getmantissa_isbase = false;
            return QCPAxisTickerDateTime::getMantissa(input);
        } else if (qcpaxistickerdatetime_getmantissa_callback != nullptr) {
            double cbval1 = input;

            double callback_ret = qcpaxistickerdatetime_getmantissa_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTickerDateTime::getMantissa(input);
        }
    }

    // Virtual method for C ABI access and custom callback
    double cleanMantissa(double input) const {
        if (qcpaxistickerdatetime_cleanmantissa_isbase) {
            qcpaxistickerdatetime_cleanmantissa_isbase = false;
            return QCPAxisTickerDateTime::cleanMantissa(input);
        } else if (qcpaxistickerdatetime_cleanmantissa_callback != nullptr) {
            double cbval1 = input;

            double callback_ret = qcpaxistickerdatetime_cleanmantissa_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTickerDateTime::cleanMantissa(input);
        }
    }

    // Friend functions
    friend double QCPAxisTickerDateTime_GetTickStep(QCPAxisTickerDateTime* self, const QCPRange* range);
    friend double QCPAxisTickerDateTime_QBaseGetTickStep(QCPAxisTickerDateTime* self, const QCPRange* range);
    friend int QCPAxisTickerDateTime_GetSubTickCount(QCPAxisTickerDateTime* self, double tickStep);
    friend int QCPAxisTickerDateTime_QBaseGetSubTickCount(QCPAxisTickerDateTime* self, double tickStep);
    friend libqt_string QCPAxisTickerDateTime_GetTickLabel(QCPAxisTickerDateTime* self, double tick, const QLocale* locale, QChar* formatChar, int precision);
    friend libqt_string QCPAxisTickerDateTime_QBaseGetTickLabel(QCPAxisTickerDateTime* self, double tick, const QLocale* locale, QChar* formatChar, int precision);
    friend libqt_list /* of double */ QCPAxisTickerDateTime_CreateTickVector(QCPAxisTickerDateTime* self, double tickStep, const QCPRange* range);
    friend libqt_list /* of double */ QCPAxisTickerDateTime_QBaseCreateTickVector(QCPAxisTickerDateTime* self, double tickStep, const QCPRange* range);
    friend libqt_list /* of double */ QCPAxisTickerDateTime_CreateSubTickVector(QCPAxisTickerDateTime* self, int subTickCount, const libqt_list /* of double */ ticks);
    friend libqt_list /* of double */ QCPAxisTickerDateTime_QBaseCreateSubTickVector(QCPAxisTickerDateTime* self, int subTickCount, const libqt_list /* of double */ ticks);
    friend libqt_list /* of libqt_string */ QCPAxisTickerDateTime_CreateLabelVector(QCPAxisTickerDateTime* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision);
    friend libqt_list /* of libqt_string */ QCPAxisTickerDateTime_QBaseCreateLabelVector(QCPAxisTickerDateTime* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision);
    friend void QCPAxisTickerDateTime_TrimTicks(const QCPAxisTickerDateTime* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier);
    friend void QCPAxisTickerDateTime_QBaseTrimTicks(const QCPAxisTickerDateTime* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier);
    friend double QCPAxisTickerDateTime_PickClosest(const QCPAxisTickerDateTime* self, double target, const libqt_list /* of double */ candidates);
    friend double QCPAxisTickerDateTime_QBasePickClosest(const QCPAxisTickerDateTime* self, double target, const libqt_list /* of double */ candidates);
    friend double QCPAxisTickerDateTime_GetMantissa(const QCPAxisTickerDateTime* self, double input);
    friend double QCPAxisTickerDateTime_QBaseGetMantissa(const QCPAxisTickerDateTime* self, double input);
    friend double QCPAxisTickerDateTime_CleanMantissa(const QCPAxisTickerDateTime* self, double input);
    friend double QCPAxisTickerDateTime_QBaseCleanMantissa(const QCPAxisTickerDateTime* self, double input);
};

// This class is a subclass of QCPAxisTickerTime so that we can call protected methods
class VirtualQCPAxisTickerTime final : public QCPAxisTickerTime {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPAxisTickerTime = true;

    // Virtual class public types (including callbacks)
    using QCPAxisTickerTime_GetTickStep_Callback = double (*)(QCPAxisTickerTime*, QCPRange*);
    using QCPAxisTickerTime_GetSubTickCount_Callback = int (*)(QCPAxisTickerTime*, double);
    using QCPAxisTickerTime_GetTickLabel_Callback = const char* (*)(QCPAxisTickerTime*, double, QLocale*, QChar*, int);
    using QCPAxisTickerTime_Generate_Callback = void (*)(QCPAxisTickerTime*, QCPRange*, QLocale*, QChar*, int, libqt_list /* of double */, libqt_list /* of double */, libqt_list /* of libqt_string */);
    using QCPAxisTickerTime_CreateTickVector_Callback = libqt_list /* of double */ (*)(QCPAxisTickerTime*, double, QCPRange*);
    using QCPAxisTickerTime_CreateSubTickVector_Callback = libqt_list /* of double */ (*)(QCPAxisTickerTime*, int, libqt_list /* of double */);
    using QCPAxisTickerTime_CreateLabelVector_Callback = const char** (*)(QCPAxisTickerTime*, libqt_list /* of double */, QLocale*, QChar*, int);
    using QCPAxisTickerTime_ReplaceUnit_Callback = void (*)(const QCPAxisTickerTime*, libqt_string, int, int);
    using QCPAxisTickerTime_TrimTicks_Callback = void (*)(const QCPAxisTickerTime*, QCPRange*, libqt_list /* of double */, bool);
    using QCPAxisTickerTime_PickClosest_Callback = double (*)(const QCPAxisTickerTime*, double, libqt_list /* of double */);
    using QCPAxisTickerTime_GetMantissa_Callback = double (*)(const QCPAxisTickerTime*, double);
    using QCPAxisTickerTime_CleanMantissa_Callback = double (*)(const QCPAxisTickerTime*, double);

  protected:
    // Instance callback storage
    QCPAxisTickerTime_GetTickStep_Callback qcpaxistickertime_gettickstep_callback = nullptr;
    QCPAxisTickerTime_GetSubTickCount_Callback qcpaxistickertime_getsubtickcount_callback = nullptr;
    QCPAxisTickerTime_GetTickLabel_Callback qcpaxistickertime_getticklabel_callback = nullptr;
    QCPAxisTickerTime_Generate_Callback qcpaxistickertime_generate_callback = nullptr;
    QCPAxisTickerTime_CreateTickVector_Callback qcpaxistickertime_createtickvector_callback = nullptr;
    QCPAxisTickerTime_CreateSubTickVector_Callback qcpaxistickertime_createsubtickvector_callback = nullptr;
    QCPAxisTickerTime_CreateLabelVector_Callback qcpaxistickertime_createlabelvector_callback = nullptr;
    QCPAxisTickerTime_ReplaceUnit_Callback qcpaxistickertime_replaceunit_callback = nullptr;
    QCPAxisTickerTime_TrimTicks_Callback qcpaxistickertime_trimticks_callback = nullptr;
    QCPAxisTickerTime_PickClosest_Callback qcpaxistickertime_pickclosest_callback = nullptr;
    QCPAxisTickerTime_GetMantissa_Callback qcpaxistickertime_getmantissa_callback = nullptr;
    QCPAxisTickerTime_CleanMantissa_Callback qcpaxistickertime_cleanmantissa_callback = nullptr;

    // Instance base flags
    mutable bool qcpaxistickertime_gettickstep_isbase = false;
    mutable bool qcpaxistickertime_getsubtickcount_isbase = false;
    mutable bool qcpaxistickertime_getticklabel_isbase = false;
    mutable bool qcpaxistickertime_generate_isbase = false;
    mutable bool qcpaxistickertime_createtickvector_isbase = false;
    mutable bool qcpaxistickertime_createsubtickvector_isbase = false;
    mutable bool qcpaxistickertime_createlabelvector_isbase = false;
    mutable bool qcpaxistickertime_replaceunit_isbase = false;
    mutable bool qcpaxistickertime_trimticks_isbase = false;
    mutable bool qcpaxistickertime_pickclosest_isbase = false;
    mutable bool qcpaxistickertime_getmantissa_isbase = false;
    mutable bool qcpaxistickertime_cleanmantissa_isbase = false;

  public:
    VirtualQCPAxisTickerTime() : QCPAxisTickerTime() {};

    ~VirtualQCPAxisTickerTime() {
        qcpaxistickertime_gettickstep_callback = nullptr;
        qcpaxistickertime_getsubtickcount_callback = nullptr;
        qcpaxistickertime_getticklabel_callback = nullptr;
        qcpaxistickertime_generate_callback = nullptr;
        qcpaxistickertime_createtickvector_callback = nullptr;
        qcpaxistickertime_createsubtickvector_callback = nullptr;
        qcpaxistickertime_createlabelvector_callback = nullptr;
        qcpaxistickertime_replaceunit_callback = nullptr;
        qcpaxistickertime_trimticks_callback = nullptr;
        qcpaxistickertime_pickclosest_callback = nullptr;
        qcpaxistickertime_getmantissa_callback = nullptr;
        qcpaxistickertime_cleanmantissa_callback = nullptr;
    }

    // Callback setters
    inline void setQCPAxisTickerTime_GetTickStep_Callback(QCPAxisTickerTime_GetTickStep_Callback cb) { qcpaxistickertime_gettickstep_callback = cb; }
    inline void setQCPAxisTickerTime_GetSubTickCount_Callback(QCPAxisTickerTime_GetSubTickCount_Callback cb) { qcpaxistickertime_getsubtickcount_callback = cb; }
    inline void setQCPAxisTickerTime_GetTickLabel_Callback(QCPAxisTickerTime_GetTickLabel_Callback cb) { qcpaxistickertime_getticklabel_callback = cb; }
    inline void setQCPAxisTickerTime_Generate_Callback(QCPAxisTickerTime_Generate_Callback cb) { qcpaxistickertime_generate_callback = cb; }
    inline void setQCPAxisTickerTime_CreateTickVector_Callback(QCPAxisTickerTime_CreateTickVector_Callback cb) { qcpaxistickertime_createtickvector_callback = cb; }
    inline void setQCPAxisTickerTime_CreateSubTickVector_Callback(QCPAxisTickerTime_CreateSubTickVector_Callback cb) { qcpaxistickertime_createsubtickvector_callback = cb; }
    inline void setQCPAxisTickerTime_CreateLabelVector_Callback(QCPAxisTickerTime_CreateLabelVector_Callback cb) { qcpaxistickertime_createlabelvector_callback = cb; }
    inline void setQCPAxisTickerTime_ReplaceUnit_Callback(QCPAxisTickerTime_ReplaceUnit_Callback cb) { qcpaxistickertime_replaceunit_callback = cb; }
    inline void setQCPAxisTickerTime_TrimTicks_Callback(QCPAxisTickerTime_TrimTicks_Callback cb) { qcpaxistickertime_trimticks_callback = cb; }
    inline void setQCPAxisTickerTime_PickClosest_Callback(QCPAxisTickerTime_PickClosest_Callback cb) { qcpaxistickertime_pickclosest_callback = cb; }
    inline void setQCPAxisTickerTime_GetMantissa_Callback(QCPAxisTickerTime_GetMantissa_Callback cb) { qcpaxistickertime_getmantissa_callback = cb; }
    inline void setQCPAxisTickerTime_CleanMantissa_Callback(QCPAxisTickerTime_CleanMantissa_Callback cb) { qcpaxistickertime_cleanmantissa_callback = cb; }

    // Base flag setters
    inline void setQCPAxisTickerTime_GetTickStep_IsBase(bool value) const { qcpaxistickertime_gettickstep_isbase = value; }
    inline void setQCPAxisTickerTime_GetSubTickCount_IsBase(bool value) const { qcpaxistickertime_getsubtickcount_isbase = value; }
    inline void setQCPAxisTickerTime_GetTickLabel_IsBase(bool value) const { qcpaxistickertime_getticklabel_isbase = value; }
    inline void setQCPAxisTickerTime_Generate_IsBase(bool value) const { qcpaxistickertime_generate_isbase = value; }
    inline void setQCPAxisTickerTime_CreateTickVector_IsBase(bool value) const { qcpaxistickertime_createtickvector_isbase = value; }
    inline void setQCPAxisTickerTime_CreateSubTickVector_IsBase(bool value) const { qcpaxistickertime_createsubtickvector_isbase = value; }
    inline void setQCPAxisTickerTime_CreateLabelVector_IsBase(bool value) const { qcpaxistickertime_createlabelvector_isbase = value; }
    inline void setQCPAxisTickerTime_ReplaceUnit_IsBase(bool value) const { qcpaxistickertime_replaceunit_isbase = value; }
    inline void setQCPAxisTickerTime_TrimTicks_IsBase(bool value) const { qcpaxistickertime_trimticks_isbase = value; }
    inline void setQCPAxisTickerTime_PickClosest_IsBase(bool value) const { qcpaxistickertime_pickclosest_isbase = value; }
    inline void setQCPAxisTickerTime_GetMantissa_IsBase(bool value) const { qcpaxistickertime_getmantissa_isbase = value; }
    inline void setQCPAxisTickerTime_CleanMantissa_IsBase(bool value) const { qcpaxistickertime_cleanmantissa_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual double getTickStep(const QCPRange& range) override {
        if (qcpaxistickertime_gettickstep_isbase) {
            qcpaxistickertime_gettickstep_isbase = false;
            return QCPAxisTickerTime::getTickStep(range);
        } else if (qcpaxistickertime_gettickstep_callback != nullptr) {
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval1 = const_cast<QCPRange*>(&range_ret);

            double callback_ret = qcpaxistickertime_gettickstep_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTickerTime::getTickStep(range);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int getSubTickCount(double tickStep) override {
        if (qcpaxistickertime_getsubtickcount_isbase) {
            qcpaxistickertime_getsubtickcount_isbase = false;
            return QCPAxisTickerTime::getSubTickCount(tickStep);
        } else if (qcpaxistickertime_getsubtickcount_callback != nullptr) {
            double cbval1 = tickStep;

            int callback_ret = qcpaxistickertime_getsubtickcount_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPAxisTickerTime::getSubTickCount(tickStep);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QString getTickLabel(double tick, const QLocale& locale, QChar formatChar, int precision) override {
        if (qcpaxistickertime_getticklabel_isbase) {
            qcpaxistickertime_getticklabel_isbase = false;
            return QCPAxisTickerTime::getTickLabel(tick, locale, formatChar, precision);
        } else if (qcpaxistickertime_getticklabel_callback != nullptr) {
            double cbval1 = tick;
            const QLocale& locale_ret = locale;
            // Cast returned reference into pointer
            QLocale* cbval2 = const_cast<QLocale*>(&locale_ret);
            QChar* cbval3 = new QChar(formatChar);
            int cbval4 = precision;

            const char* callback_ret = qcpaxistickertime_getticklabel_callback(this, cbval1, cbval2, cbval3, cbval4);
            QString callback_ret_QString = QString::fromUtf8(callback_ret);
            return callback_ret_QString;
        } else {
            return QCPAxisTickerTime::getTickLabel(tick, locale, formatChar, precision);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void generate(const QCPRange& range, const QLocale& locale, QChar formatChar, int precision, QVector<double>& ticks, QVector<double>* subTicks, QVector<QString>* tickLabels) override {
        if (qcpaxistickertime_generate_isbase) {
            qcpaxistickertime_generate_isbase = false;
            QCPAxisTickerTime::generate(range, locale, formatChar, precision, ticks, subTicks, tickLabels);
        } else if (qcpaxistickertime_generate_callback != nullptr) {
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval1 = const_cast<QCPRange*>(&range_ret);
            const QLocale& locale_ret = locale;
            // Cast returned reference into pointer
            QLocale* cbval2 = const_cast<QLocale*>(&locale_ret);
            QChar* cbval3 = new QChar(formatChar);
            int cbval4 = precision;
            QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval5 = ticks_out;
            QVector<double>* subTicks_ret = subTicks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* subTicks_arr = static_cast<double*>(malloc(sizeof(double) * (subTicks_ret->size() + 1)));
            for (qsizetype i = 0; i < subTicks_ret->size(); ++i) {
                subTicks_arr[i] = (*subTicks_ret)[i];
            }
            libqt_list subTicks_out;
            subTicks_out.len = subTicks_ret->size();
            subTicks_out.data = static_cast<void*>(subTicks_arr);
            libqt_list /* of double */ cbval6 = subTicks_out;
            QVector<QString>* tickLabels_ret = tickLabels;
            // Convert QVector<> from C++ memory to manually-managed C memory
            libqt_string* tickLabels_arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (tickLabels_ret->size() + 1)));
            for (qsizetype i = 0; i < tickLabels_ret->size(); ++i) {
                QString tickLabels_vv_ret = (*tickLabels_ret)[i];
                // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
                QByteArray tickLabels_vv_b = tickLabels_vv_ret.toUtf8();
                libqt_string tickLabels_vv_str;
                tickLabels_vv_str.len = tickLabels_vv_b.length();
                tickLabels_vv_str.data = static_cast<const char*>(malloc(tickLabels_vv_str.len + 1));
                memcpy((void*)tickLabels_vv_str.data, tickLabels_vv_b.data(), tickLabels_vv_str.len);
                ((char*)tickLabels_vv_str.data)[tickLabels_vv_str.len] = '\0';
                tickLabels_arr[i] = tickLabels_vv_str;
            }
            libqt_list tickLabels_out;
            tickLabels_out.len = tickLabels_ret->size();
            tickLabels_out.data = static_cast<void*>(tickLabels_arr);
            libqt_list /* of libqt_string */ cbval7 = tickLabels_out;

            qcpaxistickertime_generate_callback(this, cbval1, cbval2, cbval3, cbval4, cbval5, cbval6, cbval7);
        } else {
            QCPAxisTickerTime::generate(range, locale, formatChar, precision, ticks, subTicks, tickLabels);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QVector<double> createTickVector(double tickStep, const QCPRange& range) override {
        if (qcpaxistickertime_createtickvector_isbase) {
            qcpaxistickertime_createtickvector_isbase = false;
            return QCPAxisTickerTime::createTickVector(tickStep, range);
        } else if (qcpaxistickertime_createtickvector_callback != nullptr) {
            double cbval1 = tickStep;
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval2 = const_cast<QCPRange*>(&range_ret);

            libqt_list /* of double */ callback_ret = qcpaxistickertime_createtickvector_callback(this, cbval1, cbval2);
            QVector<double> callback_ret_QVector;
            callback_ret_QVector.reserve(callback_ret.len);
            double* callback_ret_arr = static_cast<double*>(callback_ret.data);
            for (size_t i = 0; i < callback_ret.len; ++i) {
                callback_ret_QVector.push_back(static_cast<double>(callback_ret_arr[i]));
            }
            return callback_ret_QVector;
        } else {
            return QCPAxisTickerTime::createTickVector(tickStep, range);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QVector<double> createSubTickVector(int subTickCount, const QVector<double>& ticks) override {
        if (qcpaxistickertime_createsubtickvector_isbase) {
            qcpaxistickertime_createsubtickvector_isbase = false;
            return QCPAxisTickerTime::createSubTickVector(subTickCount, ticks);
        } else if (qcpaxistickertime_createsubtickvector_callback != nullptr) {
            int cbval1 = subTickCount;
            const QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval2 = ticks_out;

            libqt_list /* of double */ callback_ret = qcpaxistickertime_createsubtickvector_callback(this, cbval1, cbval2);
            QVector<double> callback_ret_QVector;
            callback_ret_QVector.reserve(callback_ret.len);
            double* callback_ret_arr = static_cast<double*>(callback_ret.data);
            for (size_t i = 0; i < callback_ret.len; ++i) {
                callback_ret_QVector.push_back(static_cast<double>(callback_ret_arr[i]));
            }
            return callback_ret_QVector;
        } else {
            return QCPAxisTickerTime::createSubTickVector(subTickCount, ticks);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QVector<QString> createLabelVector(const QVector<double>& ticks, const QLocale& locale, QChar formatChar, int precision) override {
        if (qcpaxistickertime_createlabelvector_isbase) {
            qcpaxistickertime_createlabelvector_isbase = false;
            return QCPAxisTickerTime::createLabelVector(ticks, locale, formatChar, precision);
        } else if (qcpaxistickertime_createlabelvector_callback != nullptr) {
            const QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval1 = ticks_out;
            const QLocale& locale_ret = locale;
            // Cast returned reference into pointer
            QLocale* cbval2 = const_cast<QLocale*>(&locale_ret);
            QChar* cbval3 = new QChar(formatChar);
            int cbval4 = precision;

            const char** callback_ret = qcpaxistickertime_createlabelvector_callback(this, cbval1, cbval2, cbval3, cbval4);
            QVector<QString> callback_ret_QVector;
            size_t callback_ret_len = libqt_strv_length(callback_ret);
            callback_ret_QVector.reserve(callback_ret_len);
            const char** callback_ret_arr = static_cast<const char**>(callback_ret);
            for (size_t i = 0; i < callback_ret_len; ++i) {
                QString callback_ret_arr_i_QString = QString::fromUtf8(callback_ret_arr[i]);
                callback_ret_QVector.push_back(callback_ret_arr_i_QString);
            }
            return callback_ret_QVector;
        } else {
            return QCPAxisTickerTime::createLabelVector(ticks, locale, formatChar, precision);
        }
    }

    // Virtual method for C ABI access and custom callback
    void replaceUnit(QString& text, QCPAxisTickerTime::TimeUnit unit, int value) const {
        if (qcpaxistickertime_replaceunit_isbase) {
            qcpaxistickertime_replaceunit_isbase = false;
            QCPAxisTickerTime::replaceUnit(text, unit, value);
        } else if (qcpaxistickertime_replaceunit_callback != nullptr) {
            QString text_ret = text;
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray text_b = text_ret.toUtf8();
            libqt_string text_str;
            text_str.len = text_b.length();
            text_str.data = static_cast<const char*>(malloc(text_str.len + 1));
            memcpy((void*)text_str.data, text_b.data(), text_str.len);
            ((char*)text_str.data)[text_str.len] = '\0';
            libqt_string cbval1 = text_str;
            int cbval2 = static_cast<int>(unit);
            int cbval3 = value;

            qcpaxistickertime_replaceunit_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPAxisTickerTime::replaceUnit(text, unit, value);
        }
    }

    // Virtual method for C ABI access and custom callback
    void trimTicks(const QCPRange& range, QVector<double>& ticks, bool keepOneOutlier) const {
        if (qcpaxistickertime_trimticks_isbase) {
            qcpaxistickertime_trimticks_isbase = false;
            QCPAxisTickerTime::trimTicks(range, ticks, keepOneOutlier);
        } else if (qcpaxistickertime_trimticks_callback != nullptr) {
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval1 = const_cast<QCPRange*>(&range_ret);
            QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval2 = ticks_out;
            bool cbval3 = keepOneOutlier;

            qcpaxistickertime_trimticks_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPAxisTickerTime::trimTicks(range, ticks, keepOneOutlier);
        }
    }

    // Virtual method for C ABI access and custom callback
    double pickClosest(double target, const QVector<double>& candidates) const {
        if (qcpaxistickertime_pickclosest_isbase) {
            qcpaxistickertime_pickclosest_isbase = false;
            return QCPAxisTickerTime::pickClosest(target, candidates);
        } else if (qcpaxistickertime_pickclosest_callback != nullptr) {
            double cbval1 = target;
            const QVector<double>& candidates_ret = candidates;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* candidates_arr = static_cast<double*>(malloc(sizeof(double) * (candidates_ret.size() + 1)));
            for (qsizetype i = 0; i < candidates_ret.size(); ++i) {
                candidates_arr[i] = candidates_ret[i];
            }
            libqt_list candidates_out;
            candidates_out.len = candidates_ret.size();
            candidates_out.data = static_cast<void*>(candidates_arr);
            libqt_list /* of double */ cbval2 = candidates_out;

            double callback_ret = qcpaxistickertime_pickclosest_callback(this, cbval1, cbval2);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTickerTime::pickClosest(target, candidates);
        }
    }

    // Virtual method for C ABI access and custom callback
    double getMantissa(double input) const {
        if (qcpaxistickertime_getmantissa_isbase) {
            qcpaxistickertime_getmantissa_isbase = false;
            return QCPAxisTickerTime::getMantissa(input);
        } else if (qcpaxistickertime_getmantissa_callback != nullptr) {
            double cbval1 = input;

            double callback_ret = qcpaxistickertime_getmantissa_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTickerTime::getMantissa(input);
        }
    }

    // Virtual method for C ABI access and custom callback
    double cleanMantissa(double input) const {
        if (qcpaxistickertime_cleanmantissa_isbase) {
            qcpaxistickertime_cleanmantissa_isbase = false;
            return QCPAxisTickerTime::cleanMantissa(input);
        } else if (qcpaxistickertime_cleanmantissa_callback != nullptr) {
            double cbval1 = input;

            double callback_ret = qcpaxistickertime_cleanmantissa_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTickerTime::cleanMantissa(input);
        }
    }

    // Friend functions
    friend double QCPAxisTickerTime_GetTickStep(QCPAxisTickerTime* self, const QCPRange* range);
    friend double QCPAxisTickerTime_QBaseGetTickStep(QCPAxisTickerTime* self, const QCPRange* range);
    friend int QCPAxisTickerTime_GetSubTickCount(QCPAxisTickerTime* self, double tickStep);
    friend int QCPAxisTickerTime_QBaseGetSubTickCount(QCPAxisTickerTime* self, double tickStep);
    friend libqt_string QCPAxisTickerTime_GetTickLabel(QCPAxisTickerTime* self, double tick, const QLocale* locale, QChar* formatChar, int precision);
    friend libqt_string QCPAxisTickerTime_QBaseGetTickLabel(QCPAxisTickerTime* self, double tick, const QLocale* locale, QChar* formatChar, int precision);
    friend libqt_list /* of double */ QCPAxisTickerTime_CreateTickVector(QCPAxisTickerTime* self, double tickStep, const QCPRange* range);
    friend libqt_list /* of double */ QCPAxisTickerTime_QBaseCreateTickVector(QCPAxisTickerTime* self, double tickStep, const QCPRange* range);
    friend libqt_list /* of double */ QCPAxisTickerTime_CreateSubTickVector(QCPAxisTickerTime* self, int subTickCount, const libqt_list /* of double */ ticks);
    friend libqt_list /* of double */ QCPAxisTickerTime_QBaseCreateSubTickVector(QCPAxisTickerTime* self, int subTickCount, const libqt_list /* of double */ ticks);
    friend libqt_list /* of libqt_string */ QCPAxisTickerTime_CreateLabelVector(QCPAxisTickerTime* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision);
    friend libqt_list /* of libqt_string */ QCPAxisTickerTime_QBaseCreateLabelVector(QCPAxisTickerTime* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision);
    friend void QCPAxisTickerTime_ReplaceUnit(const QCPAxisTickerTime* self, libqt_string text, int unit, int value);
    friend void QCPAxisTickerTime_QBaseReplaceUnit(const QCPAxisTickerTime* self, libqt_string text, int unit, int value);
    friend void QCPAxisTickerTime_TrimTicks(const QCPAxisTickerTime* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier);
    friend void QCPAxisTickerTime_QBaseTrimTicks(const QCPAxisTickerTime* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier);
    friend double QCPAxisTickerTime_PickClosest(const QCPAxisTickerTime* self, double target, const libqt_list /* of double */ candidates);
    friend double QCPAxisTickerTime_QBasePickClosest(const QCPAxisTickerTime* self, double target, const libqt_list /* of double */ candidates);
    friend double QCPAxisTickerTime_GetMantissa(const QCPAxisTickerTime* self, double input);
    friend double QCPAxisTickerTime_QBaseGetMantissa(const QCPAxisTickerTime* self, double input);
    friend double QCPAxisTickerTime_CleanMantissa(const QCPAxisTickerTime* self, double input);
    friend double QCPAxisTickerTime_QBaseCleanMantissa(const QCPAxisTickerTime* self, double input);
};

// This class is a subclass of QCPAxisTickerFixed so that we can call protected methods
class VirtualQCPAxisTickerFixed final : public QCPAxisTickerFixed {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPAxisTickerFixed = true;

    // Virtual class public types (including callbacks)
    using QCPAxisTickerFixed_GetTickStep_Callback = double (*)(QCPAxisTickerFixed*, QCPRange*);
    using QCPAxisTickerFixed_Generate_Callback = void (*)(QCPAxisTickerFixed*, QCPRange*, QLocale*, QChar*, int, libqt_list /* of double */, libqt_list /* of double */, libqt_list /* of libqt_string */);
    using QCPAxisTickerFixed_GetSubTickCount_Callback = int (*)(QCPAxisTickerFixed*, double);
    using QCPAxisTickerFixed_GetTickLabel_Callback = const char* (*)(QCPAxisTickerFixed*, double, QLocale*, QChar*, int);
    using QCPAxisTickerFixed_CreateTickVector_Callback = libqt_list /* of double */ (*)(QCPAxisTickerFixed*, double, QCPRange*);
    using QCPAxisTickerFixed_CreateSubTickVector_Callback = libqt_list /* of double */ (*)(QCPAxisTickerFixed*, int, libqt_list /* of double */);
    using QCPAxisTickerFixed_CreateLabelVector_Callback = const char** (*)(QCPAxisTickerFixed*, libqt_list /* of double */, QLocale*, QChar*, int);
    using QCPAxisTickerFixed_TrimTicks_Callback = void (*)(const QCPAxisTickerFixed*, QCPRange*, libqt_list /* of double */, bool);
    using QCPAxisTickerFixed_PickClosest_Callback = double (*)(const QCPAxisTickerFixed*, double, libqt_list /* of double */);
    using QCPAxisTickerFixed_GetMantissa_Callback = double (*)(const QCPAxisTickerFixed*, double);
    using QCPAxisTickerFixed_CleanMantissa_Callback = double (*)(const QCPAxisTickerFixed*, double);

  protected:
    // Instance callback storage
    QCPAxisTickerFixed_GetTickStep_Callback qcpaxistickerfixed_gettickstep_callback = nullptr;
    QCPAxisTickerFixed_Generate_Callback qcpaxistickerfixed_generate_callback = nullptr;
    QCPAxisTickerFixed_GetSubTickCount_Callback qcpaxistickerfixed_getsubtickcount_callback = nullptr;
    QCPAxisTickerFixed_GetTickLabel_Callback qcpaxistickerfixed_getticklabel_callback = nullptr;
    QCPAxisTickerFixed_CreateTickVector_Callback qcpaxistickerfixed_createtickvector_callback = nullptr;
    QCPAxisTickerFixed_CreateSubTickVector_Callback qcpaxistickerfixed_createsubtickvector_callback = nullptr;
    QCPAxisTickerFixed_CreateLabelVector_Callback qcpaxistickerfixed_createlabelvector_callback = nullptr;
    QCPAxisTickerFixed_TrimTicks_Callback qcpaxistickerfixed_trimticks_callback = nullptr;
    QCPAxisTickerFixed_PickClosest_Callback qcpaxistickerfixed_pickclosest_callback = nullptr;
    QCPAxisTickerFixed_GetMantissa_Callback qcpaxistickerfixed_getmantissa_callback = nullptr;
    QCPAxisTickerFixed_CleanMantissa_Callback qcpaxistickerfixed_cleanmantissa_callback = nullptr;

    // Instance base flags
    mutable bool qcpaxistickerfixed_gettickstep_isbase = false;
    mutable bool qcpaxistickerfixed_generate_isbase = false;
    mutable bool qcpaxistickerfixed_getsubtickcount_isbase = false;
    mutable bool qcpaxistickerfixed_getticklabel_isbase = false;
    mutable bool qcpaxistickerfixed_createtickvector_isbase = false;
    mutable bool qcpaxistickerfixed_createsubtickvector_isbase = false;
    mutable bool qcpaxistickerfixed_createlabelvector_isbase = false;
    mutable bool qcpaxistickerfixed_trimticks_isbase = false;
    mutable bool qcpaxistickerfixed_pickclosest_isbase = false;
    mutable bool qcpaxistickerfixed_getmantissa_isbase = false;
    mutable bool qcpaxistickerfixed_cleanmantissa_isbase = false;

  public:
    VirtualQCPAxisTickerFixed() : QCPAxisTickerFixed() {};

    ~VirtualQCPAxisTickerFixed() {
        qcpaxistickerfixed_gettickstep_callback = nullptr;
        qcpaxistickerfixed_generate_callback = nullptr;
        qcpaxistickerfixed_getsubtickcount_callback = nullptr;
        qcpaxistickerfixed_getticklabel_callback = nullptr;
        qcpaxistickerfixed_createtickvector_callback = nullptr;
        qcpaxistickerfixed_createsubtickvector_callback = nullptr;
        qcpaxistickerfixed_createlabelvector_callback = nullptr;
        qcpaxistickerfixed_trimticks_callback = nullptr;
        qcpaxistickerfixed_pickclosest_callback = nullptr;
        qcpaxistickerfixed_getmantissa_callback = nullptr;
        qcpaxistickerfixed_cleanmantissa_callback = nullptr;
    }

    // Callback setters
    inline void setQCPAxisTickerFixed_GetTickStep_Callback(QCPAxisTickerFixed_GetTickStep_Callback cb) { qcpaxistickerfixed_gettickstep_callback = cb; }
    inline void setQCPAxisTickerFixed_Generate_Callback(QCPAxisTickerFixed_Generate_Callback cb) { qcpaxistickerfixed_generate_callback = cb; }
    inline void setQCPAxisTickerFixed_GetSubTickCount_Callback(QCPAxisTickerFixed_GetSubTickCount_Callback cb) { qcpaxistickerfixed_getsubtickcount_callback = cb; }
    inline void setQCPAxisTickerFixed_GetTickLabel_Callback(QCPAxisTickerFixed_GetTickLabel_Callback cb) { qcpaxistickerfixed_getticklabel_callback = cb; }
    inline void setQCPAxisTickerFixed_CreateTickVector_Callback(QCPAxisTickerFixed_CreateTickVector_Callback cb) { qcpaxistickerfixed_createtickvector_callback = cb; }
    inline void setQCPAxisTickerFixed_CreateSubTickVector_Callback(QCPAxisTickerFixed_CreateSubTickVector_Callback cb) { qcpaxistickerfixed_createsubtickvector_callback = cb; }
    inline void setQCPAxisTickerFixed_CreateLabelVector_Callback(QCPAxisTickerFixed_CreateLabelVector_Callback cb) { qcpaxistickerfixed_createlabelvector_callback = cb; }
    inline void setQCPAxisTickerFixed_TrimTicks_Callback(QCPAxisTickerFixed_TrimTicks_Callback cb) { qcpaxistickerfixed_trimticks_callback = cb; }
    inline void setQCPAxisTickerFixed_PickClosest_Callback(QCPAxisTickerFixed_PickClosest_Callback cb) { qcpaxistickerfixed_pickclosest_callback = cb; }
    inline void setQCPAxisTickerFixed_GetMantissa_Callback(QCPAxisTickerFixed_GetMantissa_Callback cb) { qcpaxistickerfixed_getmantissa_callback = cb; }
    inline void setQCPAxisTickerFixed_CleanMantissa_Callback(QCPAxisTickerFixed_CleanMantissa_Callback cb) { qcpaxistickerfixed_cleanmantissa_callback = cb; }

    // Base flag setters
    inline void setQCPAxisTickerFixed_GetTickStep_IsBase(bool value) const { qcpaxistickerfixed_gettickstep_isbase = value; }
    inline void setQCPAxisTickerFixed_Generate_IsBase(bool value) const { qcpaxistickerfixed_generate_isbase = value; }
    inline void setQCPAxisTickerFixed_GetSubTickCount_IsBase(bool value) const { qcpaxistickerfixed_getsubtickcount_isbase = value; }
    inline void setQCPAxisTickerFixed_GetTickLabel_IsBase(bool value) const { qcpaxistickerfixed_getticklabel_isbase = value; }
    inline void setQCPAxisTickerFixed_CreateTickVector_IsBase(bool value) const { qcpaxistickerfixed_createtickvector_isbase = value; }
    inline void setQCPAxisTickerFixed_CreateSubTickVector_IsBase(bool value) const { qcpaxistickerfixed_createsubtickvector_isbase = value; }
    inline void setQCPAxisTickerFixed_CreateLabelVector_IsBase(bool value) const { qcpaxistickerfixed_createlabelvector_isbase = value; }
    inline void setQCPAxisTickerFixed_TrimTicks_IsBase(bool value) const { qcpaxistickerfixed_trimticks_isbase = value; }
    inline void setQCPAxisTickerFixed_PickClosest_IsBase(bool value) const { qcpaxistickerfixed_pickclosest_isbase = value; }
    inline void setQCPAxisTickerFixed_GetMantissa_IsBase(bool value) const { qcpaxistickerfixed_getmantissa_isbase = value; }
    inline void setQCPAxisTickerFixed_CleanMantissa_IsBase(bool value) const { qcpaxistickerfixed_cleanmantissa_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual double getTickStep(const QCPRange& range) override {
        if (qcpaxistickerfixed_gettickstep_isbase) {
            qcpaxistickerfixed_gettickstep_isbase = false;
            return QCPAxisTickerFixed::getTickStep(range);
        } else if (qcpaxistickerfixed_gettickstep_callback != nullptr) {
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval1 = const_cast<QCPRange*>(&range_ret);

            double callback_ret = qcpaxistickerfixed_gettickstep_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTickerFixed::getTickStep(range);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void generate(const QCPRange& range, const QLocale& locale, QChar formatChar, int precision, QVector<double>& ticks, QVector<double>* subTicks, QVector<QString>* tickLabels) override {
        if (qcpaxistickerfixed_generate_isbase) {
            qcpaxistickerfixed_generate_isbase = false;
            QCPAxisTickerFixed::generate(range, locale, formatChar, precision, ticks, subTicks, tickLabels);
        } else if (qcpaxistickerfixed_generate_callback != nullptr) {
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval1 = const_cast<QCPRange*>(&range_ret);
            const QLocale& locale_ret = locale;
            // Cast returned reference into pointer
            QLocale* cbval2 = const_cast<QLocale*>(&locale_ret);
            QChar* cbval3 = new QChar(formatChar);
            int cbval4 = precision;
            QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval5 = ticks_out;
            QVector<double>* subTicks_ret = subTicks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* subTicks_arr = static_cast<double*>(malloc(sizeof(double) * (subTicks_ret->size() + 1)));
            for (qsizetype i = 0; i < subTicks_ret->size(); ++i) {
                subTicks_arr[i] = (*subTicks_ret)[i];
            }
            libqt_list subTicks_out;
            subTicks_out.len = subTicks_ret->size();
            subTicks_out.data = static_cast<void*>(subTicks_arr);
            libqt_list /* of double */ cbval6 = subTicks_out;
            QVector<QString>* tickLabels_ret = tickLabels;
            // Convert QVector<> from C++ memory to manually-managed C memory
            libqt_string* tickLabels_arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (tickLabels_ret->size() + 1)));
            for (qsizetype i = 0; i < tickLabels_ret->size(); ++i) {
                QString tickLabels_vv_ret = (*tickLabels_ret)[i];
                // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
                QByteArray tickLabels_vv_b = tickLabels_vv_ret.toUtf8();
                libqt_string tickLabels_vv_str;
                tickLabels_vv_str.len = tickLabels_vv_b.length();
                tickLabels_vv_str.data = static_cast<const char*>(malloc(tickLabels_vv_str.len + 1));
                memcpy((void*)tickLabels_vv_str.data, tickLabels_vv_b.data(), tickLabels_vv_str.len);
                ((char*)tickLabels_vv_str.data)[tickLabels_vv_str.len] = '\0';
                tickLabels_arr[i] = tickLabels_vv_str;
            }
            libqt_list tickLabels_out;
            tickLabels_out.len = tickLabels_ret->size();
            tickLabels_out.data = static_cast<void*>(tickLabels_arr);
            libqt_list /* of libqt_string */ cbval7 = tickLabels_out;

            qcpaxistickerfixed_generate_callback(this, cbval1, cbval2, cbval3, cbval4, cbval5, cbval6, cbval7);
        } else {
            QCPAxisTickerFixed::generate(range, locale, formatChar, precision, ticks, subTicks, tickLabels);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int getSubTickCount(double tickStep) override {
        if (qcpaxistickerfixed_getsubtickcount_isbase) {
            qcpaxistickerfixed_getsubtickcount_isbase = false;
            return QCPAxisTickerFixed::getSubTickCount(tickStep);
        } else if (qcpaxistickerfixed_getsubtickcount_callback != nullptr) {
            double cbval1 = tickStep;

            int callback_ret = qcpaxistickerfixed_getsubtickcount_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPAxisTickerFixed::getSubTickCount(tickStep);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QString getTickLabel(double tick, const QLocale& locale, QChar formatChar, int precision) override {
        if (qcpaxistickerfixed_getticklabel_isbase) {
            qcpaxistickerfixed_getticklabel_isbase = false;
            return QCPAxisTickerFixed::getTickLabel(tick, locale, formatChar, precision);
        } else if (qcpaxistickerfixed_getticklabel_callback != nullptr) {
            double cbval1 = tick;
            const QLocale& locale_ret = locale;
            // Cast returned reference into pointer
            QLocale* cbval2 = const_cast<QLocale*>(&locale_ret);
            QChar* cbval3 = new QChar(formatChar);
            int cbval4 = precision;

            const char* callback_ret = qcpaxistickerfixed_getticklabel_callback(this, cbval1, cbval2, cbval3, cbval4);
            QString callback_ret_QString = QString::fromUtf8(callback_ret);
            return callback_ret_QString;
        } else {
            return QCPAxisTickerFixed::getTickLabel(tick, locale, formatChar, precision);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QVector<double> createTickVector(double tickStep, const QCPRange& range) override {
        if (qcpaxistickerfixed_createtickvector_isbase) {
            qcpaxistickerfixed_createtickvector_isbase = false;
            return QCPAxisTickerFixed::createTickVector(tickStep, range);
        } else if (qcpaxistickerfixed_createtickvector_callback != nullptr) {
            double cbval1 = tickStep;
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval2 = const_cast<QCPRange*>(&range_ret);

            libqt_list /* of double */ callback_ret = qcpaxistickerfixed_createtickvector_callback(this, cbval1, cbval2);
            QVector<double> callback_ret_QVector;
            callback_ret_QVector.reserve(callback_ret.len);
            double* callback_ret_arr = static_cast<double*>(callback_ret.data);
            for (size_t i = 0; i < callback_ret.len; ++i) {
                callback_ret_QVector.push_back(static_cast<double>(callback_ret_arr[i]));
            }
            return callback_ret_QVector;
        } else {
            return QCPAxisTickerFixed::createTickVector(tickStep, range);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QVector<double> createSubTickVector(int subTickCount, const QVector<double>& ticks) override {
        if (qcpaxistickerfixed_createsubtickvector_isbase) {
            qcpaxistickerfixed_createsubtickvector_isbase = false;
            return QCPAxisTickerFixed::createSubTickVector(subTickCount, ticks);
        } else if (qcpaxistickerfixed_createsubtickvector_callback != nullptr) {
            int cbval1 = subTickCount;
            const QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval2 = ticks_out;

            libqt_list /* of double */ callback_ret = qcpaxistickerfixed_createsubtickvector_callback(this, cbval1, cbval2);
            QVector<double> callback_ret_QVector;
            callback_ret_QVector.reserve(callback_ret.len);
            double* callback_ret_arr = static_cast<double*>(callback_ret.data);
            for (size_t i = 0; i < callback_ret.len; ++i) {
                callback_ret_QVector.push_back(static_cast<double>(callback_ret_arr[i]));
            }
            return callback_ret_QVector;
        } else {
            return QCPAxisTickerFixed::createSubTickVector(subTickCount, ticks);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QVector<QString> createLabelVector(const QVector<double>& ticks, const QLocale& locale, QChar formatChar, int precision) override {
        if (qcpaxistickerfixed_createlabelvector_isbase) {
            qcpaxistickerfixed_createlabelvector_isbase = false;
            return QCPAxisTickerFixed::createLabelVector(ticks, locale, formatChar, precision);
        } else if (qcpaxistickerfixed_createlabelvector_callback != nullptr) {
            const QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval1 = ticks_out;
            const QLocale& locale_ret = locale;
            // Cast returned reference into pointer
            QLocale* cbval2 = const_cast<QLocale*>(&locale_ret);
            QChar* cbval3 = new QChar(formatChar);
            int cbval4 = precision;

            const char** callback_ret = qcpaxistickerfixed_createlabelvector_callback(this, cbval1, cbval2, cbval3, cbval4);
            QVector<QString> callback_ret_QVector;
            size_t callback_ret_len = libqt_strv_length(callback_ret);
            callback_ret_QVector.reserve(callback_ret_len);
            const char** callback_ret_arr = static_cast<const char**>(callback_ret);
            for (size_t i = 0; i < callback_ret_len; ++i) {
                QString callback_ret_arr_i_QString = QString::fromUtf8(callback_ret_arr[i]);
                callback_ret_QVector.push_back(callback_ret_arr_i_QString);
            }
            return callback_ret_QVector;
        } else {
            return QCPAxisTickerFixed::createLabelVector(ticks, locale, formatChar, precision);
        }
    }

    // Virtual method for C ABI access and custom callback
    void trimTicks(const QCPRange& range, QVector<double>& ticks, bool keepOneOutlier) const {
        if (qcpaxistickerfixed_trimticks_isbase) {
            qcpaxistickerfixed_trimticks_isbase = false;
            QCPAxisTickerFixed::trimTicks(range, ticks, keepOneOutlier);
        } else if (qcpaxistickerfixed_trimticks_callback != nullptr) {
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval1 = const_cast<QCPRange*>(&range_ret);
            QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval2 = ticks_out;
            bool cbval3 = keepOneOutlier;

            qcpaxistickerfixed_trimticks_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPAxisTickerFixed::trimTicks(range, ticks, keepOneOutlier);
        }
    }

    // Virtual method for C ABI access and custom callback
    double pickClosest(double target, const QVector<double>& candidates) const {
        if (qcpaxistickerfixed_pickclosest_isbase) {
            qcpaxistickerfixed_pickclosest_isbase = false;
            return QCPAxisTickerFixed::pickClosest(target, candidates);
        } else if (qcpaxistickerfixed_pickclosest_callback != nullptr) {
            double cbval1 = target;
            const QVector<double>& candidates_ret = candidates;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* candidates_arr = static_cast<double*>(malloc(sizeof(double) * (candidates_ret.size() + 1)));
            for (qsizetype i = 0; i < candidates_ret.size(); ++i) {
                candidates_arr[i] = candidates_ret[i];
            }
            libqt_list candidates_out;
            candidates_out.len = candidates_ret.size();
            candidates_out.data = static_cast<void*>(candidates_arr);
            libqt_list /* of double */ cbval2 = candidates_out;

            double callback_ret = qcpaxistickerfixed_pickclosest_callback(this, cbval1, cbval2);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTickerFixed::pickClosest(target, candidates);
        }
    }

    // Virtual method for C ABI access and custom callback
    double getMantissa(double input) const {
        if (qcpaxistickerfixed_getmantissa_isbase) {
            qcpaxistickerfixed_getmantissa_isbase = false;
            return QCPAxisTickerFixed::getMantissa(input);
        } else if (qcpaxistickerfixed_getmantissa_callback != nullptr) {
            double cbval1 = input;

            double callback_ret = qcpaxistickerfixed_getmantissa_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTickerFixed::getMantissa(input);
        }
    }

    // Virtual method for C ABI access and custom callback
    double cleanMantissa(double input) const {
        if (qcpaxistickerfixed_cleanmantissa_isbase) {
            qcpaxistickerfixed_cleanmantissa_isbase = false;
            return QCPAxisTickerFixed::cleanMantissa(input);
        } else if (qcpaxistickerfixed_cleanmantissa_callback != nullptr) {
            double cbval1 = input;

            double callback_ret = qcpaxistickerfixed_cleanmantissa_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTickerFixed::cleanMantissa(input);
        }
    }

    // Friend functions
    friend double QCPAxisTickerFixed_GetTickStep(QCPAxisTickerFixed* self, const QCPRange* range);
    friend double QCPAxisTickerFixed_QBaseGetTickStep(QCPAxisTickerFixed* self, const QCPRange* range);
    friend int QCPAxisTickerFixed_GetSubTickCount(QCPAxisTickerFixed* self, double tickStep);
    friend int QCPAxisTickerFixed_QBaseGetSubTickCount(QCPAxisTickerFixed* self, double tickStep);
    friend libqt_string QCPAxisTickerFixed_GetTickLabel(QCPAxisTickerFixed* self, double tick, const QLocale* locale, QChar* formatChar, int precision);
    friend libqt_string QCPAxisTickerFixed_QBaseGetTickLabel(QCPAxisTickerFixed* self, double tick, const QLocale* locale, QChar* formatChar, int precision);
    friend libqt_list /* of double */ QCPAxisTickerFixed_CreateTickVector(QCPAxisTickerFixed* self, double tickStep, const QCPRange* range);
    friend libqt_list /* of double */ QCPAxisTickerFixed_QBaseCreateTickVector(QCPAxisTickerFixed* self, double tickStep, const QCPRange* range);
    friend libqt_list /* of double */ QCPAxisTickerFixed_CreateSubTickVector(QCPAxisTickerFixed* self, int subTickCount, const libqt_list /* of double */ ticks);
    friend libqt_list /* of double */ QCPAxisTickerFixed_QBaseCreateSubTickVector(QCPAxisTickerFixed* self, int subTickCount, const libqt_list /* of double */ ticks);
    friend libqt_list /* of libqt_string */ QCPAxisTickerFixed_CreateLabelVector(QCPAxisTickerFixed* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision);
    friend libqt_list /* of libqt_string */ QCPAxisTickerFixed_QBaseCreateLabelVector(QCPAxisTickerFixed* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision);
    friend void QCPAxisTickerFixed_TrimTicks(const QCPAxisTickerFixed* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier);
    friend void QCPAxisTickerFixed_QBaseTrimTicks(const QCPAxisTickerFixed* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier);
    friend double QCPAxisTickerFixed_PickClosest(const QCPAxisTickerFixed* self, double target, const libqt_list /* of double */ candidates);
    friend double QCPAxisTickerFixed_QBasePickClosest(const QCPAxisTickerFixed* self, double target, const libqt_list /* of double */ candidates);
    friend double QCPAxisTickerFixed_GetMantissa(const QCPAxisTickerFixed* self, double input);
    friend double QCPAxisTickerFixed_QBaseGetMantissa(const QCPAxisTickerFixed* self, double input);
    friend double QCPAxisTickerFixed_CleanMantissa(const QCPAxisTickerFixed* self, double input);
    friend double QCPAxisTickerFixed_QBaseCleanMantissa(const QCPAxisTickerFixed* self, double input);
};

// This class is a subclass of QCPAxisTickerText so that we can call protected methods
class VirtualQCPAxisTickerText final : public QCPAxisTickerText {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPAxisTickerText = true;

    // Virtual class public types (including callbacks)
    using QCPAxisTickerText_GetTickStep_Callback = double (*)(QCPAxisTickerText*, QCPRange*);
    using QCPAxisTickerText_GetSubTickCount_Callback = int (*)(QCPAxisTickerText*, double);
    using QCPAxisTickerText_GetTickLabel_Callback = const char* (*)(QCPAxisTickerText*, double, QLocale*, QChar*, int);
    using QCPAxisTickerText_CreateTickVector_Callback = libqt_list /* of double */ (*)(QCPAxisTickerText*, double, QCPRange*);
    using QCPAxisTickerText_Generate_Callback = void (*)(QCPAxisTickerText*, QCPRange*, QLocale*, QChar*, int, libqt_list /* of double */, libqt_list /* of double */, libqt_list /* of libqt_string */);
    using QCPAxisTickerText_CreateSubTickVector_Callback = libqt_list /* of double */ (*)(QCPAxisTickerText*, int, libqt_list /* of double */);
    using QCPAxisTickerText_CreateLabelVector_Callback = const char** (*)(QCPAxisTickerText*, libqt_list /* of double */, QLocale*, QChar*, int);
    using QCPAxisTickerText_TrimTicks_Callback = void (*)(const QCPAxisTickerText*, QCPRange*, libqt_list /* of double */, bool);
    using QCPAxisTickerText_PickClosest_Callback = double (*)(const QCPAxisTickerText*, double, libqt_list /* of double */);
    using QCPAxisTickerText_GetMantissa_Callback = double (*)(const QCPAxisTickerText*, double);
    using QCPAxisTickerText_CleanMantissa_Callback = double (*)(const QCPAxisTickerText*, double);

  protected:
    // Instance callback storage
    QCPAxisTickerText_GetTickStep_Callback qcpaxistickertext_gettickstep_callback = nullptr;
    QCPAxisTickerText_GetSubTickCount_Callback qcpaxistickertext_getsubtickcount_callback = nullptr;
    QCPAxisTickerText_GetTickLabel_Callback qcpaxistickertext_getticklabel_callback = nullptr;
    QCPAxisTickerText_CreateTickVector_Callback qcpaxistickertext_createtickvector_callback = nullptr;
    QCPAxisTickerText_Generate_Callback qcpaxistickertext_generate_callback = nullptr;
    QCPAxisTickerText_CreateSubTickVector_Callback qcpaxistickertext_createsubtickvector_callback = nullptr;
    QCPAxisTickerText_CreateLabelVector_Callback qcpaxistickertext_createlabelvector_callback = nullptr;
    QCPAxisTickerText_TrimTicks_Callback qcpaxistickertext_trimticks_callback = nullptr;
    QCPAxisTickerText_PickClosest_Callback qcpaxistickertext_pickclosest_callback = nullptr;
    QCPAxisTickerText_GetMantissa_Callback qcpaxistickertext_getmantissa_callback = nullptr;
    QCPAxisTickerText_CleanMantissa_Callback qcpaxistickertext_cleanmantissa_callback = nullptr;

    // Instance base flags
    mutable bool qcpaxistickertext_gettickstep_isbase = false;
    mutable bool qcpaxistickertext_getsubtickcount_isbase = false;
    mutable bool qcpaxistickertext_getticklabel_isbase = false;
    mutable bool qcpaxistickertext_createtickvector_isbase = false;
    mutable bool qcpaxistickertext_generate_isbase = false;
    mutable bool qcpaxistickertext_createsubtickvector_isbase = false;
    mutable bool qcpaxistickertext_createlabelvector_isbase = false;
    mutable bool qcpaxistickertext_trimticks_isbase = false;
    mutable bool qcpaxistickertext_pickclosest_isbase = false;
    mutable bool qcpaxistickertext_getmantissa_isbase = false;
    mutable bool qcpaxistickertext_cleanmantissa_isbase = false;

  public:
    VirtualQCPAxisTickerText() : QCPAxisTickerText() {};

    ~VirtualQCPAxisTickerText() {
        qcpaxistickertext_gettickstep_callback = nullptr;
        qcpaxistickertext_getsubtickcount_callback = nullptr;
        qcpaxistickertext_getticklabel_callback = nullptr;
        qcpaxistickertext_createtickvector_callback = nullptr;
        qcpaxistickertext_generate_callback = nullptr;
        qcpaxistickertext_createsubtickvector_callback = nullptr;
        qcpaxistickertext_createlabelvector_callback = nullptr;
        qcpaxistickertext_trimticks_callback = nullptr;
        qcpaxistickertext_pickclosest_callback = nullptr;
        qcpaxistickertext_getmantissa_callback = nullptr;
        qcpaxistickertext_cleanmantissa_callback = nullptr;
    }

    // Callback setters
    inline void setQCPAxisTickerText_GetTickStep_Callback(QCPAxisTickerText_GetTickStep_Callback cb) { qcpaxistickertext_gettickstep_callback = cb; }
    inline void setQCPAxisTickerText_GetSubTickCount_Callback(QCPAxisTickerText_GetSubTickCount_Callback cb) { qcpaxistickertext_getsubtickcount_callback = cb; }
    inline void setQCPAxisTickerText_GetTickLabel_Callback(QCPAxisTickerText_GetTickLabel_Callback cb) { qcpaxistickertext_getticklabel_callback = cb; }
    inline void setQCPAxisTickerText_CreateTickVector_Callback(QCPAxisTickerText_CreateTickVector_Callback cb) { qcpaxistickertext_createtickvector_callback = cb; }
    inline void setQCPAxisTickerText_Generate_Callback(QCPAxisTickerText_Generate_Callback cb) { qcpaxistickertext_generate_callback = cb; }
    inline void setQCPAxisTickerText_CreateSubTickVector_Callback(QCPAxisTickerText_CreateSubTickVector_Callback cb) { qcpaxistickertext_createsubtickvector_callback = cb; }
    inline void setQCPAxisTickerText_CreateLabelVector_Callback(QCPAxisTickerText_CreateLabelVector_Callback cb) { qcpaxistickertext_createlabelvector_callback = cb; }
    inline void setQCPAxisTickerText_TrimTicks_Callback(QCPAxisTickerText_TrimTicks_Callback cb) { qcpaxistickertext_trimticks_callback = cb; }
    inline void setQCPAxisTickerText_PickClosest_Callback(QCPAxisTickerText_PickClosest_Callback cb) { qcpaxistickertext_pickclosest_callback = cb; }
    inline void setQCPAxisTickerText_GetMantissa_Callback(QCPAxisTickerText_GetMantissa_Callback cb) { qcpaxistickertext_getmantissa_callback = cb; }
    inline void setQCPAxisTickerText_CleanMantissa_Callback(QCPAxisTickerText_CleanMantissa_Callback cb) { qcpaxistickertext_cleanmantissa_callback = cb; }

    // Base flag setters
    inline void setQCPAxisTickerText_GetTickStep_IsBase(bool value) const { qcpaxistickertext_gettickstep_isbase = value; }
    inline void setQCPAxisTickerText_GetSubTickCount_IsBase(bool value) const { qcpaxistickertext_getsubtickcount_isbase = value; }
    inline void setQCPAxisTickerText_GetTickLabel_IsBase(bool value) const { qcpaxistickertext_getticklabel_isbase = value; }
    inline void setQCPAxisTickerText_CreateTickVector_IsBase(bool value) const { qcpaxistickertext_createtickvector_isbase = value; }
    inline void setQCPAxisTickerText_Generate_IsBase(bool value) const { qcpaxistickertext_generate_isbase = value; }
    inline void setQCPAxisTickerText_CreateSubTickVector_IsBase(bool value) const { qcpaxistickertext_createsubtickvector_isbase = value; }
    inline void setQCPAxisTickerText_CreateLabelVector_IsBase(bool value) const { qcpaxistickertext_createlabelvector_isbase = value; }
    inline void setQCPAxisTickerText_TrimTicks_IsBase(bool value) const { qcpaxistickertext_trimticks_isbase = value; }
    inline void setQCPAxisTickerText_PickClosest_IsBase(bool value) const { qcpaxistickertext_pickclosest_isbase = value; }
    inline void setQCPAxisTickerText_GetMantissa_IsBase(bool value) const { qcpaxistickertext_getmantissa_isbase = value; }
    inline void setQCPAxisTickerText_CleanMantissa_IsBase(bool value) const { qcpaxistickertext_cleanmantissa_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual double getTickStep(const QCPRange& range) override {
        if (qcpaxistickertext_gettickstep_isbase) {
            qcpaxistickertext_gettickstep_isbase = false;
            return QCPAxisTickerText::getTickStep(range);
        } else if (qcpaxistickertext_gettickstep_callback != nullptr) {
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval1 = const_cast<QCPRange*>(&range_ret);

            double callback_ret = qcpaxistickertext_gettickstep_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTickerText::getTickStep(range);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int getSubTickCount(double tickStep) override {
        if (qcpaxistickertext_getsubtickcount_isbase) {
            qcpaxistickertext_getsubtickcount_isbase = false;
            return QCPAxisTickerText::getSubTickCount(tickStep);
        } else if (qcpaxistickertext_getsubtickcount_callback != nullptr) {
            double cbval1 = tickStep;

            int callback_ret = qcpaxistickertext_getsubtickcount_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPAxisTickerText::getSubTickCount(tickStep);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QString getTickLabel(double tick, const QLocale& locale, QChar formatChar, int precision) override {
        if (qcpaxistickertext_getticklabel_isbase) {
            qcpaxistickertext_getticklabel_isbase = false;
            return QCPAxisTickerText::getTickLabel(tick, locale, formatChar, precision);
        } else if (qcpaxistickertext_getticklabel_callback != nullptr) {
            double cbval1 = tick;
            const QLocale& locale_ret = locale;
            // Cast returned reference into pointer
            QLocale* cbval2 = const_cast<QLocale*>(&locale_ret);
            QChar* cbval3 = new QChar(formatChar);
            int cbval4 = precision;

            const char* callback_ret = qcpaxistickertext_getticklabel_callback(this, cbval1, cbval2, cbval3, cbval4);
            QString callback_ret_QString = QString::fromUtf8(callback_ret);
            return callback_ret_QString;
        } else {
            return QCPAxisTickerText::getTickLabel(tick, locale, formatChar, precision);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QVector<double> createTickVector(double tickStep, const QCPRange& range) override {
        if (qcpaxistickertext_createtickvector_isbase) {
            qcpaxistickertext_createtickvector_isbase = false;
            return QCPAxisTickerText::createTickVector(tickStep, range);
        } else if (qcpaxistickertext_createtickvector_callback != nullptr) {
            double cbval1 = tickStep;
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval2 = const_cast<QCPRange*>(&range_ret);

            libqt_list /* of double */ callback_ret = qcpaxistickertext_createtickvector_callback(this, cbval1, cbval2);
            QVector<double> callback_ret_QVector;
            callback_ret_QVector.reserve(callback_ret.len);
            double* callback_ret_arr = static_cast<double*>(callback_ret.data);
            for (size_t i = 0; i < callback_ret.len; ++i) {
                callback_ret_QVector.push_back(static_cast<double>(callback_ret_arr[i]));
            }
            return callback_ret_QVector;
        } else {
            return QCPAxisTickerText::createTickVector(tickStep, range);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void generate(const QCPRange& range, const QLocale& locale, QChar formatChar, int precision, QVector<double>& ticks, QVector<double>* subTicks, QVector<QString>* tickLabels) override {
        if (qcpaxistickertext_generate_isbase) {
            qcpaxistickertext_generate_isbase = false;
            QCPAxisTickerText::generate(range, locale, formatChar, precision, ticks, subTicks, tickLabels);
        } else if (qcpaxistickertext_generate_callback != nullptr) {
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval1 = const_cast<QCPRange*>(&range_ret);
            const QLocale& locale_ret = locale;
            // Cast returned reference into pointer
            QLocale* cbval2 = const_cast<QLocale*>(&locale_ret);
            QChar* cbval3 = new QChar(formatChar);
            int cbval4 = precision;
            QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval5 = ticks_out;
            QVector<double>* subTicks_ret = subTicks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* subTicks_arr = static_cast<double*>(malloc(sizeof(double) * (subTicks_ret->size() + 1)));
            for (qsizetype i = 0; i < subTicks_ret->size(); ++i) {
                subTicks_arr[i] = (*subTicks_ret)[i];
            }
            libqt_list subTicks_out;
            subTicks_out.len = subTicks_ret->size();
            subTicks_out.data = static_cast<void*>(subTicks_arr);
            libqt_list /* of double */ cbval6 = subTicks_out;
            QVector<QString>* tickLabels_ret = tickLabels;
            // Convert QVector<> from C++ memory to manually-managed C memory
            libqt_string* tickLabels_arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (tickLabels_ret->size() + 1)));
            for (qsizetype i = 0; i < tickLabels_ret->size(); ++i) {
                QString tickLabels_vv_ret = (*tickLabels_ret)[i];
                // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
                QByteArray tickLabels_vv_b = tickLabels_vv_ret.toUtf8();
                libqt_string tickLabels_vv_str;
                tickLabels_vv_str.len = tickLabels_vv_b.length();
                tickLabels_vv_str.data = static_cast<const char*>(malloc(tickLabels_vv_str.len + 1));
                memcpy((void*)tickLabels_vv_str.data, tickLabels_vv_b.data(), tickLabels_vv_str.len);
                ((char*)tickLabels_vv_str.data)[tickLabels_vv_str.len] = '\0';
                tickLabels_arr[i] = tickLabels_vv_str;
            }
            libqt_list tickLabels_out;
            tickLabels_out.len = tickLabels_ret->size();
            tickLabels_out.data = static_cast<void*>(tickLabels_arr);
            libqt_list /* of libqt_string */ cbval7 = tickLabels_out;

            qcpaxistickertext_generate_callback(this, cbval1, cbval2, cbval3, cbval4, cbval5, cbval6, cbval7);
        } else {
            QCPAxisTickerText::generate(range, locale, formatChar, precision, ticks, subTicks, tickLabels);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QVector<double> createSubTickVector(int subTickCount, const QVector<double>& ticks) override {
        if (qcpaxistickertext_createsubtickvector_isbase) {
            qcpaxistickertext_createsubtickvector_isbase = false;
            return QCPAxisTickerText::createSubTickVector(subTickCount, ticks);
        } else if (qcpaxistickertext_createsubtickvector_callback != nullptr) {
            int cbval1 = subTickCount;
            const QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval2 = ticks_out;

            libqt_list /* of double */ callback_ret = qcpaxistickertext_createsubtickvector_callback(this, cbval1, cbval2);
            QVector<double> callback_ret_QVector;
            callback_ret_QVector.reserve(callback_ret.len);
            double* callback_ret_arr = static_cast<double*>(callback_ret.data);
            for (size_t i = 0; i < callback_ret.len; ++i) {
                callback_ret_QVector.push_back(static_cast<double>(callback_ret_arr[i]));
            }
            return callback_ret_QVector;
        } else {
            return QCPAxisTickerText::createSubTickVector(subTickCount, ticks);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QVector<QString> createLabelVector(const QVector<double>& ticks, const QLocale& locale, QChar formatChar, int precision) override {
        if (qcpaxistickertext_createlabelvector_isbase) {
            qcpaxistickertext_createlabelvector_isbase = false;
            return QCPAxisTickerText::createLabelVector(ticks, locale, formatChar, precision);
        } else if (qcpaxistickertext_createlabelvector_callback != nullptr) {
            const QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval1 = ticks_out;
            const QLocale& locale_ret = locale;
            // Cast returned reference into pointer
            QLocale* cbval2 = const_cast<QLocale*>(&locale_ret);
            QChar* cbval3 = new QChar(formatChar);
            int cbval4 = precision;

            const char** callback_ret = qcpaxistickertext_createlabelvector_callback(this, cbval1, cbval2, cbval3, cbval4);
            QVector<QString> callback_ret_QVector;
            size_t callback_ret_len = libqt_strv_length(callback_ret);
            callback_ret_QVector.reserve(callback_ret_len);
            const char** callback_ret_arr = static_cast<const char**>(callback_ret);
            for (size_t i = 0; i < callback_ret_len; ++i) {
                QString callback_ret_arr_i_QString = QString::fromUtf8(callback_ret_arr[i]);
                callback_ret_QVector.push_back(callback_ret_arr_i_QString);
            }
            return callback_ret_QVector;
        } else {
            return QCPAxisTickerText::createLabelVector(ticks, locale, formatChar, precision);
        }
    }

    // Virtual method for C ABI access and custom callback
    void trimTicks(const QCPRange& range, QVector<double>& ticks, bool keepOneOutlier) const {
        if (qcpaxistickertext_trimticks_isbase) {
            qcpaxistickertext_trimticks_isbase = false;
            QCPAxisTickerText::trimTicks(range, ticks, keepOneOutlier);
        } else if (qcpaxistickertext_trimticks_callback != nullptr) {
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval1 = const_cast<QCPRange*>(&range_ret);
            QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval2 = ticks_out;
            bool cbval3 = keepOneOutlier;

            qcpaxistickertext_trimticks_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPAxisTickerText::trimTicks(range, ticks, keepOneOutlier);
        }
    }

    // Virtual method for C ABI access and custom callback
    double pickClosest(double target, const QVector<double>& candidates) const {
        if (qcpaxistickertext_pickclosest_isbase) {
            qcpaxistickertext_pickclosest_isbase = false;
            return QCPAxisTickerText::pickClosest(target, candidates);
        } else if (qcpaxistickertext_pickclosest_callback != nullptr) {
            double cbval1 = target;
            const QVector<double>& candidates_ret = candidates;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* candidates_arr = static_cast<double*>(malloc(sizeof(double) * (candidates_ret.size() + 1)));
            for (qsizetype i = 0; i < candidates_ret.size(); ++i) {
                candidates_arr[i] = candidates_ret[i];
            }
            libqt_list candidates_out;
            candidates_out.len = candidates_ret.size();
            candidates_out.data = static_cast<void*>(candidates_arr);
            libqt_list /* of double */ cbval2 = candidates_out;

            double callback_ret = qcpaxistickertext_pickclosest_callback(this, cbval1, cbval2);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTickerText::pickClosest(target, candidates);
        }
    }

    // Virtual method for C ABI access and custom callback
    double getMantissa(double input) const {
        if (qcpaxistickertext_getmantissa_isbase) {
            qcpaxistickertext_getmantissa_isbase = false;
            return QCPAxisTickerText::getMantissa(input);
        } else if (qcpaxistickertext_getmantissa_callback != nullptr) {
            double cbval1 = input;

            double callback_ret = qcpaxistickertext_getmantissa_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTickerText::getMantissa(input);
        }
    }

    // Virtual method for C ABI access and custom callback
    double cleanMantissa(double input) const {
        if (qcpaxistickertext_cleanmantissa_isbase) {
            qcpaxistickertext_cleanmantissa_isbase = false;
            return QCPAxisTickerText::cleanMantissa(input);
        } else if (qcpaxistickertext_cleanmantissa_callback != nullptr) {
            double cbval1 = input;

            double callback_ret = qcpaxistickertext_cleanmantissa_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTickerText::cleanMantissa(input);
        }
    }

    // Friend functions
    friend double QCPAxisTickerText_GetTickStep(QCPAxisTickerText* self, const QCPRange* range);
    friend double QCPAxisTickerText_QBaseGetTickStep(QCPAxisTickerText* self, const QCPRange* range);
    friend int QCPAxisTickerText_GetSubTickCount(QCPAxisTickerText* self, double tickStep);
    friend int QCPAxisTickerText_QBaseGetSubTickCount(QCPAxisTickerText* self, double tickStep);
    friend libqt_string QCPAxisTickerText_GetTickLabel(QCPAxisTickerText* self, double tick, const QLocale* locale, QChar* formatChar, int precision);
    friend libqt_string QCPAxisTickerText_QBaseGetTickLabel(QCPAxisTickerText* self, double tick, const QLocale* locale, QChar* formatChar, int precision);
    friend libqt_list /* of double */ QCPAxisTickerText_CreateTickVector(QCPAxisTickerText* self, double tickStep, const QCPRange* range);
    friend libqt_list /* of double */ QCPAxisTickerText_QBaseCreateTickVector(QCPAxisTickerText* self, double tickStep, const QCPRange* range);
    friend libqt_list /* of double */ QCPAxisTickerText_CreateSubTickVector(QCPAxisTickerText* self, int subTickCount, const libqt_list /* of double */ ticks);
    friend libqt_list /* of double */ QCPAxisTickerText_QBaseCreateSubTickVector(QCPAxisTickerText* self, int subTickCount, const libqt_list /* of double */ ticks);
    friend libqt_list /* of libqt_string */ QCPAxisTickerText_CreateLabelVector(QCPAxisTickerText* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision);
    friend libqt_list /* of libqt_string */ QCPAxisTickerText_QBaseCreateLabelVector(QCPAxisTickerText* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision);
    friend void QCPAxisTickerText_TrimTicks(const QCPAxisTickerText* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier);
    friend void QCPAxisTickerText_QBaseTrimTicks(const QCPAxisTickerText* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier);
    friend double QCPAxisTickerText_PickClosest(const QCPAxisTickerText* self, double target, const libqt_list /* of double */ candidates);
    friend double QCPAxisTickerText_QBasePickClosest(const QCPAxisTickerText* self, double target, const libqt_list /* of double */ candidates);
    friend double QCPAxisTickerText_GetMantissa(const QCPAxisTickerText* self, double input);
    friend double QCPAxisTickerText_QBaseGetMantissa(const QCPAxisTickerText* self, double input);
    friend double QCPAxisTickerText_CleanMantissa(const QCPAxisTickerText* self, double input);
    friend double QCPAxisTickerText_QBaseCleanMantissa(const QCPAxisTickerText* self, double input);
};

// This class is a subclass of QCPAxisTickerPi so that we can call protected methods
class VirtualQCPAxisTickerPi final : public QCPAxisTickerPi {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPAxisTickerPi = true;

    // Virtual class public types (including callbacks)
    using QCPAxisTickerPi_GetTickStep_Callback = double (*)(QCPAxisTickerPi*, QCPRange*);
    using QCPAxisTickerPi_GetSubTickCount_Callback = int (*)(QCPAxisTickerPi*, double);
    using QCPAxisTickerPi_GetTickLabel_Callback = const char* (*)(QCPAxisTickerPi*, double, QLocale*, QChar*, int);
    using QCPAxisTickerPi_Generate_Callback = void (*)(QCPAxisTickerPi*, QCPRange*, QLocale*, QChar*, int, libqt_list /* of double */, libqt_list /* of double */, libqt_list /* of libqt_string */);
    using QCPAxisTickerPi_CreateTickVector_Callback = libqt_list /* of double */ (*)(QCPAxisTickerPi*, double, QCPRange*);
    using QCPAxisTickerPi_CreateSubTickVector_Callback = libqt_list /* of double */ (*)(QCPAxisTickerPi*, int, libqt_list /* of double */);
    using QCPAxisTickerPi_CreateLabelVector_Callback = const char** (*)(QCPAxisTickerPi*, libqt_list /* of double */, QLocale*, QChar*, int);
    using QCPAxisTickerPi_SimplifyFraction_Callback = void (*)(const QCPAxisTickerPi*, int*, int*);
    using QCPAxisTickerPi_FractionToString_Callback = const char* (*)(const QCPAxisTickerPi*, int, int);
    using QCPAxisTickerPi_UnicodeFraction_Callback = const char* (*)(const QCPAxisTickerPi*, int, int);
    using QCPAxisTickerPi_UnicodeSuperscript_Callback = const char* (*)(const QCPAxisTickerPi*, int);
    using QCPAxisTickerPi_UnicodeSubscript_Callback = const char* (*)(const QCPAxisTickerPi*, int);
    using QCPAxisTickerPi_TrimTicks_Callback = void (*)(const QCPAxisTickerPi*, QCPRange*, libqt_list /* of double */, bool);
    using QCPAxisTickerPi_PickClosest_Callback = double (*)(const QCPAxisTickerPi*, double, libqt_list /* of double */);
    using QCPAxisTickerPi_GetMantissa_Callback = double (*)(const QCPAxisTickerPi*, double);
    using QCPAxisTickerPi_CleanMantissa_Callback = double (*)(const QCPAxisTickerPi*, double);

  protected:
    // Instance callback storage
    QCPAxisTickerPi_GetTickStep_Callback qcpaxistickerpi_gettickstep_callback = nullptr;
    QCPAxisTickerPi_GetSubTickCount_Callback qcpaxistickerpi_getsubtickcount_callback = nullptr;
    QCPAxisTickerPi_GetTickLabel_Callback qcpaxistickerpi_getticklabel_callback = nullptr;
    QCPAxisTickerPi_Generate_Callback qcpaxistickerpi_generate_callback = nullptr;
    QCPAxisTickerPi_CreateTickVector_Callback qcpaxistickerpi_createtickvector_callback = nullptr;
    QCPAxisTickerPi_CreateSubTickVector_Callback qcpaxistickerpi_createsubtickvector_callback = nullptr;
    QCPAxisTickerPi_CreateLabelVector_Callback qcpaxistickerpi_createlabelvector_callback = nullptr;
    QCPAxisTickerPi_SimplifyFraction_Callback qcpaxistickerpi_simplifyfraction_callback = nullptr;
    QCPAxisTickerPi_FractionToString_Callback qcpaxistickerpi_fractiontostring_callback = nullptr;
    QCPAxisTickerPi_UnicodeFraction_Callback qcpaxistickerpi_unicodefraction_callback = nullptr;
    QCPAxisTickerPi_UnicodeSuperscript_Callback qcpaxistickerpi_unicodesuperscript_callback = nullptr;
    QCPAxisTickerPi_UnicodeSubscript_Callback qcpaxistickerpi_unicodesubscript_callback = nullptr;
    QCPAxisTickerPi_TrimTicks_Callback qcpaxistickerpi_trimticks_callback = nullptr;
    QCPAxisTickerPi_PickClosest_Callback qcpaxistickerpi_pickclosest_callback = nullptr;
    QCPAxisTickerPi_GetMantissa_Callback qcpaxistickerpi_getmantissa_callback = nullptr;
    QCPAxisTickerPi_CleanMantissa_Callback qcpaxistickerpi_cleanmantissa_callback = nullptr;

    // Instance base flags
    mutable bool qcpaxistickerpi_gettickstep_isbase = false;
    mutable bool qcpaxistickerpi_getsubtickcount_isbase = false;
    mutable bool qcpaxistickerpi_getticklabel_isbase = false;
    mutable bool qcpaxistickerpi_generate_isbase = false;
    mutable bool qcpaxistickerpi_createtickvector_isbase = false;
    mutable bool qcpaxistickerpi_createsubtickvector_isbase = false;
    mutable bool qcpaxistickerpi_createlabelvector_isbase = false;
    mutable bool qcpaxistickerpi_simplifyfraction_isbase = false;
    mutable bool qcpaxistickerpi_fractiontostring_isbase = false;
    mutable bool qcpaxistickerpi_unicodefraction_isbase = false;
    mutable bool qcpaxistickerpi_unicodesuperscript_isbase = false;
    mutable bool qcpaxistickerpi_unicodesubscript_isbase = false;
    mutable bool qcpaxistickerpi_trimticks_isbase = false;
    mutable bool qcpaxistickerpi_pickclosest_isbase = false;
    mutable bool qcpaxistickerpi_getmantissa_isbase = false;
    mutable bool qcpaxistickerpi_cleanmantissa_isbase = false;

  public:
    VirtualQCPAxisTickerPi() : QCPAxisTickerPi() {};

    ~VirtualQCPAxisTickerPi() {
        qcpaxistickerpi_gettickstep_callback = nullptr;
        qcpaxistickerpi_getsubtickcount_callback = nullptr;
        qcpaxistickerpi_getticklabel_callback = nullptr;
        qcpaxistickerpi_generate_callback = nullptr;
        qcpaxistickerpi_createtickvector_callback = nullptr;
        qcpaxistickerpi_createsubtickvector_callback = nullptr;
        qcpaxistickerpi_createlabelvector_callback = nullptr;
        qcpaxistickerpi_simplifyfraction_callback = nullptr;
        qcpaxistickerpi_fractiontostring_callback = nullptr;
        qcpaxistickerpi_unicodefraction_callback = nullptr;
        qcpaxistickerpi_unicodesuperscript_callback = nullptr;
        qcpaxistickerpi_unicodesubscript_callback = nullptr;
        qcpaxistickerpi_trimticks_callback = nullptr;
        qcpaxistickerpi_pickclosest_callback = nullptr;
        qcpaxistickerpi_getmantissa_callback = nullptr;
        qcpaxistickerpi_cleanmantissa_callback = nullptr;
    }

    // Callback setters
    inline void setQCPAxisTickerPi_GetTickStep_Callback(QCPAxisTickerPi_GetTickStep_Callback cb) { qcpaxistickerpi_gettickstep_callback = cb; }
    inline void setQCPAxisTickerPi_GetSubTickCount_Callback(QCPAxisTickerPi_GetSubTickCount_Callback cb) { qcpaxistickerpi_getsubtickcount_callback = cb; }
    inline void setQCPAxisTickerPi_GetTickLabel_Callback(QCPAxisTickerPi_GetTickLabel_Callback cb) { qcpaxistickerpi_getticklabel_callback = cb; }
    inline void setQCPAxisTickerPi_Generate_Callback(QCPAxisTickerPi_Generate_Callback cb) { qcpaxistickerpi_generate_callback = cb; }
    inline void setQCPAxisTickerPi_CreateTickVector_Callback(QCPAxisTickerPi_CreateTickVector_Callback cb) { qcpaxistickerpi_createtickvector_callback = cb; }
    inline void setQCPAxisTickerPi_CreateSubTickVector_Callback(QCPAxisTickerPi_CreateSubTickVector_Callback cb) { qcpaxistickerpi_createsubtickvector_callback = cb; }
    inline void setQCPAxisTickerPi_CreateLabelVector_Callback(QCPAxisTickerPi_CreateLabelVector_Callback cb) { qcpaxistickerpi_createlabelvector_callback = cb; }
    inline void setQCPAxisTickerPi_SimplifyFraction_Callback(QCPAxisTickerPi_SimplifyFraction_Callback cb) { qcpaxistickerpi_simplifyfraction_callback = cb; }
    inline void setQCPAxisTickerPi_FractionToString_Callback(QCPAxisTickerPi_FractionToString_Callback cb) { qcpaxistickerpi_fractiontostring_callback = cb; }
    inline void setQCPAxisTickerPi_UnicodeFraction_Callback(QCPAxisTickerPi_UnicodeFraction_Callback cb) { qcpaxistickerpi_unicodefraction_callback = cb; }
    inline void setQCPAxisTickerPi_UnicodeSuperscript_Callback(QCPAxisTickerPi_UnicodeSuperscript_Callback cb) { qcpaxistickerpi_unicodesuperscript_callback = cb; }
    inline void setQCPAxisTickerPi_UnicodeSubscript_Callback(QCPAxisTickerPi_UnicodeSubscript_Callback cb) { qcpaxistickerpi_unicodesubscript_callback = cb; }
    inline void setQCPAxisTickerPi_TrimTicks_Callback(QCPAxisTickerPi_TrimTicks_Callback cb) { qcpaxistickerpi_trimticks_callback = cb; }
    inline void setQCPAxisTickerPi_PickClosest_Callback(QCPAxisTickerPi_PickClosest_Callback cb) { qcpaxistickerpi_pickclosest_callback = cb; }
    inline void setQCPAxisTickerPi_GetMantissa_Callback(QCPAxisTickerPi_GetMantissa_Callback cb) { qcpaxistickerpi_getmantissa_callback = cb; }
    inline void setQCPAxisTickerPi_CleanMantissa_Callback(QCPAxisTickerPi_CleanMantissa_Callback cb) { qcpaxistickerpi_cleanmantissa_callback = cb; }

    // Base flag setters
    inline void setQCPAxisTickerPi_GetTickStep_IsBase(bool value) const { qcpaxistickerpi_gettickstep_isbase = value; }
    inline void setQCPAxisTickerPi_GetSubTickCount_IsBase(bool value) const { qcpaxistickerpi_getsubtickcount_isbase = value; }
    inline void setQCPAxisTickerPi_GetTickLabel_IsBase(bool value) const { qcpaxistickerpi_getticklabel_isbase = value; }
    inline void setQCPAxisTickerPi_Generate_IsBase(bool value) const { qcpaxistickerpi_generate_isbase = value; }
    inline void setQCPAxisTickerPi_CreateTickVector_IsBase(bool value) const { qcpaxistickerpi_createtickvector_isbase = value; }
    inline void setQCPAxisTickerPi_CreateSubTickVector_IsBase(bool value) const { qcpaxistickerpi_createsubtickvector_isbase = value; }
    inline void setQCPAxisTickerPi_CreateLabelVector_IsBase(bool value) const { qcpaxistickerpi_createlabelvector_isbase = value; }
    inline void setQCPAxisTickerPi_SimplifyFraction_IsBase(bool value) const { qcpaxistickerpi_simplifyfraction_isbase = value; }
    inline void setQCPAxisTickerPi_FractionToString_IsBase(bool value) const { qcpaxistickerpi_fractiontostring_isbase = value; }
    inline void setQCPAxisTickerPi_UnicodeFraction_IsBase(bool value) const { qcpaxistickerpi_unicodefraction_isbase = value; }
    inline void setQCPAxisTickerPi_UnicodeSuperscript_IsBase(bool value) const { qcpaxistickerpi_unicodesuperscript_isbase = value; }
    inline void setQCPAxisTickerPi_UnicodeSubscript_IsBase(bool value) const { qcpaxistickerpi_unicodesubscript_isbase = value; }
    inline void setQCPAxisTickerPi_TrimTicks_IsBase(bool value) const { qcpaxistickerpi_trimticks_isbase = value; }
    inline void setQCPAxisTickerPi_PickClosest_IsBase(bool value) const { qcpaxistickerpi_pickclosest_isbase = value; }
    inline void setQCPAxisTickerPi_GetMantissa_IsBase(bool value) const { qcpaxistickerpi_getmantissa_isbase = value; }
    inline void setQCPAxisTickerPi_CleanMantissa_IsBase(bool value) const { qcpaxistickerpi_cleanmantissa_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual double getTickStep(const QCPRange& range) override {
        if (qcpaxistickerpi_gettickstep_isbase) {
            qcpaxistickerpi_gettickstep_isbase = false;
            return QCPAxisTickerPi::getTickStep(range);
        } else if (qcpaxistickerpi_gettickstep_callback != nullptr) {
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval1 = const_cast<QCPRange*>(&range_ret);

            double callback_ret = qcpaxistickerpi_gettickstep_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTickerPi::getTickStep(range);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int getSubTickCount(double tickStep) override {
        if (qcpaxistickerpi_getsubtickcount_isbase) {
            qcpaxistickerpi_getsubtickcount_isbase = false;
            return QCPAxisTickerPi::getSubTickCount(tickStep);
        } else if (qcpaxistickerpi_getsubtickcount_callback != nullptr) {
            double cbval1 = tickStep;

            int callback_ret = qcpaxistickerpi_getsubtickcount_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPAxisTickerPi::getSubTickCount(tickStep);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QString getTickLabel(double tick, const QLocale& locale, QChar formatChar, int precision) override {
        if (qcpaxistickerpi_getticklabel_isbase) {
            qcpaxistickerpi_getticklabel_isbase = false;
            return QCPAxisTickerPi::getTickLabel(tick, locale, formatChar, precision);
        } else if (qcpaxistickerpi_getticklabel_callback != nullptr) {
            double cbval1 = tick;
            const QLocale& locale_ret = locale;
            // Cast returned reference into pointer
            QLocale* cbval2 = const_cast<QLocale*>(&locale_ret);
            QChar* cbval3 = new QChar(formatChar);
            int cbval4 = precision;

            const char* callback_ret = qcpaxistickerpi_getticklabel_callback(this, cbval1, cbval2, cbval3, cbval4);
            QString callback_ret_QString = QString::fromUtf8(callback_ret);
            return callback_ret_QString;
        } else {
            return QCPAxisTickerPi::getTickLabel(tick, locale, formatChar, precision);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void generate(const QCPRange& range, const QLocale& locale, QChar formatChar, int precision, QVector<double>& ticks, QVector<double>* subTicks, QVector<QString>* tickLabels) override {
        if (qcpaxistickerpi_generate_isbase) {
            qcpaxistickerpi_generate_isbase = false;
            QCPAxisTickerPi::generate(range, locale, formatChar, precision, ticks, subTicks, tickLabels);
        } else if (qcpaxistickerpi_generate_callback != nullptr) {
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval1 = const_cast<QCPRange*>(&range_ret);
            const QLocale& locale_ret = locale;
            // Cast returned reference into pointer
            QLocale* cbval2 = const_cast<QLocale*>(&locale_ret);
            QChar* cbval3 = new QChar(formatChar);
            int cbval4 = precision;
            QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval5 = ticks_out;
            QVector<double>* subTicks_ret = subTicks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* subTicks_arr = static_cast<double*>(malloc(sizeof(double) * (subTicks_ret->size() + 1)));
            for (qsizetype i = 0; i < subTicks_ret->size(); ++i) {
                subTicks_arr[i] = (*subTicks_ret)[i];
            }
            libqt_list subTicks_out;
            subTicks_out.len = subTicks_ret->size();
            subTicks_out.data = static_cast<void*>(subTicks_arr);
            libqt_list /* of double */ cbval6 = subTicks_out;
            QVector<QString>* tickLabels_ret = tickLabels;
            // Convert QVector<> from C++ memory to manually-managed C memory
            libqt_string* tickLabels_arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (tickLabels_ret->size() + 1)));
            for (qsizetype i = 0; i < tickLabels_ret->size(); ++i) {
                QString tickLabels_vv_ret = (*tickLabels_ret)[i];
                // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
                QByteArray tickLabels_vv_b = tickLabels_vv_ret.toUtf8();
                libqt_string tickLabels_vv_str;
                tickLabels_vv_str.len = tickLabels_vv_b.length();
                tickLabels_vv_str.data = static_cast<const char*>(malloc(tickLabels_vv_str.len + 1));
                memcpy((void*)tickLabels_vv_str.data, tickLabels_vv_b.data(), tickLabels_vv_str.len);
                ((char*)tickLabels_vv_str.data)[tickLabels_vv_str.len] = '\0';
                tickLabels_arr[i] = tickLabels_vv_str;
            }
            libqt_list tickLabels_out;
            tickLabels_out.len = tickLabels_ret->size();
            tickLabels_out.data = static_cast<void*>(tickLabels_arr);
            libqt_list /* of libqt_string */ cbval7 = tickLabels_out;

            qcpaxistickerpi_generate_callback(this, cbval1, cbval2, cbval3, cbval4, cbval5, cbval6, cbval7);
        } else {
            QCPAxisTickerPi::generate(range, locale, formatChar, precision, ticks, subTicks, tickLabels);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QVector<double> createTickVector(double tickStep, const QCPRange& range) override {
        if (qcpaxistickerpi_createtickvector_isbase) {
            qcpaxistickerpi_createtickvector_isbase = false;
            return QCPAxisTickerPi::createTickVector(tickStep, range);
        } else if (qcpaxistickerpi_createtickvector_callback != nullptr) {
            double cbval1 = tickStep;
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval2 = const_cast<QCPRange*>(&range_ret);

            libqt_list /* of double */ callback_ret = qcpaxistickerpi_createtickvector_callback(this, cbval1, cbval2);
            QVector<double> callback_ret_QVector;
            callback_ret_QVector.reserve(callback_ret.len);
            double* callback_ret_arr = static_cast<double*>(callback_ret.data);
            for (size_t i = 0; i < callback_ret.len; ++i) {
                callback_ret_QVector.push_back(static_cast<double>(callback_ret_arr[i]));
            }
            return callback_ret_QVector;
        } else {
            return QCPAxisTickerPi::createTickVector(tickStep, range);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QVector<double> createSubTickVector(int subTickCount, const QVector<double>& ticks) override {
        if (qcpaxistickerpi_createsubtickvector_isbase) {
            qcpaxistickerpi_createsubtickvector_isbase = false;
            return QCPAxisTickerPi::createSubTickVector(subTickCount, ticks);
        } else if (qcpaxistickerpi_createsubtickvector_callback != nullptr) {
            int cbval1 = subTickCount;
            const QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval2 = ticks_out;

            libqt_list /* of double */ callback_ret = qcpaxistickerpi_createsubtickvector_callback(this, cbval1, cbval2);
            QVector<double> callback_ret_QVector;
            callback_ret_QVector.reserve(callback_ret.len);
            double* callback_ret_arr = static_cast<double*>(callback_ret.data);
            for (size_t i = 0; i < callback_ret.len; ++i) {
                callback_ret_QVector.push_back(static_cast<double>(callback_ret_arr[i]));
            }
            return callback_ret_QVector;
        } else {
            return QCPAxisTickerPi::createSubTickVector(subTickCount, ticks);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QVector<QString> createLabelVector(const QVector<double>& ticks, const QLocale& locale, QChar formatChar, int precision) override {
        if (qcpaxistickerpi_createlabelvector_isbase) {
            qcpaxistickerpi_createlabelvector_isbase = false;
            return QCPAxisTickerPi::createLabelVector(ticks, locale, formatChar, precision);
        } else if (qcpaxistickerpi_createlabelvector_callback != nullptr) {
            const QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval1 = ticks_out;
            const QLocale& locale_ret = locale;
            // Cast returned reference into pointer
            QLocale* cbval2 = const_cast<QLocale*>(&locale_ret);
            QChar* cbval3 = new QChar(formatChar);
            int cbval4 = precision;

            const char** callback_ret = qcpaxistickerpi_createlabelvector_callback(this, cbval1, cbval2, cbval3, cbval4);
            QVector<QString> callback_ret_QVector;
            size_t callback_ret_len = libqt_strv_length(callback_ret);
            callback_ret_QVector.reserve(callback_ret_len);
            const char** callback_ret_arr = static_cast<const char**>(callback_ret);
            for (size_t i = 0; i < callback_ret_len; ++i) {
                QString callback_ret_arr_i_QString = QString::fromUtf8(callback_ret_arr[i]);
                callback_ret_QVector.push_back(callback_ret_arr_i_QString);
            }
            return callback_ret_QVector;
        } else {
            return QCPAxisTickerPi::createLabelVector(ticks, locale, formatChar, precision);
        }
    }

    // Virtual method for C ABI access and custom callback
    void simplifyFraction(int& numerator, int& denominator) const {
        if (qcpaxistickerpi_simplifyfraction_isbase) {
            qcpaxistickerpi_simplifyfraction_isbase = false;
            QCPAxisTickerPi::simplifyFraction(numerator, denominator);
        } else if (qcpaxistickerpi_simplifyfraction_callback != nullptr) {
            int* cbval1 = &numerator;
            int* cbval2 = &denominator;

            qcpaxistickerpi_simplifyfraction_callback(this, cbval1, cbval2);
        } else {
            QCPAxisTickerPi::simplifyFraction(numerator, denominator);
        }
    }

    // Virtual method for C ABI access and custom callback
    QString fractionToString(int numerator, int denominator) const {
        if (qcpaxistickerpi_fractiontostring_isbase) {
            qcpaxistickerpi_fractiontostring_isbase = false;
            return QCPAxisTickerPi::fractionToString(numerator, denominator);
        } else if (qcpaxistickerpi_fractiontostring_callback != nullptr) {
            int cbval1 = numerator;
            int cbval2 = denominator;

            const char* callback_ret = qcpaxistickerpi_fractiontostring_callback(this, cbval1, cbval2);
            QString callback_ret_QString = QString::fromUtf8(callback_ret);
            return callback_ret_QString;
        } else {
            return QCPAxisTickerPi::fractionToString(numerator, denominator);
        }
    }

    // Virtual method for C ABI access and custom callback
    QString unicodeFraction(int numerator, int denominator) const {
        if (qcpaxistickerpi_unicodefraction_isbase) {
            qcpaxistickerpi_unicodefraction_isbase = false;
            return QCPAxisTickerPi::unicodeFraction(numerator, denominator);
        } else if (qcpaxistickerpi_unicodefraction_callback != nullptr) {
            int cbval1 = numerator;
            int cbval2 = denominator;

            const char* callback_ret = qcpaxistickerpi_unicodefraction_callback(this, cbval1, cbval2);
            QString callback_ret_QString = QString::fromUtf8(callback_ret);
            return callback_ret_QString;
        } else {
            return QCPAxisTickerPi::unicodeFraction(numerator, denominator);
        }
    }

    // Virtual method for C ABI access and custom callback
    QString unicodeSuperscript(int number) const {
        if (qcpaxistickerpi_unicodesuperscript_isbase) {
            qcpaxistickerpi_unicodesuperscript_isbase = false;
            return QCPAxisTickerPi::unicodeSuperscript(number);
        } else if (qcpaxistickerpi_unicodesuperscript_callback != nullptr) {
            int cbval1 = number;

            const char* callback_ret = qcpaxistickerpi_unicodesuperscript_callback(this, cbval1);
            QString callback_ret_QString = QString::fromUtf8(callback_ret);
            return callback_ret_QString;
        } else {
            return QCPAxisTickerPi::unicodeSuperscript(number);
        }
    }

    // Virtual method for C ABI access and custom callback
    QString unicodeSubscript(int number) const {
        if (qcpaxistickerpi_unicodesubscript_isbase) {
            qcpaxistickerpi_unicodesubscript_isbase = false;
            return QCPAxisTickerPi::unicodeSubscript(number);
        } else if (qcpaxistickerpi_unicodesubscript_callback != nullptr) {
            int cbval1 = number;

            const char* callback_ret = qcpaxistickerpi_unicodesubscript_callback(this, cbval1);
            QString callback_ret_QString = QString::fromUtf8(callback_ret);
            return callback_ret_QString;
        } else {
            return QCPAxisTickerPi::unicodeSubscript(number);
        }
    }

    // Virtual method for C ABI access and custom callback
    void trimTicks(const QCPRange& range, QVector<double>& ticks, bool keepOneOutlier) const {
        if (qcpaxistickerpi_trimticks_isbase) {
            qcpaxistickerpi_trimticks_isbase = false;
            QCPAxisTickerPi::trimTicks(range, ticks, keepOneOutlier);
        } else if (qcpaxistickerpi_trimticks_callback != nullptr) {
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval1 = const_cast<QCPRange*>(&range_ret);
            QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval2 = ticks_out;
            bool cbval3 = keepOneOutlier;

            qcpaxistickerpi_trimticks_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPAxisTickerPi::trimTicks(range, ticks, keepOneOutlier);
        }
    }

    // Virtual method for C ABI access and custom callback
    double pickClosest(double target, const QVector<double>& candidates) const {
        if (qcpaxistickerpi_pickclosest_isbase) {
            qcpaxistickerpi_pickclosest_isbase = false;
            return QCPAxisTickerPi::pickClosest(target, candidates);
        } else if (qcpaxistickerpi_pickclosest_callback != nullptr) {
            double cbval1 = target;
            const QVector<double>& candidates_ret = candidates;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* candidates_arr = static_cast<double*>(malloc(sizeof(double) * (candidates_ret.size() + 1)));
            for (qsizetype i = 0; i < candidates_ret.size(); ++i) {
                candidates_arr[i] = candidates_ret[i];
            }
            libqt_list candidates_out;
            candidates_out.len = candidates_ret.size();
            candidates_out.data = static_cast<void*>(candidates_arr);
            libqt_list /* of double */ cbval2 = candidates_out;

            double callback_ret = qcpaxistickerpi_pickclosest_callback(this, cbval1, cbval2);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTickerPi::pickClosest(target, candidates);
        }
    }

    // Virtual method for C ABI access and custom callback
    double getMantissa(double input) const {
        if (qcpaxistickerpi_getmantissa_isbase) {
            qcpaxistickerpi_getmantissa_isbase = false;
            return QCPAxisTickerPi::getMantissa(input);
        } else if (qcpaxistickerpi_getmantissa_callback != nullptr) {
            double cbval1 = input;

            double callback_ret = qcpaxistickerpi_getmantissa_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTickerPi::getMantissa(input);
        }
    }

    // Virtual method for C ABI access and custom callback
    double cleanMantissa(double input) const {
        if (qcpaxistickerpi_cleanmantissa_isbase) {
            qcpaxistickerpi_cleanmantissa_isbase = false;
            return QCPAxisTickerPi::cleanMantissa(input);
        } else if (qcpaxistickerpi_cleanmantissa_callback != nullptr) {
            double cbval1 = input;

            double callback_ret = qcpaxistickerpi_cleanmantissa_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTickerPi::cleanMantissa(input);
        }
    }

    // Friend functions
    friend double QCPAxisTickerPi_GetTickStep(QCPAxisTickerPi* self, const QCPRange* range);
    friend double QCPAxisTickerPi_QBaseGetTickStep(QCPAxisTickerPi* self, const QCPRange* range);
    friend int QCPAxisTickerPi_GetSubTickCount(QCPAxisTickerPi* self, double tickStep);
    friend int QCPAxisTickerPi_QBaseGetSubTickCount(QCPAxisTickerPi* self, double tickStep);
    friend libqt_string QCPAxisTickerPi_GetTickLabel(QCPAxisTickerPi* self, double tick, const QLocale* locale, QChar* formatChar, int precision);
    friend libqt_string QCPAxisTickerPi_QBaseGetTickLabel(QCPAxisTickerPi* self, double tick, const QLocale* locale, QChar* formatChar, int precision);
    friend libqt_list /* of double */ QCPAxisTickerPi_CreateTickVector(QCPAxisTickerPi* self, double tickStep, const QCPRange* range);
    friend libqt_list /* of double */ QCPAxisTickerPi_QBaseCreateTickVector(QCPAxisTickerPi* self, double tickStep, const QCPRange* range);
    friend libqt_list /* of double */ QCPAxisTickerPi_CreateSubTickVector(QCPAxisTickerPi* self, int subTickCount, const libqt_list /* of double */ ticks);
    friend libqt_list /* of double */ QCPAxisTickerPi_QBaseCreateSubTickVector(QCPAxisTickerPi* self, int subTickCount, const libqt_list /* of double */ ticks);
    friend libqt_list /* of libqt_string */ QCPAxisTickerPi_CreateLabelVector(QCPAxisTickerPi* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision);
    friend libqt_list /* of libqt_string */ QCPAxisTickerPi_QBaseCreateLabelVector(QCPAxisTickerPi* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision);
    friend void QCPAxisTickerPi_SimplifyFraction(const QCPAxisTickerPi* self, int* numerator, int* denominator);
    friend void QCPAxisTickerPi_QBaseSimplifyFraction(const QCPAxisTickerPi* self, int* numerator, int* denominator);
    friend libqt_string QCPAxisTickerPi_FractionToString(const QCPAxisTickerPi* self, int numerator, int denominator);
    friend libqt_string QCPAxisTickerPi_QBaseFractionToString(const QCPAxisTickerPi* self, int numerator, int denominator);
    friend libqt_string QCPAxisTickerPi_UnicodeFraction(const QCPAxisTickerPi* self, int numerator, int denominator);
    friend libqt_string QCPAxisTickerPi_QBaseUnicodeFraction(const QCPAxisTickerPi* self, int numerator, int denominator);
    friend libqt_string QCPAxisTickerPi_UnicodeSuperscript(const QCPAxisTickerPi* self, int number);
    friend libqt_string QCPAxisTickerPi_QBaseUnicodeSuperscript(const QCPAxisTickerPi* self, int number);
    friend libqt_string QCPAxisTickerPi_UnicodeSubscript(const QCPAxisTickerPi* self, int number);
    friend libqt_string QCPAxisTickerPi_QBaseUnicodeSubscript(const QCPAxisTickerPi* self, int number);
    friend void QCPAxisTickerPi_TrimTicks(const QCPAxisTickerPi* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier);
    friend void QCPAxisTickerPi_QBaseTrimTicks(const QCPAxisTickerPi* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier);
    friend double QCPAxisTickerPi_PickClosest(const QCPAxisTickerPi* self, double target, const libqt_list /* of double */ candidates);
    friend double QCPAxisTickerPi_QBasePickClosest(const QCPAxisTickerPi* self, double target, const libqt_list /* of double */ candidates);
    friend double QCPAxisTickerPi_GetMantissa(const QCPAxisTickerPi* self, double input);
    friend double QCPAxisTickerPi_QBaseGetMantissa(const QCPAxisTickerPi* self, double input);
    friend double QCPAxisTickerPi_CleanMantissa(const QCPAxisTickerPi* self, double input);
    friend double QCPAxisTickerPi_QBaseCleanMantissa(const QCPAxisTickerPi* self, double input);
};

// This class is a subclass of QCPAxisTickerLog so that we can call protected methods
class VirtualQCPAxisTickerLog final : public QCPAxisTickerLog {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPAxisTickerLog = true;

    // Virtual class public types (including callbacks)
    using QCPAxisTickerLog_GetSubTickCount_Callback = int (*)(QCPAxisTickerLog*, double);
    using QCPAxisTickerLog_CreateTickVector_Callback = libqt_list /* of double */ (*)(QCPAxisTickerLog*, double, QCPRange*);
    using QCPAxisTickerLog_Generate_Callback = void (*)(QCPAxisTickerLog*, QCPRange*, QLocale*, QChar*, int, libqt_list /* of double */, libqt_list /* of double */, libqt_list /* of libqt_string */);
    using QCPAxisTickerLog_GetTickStep_Callback = double (*)(QCPAxisTickerLog*, QCPRange*);
    using QCPAxisTickerLog_GetTickLabel_Callback = const char* (*)(QCPAxisTickerLog*, double, QLocale*, QChar*, int);
    using QCPAxisTickerLog_CreateSubTickVector_Callback = libqt_list /* of double */ (*)(QCPAxisTickerLog*, int, libqt_list /* of double */);
    using QCPAxisTickerLog_CreateLabelVector_Callback = const char** (*)(QCPAxisTickerLog*, libqt_list /* of double */, QLocale*, QChar*, int);
    using QCPAxisTickerLog_TrimTicks_Callback = void (*)(const QCPAxisTickerLog*, QCPRange*, libqt_list /* of double */, bool);
    using QCPAxisTickerLog_PickClosest_Callback = double (*)(const QCPAxisTickerLog*, double, libqt_list /* of double */);
    using QCPAxisTickerLog_GetMantissa_Callback = double (*)(const QCPAxisTickerLog*, double);
    using QCPAxisTickerLog_CleanMantissa_Callback = double (*)(const QCPAxisTickerLog*, double);

  protected:
    // Instance callback storage
    QCPAxisTickerLog_GetSubTickCount_Callback qcpaxistickerlog_getsubtickcount_callback = nullptr;
    QCPAxisTickerLog_CreateTickVector_Callback qcpaxistickerlog_createtickvector_callback = nullptr;
    QCPAxisTickerLog_Generate_Callback qcpaxistickerlog_generate_callback = nullptr;
    QCPAxisTickerLog_GetTickStep_Callback qcpaxistickerlog_gettickstep_callback = nullptr;
    QCPAxisTickerLog_GetTickLabel_Callback qcpaxistickerlog_getticklabel_callback = nullptr;
    QCPAxisTickerLog_CreateSubTickVector_Callback qcpaxistickerlog_createsubtickvector_callback = nullptr;
    QCPAxisTickerLog_CreateLabelVector_Callback qcpaxistickerlog_createlabelvector_callback = nullptr;
    QCPAxisTickerLog_TrimTicks_Callback qcpaxistickerlog_trimticks_callback = nullptr;
    QCPAxisTickerLog_PickClosest_Callback qcpaxistickerlog_pickclosest_callback = nullptr;
    QCPAxisTickerLog_GetMantissa_Callback qcpaxistickerlog_getmantissa_callback = nullptr;
    QCPAxisTickerLog_CleanMantissa_Callback qcpaxistickerlog_cleanmantissa_callback = nullptr;

    // Instance base flags
    mutable bool qcpaxistickerlog_getsubtickcount_isbase = false;
    mutable bool qcpaxistickerlog_createtickvector_isbase = false;
    mutable bool qcpaxistickerlog_generate_isbase = false;
    mutable bool qcpaxistickerlog_gettickstep_isbase = false;
    mutable bool qcpaxistickerlog_getticklabel_isbase = false;
    mutable bool qcpaxistickerlog_createsubtickvector_isbase = false;
    mutable bool qcpaxistickerlog_createlabelvector_isbase = false;
    mutable bool qcpaxistickerlog_trimticks_isbase = false;
    mutable bool qcpaxistickerlog_pickclosest_isbase = false;
    mutable bool qcpaxistickerlog_getmantissa_isbase = false;
    mutable bool qcpaxistickerlog_cleanmantissa_isbase = false;

  public:
    VirtualQCPAxisTickerLog() : QCPAxisTickerLog() {};

    ~VirtualQCPAxisTickerLog() {
        qcpaxistickerlog_getsubtickcount_callback = nullptr;
        qcpaxistickerlog_createtickvector_callback = nullptr;
        qcpaxistickerlog_generate_callback = nullptr;
        qcpaxistickerlog_gettickstep_callback = nullptr;
        qcpaxistickerlog_getticklabel_callback = nullptr;
        qcpaxistickerlog_createsubtickvector_callback = nullptr;
        qcpaxistickerlog_createlabelvector_callback = nullptr;
        qcpaxistickerlog_trimticks_callback = nullptr;
        qcpaxistickerlog_pickclosest_callback = nullptr;
        qcpaxistickerlog_getmantissa_callback = nullptr;
        qcpaxistickerlog_cleanmantissa_callback = nullptr;
    }

    // Callback setters
    inline void setQCPAxisTickerLog_GetSubTickCount_Callback(QCPAxisTickerLog_GetSubTickCount_Callback cb) { qcpaxistickerlog_getsubtickcount_callback = cb; }
    inline void setQCPAxisTickerLog_CreateTickVector_Callback(QCPAxisTickerLog_CreateTickVector_Callback cb) { qcpaxistickerlog_createtickvector_callback = cb; }
    inline void setQCPAxisTickerLog_Generate_Callback(QCPAxisTickerLog_Generate_Callback cb) { qcpaxistickerlog_generate_callback = cb; }
    inline void setQCPAxisTickerLog_GetTickStep_Callback(QCPAxisTickerLog_GetTickStep_Callback cb) { qcpaxistickerlog_gettickstep_callback = cb; }
    inline void setQCPAxisTickerLog_GetTickLabel_Callback(QCPAxisTickerLog_GetTickLabel_Callback cb) { qcpaxistickerlog_getticklabel_callback = cb; }
    inline void setQCPAxisTickerLog_CreateSubTickVector_Callback(QCPAxisTickerLog_CreateSubTickVector_Callback cb) { qcpaxistickerlog_createsubtickvector_callback = cb; }
    inline void setQCPAxisTickerLog_CreateLabelVector_Callback(QCPAxisTickerLog_CreateLabelVector_Callback cb) { qcpaxistickerlog_createlabelvector_callback = cb; }
    inline void setQCPAxisTickerLog_TrimTicks_Callback(QCPAxisTickerLog_TrimTicks_Callback cb) { qcpaxistickerlog_trimticks_callback = cb; }
    inline void setQCPAxisTickerLog_PickClosest_Callback(QCPAxisTickerLog_PickClosest_Callback cb) { qcpaxistickerlog_pickclosest_callback = cb; }
    inline void setQCPAxisTickerLog_GetMantissa_Callback(QCPAxisTickerLog_GetMantissa_Callback cb) { qcpaxistickerlog_getmantissa_callback = cb; }
    inline void setQCPAxisTickerLog_CleanMantissa_Callback(QCPAxisTickerLog_CleanMantissa_Callback cb) { qcpaxistickerlog_cleanmantissa_callback = cb; }

    // Base flag setters
    inline void setQCPAxisTickerLog_GetSubTickCount_IsBase(bool value) const { qcpaxistickerlog_getsubtickcount_isbase = value; }
    inline void setQCPAxisTickerLog_CreateTickVector_IsBase(bool value) const { qcpaxistickerlog_createtickvector_isbase = value; }
    inline void setQCPAxisTickerLog_Generate_IsBase(bool value) const { qcpaxistickerlog_generate_isbase = value; }
    inline void setQCPAxisTickerLog_GetTickStep_IsBase(bool value) const { qcpaxistickerlog_gettickstep_isbase = value; }
    inline void setQCPAxisTickerLog_GetTickLabel_IsBase(bool value) const { qcpaxistickerlog_getticklabel_isbase = value; }
    inline void setQCPAxisTickerLog_CreateSubTickVector_IsBase(bool value) const { qcpaxistickerlog_createsubtickvector_isbase = value; }
    inline void setQCPAxisTickerLog_CreateLabelVector_IsBase(bool value) const { qcpaxistickerlog_createlabelvector_isbase = value; }
    inline void setQCPAxisTickerLog_TrimTicks_IsBase(bool value) const { qcpaxistickerlog_trimticks_isbase = value; }
    inline void setQCPAxisTickerLog_PickClosest_IsBase(bool value) const { qcpaxistickerlog_pickclosest_isbase = value; }
    inline void setQCPAxisTickerLog_GetMantissa_IsBase(bool value) const { qcpaxistickerlog_getmantissa_isbase = value; }
    inline void setQCPAxisTickerLog_CleanMantissa_IsBase(bool value) const { qcpaxistickerlog_cleanmantissa_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int getSubTickCount(double tickStep) override {
        if (qcpaxistickerlog_getsubtickcount_isbase) {
            qcpaxistickerlog_getsubtickcount_isbase = false;
            return QCPAxisTickerLog::getSubTickCount(tickStep);
        } else if (qcpaxistickerlog_getsubtickcount_callback != nullptr) {
            double cbval1 = tickStep;

            int callback_ret = qcpaxistickerlog_getsubtickcount_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPAxisTickerLog::getSubTickCount(tickStep);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QVector<double> createTickVector(double tickStep, const QCPRange& range) override {
        if (qcpaxistickerlog_createtickvector_isbase) {
            qcpaxistickerlog_createtickvector_isbase = false;
            return QCPAxisTickerLog::createTickVector(tickStep, range);
        } else if (qcpaxistickerlog_createtickvector_callback != nullptr) {
            double cbval1 = tickStep;
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval2 = const_cast<QCPRange*>(&range_ret);

            libqt_list /* of double */ callback_ret = qcpaxistickerlog_createtickvector_callback(this, cbval1, cbval2);
            QVector<double> callback_ret_QVector;
            callback_ret_QVector.reserve(callback_ret.len);
            double* callback_ret_arr = static_cast<double*>(callback_ret.data);
            for (size_t i = 0; i < callback_ret.len; ++i) {
                callback_ret_QVector.push_back(static_cast<double>(callback_ret_arr[i]));
            }
            return callback_ret_QVector;
        } else {
            return QCPAxisTickerLog::createTickVector(tickStep, range);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void generate(const QCPRange& range, const QLocale& locale, QChar formatChar, int precision, QVector<double>& ticks, QVector<double>* subTicks, QVector<QString>* tickLabels) override {
        if (qcpaxistickerlog_generate_isbase) {
            qcpaxistickerlog_generate_isbase = false;
            QCPAxisTickerLog::generate(range, locale, formatChar, precision, ticks, subTicks, tickLabels);
        } else if (qcpaxistickerlog_generate_callback != nullptr) {
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval1 = const_cast<QCPRange*>(&range_ret);
            const QLocale& locale_ret = locale;
            // Cast returned reference into pointer
            QLocale* cbval2 = const_cast<QLocale*>(&locale_ret);
            QChar* cbval3 = new QChar(formatChar);
            int cbval4 = precision;
            QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval5 = ticks_out;
            QVector<double>* subTicks_ret = subTicks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* subTicks_arr = static_cast<double*>(malloc(sizeof(double) * (subTicks_ret->size() + 1)));
            for (qsizetype i = 0; i < subTicks_ret->size(); ++i) {
                subTicks_arr[i] = (*subTicks_ret)[i];
            }
            libqt_list subTicks_out;
            subTicks_out.len = subTicks_ret->size();
            subTicks_out.data = static_cast<void*>(subTicks_arr);
            libqt_list /* of double */ cbval6 = subTicks_out;
            QVector<QString>* tickLabels_ret = tickLabels;
            // Convert QVector<> from C++ memory to manually-managed C memory
            libqt_string* tickLabels_arr = static_cast<libqt_string*>(malloc(sizeof(libqt_string) * (tickLabels_ret->size() + 1)));
            for (qsizetype i = 0; i < tickLabels_ret->size(); ++i) {
                QString tickLabels_vv_ret = (*tickLabels_ret)[i];
                // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
                QByteArray tickLabels_vv_b = tickLabels_vv_ret.toUtf8();
                libqt_string tickLabels_vv_str;
                tickLabels_vv_str.len = tickLabels_vv_b.length();
                tickLabels_vv_str.data = static_cast<const char*>(malloc(tickLabels_vv_str.len + 1));
                memcpy((void*)tickLabels_vv_str.data, tickLabels_vv_b.data(), tickLabels_vv_str.len);
                ((char*)tickLabels_vv_str.data)[tickLabels_vv_str.len] = '\0';
                tickLabels_arr[i] = tickLabels_vv_str;
            }
            libqt_list tickLabels_out;
            tickLabels_out.len = tickLabels_ret->size();
            tickLabels_out.data = static_cast<void*>(tickLabels_arr);
            libqt_list /* of libqt_string */ cbval7 = tickLabels_out;

            qcpaxistickerlog_generate_callback(this, cbval1, cbval2, cbval3, cbval4, cbval5, cbval6, cbval7);
        } else {
            QCPAxisTickerLog::generate(range, locale, formatChar, precision, ticks, subTicks, tickLabels);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double getTickStep(const QCPRange& range) override {
        if (qcpaxistickerlog_gettickstep_isbase) {
            qcpaxistickerlog_gettickstep_isbase = false;
            return QCPAxisTickerLog::getTickStep(range);
        } else if (qcpaxistickerlog_gettickstep_callback != nullptr) {
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval1 = const_cast<QCPRange*>(&range_ret);

            double callback_ret = qcpaxistickerlog_gettickstep_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTickerLog::getTickStep(range);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QString getTickLabel(double tick, const QLocale& locale, QChar formatChar, int precision) override {
        if (qcpaxistickerlog_getticklabel_isbase) {
            qcpaxistickerlog_getticklabel_isbase = false;
            return QCPAxisTickerLog::getTickLabel(tick, locale, formatChar, precision);
        } else if (qcpaxistickerlog_getticklabel_callback != nullptr) {
            double cbval1 = tick;
            const QLocale& locale_ret = locale;
            // Cast returned reference into pointer
            QLocale* cbval2 = const_cast<QLocale*>(&locale_ret);
            QChar* cbval3 = new QChar(formatChar);
            int cbval4 = precision;

            const char* callback_ret = qcpaxistickerlog_getticklabel_callback(this, cbval1, cbval2, cbval3, cbval4);
            QString callback_ret_QString = QString::fromUtf8(callback_ret);
            return callback_ret_QString;
        } else {
            return QCPAxisTickerLog::getTickLabel(tick, locale, formatChar, precision);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QVector<double> createSubTickVector(int subTickCount, const QVector<double>& ticks) override {
        if (qcpaxistickerlog_createsubtickvector_isbase) {
            qcpaxistickerlog_createsubtickvector_isbase = false;
            return QCPAxisTickerLog::createSubTickVector(subTickCount, ticks);
        } else if (qcpaxistickerlog_createsubtickvector_callback != nullptr) {
            int cbval1 = subTickCount;
            const QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval2 = ticks_out;

            libqt_list /* of double */ callback_ret = qcpaxistickerlog_createsubtickvector_callback(this, cbval1, cbval2);
            QVector<double> callback_ret_QVector;
            callback_ret_QVector.reserve(callback_ret.len);
            double* callback_ret_arr = static_cast<double*>(callback_ret.data);
            for (size_t i = 0; i < callback_ret.len; ++i) {
                callback_ret_QVector.push_back(static_cast<double>(callback_ret_arr[i]));
            }
            return callback_ret_QVector;
        } else {
            return QCPAxisTickerLog::createSubTickVector(subTickCount, ticks);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QVector<QString> createLabelVector(const QVector<double>& ticks, const QLocale& locale, QChar formatChar, int precision) override {
        if (qcpaxistickerlog_createlabelvector_isbase) {
            qcpaxistickerlog_createlabelvector_isbase = false;
            return QCPAxisTickerLog::createLabelVector(ticks, locale, formatChar, precision);
        } else if (qcpaxistickerlog_createlabelvector_callback != nullptr) {
            const QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval1 = ticks_out;
            const QLocale& locale_ret = locale;
            // Cast returned reference into pointer
            QLocale* cbval2 = const_cast<QLocale*>(&locale_ret);
            QChar* cbval3 = new QChar(formatChar);
            int cbval4 = precision;

            const char** callback_ret = qcpaxistickerlog_createlabelvector_callback(this, cbval1, cbval2, cbval3, cbval4);
            QVector<QString> callback_ret_QVector;
            size_t callback_ret_len = libqt_strv_length(callback_ret);
            callback_ret_QVector.reserve(callback_ret_len);
            const char** callback_ret_arr = static_cast<const char**>(callback_ret);
            for (size_t i = 0; i < callback_ret_len; ++i) {
                QString callback_ret_arr_i_QString = QString::fromUtf8(callback_ret_arr[i]);
                callback_ret_QVector.push_back(callback_ret_arr_i_QString);
            }
            return callback_ret_QVector;
        } else {
            return QCPAxisTickerLog::createLabelVector(ticks, locale, formatChar, precision);
        }
    }

    // Virtual method for C ABI access and custom callback
    void trimTicks(const QCPRange& range, QVector<double>& ticks, bool keepOneOutlier) const {
        if (qcpaxistickerlog_trimticks_isbase) {
            qcpaxistickerlog_trimticks_isbase = false;
            QCPAxisTickerLog::trimTicks(range, ticks, keepOneOutlier);
        } else if (qcpaxistickerlog_trimticks_callback != nullptr) {
            const QCPRange& range_ret = range;
            // Cast returned reference into pointer
            QCPRange* cbval1 = const_cast<QCPRange*>(&range_ret);
            QVector<double>& ticks_ret = ticks;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* ticks_arr = static_cast<double*>(malloc(sizeof(double) * (ticks_ret.size() + 1)));
            for (qsizetype i = 0; i < ticks_ret.size(); ++i) {
                ticks_arr[i] = ticks_ret[i];
            }
            libqt_list ticks_out;
            ticks_out.len = ticks_ret.size();
            ticks_out.data = static_cast<void*>(ticks_arr);
            libqt_list /* of double */ cbval2 = ticks_out;
            bool cbval3 = keepOneOutlier;

            qcpaxistickerlog_trimticks_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPAxisTickerLog::trimTicks(range, ticks, keepOneOutlier);
        }
    }

    // Virtual method for C ABI access and custom callback
    double pickClosest(double target, const QVector<double>& candidates) const {
        if (qcpaxistickerlog_pickclosest_isbase) {
            qcpaxistickerlog_pickclosest_isbase = false;
            return QCPAxisTickerLog::pickClosest(target, candidates);
        } else if (qcpaxistickerlog_pickclosest_callback != nullptr) {
            double cbval1 = target;
            const QVector<double>& candidates_ret = candidates;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* candidates_arr = static_cast<double*>(malloc(sizeof(double) * (candidates_ret.size() + 1)));
            for (qsizetype i = 0; i < candidates_ret.size(); ++i) {
                candidates_arr[i] = candidates_ret[i];
            }
            libqt_list candidates_out;
            candidates_out.len = candidates_ret.size();
            candidates_out.data = static_cast<void*>(candidates_arr);
            libqt_list /* of double */ cbval2 = candidates_out;

            double callback_ret = qcpaxistickerlog_pickclosest_callback(this, cbval1, cbval2);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTickerLog::pickClosest(target, candidates);
        }
    }

    // Virtual method for C ABI access and custom callback
    double getMantissa(double input) const {
        if (qcpaxistickerlog_getmantissa_isbase) {
            qcpaxistickerlog_getmantissa_isbase = false;
            return QCPAxisTickerLog::getMantissa(input);
        } else if (qcpaxistickerlog_getmantissa_callback != nullptr) {
            double cbval1 = input;

            double callback_ret = qcpaxistickerlog_getmantissa_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTickerLog::getMantissa(input);
        }
    }

    // Virtual method for C ABI access and custom callback
    double cleanMantissa(double input) const {
        if (qcpaxistickerlog_cleanmantissa_isbase) {
            qcpaxistickerlog_cleanmantissa_isbase = false;
            return QCPAxisTickerLog::cleanMantissa(input);
        } else if (qcpaxistickerlog_cleanmantissa_callback != nullptr) {
            double cbval1 = input;

            double callback_ret = qcpaxistickerlog_cleanmantissa_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisTickerLog::cleanMantissa(input);
        }
    }

    // Friend functions
    friend int QCPAxisTickerLog_GetSubTickCount(QCPAxisTickerLog* self, double tickStep);
    friend int QCPAxisTickerLog_QBaseGetSubTickCount(QCPAxisTickerLog* self, double tickStep);
    friend libqt_list /* of double */ QCPAxisTickerLog_CreateTickVector(QCPAxisTickerLog* self, double tickStep, const QCPRange* range);
    friend libqt_list /* of double */ QCPAxisTickerLog_QBaseCreateTickVector(QCPAxisTickerLog* self, double tickStep, const QCPRange* range);
    friend double QCPAxisTickerLog_GetTickStep(QCPAxisTickerLog* self, const QCPRange* range);
    friend double QCPAxisTickerLog_QBaseGetTickStep(QCPAxisTickerLog* self, const QCPRange* range);
    friend libqt_string QCPAxisTickerLog_GetTickLabel(QCPAxisTickerLog* self, double tick, const QLocale* locale, QChar* formatChar, int precision);
    friend libqt_string QCPAxisTickerLog_QBaseGetTickLabel(QCPAxisTickerLog* self, double tick, const QLocale* locale, QChar* formatChar, int precision);
    friend libqt_list /* of double */ QCPAxisTickerLog_CreateSubTickVector(QCPAxisTickerLog* self, int subTickCount, const libqt_list /* of double */ ticks);
    friend libqt_list /* of double */ QCPAxisTickerLog_QBaseCreateSubTickVector(QCPAxisTickerLog* self, int subTickCount, const libqt_list /* of double */ ticks);
    friend libqt_list /* of libqt_string */ QCPAxisTickerLog_CreateLabelVector(QCPAxisTickerLog* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision);
    friend libqt_list /* of libqt_string */ QCPAxisTickerLog_QBaseCreateLabelVector(QCPAxisTickerLog* self, const libqt_list /* of double */ ticks, const QLocale* locale, QChar* formatChar, int precision);
    friend void QCPAxisTickerLog_TrimTicks(const QCPAxisTickerLog* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier);
    friend void QCPAxisTickerLog_QBaseTrimTicks(const QCPAxisTickerLog* self, const QCPRange* range, libqt_list /* of double */ ticks, bool keepOneOutlier);
    friend double QCPAxisTickerLog_PickClosest(const QCPAxisTickerLog* self, double target, const libqt_list /* of double */ candidates);
    friend double QCPAxisTickerLog_QBasePickClosest(const QCPAxisTickerLog* self, double target, const libqt_list /* of double */ candidates);
    friend double QCPAxisTickerLog_GetMantissa(const QCPAxisTickerLog* self, double input);
    friend double QCPAxisTickerLog_QBaseGetMantissa(const QCPAxisTickerLog* self, double input);
    friend double QCPAxisTickerLog_CleanMantissa(const QCPAxisTickerLog* self, double input);
    friend double QCPAxisTickerLog_QBaseCleanMantissa(const QCPAxisTickerLog* self, double input);
};

// This class is a subclass of QCPGrid so that we can call protected methods
class VirtualQCPGrid final : public QCPGrid {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPGrid = true;

    // Virtual class public types (including callbacks)
    using QCPGrid_Metacall_Callback = int (*)(QCPGrid*, int, int, void**);
    using QCPGrid_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPGrid*, QCPPainter*);
    using QCPGrid_Draw_Callback = void (*)(QCPGrid*, QCPPainter*);
    using QCPGrid_SelectTest_Callback = double (*)(const QCPGrid*, QPointF*, bool, QVariant*);
    using QCPGrid_ParentPlotInitialized_Callback = void (*)(QCPGrid*, QCustomPlot*);
    using QCPGrid_SelectionCategory_Callback = int (*)();
    using QCPGrid_ClipRect_Callback = QRect* (*)();
    using QCPGrid_SelectEvent_Callback = void (*)(QCPGrid*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPGrid_DeselectEvent_Callback = void (*)(QCPGrid*, bool*);
    using QCPGrid_MousePressEvent_Callback = void (*)(QCPGrid*, QMouseEvent*, QVariant*);
    using QCPGrid_MouseMoveEvent_Callback = void (*)(QCPGrid*, QMouseEvent*, QPointF*);
    using QCPGrid_MouseReleaseEvent_Callback = void (*)(QCPGrid*, QMouseEvent*, QPointF*);
    using QCPGrid_MouseDoubleClickEvent_Callback = void (*)(QCPGrid*, QMouseEvent*, QVariant*);
    using QCPGrid_WheelEvent_Callback = void (*)(QCPGrid*, QWheelEvent*);
    using QCPGrid_Event_Callback = bool (*)(QCPGrid*, QEvent*);
    using QCPGrid_EventFilter_Callback = bool (*)(QCPGrid*, QObject*, QEvent*);
    using QCPGrid_TimerEvent_Callback = void (*)(QCPGrid*, QTimerEvent*);
    using QCPGrid_ChildEvent_Callback = void (*)(QCPGrid*, QChildEvent*);
    using QCPGrid_CustomEvent_Callback = void (*)(QCPGrid*, QEvent*);
    using QCPGrid_ConnectNotify_Callback = void (*)(QCPGrid*, QMetaMethod*);
    using QCPGrid_DisconnectNotify_Callback = void (*)(QCPGrid*, QMetaMethod*);
    using QCPGrid_DrawGridLines_Callback = void (*)(const QCPGrid*, QCPPainter*);
    using QCPGrid_DrawSubGridLines_Callback = void (*)(const QCPGrid*, QCPPainter*);
    using QCPGrid_InitializeParentPlot_Callback = void (*)(QCPGrid*, QCustomPlot*);
    using QCPGrid_SetParentLayerable_Callback = void (*)(QCPGrid*, QCPLayerable*);
    using QCPGrid_MoveToLayer_Callback = bool (*)(QCPGrid*, QCPLayer*, bool);
    using QCPGrid_ApplyAntialiasingHint_Callback = void (*)(const QCPGrid*, QCPPainter*, bool, int);
    using QCPGrid_Sender_Callback = QObject* (*)();
    using QCPGrid_SenderSignalIndex_Callback = int (*)();
    using QCPGrid_Receivers_Callback = int (*)(const QCPGrid*, const char*);
    using QCPGrid_IsSignalConnected_Callback = bool (*)(const QCPGrid*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPGrid_Metacall_Callback qcpgrid_metacall_callback = nullptr;
    QCPGrid_ApplyDefaultAntialiasingHint_Callback qcpgrid_applydefaultantialiasinghint_callback = nullptr;
    QCPGrid_Draw_Callback qcpgrid_draw_callback = nullptr;
    QCPGrid_SelectTest_Callback qcpgrid_selecttest_callback = nullptr;
    QCPGrid_ParentPlotInitialized_Callback qcpgrid_parentplotinitialized_callback = nullptr;
    QCPGrid_SelectionCategory_Callback qcpgrid_selectioncategory_callback = nullptr;
    QCPGrid_ClipRect_Callback qcpgrid_cliprect_callback = nullptr;
    QCPGrid_SelectEvent_Callback qcpgrid_selectevent_callback = nullptr;
    QCPGrid_DeselectEvent_Callback qcpgrid_deselectevent_callback = nullptr;
    QCPGrid_MousePressEvent_Callback qcpgrid_mousepressevent_callback = nullptr;
    QCPGrid_MouseMoveEvent_Callback qcpgrid_mousemoveevent_callback = nullptr;
    QCPGrid_MouseReleaseEvent_Callback qcpgrid_mousereleaseevent_callback = nullptr;
    QCPGrid_MouseDoubleClickEvent_Callback qcpgrid_mousedoubleclickevent_callback = nullptr;
    QCPGrid_WheelEvent_Callback qcpgrid_wheelevent_callback = nullptr;
    QCPGrid_Event_Callback qcpgrid_event_callback = nullptr;
    QCPGrid_EventFilter_Callback qcpgrid_eventfilter_callback = nullptr;
    QCPGrid_TimerEvent_Callback qcpgrid_timerevent_callback = nullptr;
    QCPGrid_ChildEvent_Callback qcpgrid_childevent_callback = nullptr;
    QCPGrid_CustomEvent_Callback qcpgrid_customevent_callback = nullptr;
    QCPGrid_ConnectNotify_Callback qcpgrid_connectnotify_callback = nullptr;
    QCPGrid_DisconnectNotify_Callback qcpgrid_disconnectnotify_callback = nullptr;
    QCPGrid_DrawGridLines_Callback qcpgrid_drawgridlines_callback = nullptr;
    QCPGrid_DrawSubGridLines_Callback qcpgrid_drawsubgridlines_callback = nullptr;
    QCPGrid_InitializeParentPlot_Callback qcpgrid_initializeparentplot_callback = nullptr;
    QCPGrid_SetParentLayerable_Callback qcpgrid_setparentlayerable_callback = nullptr;
    QCPGrid_MoveToLayer_Callback qcpgrid_movetolayer_callback = nullptr;
    QCPGrid_ApplyAntialiasingHint_Callback qcpgrid_applyantialiasinghint_callback = nullptr;
    QCPGrid_Sender_Callback qcpgrid_sender_callback = nullptr;
    QCPGrid_SenderSignalIndex_Callback qcpgrid_sendersignalindex_callback = nullptr;
    QCPGrid_Receivers_Callback qcpgrid_receivers_callback = nullptr;
    QCPGrid_IsSignalConnected_Callback qcpgrid_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpgrid_metacall_isbase = false;
    mutable bool qcpgrid_applydefaultantialiasinghint_isbase = false;
    mutable bool qcpgrid_draw_isbase = false;
    mutable bool qcpgrid_selecttest_isbase = false;
    mutable bool qcpgrid_parentplotinitialized_isbase = false;
    mutable bool qcpgrid_selectioncategory_isbase = false;
    mutable bool qcpgrid_cliprect_isbase = false;
    mutable bool qcpgrid_selectevent_isbase = false;
    mutable bool qcpgrid_deselectevent_isbase = false;
    mutable bool qcpgrid_mousepressevent_isbase = false;
    mutable bool qcpgrid_mousemoveevent_isbase = false;
    mutable bool qcpgrid_mousereleaseevent_isbase = false;
    mutable bool qcpgrid_mousedoubleclickevent_isbase = false;
    mutable bool qcpgrid_wheelevent_isbase = false;
    mutable bool qcpgrid_event_isbase = false;
    mutable bool qcpgrid_eventfilter_isbase = false;
    mutable bool qcpgrid_timerevent_isbase = false;
    mutable bool qcpgrid_childevent_isbase = false;
    mutable bool qcpgrid_customevent_isbase = false;
    mutable bool qcpgrid_connectnotify_isbase = false;
    mutable bool qcpgrid_disconnectnotify_isbase = false;
    mutable bool qcpgrid_drawgridlines_isbase = false;
    mutable bool qcpgrid_drawsubgridlines_isbase = false;
    mutable bool qcpgrid_initializeparentplot_isbase = false;
    mutable bool qcpgrid_setparentlayerable_isbase = false;
    mutable bool qcpgrid_movetolayer_isbase = false;
    mutable bool qcpgrid_applyantialiasinghint_isbase = false;
    mutable bool qcpgrid_sender_isbase = false;
    mutable bool qcpgrid_sendersignalindex_isbase = false;
    mutable bool qcpgrid_receivers_isbase = false;
    mutable bool qcpgrid_issignalconnected_isbase = false;

  public:
    VirtualQCPGrid(QCPAxis* parentAxis) : QCPGrid(parentAxis) {};

    ~VirtualQCPGrid() {
        qcpgrid_metacall_callback = nullptr;
        qcpgrid_applydefaultantialiasinghint_callback = nullptr;
        qcpgrid_draw_callback = nullptr;
        qcpgrid_selecttest_callback = nullptr;
        qcpgrid_parentplotinitialized_callback = nullptr;
        qcpgrid_selectioncategory_callback = nullptr;
        qcpgrid_cliprect_callback = nullptr;
        qcpgrid_selectevent_callback = nullptr;
        qcpgrid_deselectevent_callback = nullptr;
        qcpgrid_mousepressevent_callback = nullptr;
        qcpgrid_mousemoveevent_callback = nullptr;
        qcpgrid_mousereleaseevent_callback = nullptr;
        qcpgrid_mousedoubleclickevent_callback = nullptr;
        qcpgrid_wheelevent_callback = nullptr;
        qcpgrid_event_callback = nullptr;
        qcpgrid_eventfilter_callback = nullptr;
        qcpgrid_timerevent_callback = nullptr;
        qcpgrid_childevent_callback = nullptr;
        qcpgrid_customevent_callback = nullptr;
        qcpgrid_connectnotify_callback = nullptr;
        qcpgrid_disconnectnotify_callback = nullptr;
        qcpgrid_drawgridlines_callback = nullptr;
        qcpgrid_drawsubgridlines_callback = nullptr;
        qcpgrid_initializeparentplot_callback = nullptr;
        qcpgrid_setparentlayerable_callback = nullptr;
        qcpgrid_movetolayer_callback = nullptr;
        qcpgrid_applyantialiasinghint_callback = nullptr;
        qcpgrid_sender_callback = nullptr;
        qcpgrid_sendersignalindex_callback = nullptr;
        qcpgrid_receivers_callback = nullptr;
        qcpgrid_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPGrid_Metacall_Callback(QCPGrid_Metacall_Callback cb) { qcpgrid_metacall_callback = cb; }
    inline void setQCPGrid_ApplyDefaultAntialiasingHint_Callback(QCPGrid_ApplyDefaultAntialiasingHint_Callback cb) { qcpgrid_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPGrid_Draw_Callback(QCPGrid_Draw_Callback cb) { qcpgrid_draw_callback = cb; }
    inline void setQCPGrid_SelectTest_Callback(QCPGrid_SelectTest_Callback cb) { qcpgrid_selecttest_callback = cb; }
    inline void setQCPGrid_ParentPlotInitialized_Callback(QCPGrid_ParentPlotInitialized_Callback cb) { qcpgrid_parentplotinitialized_callback = cb; }
    inline void setQCPGrid_SelectionCategory_Callback(QCPGrid_SelectionCategory_Callback cb) { qcpgrid_selectioncategory_callback = cb; }
    inline void setQCPGrid_ClipRect_Callback(QCPGrid_ClipRect_Callback cb) { qcpgrid_cliprect_callback = cb; }
    inline void setQCPGrid_SelectEvent_Callback(QCPGrid_SelectEvent_Callback cb) { qcpgrid_selectevent_callback = cb; }
    inline void setQCPGrid_DeselectEvent_Callback(QCPGrid_DeselectEvent_Callback cb) { qcpgrid_deselectevent_callback = cb; }
    inline void setQCPGrid_MousePressEvent_Callback(QCPGrid_MousePressEvent_Callback cb) { qcpgrid_mousepressevent_callback = cb; }
    inline void setQCPGrid_MouseMoveEvent_Callback(QCPGrid_MouseMoveEvent_Callback cb) { qcpgrid_mousemoveevent_callback = cb; }
    inline void setQCPGrid_MouseReleaseEvent_Callback(QCPGrid_MouseReleaseEvent_Callback cb) { qcpgrid_mousereleaseevent_callback = cb; }
    inline void setQCPGrid_MouseDoubleClickEvent_Callback(QCPGrid_MouseDoubleClickEvent_Callback cb) { qcpgrid_mousedoubleclickevent_callback = cb; }
    inline void setQCPGrid_WheelEvent_Callback(QCPGrid_WheelEvent_Callback cb) { qcpgrid_wheelevent_callback = cb; }
    inline void setQCPGrid_Event_Callback(QCPGrid_Event_Callback cb) { qcpgrid_event_callback = cb; }
    inline void setQCPGrid_EventFilter_Callback(QCPGrid_EventFilter_Callback cb) { qcpgrid_eventfilter_callback = cb; }
    inline void setQCPGrid_TimerEvent_Callback(QCPGrid_TimerEvent_Callback cb) { qcpgrid_timerevent_callback = cb; }
    inline void setQCPGrid_ChildEvent_Callback(QCPGrid_ChildEvent_Callback cb) { qcpgrid_childevent_callback = cb; }
    inline void setQCPGrid_CustomEvent_Callback(QCPGrid_CustomEvent_Callback cb) { qcpgrid_customevent_callback = cb; }
    inline void setQCPGrid_ConnectNotify_Callback(QCPGrid_ConnectNotify_Callback cb) { qcpgrid_connectnotify_callback = cb; }
    inline void setQCPGrid_DisconnectNotify_Callback(QCPGrid_DisconnectNotify_Callback cb) { qcpgrid_disconnectnotify_callback = cb; }
    inline void setQCPGrid_DrawGridLines_Callback(QCPGrid_DrawGridLines_Callback cb) { qcpgrid_drawgridlines_callback = cb; }
    inline void setQCPGrid_DrawSubGridLines_Callback(QCPGrid_DrawSubGridLines_Callback cb) { qcpgrid_drawsubgridlines_callback = cb; }
    inline void setQCPGrid_InitializeParentPlot_Callback(QCPGrid_InitializeParentPlot_Callback cb) { qcpgrid_initializeparentplot_callback = cb; }
    inline void setQCPGrid_SetParentLayerable_Callback(QCPGrid_SetParentLayerable_Callback cb) { qcpgrid_setparentlayerable_callback = cb; }
    inline void setQCPGrid_MoveToLayer_Callback(QCPGrid_MoveToLayer_Callback cb) { qcpgrid_movetolayer_callback = cb; }
    inline void setQCPGrid_ApplyAntialiasingHint_Callback(QCPGrid_ApplyAntialiasingHint_Callback cb) { qcpgrid_applyantialiasinghint_callback = cb; }
    inline void setQCPGrid_Sender_Callback(QCPGrid_Sender_Callback cb) { qcpgrid_sender_callback = cb; }
    inline void setQCPGrid_SenderSignalIndex_Callback(QCPGrid_SenderSignalIndex_Callback cb) { qcpgrid_sendersignalindex_callback = cb; }
    inline void setQCPGrid_Receivers_Callback(QCPGrid_Receivers_Callback cb) { qcpgrid_receivers_callback = cb; }
    inline void setQCPGrid_IsSignalConnected_Callback(QCPGrid_IsSignalConnected_Callback cb) { qcpgrid_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPGrid_Metacall_IsBase(bool value) const { qcpgrid_metacall_isbase = value; }
    inline void setQCPGrid_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcpgrid_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPGrid_Draw_IsBase(bool value) const { qcpgrid_draw_isbase = value; }
    inline void setQCPGrid_SelectTest_IsBase(bool value) const { qcpgrid_selecttest_isbase = value; }
    inline void setQCPGrid_ParentPlotInitialized_IsBase(bool value) const { qcpgrid_parentplotinitialized_isbase = value; }
    inline void setQCPGrid_SelectionCategory_IsBase(bool value) const { qcpgrid_selectioncategory_isbase = value; }
    inline void setQCPGrid_ClipRect_IsBase(bool value) const { qcpgrid_cliprect_isbase = value; }
    inline void setQCPGrid_SelectEvent_IsBase(bool value) const { qcpgrid_selectevent_isbase = value; }
    inline void setQCPGrid_DeselectEvent_IsBase(bool value) const { qcpgrid_deselectevent_isbase = value; }
    inline void setQCPGrid_MousePressEvent_IsBase(bool value) const { qcpgrid_mousepressevent_isbase = value; }
    inline void setQCPGrid_MouseMoveEvent_IsBase(bool value) const { qcpgrid_mousemoveevent_isbase = value; }
    inline void setQCPGrid_MouseReleaseEvent_IsBase(bool value) const { qcpgrid_mousereleaseevent_isbase = value; }
    inline void setQCPGrid_MouseDoubleClickEvent_IsBase(bool value) const { qcpgrid_mousedoubleclickevent_isbase = value; }
    inline void setQCPGrid_WheelEvent_IsBase(bool value) const { qcpgrid_wheelevent_isbase = value; }
    inline void setQCPGrid_Event_IsBase(bool value) const { qcpgrid_event_isbase = value; }
    inline void setQCPGrid_EventFilter_IsBase(bool value) const { qcpgrid_eventfilter_isbase = value; }
    inline void setQCPGrid_TimerEvent_IsBase(bool value) const { qcpgrid_timerevent_isbase = value; }
    inline void setQCPGrid_ChildEvent_IsBase(bool value) const { qcpgrid_childevent_isbase = value; }
    inline void setQCPGrid_CustomEvent_IsBase(bool value) const { qcpgrid_customevent_isbase = value; }
    inline void setQCPGrid_ConnectNotify_IsBase(bool value) const { qcpgrid_connectnotify_isbase = value; }
    inline void setQCPGrid_DisconnectNotify_IsBase(bool value) const { qcpgrid_disconnectnotify_isbase = value; }
    inline void setQCPGrid_DrawGridLines_IsBase(bool value) const { qcpgrid_drawgridlines_isbase = value; }
    inline void setQCPGrid_DrawSubGridLines_IsBase(bool value) const { qcpgrid_drawsubgridlines_isbase = value; }
    inline void setQCPGrid_InitializeParentPlot_IsBase(bool value) const { qcpgrid_initializeparentplot_isbase = value; }
    inline void setQCPGrid_SetParentLayerable_IsBase(bool value) const { qcpgrid_setparentlayerable_isbase = value; }
    inline void setQCPGrid_MoveToLayer_IsBase(bool value) const { qcpgrid_movetolayer_isbase = value; }
    inline void setQCPGrid_ApplyAntialiasingHint_IsBase(bool value) const { qcpgrid_applyantialiasinghint_isbase = value; }
    inline void setQCPGrid_Sender_IsBase(bool value) const { qcpgrid_sender_isbase = value; }
    inline void setQCPGrid_SenderSignalIndex_IsBase(bool value) const { qcpgrid_sendersignalindex_isbase = value; }
    inline void setQCPGrid_Receivers_IsBase(bool value) const { qcpgrid_receivers_isbase = value; }
    inline void setQCPGrid_IsSignalConnected_IsBase(bool value) const { qcpgrid_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpgrid_metacall_isbase) {
            qcpgrid_metacall_isbase = false;
            return QCPGrid::qt_metacall(param1, param2, param3);
        } else if (qcpgrid_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpgrid_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPGrid::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcpgrid_applydefaultantialiasinghint_isbase) {
            qcpgrid_applydefaultantialiasinghint_isbase = false;
            QCPGrid::applyDefaultAntialiasingHint(painter);
        } else if (qcpgrid_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpgrid_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPGrid::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcpgrid_draw_isbase) {
            qcpgrid_draw_isbase = false;
            QCPGrid::draw(painter);
        } else if (qcpgrid_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpgrid_draw_callback(this, cbval1);
        } else {
            QCPGrid::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcpgrid_selecttest_isbase) {
            qcpgrid_selecttest_isbase = false;
            return QCPGrid::selectTest(pos, onlySelectable, details);
        } else if (qcpgrid_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcpgrid_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPGrid::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcpgrid_parentplotinitialized_isbase) {
            qcpgrid_parentplotinitialized_isbase = false;
            QCPGrid::parentPlotInitialized(parentPlot);
        } else if (qcpgrid_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpgrid_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPGrid::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcpgrid_selectioncategory_isbase) {
            qcpgrid_selectioncategory_isbase = false;
            return QCPGrid::selectionCategory();
        } else if (qcpgrid_selectioncategory_callback != nullptr) {
            int callback_ret = qcpgrid_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPGrid::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcpgrid_cliprect_isbase) {
            qcpgrid_cliprect_isbase = false;
            return QCPGrid::clipRect();
        } else if (qcpgrid_cliprect_callback != nullptr) {
            QRect* callback_ret = qcpgrid_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPGrid::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcpgrid_selectevent_isbase) {
            qcpgrid_selectevent_isbase = false;
            QCPGrid::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcpgrid_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcpgrid_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPGrid::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcpgrid_deselectevent_isbase) {
            qcpgrid_deselectevent_isbase = false;
            QCPGrid::deselectEvent(selectionStateChanged);
        } else if (qcpgrid_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcpgrid_deselectevent_callback(this, cbval1);
        } else {
            QCPGrid::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpgrid_mousepressevent_isbase) {
            qcpgrid_mousepressevent_isbase = false;
            QCPGrid::mousePressEvent(event, details);
        } else if (qcpgrid_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpgrid_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPGrid::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpgrid_mousemoveevent_isbase) {
            qcpgrid_mousemoveevent_isbase = false;
            QCPGrid::mouseMoveEvent(event, startPos);
        } else if (qcpgrid_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpgrid_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPGrid::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpgrid_mousereleaseevent_isbase) {
            qcpgrid_mousereleaseevent_isbase = false;
            QCPGrid::mouseReleaseEvent(event, startPos);
        } else if (qcpgrid_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpgrid_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPGrid::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpgrid_mousedoubleclickevent_isbase) {
            qcpgrid_mousedoubleclickevent_isbase = false;
            QCPGrid::mouseDoubleClickEvent(event, details);
        } else if (qcpgrid_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpgrid_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPGrid::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcpgrid_wheelevent_isbase) {
            qcpgrid_wheelevent_isbase = false;
            QCPGrid::wheelEvent(event);
        } else if (qcpgrid_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcpgrid_wheelevent_callback(this, cbval1);
        } else {
            QCPGrid::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpgrid_event_isbase) {
            qcpgrid_event_isbase = false;
            return QCPGrid::event(event);
        } else if (qcpgrid_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpgrid_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPGrid::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpgrid_eventfilter_isbase) {
            qcpgrid_eventfilter_isbase = false;
            return QCPGrid::eventFilter(watched, event);
        } else if (qcpgrid_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpgrid_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPGrid::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpgrid_timerevent_isbase) {
            qcpgrid_timerevent_isbase = false;
            QCPGrid::timerEvent(event);
        } else if (qcpgrid_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpgrid_timerevent_callback(this, cbval1);
        } else {
            QCPGrid::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpgrid_childevent_isbase) {
            qcpgrid_childevent_isbase = false;
            QCPGrid::childEvent(event);
        } else if (qcpgrid_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpgrid_childevent_callback(this, cbval1);
        } else {
            QCPGrid::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpgrid_customevent_isbase) {
            qcpgrid_customevent_isbase = false;
            QCPGrid::customEvent(event);
        } else if (qcpgrid_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpgrid_customevent_callback(this, cbval1);
        } else {
            QCPGrid::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpgrid_connectnotify_isbase) {
            qcpgrid_connectnotify_isbase = false;
            QCPGrid::connectNotify(signal);
        } else if (qcpgrid_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpgrid_connectnotify_callback(this, cbval1);
        } else {
            QCPGrid::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpgrid_disconnectnotify_isbase) {
            qcpgrid_disconnectnotify_isbase = false;
            QCPGrid::disconnectNotify(signal);
        } else if (qcpgrid_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpgrid_disconnectnotify_callback(this, cbval1);
        } else {
            QCPGrid::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    void drawGridLines(QCPPainter* painter) const {
        if (qcpgrid_drawgridlines_isbase) {
            qcpgrid_drawgridlines_isbase = false;
            QCPGrid::drawGridLines(painter);
        } else if (qcpgrid_drawgridlines_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpgrid_drawgridlines_callback(this, cbval1);
        } else {
            QCPGrid::drawGridLines(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    void drawSubGridLines(QCPPainter* painter) const {
        if (qcpgrid_drawsubgridlines_isbase) {
            qcpgrid_drawsubgridlines_isbase = false;
            QCPGrid::drawSubGridLines(painter);
        } else if (qcpgrid_drawsubgridlines_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpgrid_drawsubgridlines_callback(this, cbval1);
        } else {
            QCPGrid::drawSubGridLines(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcpgrid_initializeparentplot_isbase) {
            qcpgrid_initializeparentplot_isbase = false;
            QCPGrid::initializeParentPlot(parentPlot);
        } else if (qcpgrid_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpgrid_initializeparentplot_callback(this, cbval1);
        } else {
            QCPGrid::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcpgrid_setparentlayerable_isbase) {
            qcpgrid_setparentlayerable_isbase = false;
            QCPGrid::setParentLayerable(parentLayerable);
        } else if (qcpgrid_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcpgrid_setparentlayerable_callback(this, cbval1);
        } else {
            QCPGrid::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcpgrid_movetolayer_isbase) {
            qcpgrid_movetolayer_isbase = false;
            return QCPGrid::moveToLayer(layer, prepend);
        } else if (qcpgrid_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcpgrid_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPGrid::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcpgrid_applyantialiasinghint_isbase) {
            qcpgrid_applyantialiasinghint_isbase = false;
            QCPGrid::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcpgrid_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcpgrid_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPGrid::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpgrid_sender_isbase) {
            qcpgrid_sender_isbase = false;
            return QCPGrid::sender();
        } else if (qcpgrid_sender_callback != nullptr) {
            QObject* callback_ret = qcpgrid_sender_callback();
            return callback_ret;
        } else {
            return QCPGrid::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpgrid_sendersignalindex_isbase) {
            qcpgrid_sendersignalindex_isbase = false;
            return QCPGrid::senderSignalIndex();
        } else if (qcpgrid_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpgrid_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPGrid::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpgrid_receivers_isbase) {
            qcpgrid_receivers_isbase = false;
            return QCPGrid::receivers(signal);
        } else if (qcpgrid_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpgrid_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPGrid::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpgrid_issignalconnected_isbase) {
            qcpgrid_issignalconnected_isbase = false;
            return QCPGrid::isSignalConnected(signal);
        } else if (qcpgrid_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpgrid_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPGrid::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPGrid_ApplyDefaultAntialiasingHint(const QCPGrid* self, QCPPainter* painter);
    friend void QCPGrid_QBaseApplyDefaultAntialiasingHint(const QCPGrid* self, QCPPainter* painter);
    friend void QCPGrid_Draw(QCPGrid* self, QCPPainter* painter);
    friend void QCPGrid_QBaseDraw(QCPGrid* self, QCPPainter* painter);
    friend void QCPGrid_ParentPlotInitialized(QCPGrid* self, QCustomPlot* parentPlot);
    friend void QCPGrid_QBaseParentPlotInitialized(QCPGrid* self, QCustomPlot* parentPlot);
    friend int QCPGrid_SelectionCategory(const QCPGrid* self);
    friend int QCPGrid_QBaseSelectionCategory(const QCPGrid* self);
    friend QRect* QCPGrid_ClipRect(const QCPGrid* self);
    friend QRect* QCPGrid_QBaseClipRect(const QCPGrid* self);
    friend void QCPGrid_SelectEvent(QCPGrid* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPGrid_QBaseSelectEvent(QCPGrid* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPGrid_DeselectEvent(QCPGrid* self, bool* selectionStateChanged);
    friend void QCPGrid_QBaseDeselectEvent(QCPGrid* self, bool* selectionStateChanged);
    friend void QCPGrid_MousePressEvent(QCPGrid* self, QMouseEvent* event, const QVariant* details);
    friend void QCPGrid_QBaseMousePressEvent(QCPGrid* self, QMouseEvent* event, const QVariant* details);
    friend void QCPGrid_MouseMoveEvent(QCPGrid* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPGrid_QBaseMouseMoveEvent(QCPGrid* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPGrid_MouseReleaseEvent(QCPGrid* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPGrid_QBaseMouseReleaseEvent(QCPGrid* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPGrid_MouseDoubleClickEvent(QCPGrid* self, QMouseEvent* event, const QVariant* details);
    friend void QCPGrid_QBaseMouseDoubleClickEvent(QCPGrid* self, QMouseEvent* event, const QVariant* details);
    friend void QCPGrid_WheelEvent(QCPGrid* self, QWheelEvent* event);
    friend void QCPGrid_QBaseWheelEvent(QCPGrid* self, QWheelEvent* event);
    friend void QCPGrid_TimerEvent(QCPGrid* self, QTimerEvent* event);
    friend void QCPGrid_QBaseTimerEvent(QCPGrid* self, QTimerEvent* event);
    friend void QCPGrid_ChildEvent(QCPGrid* self, QChildEvent* event);
    friend void QCPGrid_QBaseChildEvent(QCPGrid* self, QChildEvent* event);
    friend void QCPGrid_CustomEvent(QCPGrid* self, QEvent* event);
    friend void QCPGrid_QBaseCustomEvent(QCPGrid* self, QEvent* event);
    friend void QCPGrid_ConnectNotify(QCPGrid* self, const QMetaMethod* signal);
    friend void QCPGrid_QBaseConnectNotify(QCPGrid* self, const QMetaMethod* signal);
    friend void QCPGrid_DisconnectNotify(QCPGrid* self, const QMetaMethod* signal);
    friend void QCPGrid_QBaseDisconnectNotify(QCPGrid* self, const QMetaMethod* signal);
    friend void QCPGrid_DrawGridLines(const QCPGrid* self, QCPPainter* painter);
    friend void QCPGrid_QBaseDrawGridLines(const QCPGrid* self, QCPPainter* painter);
    friend void QCPGrid_DrawSubGridLines(const QCPGrid* self, QCPPainter* painter);
    friend void QCPGrid_QBaseDrawSubGridLines(const QCPGrid* self, QCPPainter* painter);
    friend void QCPGrid_InitializeParentPlot(QCPGrid* self, QCustomPlot* parentPlot);
    friend void QCPGrid_QBaseInitializeParentPlot(QCPGrid* self, QCustomPlot* parentPlot);
    friend void QCPGrid_SetParentLayerable(QCPGrid* self, QCPLayerable* parentLayerable);
    friend void QCPGrid_QBaseSetParentLayerable(QCPGrid* self, QCPLayerable* parentLayerable);
    friend bool QCPGrid_MoveToLayer(QCPGrid* self, QCPLayer* layer, bool prepend);
    friend bool QCPGrid_QBaseMoveToLayer(QCPGrid* self, QCPLayer* layer, bool prepend);
    friend void QCPGrid_ApplyAntialiasingHint(const QCPGrid* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPGrid_QBaseApplyAntialiasingHint(const QCPGrid* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPGrid_Sender(const QCPGrid* self);
    friend QObject* QCPGrid_QBaseSender(const QCPGrid* self);
    friend int QCPGrid_SenderSignalIndex(const QCPGrid* self);
    friend int QCPGrid_QBaseSenderSignalIndex(const QCPGrid* self);
    friend int QCPGrid_Receivers(const QCPGrid* self, const char* signal);
    friend int QCPGrid_QBaseReceivers(const QCPGrid* self, const char* signal);
    friend bool QCPGrid_IsSignalConnected(const QCPGrid* self, const QMetaMethod* signal);
    friend bool QCPGrid_QBaseIsSignalConnected(const QCPGrid* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPAxis so that we can call protected methods
class VirtualQCPAxis final : public QCPAxis {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPAxis = true;

    // Virtual class public types (including callbacks)
    using QCPAxis_Metacall_Callback = int (*)(QCPAxis*, int, int, void**);
    using QCPAxis_SelectTest_Callback = double (*)(const QCPAxis*, QPointF*, bool, QVariant*);
    using QCPAxis_CalculateMargin_Callback = int (*)();
    using QCPAxis_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPAxis*, QCPPainter*);
    using QCPAxis_Draw_Callback = void (*)(QCPAxis*, QCPPainter*);
    using QCPAxis_SelectionCategory_Callback = int (*)();
    using QCPAxis_SelectEvent_Callback = void (*)(QCPAxis*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPAxis_DeselectEvent_Callback = void (*)(QCPAxis*, bool*);
    using QCPAxis_MousePressEvent_Callback = void (*)(QCPAxis*, QMouseEvent*, QVariant*);
    using QCPAxis_MouseMoveEvent_Callback = void (*)(QCPAxis*, QMouseEvent*, QPointF*);
    using QCPAxis_MouseReleaseEvent_Callback = void (*)(QCPAxis*, QMouseEvent*, QPointF*);
    using QCPAxis_WheelEvent_Callback = void (*)(QCPAxis*, QWheelEvent*);
    using QCPAxis_ParentPlotInitialized_Callback = void (*)(QCPAxis*, QCustomPlot*);
    using QCPAxis_ClipRect_Callback = QRect* (*)();
    using QCPAxis_MouseDoubleClickEvent_Callback = void (*)(QCPAxis*, QMouseEvent*, QVariant*);
    using QCPAxis_Event_Callback = bool (*)(QCPAxis*, QEvent*);
    using QCPAxis_EventFilter_Callback = bool (*)(QCPAxis*, QObject*, QEvent*);
    using QCPAxis_TimerEvent_Callback = void (*)(QCPAxis*, QTimerEvent*);
    using QCPAxis_ChildEvent_Callback = void (*)(QCPAxis*, QChildEvent*);
    using QCPAxis_CustomEvent_Callback = void (*)(QCPAxis*, QEvent*);
    using QCPAxis_ConnectNotify_Callback = void (*)(QCPAxis*, QMetaMethod*);
    using QCPAxis_DisconnectNotify_Callback = void (*)(QCPAxis*, QMetaMethod*);
    using QCPAxis_SetupTickVectors_Callback = void (*)();
    using QCPAxis_GetBasePen_Callback = QPen* (*)();
    using QCPAxis_GetTickPen_Callback = QPen* (*)();
    using QCPAxis_GetSubTickPen_Callback = QPen* (*)();
    using QCPAxis_GetTickLabelFont_Callback = QFont* (*)();
    using QCPAxis_GetLabelFont_Callback = QFont* (*)();
    using QCPAxis_GetTickLabelColor_Callback = QColor* (*)();
    using QCPAxis_GetLabelColor_Callback = QColor* (*)();
    using QCPAxis_InitializeParentPlot_Callback = void (*)(QCPAxis*, QCustomPlot*);
    using QCPAxis_SetParentLayerable_Callback = void (*)(QCPAxis*, QCPLayerable*);
    using QCPAxis_MoveToLayer_Callback = bool (*)(QCPAxis*, QCPLayer*, bool);
    using QCPAxis_ApplyAntialiasingHint_Callback = void (*)(const QCPAxis*, QCPPainter*, bool, int);
    using QCPAxis_Sender_Callback = QObject* (*)();
    using QCPAxis_SenderSignalIndex_Callback = int (*)();
    using QCPAxis_Receivers_Callback = int (*)(const QCPAxis*, const char*);
    using QCPAxis_IsSignalConnected_Callback = bool (*)(const QCPAxis*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPAxis_Metacall_Callback qcpaxis_metacall_callback = nullptr;
    QCPAxis_SelectTest_Callback qcpaxis_selecttest_callback = nullptr;
    QCPAxis_CalculateMargin_Callback qcpaxis_calculatemargin_callback = nullptr;
    QCPAxis_ApplyDefaultAntialiasingHint_Callback qcpaxis_applydefaultantialiasinghint_callback = nullptr;
    QCPAxis_Draw_Callback qcpaxis_draw_callback = nullptr;
    QCPAxis_SelectionCategory_Callback qcpaxis_selectioncategory_callback = nullptr;
    QCPAxis_SelectEvent_Callback qcpaxis_selectevent_callback = nullptr;
    QCPAxis_DeselectEvent_Callback qcpaxis_deselectevent_callback = nullptr;
    QCPAxis_MousePressEvent_Callback qcpaxis_mousepressevent_callback = nullptr;
    QCPAxis_MouseMoveEvent_Callback qcpaxis_mousemoveevent_callback = nullptr;
    QCPAxis_MouseReleaseEvent_Callback qcpaxis_mousereleaseevent_callback = nullptr;
    QCPAxis_WheelEvent_Callback qcpaxis_wheelevent_callback = nullptr;
    QCPAxis_ParentPlotInitialized_Callback qcpaxis_parentplotinitialized_callback = nullptr;
    QCPAxis_ClipRect_Callback qcpaxis_cliprect_callback = nullptr;
    QCPAxis_MouseDoubleClickEvent_Callback qcpaxis_mousedoubleclickevent_callback = nullptr;
    QCPAxis_Event_Callback qcpaxis_event_callback = nullptr;
    QCPAxis_EventFilter_Callback qcpaxis_eventfilter_callback = nullptr;
    QCPAxis_TimerEvent_Callback qcpaxis_timerevent_callback = nullptr;
    QCPAxis_ChildEvent_Callback qcpaxis_childevent_callback = nullptr;
    QCPAxis_CustomEvent_Callback qcpaxis_customevent_callback = nullptr;
    QCPAxis_ConnectNotify_Callback qcpaxis_connectnotify_callback = nullptr;
    QCPAxis_DisconnectNotify_Callback qcpaxis_disconnectnotify_callback = nullptr;
    QCPAxis_SetupTickVectors_Callback qcpaxis_setuptickvectors_callback = nullptr;
    QCPAxis_GetBasePen_Callback qcpaxis_getbasepen_callback = nullptr;
    QCPAxis_GetTickPen_Callback qcpaxis_gettickpen_callback = nullptr;
    QCPAxis_GetSubTickPen_Callback qcpaxis_getsubtickpen_callback = nullptr;
    QCPAxis_GetTickLabelFont_Callback qcpaxis_getticklabelfont_callback = nullptr;
    QCPAxis_GetLabelFont_Callback qcpaxis_getlabelfont_callback = nullptr;
    QCPAxis_GetTickLabelColor_Callback qcpaxis_getticklabelcolor_callback = nullptr;
    QCPAxis_GetLabelColor_Callback qcpaxis_getlabelcolor_callback = nullptr;
    QCPAxis_InitializeParentPlot_Callback qcpaxis_initializeparentplot_callback = nullptr;
    QCPAxis_SetParentLayerable_Callback qcpaxis_setparentlayerable_callback = nullptr;
    QCPAxis_MoveToLayer_Callback qcpaxis_movetolayer_callback = nullptr;
    QCPAxis_ApplyAntialiasingHint_Callback qcpaxis_applyantialiasinghint_callback = nullptr;
    QCPAxis_Sender_Callback qcpaxis_sender_callback = nullptr;
    QCPAxis_SenderSignalIndex_Callback qcpaxis_sendersignalindex_callback = nullptr;
    QCPAxis_Receivers_Callback qcpaxis_receivers_callback = nullptr;
    QCPAxis_IsSignalConnected_Callback qcpaxis_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpaxis_metacall_isbase = false;
    mutable bool qcpaxis_selecttest_isbase = false;
    mutable bool qcpaxis_calculatemargin_isbase = false;
    mutable bool qcpaxis_applydefaultantialiasinghint_isbase = false;
    mutable bool qcpaxis_draw_isbase = false;
    mutable bool qcpaxis_selectioncategory_isbase = false;
    mutable bool qcpaxis_selectevent_isbase = false;
    mutable bool qcpaxis_deselectevent_isbase = false;
    mutable bool qcpaxis_mousepressevent_isbase = false;
    mutable bool qcpaxis_mousemoveevent_isbase = false;
    mutable bool qcpaxis_mousereleaseevent_isbase = false;
    mutable bool qcpaxis_wheelevent_isbase = false;
    mutable bool qcpaxis_parentplotinitialized_isbase = false;
    mutable bool qcpaxis_cliprect_isbase = false;
    mutable bool qcpaxis_mousedoubleclickevent_isbase = false;
    mutable bool qcpaxis_event_isbase = false;
    mutable bool qcpaxis_eventfilter_isbase = false;
    mutable bool qcpaxis_timerevent_isbase = false;
    mutable bool qcpaxis_childevent_isbase = false;
    mutable bool qcpaxis_customevent_isbase = false;
    mutable bool qcpaxis_connectnotify_isbase = false;
    mutable bool qcpaxis_disconnectnotify_isbase = false;
    mutable bool qcpaxis_setuptickvectors_isbase = false;
    mutable bool qcpaxis_getbasepen_isbase = false;
    mutable bool qcpaxis_gettickpen_isbase = false;
    mutable bool qcpaxis_getsubtickpen_isbase = false;
    mutable bool qcpaxis_getticklabelfont_isbase = false;
    mutable bool qcpaxis_getlabelfont_isbase = false;
    mutable bool qcpaxis_getticklabelcolor_isbase = false;
    mutable bool qcpaxis_getlabelcolor_isbase = false;
    mutable bool qcpaxis_initializeparentplot_isbase = false;
    mutable bool qcpaxis_setparentlayerable_isbase = false;
    mutable bool qcpaxis_movetolayer_isbase = false;
    mutable bool qcpaxis_applyantialiasinghint_isbase = false;
    mutable bool qcpaxis_sender_isbase = false;
    mutable bool qcpaxis_sendersignalindex_isbase = false;
    mutable bool qcpaxis_receivers_isbase = false;
    mutable bool qcpaxis_issignalconnected_isbase = false;

  public:
    VirtualQCPAxis(QCPAxisRect* parent, QCPAxis::AxisType typeVal) : QCPAxis(parent, typeVal) {};

    ~VirtualQCPAxis() {
        qcpaxis_metacall_callback = nullptr;
        qcpaxis_selecttest_callback = nullptr;
        qcpaxis_calculatemargin_callback = nullptr;
        qcpaxis_applydefaultantialiasinghint_callback = nullptr;
        qcpaxis_draw_callback = nullptr;
        qcpaxis_selectioncategory_callback = nullptr;
        qcpaxis_selectevent_callback = nullptr;
        qcpaxis_deselectevent_callback = nullptr;
        qcpaxis_mousepressevent_callback = nullptr;
        qcpaxis_mousemoveevent_callback = nullptr;
        qcpaxis_mousereleaseevent_callback = nullptr;
        qcpaxis_wheelevent_callback = nullptr;
        qcpaxis_parentplotinitialized_callback = nullptr;
        qcpaxis_cliprect_callback = nullptr;
        qcpaxis_mousedoubleclickevent_callback = nullptr;
        qcpaxis_event_callback = nullptr;
        qcpaxis_eventfilter_callback = nullptr;
        qcpaxis_timerevent_callback = nullptr;
        qcpaxis_childevent_callback = nullptr;
        qcpaxis_customevent_callback = nullptr;
        qcpaxis_connectnotify_callback = nullptr;
        qcpaxis_disconnectnotify_callback = nullptr;
        qcpaxis_setuptickvectors_callback = nullptr;
        qcpaxis_getbasepen_callback = nullptr;
        qcpaxis_gettickpen_callback = nullptr;
        qcpaxis_getsubtickpen_callback = nullptr;
        qcpaxis_getticklabelfont_callback = nullptr;
        qcpaxis_getlabelfont_callback = nullptr;
        qcpaxis_getticklabelcolor_callback = nullptr;
        qcpaxis_getlabelcolor_callback = nullptr;
        qcpaxis_initializeparentplot_callback = nullptr;
        qcpaxis_setparentlayerable_callback = nullptr;
        qcpaxis_movetolayer_callback = nullptr;
        qcpaxis_applyantialiasinghint_callback = nullptr;
        qcpaxis_sender_callback = nullptr;
        qcpaxis_sendersignalindex_callback = nullptr;
        qcpaxis_receivers_callback = nullptr;
        qcpaxis_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPAxis_Metacall_Callback(QCPAxis_Metacall_Callback cb) { qcpaxis_metacall_callback = cb; }
    inline void setQCPAxis_SelectTest_Callback(QCPAxis_SelectTest_Callback cb) { qcpaxis_selecttest_callback = cb; }
    inline void setQCPAxis_CalculateMargin_Callback(QCPAxis_CalculateMargin_Callback cb) { qcpaxis_calculatemargin_callback = cb; }
    inline void setQCPAxis_ApplyDefaultAntialiasingHint_Callback(QCPAxis_ApplyDefaultAntialiasingHint_Callback cb) { qcpaxis_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPAxis_Draw_Callback(QCPAxis_Draw_Callback cb) { qcpaxis_draw_callback = cb; }
    inline void setQCPAxis_SelectionCategory_Callback(QCPAxis_SelectionCategory_Callback cb) { qcpaxis_selectioncategory_callback = cb; }
    inline void setQCPAxis_SelectEvent_Callback(QCPAxis_SelectEvent_Callback cb) { qcpaxis_selectevent_callback = cb; }
    inline void setQCPAxis_DeselectEvent_Callback(QCPAxis_DeselectEvent_Callback cb) { qcpaxis_deselectevent_callback = cb; }
    inline void setQCPAxis_MousePressEvent_Callback(QCPAxis_MousePressEvent_Callback cb) { qcpaxis_mousepressevent_callback = cb; }
    inline void setQCPAxis_MouseMoveEvent_Callback(QCPAxis_MouseMoveEvent_Callback cb) { qcpaxis_mousemoveevent_callback = cb; }
    inline void setQCPAxis_MouseReleaseEvent_Callback(QCPAxis_MouseReleaseEvent_Callback cb) { qcpaxis_mousereleaseevent_callback = cb; }
    inline void setQCPAxis_WheelEvent_Callback(QCPAxis_WheelEvent_Callback cb) { qcpaxis_wheelevent_callback = cb; }
    inline void setQCPAxis_ParentPlotInitialized_Callback(QCPAxis_ParentPlotInitialized_Callback cb) { qcpaxis_parentplotinitialized_callback = cb; }
    inline void setQCPAxis_ClipRect_Callback(QCPAxis_ClipRect_Callback cb) { qcpaxis_cliprect_callback = cb; }
    inline void setQCPAxis_MouseDoubleClickEvent_Callback(QCPAxis_MouseDoubleClickEvent_Callback cb) { qcpaxis_mousedoubleclickevent_callback = cb; }
    inline void setQCPAxis_Event_Callback(QCPAxis_Event_Callback cb) { qcpaxis_event_callback = cb; }
    inline void setQCPAxis_EventFilter_Callback(QCPAxis_EventFilter_Callback cb) { qcpaxis_eventfilter_callback = cb; }
    inline void setQCPAxis_TimerEvent_Callback(QCPAxis_TimerEvent_Callback cb) { qcpaxis_timerevent_callback = cb; }
    inline void setQCPAxis_ChildEvent_Callback(QCPAxis_ChildEvent_Callback cb) { qcpaxis_childevent_callback = cb; }
    inline void setQCPAxis_CustomEvent_Callback(QCPAxis_CustomEvent_Callback cb) { qcpaxis_customevent_callback = cb; }
    inline void setQCPAxis_ConnectNotify_Callback(QCPAxis_ConnectNotify_Callback cb) { qcpaxis_connectnotify_callback = cb; }
    inline void setQCPAxis_DisconnectNotify_Callback(QCPAxis_DisconnectNotify_Callback cb) { qcpaxis_disconnectnotify_callback = cb; }
    inline void setQCPAxis_SetupTickVectors_Callback(QCPAxis_SetupTickVectors_Callback cb) { qcpaxis_setuptickvectors_callback = cb; }
    inline void setQCPAxis_GetBasePen_Callback(QCPAxis_GetBasePen_Callback cb) { qcpaxis_getbasepen_callback = cb; }
    inline void setQCPAxis_GetTickPen_Callback(QCPAxis_GetTickPen_Callback cb) { qcpaxis_gettickpen_callback = cb; }
    inline void setQCPAxis_GetSubTickPen_Callback(QCPAxis_GetSubTickPen_Callback cb) { qcpaxis_getsubtickpen_callback = cb; }
    inline void setQCPAxis_GetTickLabelFont_Callback(QCPAxis_GetTickLabelFont_Callback cb) { qcpaxis_getticklabelfont_callback = cb; }
    inline void setQCPAxis_GetLabelFont_Callback(QCPAxis_GetLabelFont_Callback cb) { qcpaxis_getlabelfont_callback = cb; }
    inline void setQCPAxis_GetTickLabelColor_Callback(QCPAxis_GetTickLabelColor_Callback cb) { qcpaxis_getticklabelcolor_callback = cb; }
    inline void setQCPAxis_GetLabelColor_Callback(QCPAxis_GetLabelColor_Callback cb) { qcpaxis_getlabelcolor_callback = cb; }
    inline void setQCPAxis_InitializeParentPlot_Callback(QCPAxis_InitializeParentPlot_Callback cb) { qcpaxis_initializeparentplot_callback = cb; }
    inline void setQCPAxis_SetParentLayerable_Callback(QCPAxis_SetParentLayerable_Callback cb) { qcpaxis_setparentlayerable_callback = cb; }
    inline void setQCPAxis_MoveToLayer_Callback(QCPAxis_MoveToLayer_Callback cb) { qcpaxis_movetolayer_callback = cb; }
    inline void setQCPAxis_ApplyAntialiasingHint_Callback(QCPAxis_ApplyAntialiasingHint_Callback cb) { qcpaxis_applyantialiasinghint_callback = cb; }
    inline void setQCPAxis_Sender_Callback(QCPAxis_Sender_Callback cb) { qcpaxis_sender_callback = cb; }
    inline void setQCPAxis_SenderSignalIndex_Callback(QCPAxis_SenderSignalIndex_Callback cb) { qcpaxis_sendersignalindex_callback = cb; }
    inline void setQCPAxis_Receivers_Callback(QCPAxis_Receivers_Callback cb) { qcpaxis_receivers_callback = cb; }
    inline void setQCPAxis_IsSignalConnected_Callback(QCPAxis_IsSignalConnected_Callback cb) { qcpaxis_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPAxis_Metacall_IsBase(bool value) const { qcpaxis_metacall_isbase = value; }
    inline void setQCPAxis_SelectTest_IsBase(bool value) const { qcpaxis_selecttest_isbase = value; }
    inline void setQCPAxis_CalculateMargin_IsBase(bool value) const { qcpaxis_calculatemargin_isbase = value; }
    inline void setQCPAxis_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcpaxis_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPAxis_Draw_IsBase(bool value) const { qcpaxis_draw_isbase = value; }
    inline void setQCPAxis_SelectionCategory_IsBase(bool value) const { qcpaxis_selectioncategory_isbase = value; }
    inline void setQCPAxis_SelectEvent_IsBase(bool value) const { qcpaxis_selectevent_isbase = value; }
    inline void setQCPAxis_DeselectEvent_IsBase(bool value) const { qcpaxis_deselectevent_isbase = value; }
    inline void setQCPAxis_MousePressEvent_IsBase(bool value) const { qcpaxis_mousepressevent_isbase = value; }
    inline void setQCPAxis_MouseMoveEvent_IsBase(bool value) const { qcpaxis_mousemoveevent_isbase = value; }
    inline void setQCPAxis_MouseReleaseEvent_IsBase(bool value) const { qcpaxis_mousereleaseevent_isbase = value; }
    inline void setQCPAxis_WheelEvent_IsBase(bool value) const { qcpaxis_wheelevent_isbase = value; }
    inline void setQCPAxis_ParentPlotInitialized_IsBase(bool value) const { qcpaxis_parentplotinitialized_isbase = value; }
    inline void setQCPAxis_ClipRect_IsBase(bool value) const { qcpaxis_cliprect_isbase = value; }
    inline void setQCPAxis_MouseDoubleClickEvent_IsBase(bool value) const { qcpaxis_mousedoubleclickevent_isbase = value; }
    inline void setQCPAxis_Event_IsBase(bool value) const { qcpaxis_event_isbase = value; }
    inline void setQCPAxis_EventFilter_IsBase(bool value) const { qcpaxis_eventfilter_isbase = value; }
    inline void setQCPAxis_TimerEvent_IsBase(bool value) const { qcpaxis_timerevent_isbase = value; }
    inline void setQCPAxis_ChildEvent_IsBase(bool value) const { qcpaxis_childevent_isbase = value; }
    inline void setQCPAxis_CustomEvent_IsBase(bool value) const { qcpaxis_customevent_isbase = value; }
    inline void setQCPAxis_ConnectNotify_IsBase(bool value) const { qcpaxis_connectnotify_isbase = value; }
    inline void setQCPAxis_DisconnectNotify_IsBase(bool value) const { qcpaxis_disconnectnotify_isbase = value; }
    inline void setQCPAxis_SetupTickVectors_IsBase(bool value) const { qcpaxis_setuptickvectors_isbase = value; }
    inline void setQCPAxis_GetBasePen_IsBase(bool value) const { qcpaxis_getbasepen_isbase = value; }
    inline void setQCPAxis_GetTickPen_IsBase(bool value) const { qcpaxis_gettickpen_isbase = value; }
    inline void setQCPAxis_GetSubTickPen_IsBase(bool value) const { qcpaxis_getsubtickpen_isbase = value; }
    inline void setQCPAxis_GetTickLabelFont_IsBase(bool value) const { qcpaxis_getticklabelfont_isbase = value; }
    inline void setQCPAxis_GetLabelFont_IsBase(bool value) const { qcpaxis_getlabelfont_isbase = value; }
    inline void setQCPAxis_GetTickLabelColor_IsBase(bool value) const { qcpaxis_getticklabelcolor_isbase = value; }
    inline void setQCPAxis_GetLabelColor_IsBase(bool value) const { qcpaxis_getlabelcolor_isbase = value; }
    inline void setQCPAxis_InitializeParentPlot_IsBase(bool value) const { qcpaxis_initializeparentplot_isbase = value; }
    inline void setQCPAxis_SetParentLayerable_IsBase(bool value) const { qcpaxis_setparentlayerable_isbase = value; }
    inline void setQCPAxis_MoveToLayer_IsBase(bool value) const { qcpaxis_movetolayer_isbase = value; }
    inline void setQCPAxis_ApplyAntialiasingHint_IsBase(bool value) const { qcpaxis_applyantialiasinghint_isbase = value; }
    inline void setQCPAxis_Sender_IsBase(bool value) const { qcpaxis_sender_isbase = value; }
    inline void setQCPAxis_SenderSignalIndex_IsBase(bool value) const { qcpaxis_sendersignalindex_isbase = value; }
    inline void setQCPAxis_Receivers_IsBase(bool value) const { qcpaxis_receivers_isbase = value; }
    inline void setQCPAxis_IsSignalConnected_IsBase(bool value) const { qcpaxis_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpaxis_metacall_isbase) {
            qcpaxis_metacall_isbase = false;
            return QCPAxis::qt_metacall(param1, param2, param3);
        } else if (qcpaxis_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpaxis_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPAxis::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcpaxis_selecttest_isbase) {
            qcpaxis_selecttest_isbase = false;
            return QCPAxis::selectTest(pos, onlySelectable, details);
        } else if (qcpaxis_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcpaxis_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxis::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int calculateMargin() override {
        if (qcpaxis_calculatemargin_isbase) {
            qcpaxis_calculatemargin_isbase = false;
            return QCPAxis::calculateMargin();
        } else if (qcpaxis_calculatemargin_callback != nullptr) {
            int callback_ret = qcpaxis_calculatemargin_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPAxis::calculateMargin();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcpaxis_applydefaultantialiasinghint_isbase) {
            qcpaxis_applydefaultantialiasinghint_isbase = false;
            QCPAxis::applyDefaultAntialiasingHint(painter);
        } else if (qcpaxis_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpaxis_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPAxis::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcpaxis_draw_isbase) {
            qcpaxis_draw_isbase = false;
            QCPAxis::draw(painter);
        } else if (qcpaxis_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpaxis_draw_callback(this, cbval1);
        } else {
            QCPAxis::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcpaxis_selectioncategory_isbase) {
            qcpaxis_selectioncategory_isbase = false;
            return QCPAxis::selectionCategory();
        } else if (qcpaxis_selectioncategory_callback != nullptr) {
            int callback_ret = qcpaxis_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPAxis::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcpaxis_selectevent_isbase) {
            qcpaxis_selectevent_isbase = false;
            QCPAxis::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcpaxis_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcpaxis_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPAxis::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcpaxis_deselectevent_isbase) {
            qcpaxis_deselectevent_isbase = false;
            QCPAxis::deselectEvent(selectionStateChanged);
        } else if (qcpaxis_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcpaxis_deselectevent_callback(this, cbval1);
        } else {
            QCPAxis::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpaxis_mousepressevent_isbase) {
            qcpaxis_mousepressevent_isbase = false;
            QCPAxis::mousePressEvent(event, details);
        } else if (qcpaxis_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpaxis_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPAxis::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpaxis_mousemoveevent_isbase) {
            qcpaxis_mousemoveevent_isbase = false;
            QCPAxis::mouseMoveEvent(event, startPos);
        } else if (qcpaxis_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpaxis_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPAxis::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpaxis_mousereleaseevent_isbase) {
            qcpaxis_mousereleaseevent_isbase = false;
            QCPAxis::mouseReleaseEvent(event, startPos);
        } else if (qcpaxis_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpaxis_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPAxis::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcpaxis_wheelevent_isbase) {
            qcpaxis_wheelevent_isbase = false;
            QCPAxis::wheelEvent(event);
        } else if (qcpaxis_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcpaxis_wheelevent_callback(this, cbval1);
        } else {
            QCPAxis::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcpaxis_parentplotinitialized_isbase) {
            qcpaxis_parentplotinitialized_isbase = false;
            QCPAxis::parentPlotInitialized(parentPlot);
        } else if (qcpaxis_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpaxis_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPAxis::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcpaxis_cliprect_isbase) {
            qcpaxis_cliprect_isbase = false;
            return QCPAxis::clipRect();
        } else if (qcpaxis_cliprect_callback != nullptr) {
            QRect* callback_ret = qcpaxis_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPAxis::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpaxis_mousedoubleclickevent_isbase) {
            qcpaxis_mousedoubleclickevent_isbase = false;
            QCPAxis::mouseDoubleClickEvent(event, details);
        } else if (qcpaxis_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpaxis_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPAxis::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpaxis_event_isbase) {
            qcpaxis_event_isbase = false;
            return QCPAxis::event(event);
        } else if (qcpaxis_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpaxis_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPAxis::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpaxis_eventfilter_isbase) {
            qcpaxis_eventfilter_isbase = false;
            return QCPAxis::eventFilter(watched, event);
        } else if (qcpaxis_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpaxis_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPAxis::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpaxis_timerevent_isbase) {
            qcpaxis_timerevent_isbase = false;
            QCPAxis::timerEvent(event);
        } else if (qcpaxis_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpaxis_timerevent_callback(this, cbval1);
        } else {
            QCPAxis::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpaxis_childevent_isbase) {
            qcpaxis_childevent_isbase = false;
            QCPAxis::childEvent(event);
        } else if (qcpaxis_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpaxis_childevent_callback(this, cbval1);
        } else {
            QCPAxis::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpaxis_customevent_isbase) {
            qcpaxis_customevent_isbase = false;
            QCPAxis::customEvent(event);
        } else if (qcpaxis_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpaxis_customevent_callback(this, cbval1);
        } else {
            QCPAxis::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpaxis_connectnotify_isbase) {
            qcpaxis_connectnotify_isbase = false;
            QCPAxis::connectNotify(signal);
        } else if (qcpaxis_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpaxis_connectnotify_callback(this, cbval1);
        } else {
            QCPAxis::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpaxis_disconnectnotify_isbase) {
            qcpaxis_disconnectnotify_isbase = false;
            QCPAxis::disconnectNotify(signal);
        } else if (qcpaxis_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpaxis_disconnectnotify_callback(this, cbval1);
        } else {
            QCPAxis::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setupTickVectors() {
        if (qcpaxis_setuptickvectors_isbase) {
            qcpaxis_setuptickvectors_isbase = false;
            QCPAxis::setupTickVectors();
        } else if (qcpaxis_setuptickvectors_callback != nullptr) {
            qcpaxis_setuptickvectors_callback();
        } else {
            QCPAxis::setupTickVectors();
        }
    }

    // Virtual method for C ABI access and custom callback
    QPen getBasePen() const {
        if (qcpaxis_getbasepen_isbase) {
            qcpaxis_getbasepen_isbase = false;
            return QCPAxis::getBasePen();
        } else if (qcpaxis_getbasepen_callback != nullptr) {
            QPen* callback_ret = qcpaxis_getbasepen_callback();
            return *callback_ret;
        } else {
            return QCPAxis::getBasePen();
        }
    }

    // Virtual method for C ABI access and custom callback
    QPen getTickPen() const {
        if (qcpaxis_gettickpen_isbase) {
            qcpaxis_gettickpen_isbase = false;
            return QCPAxis::getTickPen();
        } else if (qcpaxis_gettickpen_callback != nullptr) {
            QPen* callback_ret = qcpaxis_gettickpen_callback();
            return *callback_ret;
        } else {
            return QCPAxis::getTickPen();
        }
    }

    // Virtual method for C ABI access and custom callback
    QPen getSubTickPen() const {
        if (qcpaxis_getsubtickpen_isbase) {
            qcpaxis_getsubtickpen_isbase = false;
            return QCPAxis::getSubTickPen();
        } else if (qcpaxis_getsubtickpen_callback != nullptr) {
            QPen* callback_ret = qcpaxis_getsubtickpen_callback();
            return *callback_ret;
        } else {
            return QCPAxis::getSubTickPen();
        }
    }

    // Virtual method for C ABI access and custom callback
    QFont getTickLabelFont() const {
        if (qcpaxis_getticklabelfont_isbase) {
            qcpaxis_getticklabelfont_isbase = false;
            return QCPAxis::getTickLabelFont();
        } else if (qcpaxis_getticklabelfont_callback != nullptr) {
            QFont* callback_ret = qcpaxis_getticklabelfont_callback();
            return *callback_ret;
        } else {
            return QCPAxis::getTickLabelFont();
        }
    }

    // Virtual method for C ABI access and custom callback
    QFont getLabelFont() const {
        if (qcpaxis_getlabelfont_isbase) {
            qcpaxis_getlabelfont_isbase = false;
            return QCPAxis::getLabelFont();
        } else if (qcpaxis_getlabelfont_callback != nullptr) {
            QFont* callback_ret = qcpaxis_getlabelfont_callback();
            return *callback_ret;
        } else {
            return QCPAxis::getLabelFont();
        }
    }

    // Virtual method for C ABI access and custom callback
    QColor getTickLabelColor() const {
        if (qcpaxis_getticklabelcolor_isbase) {
            qcpaxis_getticklabelcolor_isbase = false;
            return QCPAxis::getTickLabelColor();
        } else if (qcpaxis_getticklabelcolor_callback != nullptr) {
            QColor* callback_ret = qcpaxis_getticklabelcolor_callback();
            return *callback_ret;
        } else {
            return QCPAxis::getTickLabelColor();
        }
    }

    // Virtual method for C ABI access and custom callback
    QColor getLabelColor() const {
        if (qcpaxis_getlabelcolor_isbase) {
            qcpaxis_getlabelcolor_isbase = false;
            return QCPAxis::getLabelColor();
        } else if (qcpaxis_getlabelcolor_callback != nullptr) {
            QColor* callback_ret = qcpaxis_getlabelcolor_callback();
            return *callback_ret;
        } else {
            return QCPAxis::getLabelColor();
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcpaxis_initializeparentplot_isbase) {
            qcpaxis_initializeparentplot_isbase = false;
            QCPAxis::initializeParentPlot(parentPlot);
        } else if (qcpaxis_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpaxis_initializeparentplot_callback(this, cbval1);
        } else {
            QCPAxis::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcpaxis_setparentlayerable_isbase) {
            qcpaxis_setparentlayerable_isbase = false;
            QCPAxis::setParentLayerable(parentLayerable);
        } else if (qcpaxis_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcpaxis_setparentlayerable_callback(this, cbval1);
        } else {
            QCPAxis::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcpaxis_movetolayer_isbase) {
            qcpaxis_movetolayer_isbase = false;
            return QCPAxis::moveToLayer(layer, prepend);
        } else if (qcpaxis_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcpaxis_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPAxis::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcpaxis_applyantialiasinghint_isbase) {
            qcpaxis_applyantialiasinghint_isbase = false;
            QCPAxis::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcpaxis_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcpaxis_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPAxis::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpaxis_sender_isbase) {
            qcpaxis_sender_isbase = false;
            return QCPAxis::sender();
        } else if (qcpaxis_sender_callback != nullptr) {
            QObject* callback_ret = qcpaxis_sender_callback();
            return callback_ret;
        } else {
            return QCPAxis::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpaxis_sendersignalindex_isbase) {
            qcpaxis_sendersignalindex_isbase = false;
            return QCPAxis::senderSignalIndex();
        } else if (qcpaxis_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpaxis_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPAxis::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpaxis_receivers_isbase) {
            qcpaxis_receivers_isbase = false;
            return QCPAxis::receivers(signal);
        } else if (qcpaxis_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpaxis_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPAxis::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpaxis_issignalconnected_isbase) {
            qcpaxis_issignalconnected_isbase = false;
            return QCPAxis::isSignalConnected(signal);
        } else if (qcpaxis_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpaxis_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPAxis::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend int QCPAxis_CalculateMargin(QCPAxis* self);
    friend int QCPAxis_QBaseCalculateMargin(QCPAxis* self);
    friend void QCPAxis_ApplyDefaultAntialiasingHint(const QCPAxis* self, QCPPainter* painter);
    friend void QCPAxis_QBaseApplyDefaultAntialiasingHint(const QCPAxis* self, QCPPainter* painter);
    friend void QCPAxis_Draw(QCPAxis* self, QCPPainter* painter);
    friend void QCPAxis_QBaseDraw(QCPAxis* self, QCPPainter* painter);
    friend int QCPAxis_SelectionCategory(const QCPAxis* self);
    friend int QCPAxis_QBaseSelectionCategory(const QCPAxis* self);
    friend void QCPAxis_SelectEvent(QCPAxis* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPAxis_QBaseSelectEvent(QCPAxis* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPAxis_DeselectEvent(QCPAxis* self, bool* selectionStateChanged);
    friend void QCPAxis_QBaseDeselectEvent(QCPAxis* self, bool* selectionStateChanged);
    friend void QCPAxis_MousePressEvent(QCPAxis* self, QMouseEvent* event, const QVariant* details);
    friend void QCPAxis_QBaseMousePressEvent(QCPAxis* self, QMouseEvent* event, const QVariant* details);
    friend void QCPAxis_MouseMoveEvent(QCPAxis* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPAxis_QBaseMouseMoveEvent(QCPAxis* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPAxis_MouseReleaseEvent(QCPAxis* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPAxis_QBaseMouseReleaseEvent(QCPAxis* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPAxis_WheelEvent(QCPAxis* self, QWheelEvent* event);
    friend void QCPAxis_QBaseWheelEvent(QCPAxis* self, QWheelEvent* event);
    friend void QCPAxis_ParentPlotInitialized(QCPAxis* self, QCustomPlot* parentPlot);
    friend void QCPAxis_QBaseParentPlotInitialized(QCPAxis* self, QCustomPlot* parentPlot);
    friend QRect* QCPAxis_ClipRect(const QCPAxis* self);
    friend QRect* QCPAxis_QBaseClipRect(const QCPAxis* self);
    friend void QCPAxis_MouseDoubleClickEvent(QCPAxis* self, QMouseEvent* event, const QVariant* details);
    friend void QCPAxis_QBaseMouseDoubleClickEvent(QCPAxis* self, QMouseEvent* event, const QVariant* details);
    friend void QCPAxis_TimerEvent(QCPAxis* self, QTimerEvent* event);
    friend void QCPAxis_QBaseTimerEvent(QCPAxis* self, QTimerEvent* event);
    friend void QCPAxis_ChildEvent(QCPAxis* self, QChildEvent* event);
    friend void QCPAxis_QBaseChildEvent(QCPAxis* self, QChildEvent* event);
    friend void QCPAxis_CustomEvent(QCPAxis* self, QEvent* event);
    friend void QCPAxis_QBaseCustomEvent(QCPAxis* self, QEvent* event);
    friend void QCPAxis_ConnectNotify(QCPAxis* self, const QMetaMethod* signal);
    friend void QCPAxis_QBaseConnectNotify(QCPAxis* self, const QMetaMethod* signal);
    friend void QCPAxis_DisconnectNotify(QCPAxis* self, const QMetaMethod* signal);
    friend void QCPAxis_QBaseDisconnectNotify(QCPAxis* self, const QMetaMethod* signal);
    friend void QCPAxis_SetupTickVectors(QCPAxis* self);
    friend void QCPAxis_QBaseSetupTickVectors(QCPAxis* self);
    friend QPen* QCPAxis_GetBasePen(const QCPAxis* self);
    friend QPen* QCPAxis_QBaseGetBasePen(const QCPAxis* self);
    friend QPen* QCPAxis_GetTickPen(const QCPAxis* self);
    friend QPen* QCPAxis_QBaseGetTickPen(const QCPAxis* self);
    friend QPen* QCPAxis_GetSubTickPen(const QCPAxis* self);
    friend QPen* QCPAxis_QBaseGetSubTickPen(const QCPAxis* self);
    friend QFont* QCPAxis_GetTickLabelFont(const QCPAxis* self);
    friend QFont* QCPAxis_QBaseGetTickLabelFont(const QCPAxis* self);
    friend QFont* QCPAxis_GetLabelFont(const QCPAxis* self);
    friend QFont* QCPAxis_QBaseGetLabelFont(const QCPAxis* self);
    friend QColor* QCPAxis_GetTickLabelColor(const QCPAxis* self);
    friend QColor* QCPAxis_QBaseGetTickLabelColor(const QCPAxis* self);
    friend QColor* QCPAxis_GetLabelColor(const QCPAxis* self);
    friend QColor* QCPAxis_QBaseGetLabelColor(const QCPAxis* self);
    friend void QCPAxis_InitializeParentPlot(QCPAxis* self, QCustomPlot* parentPlot);
    friend void QCPAxis_QBaseInitializeParentPlot(QCPAxis* self, QCustomPlot* parentPlot);
    friend void QCPAxis_SetParentLayerable(QCPAxis* self, QCPLayerable* parentLayerable);
    friend void QCPAxis_QBaseSetParentLayerable(QCPAxis* self, QCPLayerable* parentLayerable);
    friend bool QCPAxis_MoveToLayer(QCPAxis* self, QCPLayer* layer, bool prepend);
    friend bool QCPAxis_QBaseMoveToLayer(QCPAxis* self, QCPLayer* layer, bool prepend);
    friend void QCPAxis_ApplyAntialiasingHint(const QCPAxis* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPAxis_QBaseApplyAntialiasingHint(const QCPAxis* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPAxis_Sender(const QCPAxis* self);
    friend QObject* QCPAxis_QBaseSender(const QCPAxis* self);
    friend int QCPAxis_SenderSignalIndex(const QCPAxis* self);
    friend int QCPAxis_QBaseSenderSignalIndex(const QCPAxis* self);
    friend int QCPAxis_Receivers(const QCPAxis* self, const char* signal);
    friend int QCPAxis_QBaseReceivers(const QCPAxis* self, const char* signal);
    friend bool QCPAxis_IsSignalConnected(const QCPAxis* self, const QMetaMethod* signal);
    friend bool QCPAxis_QBaseIsSignalConnected(const QCPAxis* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPSelectionDecorator so that we can call protected methods
class VirtualQCPSelectionDecorator final : public QCPSelectionDecorator {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPSelectionDecorator = true;

    // Virtual class public types (including callbacks)
    using QCPSelectionDecorator_CopyFrom_Callback = void (*)(QCPSelectionDecorator*, QCPSelectionDecorator*);
    using QCPSelectionDecorator_DrawDecoration_Callback = void (*)(QCPSelectionDecorator*, QCPPainter*, QCPDataSelection*);
    using QCPSelectionDecorator_RegisterWithPlottable_Callback = bool (*)(QCPSelectionDecorator*, QCPAbstractPlottable*);

  protected:
    // Instance callback storage
    QCPSelectionDecorator_CopyFrom_Callback qcpselectiondecorator_copyfrom_callback = nullptr;
    QCPSelectionDecorator_DrawDecoration_Callback qcpselectiondecorator_drawdecoration_callback = nullptr;
    QCPSelectionDecorator_RegisterWithPlottable_Callback qcpselectiondecorator_registerwithplottable_callback = nullptr;

    // Instance base flags
    mutable bool qcpselectiondecorator_copyfrom_isbase = false;
    mutable bool qcpselectiondecorator_drawdecoration_isbase = false;
    mutable bool qcpselectiondecorator_registerwithplottable_isbase = false;

  public:
    VirtualQCPSelectionDecorator() : QCPSelectionDecorator() {};

    ~VirtualQCPSelectionDecorator() {
        qcpselectiondecorator_copyfrom_callback = nullptr;
        qcpselectiondecorator_drawdecoration_callback = nullptr;
        qcpselectiondecorator_registerwithplottable_callback = nullptr;
    }

    // Callback setters
    inline void setQCPSelectionDecorator_CopyFrom_Callback(QCPSelectionDecorator_CopyFrom_Callback cb) { qcpselectiondecorator_copyfrom_callback = cb; }
    inline void setQCPSelectionDecorator_DrawDecoration_Callback(QCPSelectionDecorator_DrawDecoration_Callback cb) { qcpselectiondecorator_drawdecoration_callback = cb; }
    inline void setQCPSelectionDecorator_RegisterWithPlottable_Callback(QCPSelectionDecorator_RegisterWithPlottable_Callback cb) { qcpselectiondecorator_registerwithplottable_callback = cb; }

    // Base flag setters
    inline void setQCPSelectionDecorator_CopyFrom_IsBase(bool value) const { qcpselectiondecorator_copyfrom_isbase = value; }
    inline void setQCPSelectionDecorator_DrawDecoration_IsBase(bool value) const { qcpselectiondecorator_drawdecoration_isbase = value; }
    inline void setQCPSelectionDecorator_RegisterWithPlottable_IsBase(bool value) const { qcpselectiondecorator_registerwithplottable_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual void copyFrom(const QCPSelectionDecorator* other) override {
        if (qcpselectiondecorator_copyfrom_isbase) {
            qcpselectiondecorator_copyfrom_isbase = false;
            QCPSelectionDecorator::copyFrom(other);
        } else if (qcpselectiondecorator_copyfrom_callback != nullptr) {
            QCPSelectionDecorator* cbval1 = (QCPSelectionDecorator*)other;

            qcpselectiondecorator_copyfrom_callback(this, cbval1);
        } else {
            QCPSelectionDecorator::copyFrom(other);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void drawDecoration(QCPPainter* painter, QCPDataSelection selection) override {
        if (qcpselectiondecorator_drawdecoration_isbase) {
            qcpselectiondecorator_drawdecoration_isbase = false;
            QCPSelectionDecorator::drawDecoration(painter, selection);
        } else if (qcpselectiondecorator_drawdecoration_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            QCPDataSelection* cbval2 = new QCPDataSelection(selection);

            qcpselectiondecorator_drawdecoration_callback(this, cbval1, cbval2);
        } else {
            QCPSelectionDecorator::drawDecoration(painter, selection);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool registerWithPlottable(QCPAbstractPlottable* plottable) override {
        if (qcpselectiondecorator_registerwithplottable_isbase) {
            qcpselectiondecorator_registerwithplottable_isbase = false;
            return QCPSelectionDecorator::registerWithPlottable(plottable);
        } else if (qcpselectiondecorator_registerwithplottable_callback != nullptr) {
            QCPAbstractPlottable* cbval1 = plottable;

            bool callback_ret = qcpselectiondecorator_registerwithplottable_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPSelectionDecorator::registerWithPlottable(plottable);
        }
    }

    // Friend functions
    friend bool QCPSelectionDecorator_RegisterWithPlottable(QCPSelectionDecorator* self, QCPAbstractPlottable* plottable);
    friend bool QCPSelectionDecorator_QBaseRegisterWithPlottable(QCPSelectionDecorator* self, QCPAbstractPlottable* plottable);
};

// This class is a subclass of QCPAbstractPlottable so that we can call protected methods
class VirtualQCPAbstractPlottable : public QCPAbstractPlottable {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPAbstractPlottable = true;

    // Virtual class public types (including callbacks)
    using QCPAbstractPlottable_Metacall_Callback = int (*)(QCPAbstractPlottable*, int, int, void**);
    using QCPAbstractPlottable_SelectTest_Callback = double (*)(const QCPAbstractPlottable*, QPointF*, bool, QVariant*);
    using QCPAbstractPlottable_Interface1D_Callback = QCPPlottableInterface1D* (*)();
    using QCPAbstractPlottable_GetKeyRange_Callback = QCPRange* (*)(const QCPAbstractPlottable*, bool*, int);
    using QCPAbstractPlottable_GetValueRange_Callback = QCPRange* (*)(const QCPAbstractPlottable*, bool*, int, QCPRange*);
    using QCPAbstractPlottable_ClipRect_Callback = QRect* (*)();
    using QCPAbstractPlottable_Draw_Callback = void (*)(QCPAbstractPlottable*, QCPPainter*);
    using QCPAbstractPlottable_SelectionCategory_Callback = int (*)();
    using QCPAbstractPlottable_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPAbstractPlottable*, QCPPainter*);
    using QCPAbstractPlottable_SelectEvent_Callback = void (*)(QCPAbstractPlottable*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPAbstractPlottable_DeselectEvent_Callback = void (*)(QCPAbstractPlottable*, bool*);
    using QCPAbstractPlottable_DrawLegendIcon_Callback = void (*)(const QCPAbstractPlottable*, QCPPainter*, QRectF*);
    using QCPAbstractPlottable_ParentPlotInitialized_Callback = void (*)(QCPAbstractPlottable*, QCustomPlot*);
    using QCPAbstractPlottable_MousePressEvent_Callback = void (*)(QCPAbstractPlottable*, QMouseEvent*, QVariant*);
    using QCPAbstractPlottable_MouseMoveEvent_Callback = void (*)(QCPAbstractPlottable*, QMouseEvent*, QPointF*);
    using QCPAbstractPlottable_MouseReleaseEvent_Callback = void (*)(QCPAbstractPlottable*, QMouseEvent*, QPointF*);
    using QCPAbstractPlottable_MouseDoubleClickEvent_Callback = void (*)(QCPAbstractPlottable*, QMouseEvent*, QVariant*);
    using QCPAbstractPlottable_WheelEvent_Callback = void (*)(QCPAbstractPlottable*, QWheelEvent*);
    using QCPAbstractPlottable_Event_Callback = bool (*)(QCPAbstractPlottable*, QEvent*);
    using QCPAbstractPlottable_EventFilter_Callback = bool (*)(QCPAbstractPlottable*, QObject*, QEvent*);
    using QCPAbstractPlottable_TimerEvent_Callback = void (*)(QCPAbstractPlottable*, QTimerEvent*);
    using QCPAbstractPlottable_ChildEvent_Callback = void (*)(QCPAbstractPlottable*, QChildEvent*);
    using QCPAbstractPlottable_CustomEvent_Callback = void (*)(QCPAbstractPlottable*, QEvent*);
    using QCPAbstractPlottable_ConnectNotify_Callback = void (*)(QCPAbstractPlottable*, QMetaMethod*);
    using QCPAbstractPlottable_DisconnectNotify_Callback = void (*)(QCPAbstractPlottable*, QMetaMethod*);
    using QCPAbstractPlottable_ApplyFillAntialiasingHint_Callback = void (*)(const QCPAbstractPlottable*, QCPPainter*);
    using QCPAbstractPlottable_ApplyScattersAntialiasingHint_Callback = void (*)(const QCPAbstractPlottable*, QCPPainter*);
    using QCPAbstractPlottable_InitializeParentPlot_Callback = void (*)(QCPAbstractPlottable*, QCustomPlot*);
    using QCPAbstractPlottable_SetParentLayerable_Callback = void (*)(QCPAbstractPlottable*, QCPLayerable*);
    using QCPAbstractPlottable_MoveToLayer_Callback = bool (*)(QCPAbstractPlottable*, QCPLayer*, bool);
    using QCPAbstractPlottable_ApplyAntialiasingHint_Callback = void (*)(const QCPAbstractPlottable*, QCPPainter*, bool, int);
    using QCPAbstractPlottable_Sender_Callback = QObject* (*)();
    using QCPAbstractPlottable_SenderSignalIndex_Callback = int (*)();
    using QCPAbstractPlottable_Receivers_Callback = int (*)(const QCPAbstractPlottable*, const char*);
    using QCPAbstractPlottable_IsSignalConnected_Callback = bool (*)(const QCPAbstractPlottable*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPAbstractPlottable_Metacall_Callback qcpabstractplottable_metacall_callback = nullptr;
    QCPAbstractPlottable_SelectTest_Callback qcpabstractplottable_selecttest_callback = nullptr;
    QCPAbstractPlottable_Interface1D_Callback qcpabstractplottable_interface1d_callback = nullptr;
    QCPAbstractPlottable_GetKeyRange_Callback qcpabstractplottable_getkeyrange_callback = nullptr;
    QCPAbstractPlottable_GetValueRange_Callback qcpabstractplottable_getvaluerange_callback = nullptr;
    QCPAbstractPlottable_ClipRect_Callback qcpabstractplottable_cliprect_callback = nullptr;
    QCPAbstractPlottable_Draw_Callback qcpabstractplottable_draw_callback = nullptr;
    QCPAbstractPlottable_SelectionCategory_Callback qcpabstractplottable_selectioncategory_callback = nullptr;
    QCPAbstractPlottable_ApplyDefaultAntialiasingHint_Callback qcpabstractplottable_applydefaultantialiasinghint_callback = nullptr;
    QCPAbstractPlottable_SelectEvent_Callback qcpabstractplottable_selectevent_callback = nullptr;
    QCPAbstractPlottable_DeselectEvent_Callback qcpabstractplottable_deselectevent_callback = nullptr;
    QCPAbstractPlottable_DrawLegendIcon_Callback qcpabstractplottable_drawlegendicon_callback = nullptr;
    QCPAbstractPlottable_ParentPlotInitialized_Callback qcpabstractplottable_parentplotinitialized_callback = nullptr;
    QCPAbstractPlottable_MousePressEvent_Callback qcpabstractplottable_mousepressevent_callback = nullptr;
    QCPAbstractPlottable_MouseMoveEvent_Callback qcpabstractplottable_mousemoveevent_callback = nullptr;
    QCPAbstractPlottable_MouseReleaseEvent_Callback qcpabstractplottable_mousereleaseevent_callback = nullptr;
    QCPAbstractPlottable_MouseDoubleClickEvent_Callback qcpabstractplottable_mousedoubleclickevent_callback = nullptr;
    QCPAbstractPlottable_WheelEvent_Callback qcpabstractplottable_wheelevent_callback = nullptr;
    QCPAbstractPlottable_Event_Callback qcpabstractplottable_event_callback = nullptr;
    QCPAbstractPlottable_EventFilter_Callback qcpabstractplottable_eventfilter_callback = nullptr;
    QCPAbstractPlottable_TimerEvent_Callback qcpabstractplottable_timerevent_callback = nullptr;
    QCPAbstractPlottable_ChildEvent_Callback qcpabstractplottable_childevent_callback = nullptr;
    QCPAbstractPlottable_CustomEvent_Callback qcpabstractplottable_customevent_callback = nullptr;
    QCPAbstractPlottable_ConnectNotify_Callback qcpabstractplottable_connectnotify_callback = nullptr;
    QCPAbstractPlottable_DisconnectNotify_Callback qcpabstractplottable_disconnectnotify_callback = nullptr;
    QCPAbstractPlottable_ApplyFillAntialiasingHint_Callback qcpabstractplottable_applyfillantialiasinghint_callback = nullptr;
    QCPAbstractPlottable_ApplyScattersAntialiasingHint_Callback qcpabstractplottable_applyscattersantialiasinghint_callback = nullptr;
    QCPAbstractPlottable_InitializeParentPlot_Callback qcpabstractplottable_initializeparentplot_callback = nullptr;
    QCPAbstractPlottable_SetParentLayerable_Callback qcpabstractplottable_setparentlayerable_callback = nullptr;
    QCPAbstractPlottable_MoveToLayer_Callback qcpabstractplottable_movetolayer_callback = nullptr;
    QCPAbstractPlottable_ApplyAntialiasingHint_Callback qcpabstractplottable_applyantialiasinghint_callback = nullptr;
    QCPAbstractPlottable_Sender_Callback qcpabstractplottable_sender_callback = nullptr;
    QCPAbstractPlottable_SenderSignalIndex_Callback qcpabstractplottable_sendersignalindex_callback = nullptr;
    QCPAbstractPlottable_Receivers_Callback qcpabstractplottable_receivers_callback = nullptr;
    QCPAbstractPlottable_IsSignalConnected_Callback qcpabstractplottable_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpabstractplottable_metacall_isbase = false;
    mutable bool qcpabstractplottable_selecttest_isbase = false;
    mutable bool qcpabstractplottable_interface1d_isbase = false;
    mutable bool qcpabstractplottable_getkeyrange_isbase = false;
    mutable bool qcpabstractplottable_getvaluerange_isbase = false;
    mutable bool qcpabstractplottable_cliprect_isbase = false;
    mutable bool qcpabstractplottable_draw_isbase = false;
    mutable bool qcpabstractplottable_selectioncategory_isbase = false;
    mutable bool qcpabstractplottable_applydefaultantialiasinghint_isbase = false;
    mutable bool qcpabstractplottable_selectevent_isbase = false;
    mutable bool qcpabstractplottable_deselectevent_isbase = false;
    mutable bool qcpabstractplottable_drawlegendicon_isbase = false;
    mutable bool qcpabstractplottable_parentplotinitialized_isbase = false;
    mutable bool qcpabstractplottable_mousepressevent_isbase = false;
    mutable bool qcpabstractplottable_mousemoveevent_isbase = false;
    mutable bool qcpabstractplottable_mousereleaseevent_isbase = false;
    mutable bool qcpabstractplottable_mousedoubleclickevent_isbase = false;
    mutable bool qcpabstractplottable_wheelevent_isbase = false;
    mutable bool qcpabstractplottable_event_isbase = false;
    mutable bool qcpabstractplottable_eventfilter_isbase = false;
    mutable bool qcpabstractplottable_timerevent_isbase = false;
    mutable bool qcpabstractplottable_childevent_isbase = false;
    mutable bool qcpabstractplottable_customevent_isbase = false;
    mutable bool qcpabstractplottable_connectnotify_isbase = false;
    mutable bool qcpabstractplottable_disconnectnotify_isbase = false;
    mutable bool qcpabstractplottable_applyfillantialiasinghint_isbase = false;
    mutable bool qcpabstractplottable_applyscattersantialiasinghint_isbase = false;
    mutable bool qcpabstractplottable_initializeparentplot_isbase = false;
    mutable bool qcpabstractplottable_setparentlayerable_isbase = false;
    mutable bool qcpabstractplottable_movetolayer_isbase = false;
    mutable bool qcpabstractplottable_applyantialiasinghint_isbase = false;
    mutable bool qcpabstractplottable_sender_isbase = false;
    mutable bool qcpabstractplottable_sendersignalindex_isbase = false;
    mutable bool qcpabstractplottable_receivers_isbase = false;
    mutable bool qcpabstractplottable_issignalconnected_isbase = false;

  public:
    VirtualQCPAbstractPlottable(QCPAxis* keyAxis, QCPAxis* valueAxis) : QCPAbstractPlottable(keyAxis, valueAxis) {};

    ~VirtualQCPAbstractPlottable() {
        qcpabstractplottable_metacall_callback = nullptr;
        qcpabstractplottable_selecttest_callback = nullptr;
        qcpabstractplottable_interface1d_callback = nullptr;
        qcpabstractplottable_getkeyrange_callback = nullptr;
        qcpabstractplottable_getvaluerange_callback = nullptr;
        qcpabstractplottable_cliprect_callback = nullptr;
        qcpabstractplottable_draw_callback = nullptr;
        qcpabstractplottable_selectioncategory_callback = nullptr;
        qcpabstractplottable_applydefaultantialiasinghint_callback = nullptr;
        qcpabstractplottable_selectevent_callback = nullptr;
        qcpabstractplottable_deselectevent_callback = nullptr;
        qcpabstractplottable_drawlegendicon_callback = nullptr;
        qcpabstractplottable_parentplotinitialized_callback = nullptr;
        qcpabstractplottable_mousepressevent_callback = nullptr;
        qcpabstractplottable_mousemoveevent_callback = nullptr;
        qcpabstractplottable_mousereleaseevent_callback = nullptr;
        qcpabstractplottable_mousedoubleclickevent_callback = nullptr;
        qcpabstractplottable_wheelevent_callback = nullptr;
        qcpabstractplottable_event_callback = nullptr;
        qcpabstractplottable_eventfilter_callback = nullptr;
        qcpabstractplottable_timerevent_callback = nullptr;
        qcpabstractplottable_childevent_callback = nullptr;
        qcpabstractplottable_customevent_callback = nullptr;
        qcpabstractplottable_connectnotify_callback = nullptr;
        qcpabstractplottable_disconnectnotify_callback = nullptr;
        qcpabstractplottable_applyfillantialiasinghint_callback = nullptr;
        qcpabstractplottable_applyscattersantialiasinghint_callback = nullptr;
        qcpabstractplottable_initializeparentplot_callback = nullptr;
        qcpabstractplottable_setparentlayerable_callback = nullptr;
        qcpabstractplottable_movetolayer_callback = nullptr;
        qcpabstractplottable_applyantialiasinghint_callback = nullptr;
        qcpabstractplottable_sender_callback = nullptr;
        qcpabstractplottable_sendersignalindex_callback = nullptr;
        qcpabstractplottable_receivers_callback = nullptr;
        qcpabstractplottable_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPAbstractPlottable_Metacall_Callback(QCPAbstractPlottable_Metacall_Callback cb) { qcpabstractplottable_metacall_callback = cb; }
    inline void setQCPAbstractPlottable_SelectTest_Callback(QCPAbstractPlottable_SelectTest_Callback cb) { qcpabstractplottable_selecttest_callback = cb; }
    inline void setQCPAbstractPlottable_Interface1D_Callback(QCPAbstractPlottable_Interface1D_Callback cb) { qcpabstractplottable_interface1d_callback = cb; }
    inline void setQCPAbstractPlottable_GetKeyRange_Callback(QCPAbstractPlottable_GetKeyRange_Callback cb) { qcpabstractplottable_getkeyrange_callback = cb; }
    inline void setQCPAbstractPlottable_GetValueRange_Callback(QCPAbstractPlottable_GetValueRange_Callback cb) { qcpabstractplottable_getvaluerange_callback = cb; }
    inline void setQCPAbstractPlottable_ClipRect_Callback(QCPAbstractPlottable_ClipRect_Callback cb) { qcpabstractplottable_cliprect_callback = cb; }
    inline void setQCPAbstractPlottable_Draw_Callback(QCPAbstractPlottable_Draw_Callback cb) { qcpabstractplottable_draw_callback = cb; }
    inline void setQCPAbstractPlottable_SelectionCategory_Callback(QCPAbstractPlottable_SelectionCategory_Callback cb) { qcpabstractplottable_selectioncategory_callback = cb; }
    inline void setQCPAbstractPlottable_ApplyDefaultAntialiasingHint_Callback(QCPAbstractPlottable_ApplyDefaultAntialiasingHint_Callback cb) { qcpabstractplottable_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPAbstractPlottable_SelectEvent_Callback(QCPAbstractPlottable_SelectEvent_Callback cb) { qcpabstractplottable_selectevent_callback = cb; }
    inline void setQCPAbstractPlottable_DeselectEvent_Callback(QCPAbstractPlottable_DeselectEvent_Callback cb) { qcpabstractplottable_deselectevent_callback = cb; }
    inline void setQCPAbstractPlottable_DrawLegendIcon_Callback(QCPAbstractPlottable_DrawLegendIcon_Callback cb) { qcpabstractplottable_drawlegendicon_callback = cb; }
    inline void setQCPAbstractPlottable_ParentPlotInitialized_Callback(QCPAbstractPlottable_ParentPlotInitialized_Callback cb) { qcpabstractplottable_parentplotinitialized_callback = cb; }
    inline void setQCPAbstractPlottable_MousePressEvent_Callback(QCPAbstractPlottable_MousePressEvent_Callback cb) { qcpabstractplottable_mousepressevent_callback = cb; }
    inline void setQCPAbstractPlottable_MouseMoveEvent_Callback(QCPAbstractPlottable_MouseMoveEvent_Callback cb) { qcpabstractplottable_mousemoveevent_callback = cb; }
    inline void setQCPAbstractPlottable_MouseReleaseEvent_Callback(QCPAbstractPlottable_MouseReleaseEvent_Callback cb) { qcpabstractplottable_mousereleaseevent_callback = cb; }
    inline void setQCPAbstractPlottable_MouseDoubleClickEvent_Callback(QCPAbstractPlottable_MouseDoubleClickEvent_Callback cb) { qcpabstractplottable_mousedoubleclickevent_callback = cb; }
    inline void setQCPAbstractPlottable_WheelEvent_Callback(QCPAbstractPlottable_WheelEvent_Callback cb) { qcpabstractplottable_wheelevent_callback = cb; }
    inline void setQCPAbstractPlottable_Event_Callback(QCPAbstractPlottable_Event_Callback cb) { qcpabstractplottable_event_callback = cb; }
    inline void setQCPAbstractPlottable_EventFilter_Callback(QCPAbstractPlottable_EventFilter_Callback cb) { qcpabstractplottable_eventfilter_callback = cb; }
    inline void setQCPAbstractPlottable_TimerEvent_Callback(QCPAbstractPlottable_TimerEvent_Callback cb) { qcpabstractplottable_timerevent_callback = cb; }
    inline void setQCPAbstractPlottable_ChildEvent_Callback(QCPAbstractPlottable_ChildEvent_Callback cb) { qcpabstractplottable_childevent_callback = cb; }
    inline void setQCPAbstractPlottable_CustomEvent_Callback(QCPAbstractPlottable_CustomEvent_Callback cb) { qcpabstractplottable_customevent_callback = cb; }
    inline void setQCPAbstractPlottable_ConnectNotify_Callback(QCPAbstractPlottable_ConnectNotify_Callback cb) { qcpabstractplottable_connectnotify_callback = cb; }
    inline void setQCPAbstractPlottable_DisconnectNotify_Callback(QCPAbstractPlottable_DisconnectNotify_Callback cb) { qcpabstractplottable_disconnectnotify_callback = cb; }
    inline void setQCPAbstractPlottable_ApplyFillAntialiasingHint_Callback(QCPAbstractPlottable_ApplyFillAntialiasingHint_Callback cb) { qcpabstractplottable_applyfillantialiasinghint_callback = cb; }
    inline void setQCPAbstractPlottable_ApplyScattersAntialiasingHint_Callback(QCPAbstractPlottable_ApplyScattersAntialiasingHint_Callback cb) { qcpabstractplottable_applyscattersantialiasinghint_callback = cb; }
    inline void setQCPAbstractPlottable_InitializeParentPlot_Callback(QCPAbstractPlottable_InitializeParentPlot_Callback cb) { qcpabstractplottable_initializeparentplot_callback = cb; }
    inline void setQCPAbstractPlottable_SetParentLayerable_Callback(QCPAbstractPlottable_SetParentLayerable_Callback cb) { qcpabstractplottable_setparentlayerable_callback = cb; }
    inline void setQCPAbstractPlottable_MoveToLayer_Callback(QCPAbstractPlottable_MoveToLayer_Callback cb) { qcpabstractplottable_movetolayer_callback = cb; }
    inline void setQCPAbstractPlottable_ApplyAntialiasingHint_Callback(QCPAbstractPlottable_ApplyAntialiasingHint_Callback cb) { qcpabstractplottable_applyantialiasinghint_callback = cb; }
    inline void setQCPAbstractPlottable_Sender_Callback(QCPAbstractPlottable_Sender_Callback cb) { qcpabstractplottable_sender_callback = cb; }
    inline void setQCPAbstractPlottable_SenderSignalIndex_Callback(QCPAbstractPlottable_SenderSignalIndex_Callback cb) { qcpabstractplottable_sendersignalindex_callback = cb; }
    inline void setQCPAbstractPlottable_Receivers_Callback(QCPAbstractPlottable_Receivers_Callback cb) { qcpabstractplottable_receivers_callback = cb; }
    inline void setQCPAbstractPlottable_IsSignalConnected_Callback(QCPAbstractPlottable_IsSignalConnected_Callback cb) { qcpabstractplottable_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPAbstractPlottable_Metacall_IsBase(bool value) const { qcpabstractplottable_metacall_isbase = value; }
    inline void setQCPAbstractPlottable_SelectTest_IsBase(bool value) const { qcpabstractplottable_selecttest_isbase = value; }
    inline void setQCPAbstractPlottable_Interface1D_IsBase(bool value) const { qcpabstractplottable_interface1d_isbase = value; }
    inline void setQCPAbstractPlottable_GetKeyRange_IsBase(bool value) const { qcpabstractplottable_getkeyrange_isbase = value; }
    inline void setQCPAbstractPlottable_GetValueRange_IsBase(bool value) const { qcpabstractplottable_getvaluerange_isbase = value; }
    inline void setQCPAbstractPlottable_ClipRect_IsBase(bool value) const { qcpabstractplottable_cliprect_isbase = value; }
    inline void setQCPAbstractPlottable_Draw_IsBase(bool value) const { qcpabstractplottable_draw_isbase = value; }
    inline void setQCPAbstractPlottable_SelectionCategory_IsBase(bool value) const { qcpabstractplottable_selectioncategory_isbase = value; }
    inline void setQCPAbstractPlottable_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcpabstractplottable_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPAbstractPlottable_SelectEvent_IsBase(bool value) const { qcpabstractplottable_selectevent_isbase = value; }
    inline void setQCPAbstractPlottable_DeselectEvent_IsBase(bool value) const { qcpabstractplottable_deselectevent_isbase = value; }
    inline void setQCPAbstractPlottable_DrawLegendIcon_IsBase(bool value) const { qcpabstractplottable_drawlegendicon_isbase = value; }
    inline void setQCPAbstractPlottable_ParentPlotInitialized_IsBase(bool value) const { qcpabstractplottable_parentplotinitialized_isbase = value; }
    inline void setQCPAbstractPlottable_MousePressEvent_IsBase(bool value) const { qcpabstractplottable_mousepressevent_isbase = value; }
    inline void setQCPAbstractPlottable_MouseMoveEvent_IsBase(bool value) const { qcpabstractplottable_mousemoveevent_isbase = value; }
    inline void setQCPAbstractPlottable_MouseReleaseEvent_IsBase(bool value) const { qcpabstractplottable_mousereleaseevent_isbase = value; }
    inline void setQCPAbstractPlottable_MouseDoubleClickEvent_IsBase(bool value) const { qcpabstractplottable_mousedoubleclickevent_isbase = value; }
    inline void setQCPAbstractPlottable_WheelEvent_IsBase(bool value) const { qcpabstractplottable_wheelevent_isbase = value; }
    inline void setQCPAbstractPlottable_Event_IsBase(bool value) const { qcpabstractplottable_event_isbase = value; }
    inline void setQCPAbstractPlottable_EventFilter_IsBase(bool value) const { qcpabstractplottable_eventfilter_isbase = value; }
    inline void setQCPAbstractPlottable_TimerEvent_IsBase(bool value) const { qcpabstractplottable_timerevent_isbase = value; }
    inline void setQCPAbstractPlottable_ChildEvent_IsBase(bool value) const { qcpabstractplottable_childevent_isbase = value; }
    inline void setQCPAbstractPlottable_CustomEvent_IsBase(bool value) const { qcpabstractplottable_customevent_isbase = value; }
    inline void setQCPAbstractPlottable_ConnectNotify_IsBase(bool value) const { qcpabstractplottable_connectnotify_isbase = value; }
    inline void setQCPAbstractPlottable_DisconnectNotify_IsBase(bool value) const { qcpabstractplottable_disconnectnotify_isbase = value; }
    inline void setQCPAbstractPlottable_ApplyFillAntialiasingHint_IsBase(bool value) const { qcpabstractplottable_applyfillantialiasinghint_isbase = value; }
    inline void setQCPAbstractPlottable_ApplyScattersAntialiasingHint_IsBase(bool value) const { qcpabstractplottable_applyscattersantialiasinghint_isbase = value; }
    inline void setQCPAbstractPlottable_InitializeParentPlot_IsBase(bool value) const { qcpabstractplottable_initializeparentplot_isbase = value; }
    inline void setQCPAbstractPlottable_SetParentLayerable_IsBase(bool value) const { qcpabstractplottable_setparentlayerable_isbase = value; }
    inline void setQCPAbstractPlottable_MoveToLayer_IsBase(bool value) const { qcpabstractplottable_movetolayer_isbase = value; }
    inline void setQCPAbstractPlottable_ApplyAntialiasingHint_IsBase(bool value) const { qcpabstractplottable_applyantialiasinghint_isbase = value; }
    inline void setQCPAbstractPlottable_Sender_IsBase(bool value) const { qcpabstractplottable_sender_isbase = value; }
    inline void setQCPAbstractPlottable_SenderSignalIndex_IsBase(bool value) const { qcpabstractplottable_sendersignalindex_isbase = value; }
    inline void setQCPAbstractPlottable_Receivers_IsBase(bool value) const { qcpabstractplottable_receivers_isbase = value; }
    inline void setQCPAbstractPlottable_IsSignalConnected_IsBase(bool value) const { qcpabstractplottable_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpabstractplottable_metacall_isbase) {
            qcpabstractplottable_metacall_isbase = false;
            return QCPAbstractPlottable::qt_metacall(param1, param2, param3);
        } else if (qcpabstractplottable_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpabstractplottable_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPAbstractPlottable::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcpabstractplottable_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcpabstractplottable_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPPlottableInterface1D* interface1D() override {
        if (qcpabstractplottable_interface1d_isbase) {
            qcpabstractplottable_interface1d_isbase = false;
            return QCPAbstractPlottable::interface1D();
        } else if (qcpabstractplottable_interface1d_callback != nullptr) {
            QCPPlottableInterface1D* callback_ret = qcpabstractplottable_interface1d_callback();
            return callback_ret;
        } else {
            return QCPAbstractPlottable::interface1D();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPRange getKeyRange(bool& foundRange, QCP::SignDomain inSignDomain) const override {
        if (qcpabstractplottable_getkeyrange_callback != nullptr) {
            bool* cbval1 = &foundRange;
            int cbval2 = static_cast<int>(inSignDomain);

            QCPRange* callback_ret = qcpabstractplottable_getkeyrange_callback(this, cbval1, cbval2);
            return *callback_ret;
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPRange getValueRange(bool& foundRange, QCP::SignDomain inSignDomain, const QCPRange& inKeyRange) const override {
        if (qcpabstractplottable_getvaluerange_callback != nullptr) {
            bool* cbval1 = &foundRange;
            int cbval2 = static_cast<int>(inSignDomain);
            const QCPRange& inKeyRange_ret = inKeyRange;
            // Cast returned reference into pointer
            QCPRange* cbval3 = const_cast<QCPRange*>(&inKeyRange_ret);

            QCPRange* callback_ret = qcpabstractplottable_getvaluerange_callback(this, cbval1, cbval2, cbval3);
            return *callback_ret;
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcpabstractplottable_cliprect_isbase) {
            qcpabstractplottable_cliprect_isbase = false;
            return QCPAbstractPlottable::clipRect();
        } else if (qcpabstractplottable_cliprect_callback != nullptr) {
            QRect* callback_ret = qcpabstractplottable_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPAbstractPlottable::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcpabstractplottable_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpabstractplottable_draw_callback(this, cbval1);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcpabstractplottable_selectioncategory_isbase) {
            qcpabstractplottable_selectioncategory_isbase = false;
            return QCPAbstractPlottable::selectionCategory();
        } else if (qcpabstractplottable_selectioncategory_callback != nullptr) {
            int callback_ret = qcpabstractplottable_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPAbstractPlottable::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcpabstractplottable_applydefaultantialiasinghint_isbase) {
            qcpabstractplottable_applydefaultantialiasinghint_isbase = false;
            QCPAbstractPlottable::applyDefaultAntialiasingHint(painter);
        } else if (qcpabstractplottable_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpabstractplottable_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPAbstractPlottable::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcpabstractplottable_selectevent_isbase) {
            qcpabstractplottable_selectevent_isbase = false;
            QCPAbstractPlottable::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcpabstractplottable_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcpabstractplottable_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPAbstractPlottable::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcpabstractplottable_deselectevent_isbase) {
            qcpabstractplottable_deselectevent_isbase = false;
            QCPAbstractPlottable::deselectEvent(selectionStateChanged);
        } else if (qcpabstractplottable_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcpabstractplottable_deselectevent_callback(this, cbval1);
        } else {
            QCPAbstractPlottable::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void drawLegendIcon(QCPPainter* painter, const QRectF& rect) const override {
        if (qcpabstractplottable_drawlegendicon_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval2 = const_cast<QRectF*>(&rect_ret);

            qcpabstractplottable_drawlegendicon_callback(this, cbval1, cbval2);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcpabstractplottable_parentplotinitialized_isbase) {
            qcpabstractplottable_parentplotinitialized_isbase = false;
            QCPAbstractPlottable::parentPlotInitialized(parentPlot);
        } else if (qcpabstractplottable_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpabstractplottable_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPAbstractPlottable::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpabstractplottable_mousepressevent_isbase) {
            qcpabstractplottable_mousepressevent_isbase = false;
            QCPAbstractPlottable::mousePressEvent(event, details);
        } else if (qcpabstractplottable_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpabstractplottable_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPAbstractPlottable::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpabstractplottable_mousemoveevent_isbase) {
            qcpabstractplottable_mousemoveevent_isbase = false;
            QCPAbstractPlottable::mouseMoveEvent(event, startPos);
        } else if (qcpabstractplottable_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpabstractplottable_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPAbstractPlottable::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpabstractplottable_mousereleaseevent_isbase) {
            qcpabstractplottable_mousereleaseevent_isbase = false;
            QCPAbstractPlottable::mouseReleaseEvent(event, startPos);
        } else if (qcpabstractplottable_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpabstractplottable_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPAbstractPlottable::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpabstractplottable_mousedoubleclickevent_isbase) {
            qcpabstractplottable_mousedoubleclickevent_isbase = false;
            QCPAbstractPlottable::mouseDoubleClickEvent(event, details);
        } else if (qcpabstractplottable_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpabstractplottable_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPAbstractPlottable::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcpabstractplottable_wheelevent_isbase) {
            qcpabstractplottable_wheelevent_isbase = false;
            QCPAbstractPlottable::wheelEvent(event);
        } else if (qcpabstractplottable_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcpabstractplottable_wheelevent_callback(this, cbval1);
        } else {
            QCPAbstractPlottable::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpabstractplottable_event_isbase) {
            qcpabstractplottable_event_isbase = false;
            return QCPAbstractPlottable::event(event);
        } else if (qcpabstractplottable_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpabstractplottable_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPAbstractPlottable::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpabstractplottable_eventfilter_isbase) {
            qcpabstractplottable_eventfilter_isbase = false;
            return QCPAbstractPlottable::eventFilter(watched, event);
        } else if (qcpabstractplottable_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpabstractplottable_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPAbstractPlottable::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpabstractplottable_timerevent_isbase) {
            qcpabstractplottable_timerevent_isbase = false;
            QCPAbstractPlottable::timerEvent(event);
        } else if (qcpabstractplottable_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpabstractplottable_timerevent_callback(this, cbval1);
        } else {
            QCPAbstractPlottable::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpabstractplottable_childevent_isbase) {
            qcpabstractplottable_childevent_isbase = false;
            QCPAbstractPlottable::childEvent(event);
        } else if (qcpabstractplottable_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpabstractplottable_childevent_callback(this, cbval1);
        } else {
            QCPAbstractPlottable::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpabstractplottable_customevent_isbase) {
            qcpabstractplottable_customevent_isbase = false;
            QCPAbstractPlottable::customEvent(event);
        } else if (qcpabstractplottable_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpabstractplottable_customevent_callback(this, cbval1);
        } else {
            QCPAbstractPlottable::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpabstractplottable_connectnotify_isbase) {
            qcpabstractplottable_connectnotify_isbase = false;
            QCPAbstractPlottable::connectNotify(signal);
        } else if (qcpabstractplottable_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpabstractplottable_connectnotify_callback(this, cbval1);
        } else {
            QCPAbstractPlottable::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpabstractplottable_disconnectnotify_isbase) {
            qcpabstractplottable_disconnectnotify_isbase = false;
            QCPAbstractPlottable::disconnectNotify(signal);
        } else if (qcpabstractplottable_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpabstractplottable_disconnectnotify_callback(this, cbval1);
        } else {
            QCPAbstractPlottable::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyFillAntialiasingHint(QCPPainter* painter) const {
        if (qcpabstractplottable_applyfillantialiasinghint_isbase) {
            qcpabstractplottable_applyfillantialiasinghint_isbase = false;
            QCPAbstractPlottable::applyFillAntialiasingHint(painter);
        } else if (qcpabstractplottable_applyfillantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpabstractplottable_applyfillantialiasinghint_callback(this, cbval1);
        } else {
            QCPAbstractPlottable::applyFillAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyScattersAntialiasingHint(QCPPainter* painter) const {
        if (qcpabstractplottable_applyscattersantialiasinghint_isbase) {
            qcpabstractplottable_applyscattersantialiasinghint_isbase = false;
            QCPAbstractPlottable::applyScattersAntialiasingHint(painter);
        } else if (qcpabstractplottable_applyscattersantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpabstractplottable_applyscattersantialiasinghint_callback(this, cbval1);
        } else {
            QCPAbstractPlottable::applyScattersAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcpabstractplottable_initializeparentplot_isbase) {
            qcpabstractplottable_initializeparentplot_isbase = false;
            QCPAbstractPlottable::initializeParentPlot(parentPlot);
        } else if (qcpabstractplottable_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpabstractplottable_initializeparentplot_callback(this, cbval1);
        } else {
            QCPAbstractPlottable::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcpabstractplottable_setparentlayerable_isbase) {
            qcpabstractplottable_setparentlayerable_isbase = false;
            QCPAbstractPlottable::setParentLayerable(parentLayerable);
        } else if (qcpabstractplottable_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcpabstractplottable_setparentlayerable_callback(this, cbval1);
        } else {
            QCPAbstractPlottable::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcpabstractplottable_movetolayer_isbase) {
            qcpabstractplottable_movetolayer_isbase = false;
            return QCPAbstractPlottable::moveToLayer(layer, prepend);
        } else if (qcpabstractplottable_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcpabstractplottable_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPAbstractPlottable::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcpabstractplottable_applyantialiasinghint_isbase) {
            qcpabstractplottable_applyantialiasinghint_isbase = false;
            QCPAbstractPlottable::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcpabstractplottable_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcpabstractplottable_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPAbstractPlottable::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpabstractplottable_sender_isbase) {
            qcpabstractplottable_sender_isbase = false;
            return QCPAbstractPlottable::sender();
        } else if (qcpabstractplottable_sender_callback != nullptr) {
            QObject* callback_ret = qcpabstractplottable_sender_callback();
            return callback_ret;
        } else {
            return QCPAbstractPlottable::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpabstractplottable_sendersignalindex_isbase) {
            qcpabstractplottable_sendersignalindex_isbase = false;
            return QCPAbstractPlottable::senderSignalIndex();
        } else if (qcpabstractplottable_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpabstractplottable_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPAbstractPlottable::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpabstractplottable_receivers_isbase) {
            qcpabstractplottable_receivers_isbase = false;
            return QCPAbstractPlottable::receivers(signal);
        } else if (qcpabstractplottable_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpabstractplottable_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPAbstractPlottable::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpabstractplottable_issignalconnected_isbase) {
            qcpabstractplottable_issignalconnected_isbase = false;
            return QCPAbstractPlottable::isSignalConnected(signal);
        } else if (qcpabstractplottable_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpabstractplottable_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPAbstractPlottable::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend QRect* QCPAbstractPlottable_ClipRect(const QCPAbstractPlottable* self);
    friend QRect* QCPAbstractPlottable_QBaseClipRect(const QCPAbstractPlottable* self);
    friend void QCPAbstractPlottable_Draw(QCPAbstractPlottable* self, QCPPainter* painter);
    friend void QCPAbstractPlottable_QBaseDraw(QCPAbstractPlottable* self, QCPPainter* painter);
    friend int QCPAbstractPlottable_SelectionCategory(const QCPAbstractPlottable* self);
    friend int QCPAbstractPlottable_QBaseSelectionCategory(const QCPAbstractPlottable* self);
    friend void QCPAbstractPlottable_ApplyDefaultAntialiasingHint(const QCPAbstractPlottable* self, QCPPainter* painter);
    friend void QCPAbstractPlottable_QBaseApplyDefaultAntialiasingHint(const QCPAbstractPlottable* self, QCPPainter* painter);
    friend void QCPAbstractPlottable_SelectEvent(QCPAbstractPlottable* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPAbstractPlottable_QBaseSelectEvent(QCPAbstractPlottable* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPAbstractPlottable_DeselectEvent(QCPAbstractPlottable* self, bool* selectionStateChanged);
    friend void QCPAbstractPlottable_QBaseDeselectEvent(QCPAbstractPlottable* self, bool* selectionStateChanged);
    friend void QCPAbstractPlottable_DrawLegendIcon(const QCPAbstractPlottable* self, QCPPainter* painter, const QRectF* rect);
    friend void QCPAbstractPlottable_QBaseDrawLegendIcon(const QCPAbstractPlottable* self, QCPPainter* painter, const QRectF* rect);
    friend void QCPAbstractPlottable_ParentPlotInitialized(QCPAbstractPlottable* self, QCustomPlot* parentPlot);
    friend void QCPAbstractPlottable_QBaseParentPlotInitialized(QCPAbstractPlottable* self, QCustomPlot* parentPlot);
    friend void QCPAbstractPlottable_MousePressEvent(QCPAbstractPlottable* self, QMouseEvent* event, const QVariant* details);
    friend void QCPAbstractPlottable_QBaseMousePressEvent(QCPAbstractPlottable* self, QMouseEvent* event, const QVariant* details);
    friend void QCPAbstractPlottable_MouseMoveEvent(QCPAbstractPlottable* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPAbstractPlottable_QBaseMouseMoveEvent(QCPAbstractPlottable* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPAbstractPlottable_MouseReleaseEvent(QCPAbstractPlottable* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPAbstractPlottable_QBaseMouseReleaseEvent(QCPAbstractPlottable* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPAbstractPlottable_MouseDoubleClickEvent(QCPAbstractPlottable* self, QMouseEvent* event, const QVariant* details);
    friend void QCPAbstractPlottable_QBaseMouseDoubleClickEvent(QCPAbstractPlottable* self, QMouseEvent* event, const QVariant* details);
    friend void QCPAbstractPlottable_WheelEvent(QCPAbstractPlottable* self, QWheelEvent* event);
    friend void QCPAbstractPlottable_QBaseWheelEvent(QCPAbstractPlottable* self, QWheelEvent* event);
    friend void QCPAbstractPlottable_TimerEvent(QCPAbstractPlottable* self, QTimerEvent* event);
    friend void QCPAbstractPlottable_QBaseTimerEvent(QCPAbstractPlottable* self, QTimerEvent* event);
    friend void QCPAbstractPlottable_ChildEvent(QCPAbstractPlottable* self, QChildEvent* event);
    friend void QCPAbstractPlottable_QBaseChildEvent(QCPAbstractPlottable* self, QChildEvent* event);
    friend void QCPAbstractPlottable_CustomEvent(QCPAbstractPlottable* self, QEvent* event);
    friend void QCPAbstractPlottable_QBaseCustomEvent(QCPAbstractPlottable* self, QEvent* event);
    friend void QCPAbstractPlottable_ConnectNotify(QCPAbstractPlottable* self, const QMetaMethod* signal);
    friend void QCPAbstractPlottable_QBaseConnectNotify(QCPAbstractPlottable* self, const QMetaMethod* signal);
    friend void QCPAbstractPlottable_DisconnectNotify(QCPAbstractPlottable* self, const QMetaMethod* signal);
    friend void QCPAbstractPlottable_QBaseDisconnectNotify(QCPAbstractPlottable* self, const QMetaMethod* signal);
    friend void QCPAbstractPlottable_ApplyFillAntialiasingHint(const QCPAbstractPlottable* self, QCPPainter* painter);
    friend void QCPAbstractPlottable_QBaseApplyFillAntialiasingHint(const QCPAbstractPlottable* self, QCPPainter* painter);
    friend void QCPAbstractPlottable_ApplyScattersAntialiasingHint(const QCPAbstractPlottable* self, QCPPainter* painter);
    friend void QCPAbstractPlottable_QBaseApplyScattersAntialiasingHint(const QCPAbstractPlottable* self, QCPPainter* painter);
    friend void QCPAbstractPlottable_InitializeParentPlot(QCPAbstractPlottable* self, QCustomPlot* parentPlot);
    friend void QCPAbstractPlottable_QBaseInitializeParentPlot(QCPAbstractPlottable* self, QCustomPlot* parentPlot);
    friend void QCPAbstractPlottable_SetParentLayerable(QCPAbstractPlottable* self, QCPLayerable* parentLayerable);
    friend void QCPAbstractPlottable_QBaseSetParentLayerable(QCPAbstractPlottable* self, QCPLayerable* parentLayerable);
    friend bool QCPAbstractPlottable_MoveToLayer(QCPAbstractPlottable* self, QCPLayer* layer, bool prepend);
    friend bool QCPAbstractPlottable_QBaseMoveToLayer(QCPAbstractPlottable* self, QCPLayer* layer, bool prepend);
    friend void QCPAbstractPlottable_ApplyAntialiasingHint(const QCPAbstractPlottable* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPAbstractPlottable_QBaseApplyAntialiasingHint(const QCPAbstractPlottable* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPAbstractPlottable_Sender(const QCPAbstractPlottable* self);
    friend QObject* QCPAbstractPlottable_QBaseSender(const QCPAbstractPlottable* self);
    friend int QCPAbstractPlottable_SenderSignalIndex(const QCPAbstractPlottable* self);
    friend int QCPAbstractPlottable_QBaseSenderSignalIndex(const QCPAbstractPlottable* self);
    friend int QCPAbstractPlottable_Receivers(const QCPAbstractPlottable* self, const char* signal);
    friend int QCPAbstractPlottable_QBaseReceivers(const QCPAbstractPlottable* self, const char* signal);
    friend bool QCPAbstractPlottable_IsSignalConnected(const QCPAbstractPlottable* self, const QMetaMethod* signal);
    friend bool QCPAbstractPlottable_QBaseIsSignalConnected(const QCPAbstractPlottable* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPItemAnchor so that we can call protected methods
class VirtualQCPItemAnchor final : public QCPItemAnchor {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPItemAnchor = true;

    // Virtual class public types (including callbacks)
    using QCPItemAnchor_PixelPosition_Callback = QPointF* (*)();
    using QCPItemAnchor_ToQCPItemPosition_Callback = QCPItemPosition* (*)();
    using QCPItemAnchor_AddChildX_Callback = void (*)(QCPItemAnchor*, QCPItemPosition*);
    using QCPItemAnchor_RemoveChildX_Callback = void (*)(QCPItemAnchor*, QCPItemPosition*);
    using QCPItemAnchor_AddChildY_Callback = void (*)(QCPItemAnchor*, QCPItemPosition*);
    using QCPItemAnchor_RemoveChildY_Callback = void (*)(QCPItemAnchor*, QCPItemPosition*);

  protected:
    // Instance callback storage
    QCPItemAnchor_PixelPosition_Callback qcpitemanchor_pixelposition_callback = nullptr;
    QCPItemAnchor_ToQCPItemPosition_Callback qcpitemanchor_toqcpitemposition_callback = nullptr;
    QCPItemAnchor_AddChildX_Callback qcpitemanchor_addchildx_callback = nullptr;
    QCPItemAnchor_RemoveChildX_Callback qcpitemanchor_removechildx_callback = nullptr;
    QCPItemAnchor_AddChildY_Callback qcpitemanchor_addchildy_callback = nullptr;
    QCPItemAnchor_RemoveChildY_Callback qcpitemanchor_removechildy_callback = nullptr;

    // Instance base flags
    mutable bool qcpitemanchor_pixelposition_isbase = false;
    mutable bool qcpitemanchor_toqcpitemposition_isbase = false;
    mutable bool qcpitemanchor_addchildx_isbase = false;
    mutable bool qcpitemanchor_removechildx_isbase = false;
    mutable bool qcpitemanchor_addchildy_isbase = false;
    mutable bool qcpitemanchor_removechildy_isbase = false;

  public:
    VirtualQCPItemAnchor(QCustomPlot* parentPlot, QCPAbstractItem* parentItem, const QString& name) : QCPItemAnchor(parentPlot, parentItem, name) {};
    VirtualQCPItemAnchor(QCustomPlot* parentPlot, QCPAbstractItem* parentItem, const QString& name, int anchorId) : QCPItemAnchor(parentPlot, parentItem, name, anchorId) {};

    ~VirtualQCPItemAnchor() {
        qcpitemanchor_pixelposition_callback = nullptr;
        qcpitemanchor_toqcpitemposition_callback = nullptr;
        qcpitemanchor_addchildx_callback = nullptr;
        qcpitemanchor_removechildx_callback = nullptr;
        qcpitemanchor_addchildy_callback = nullptr;
        qcpitemanchor_removechildy_callback = nullptr;
    }

    // Callback setters
    inline void setQCPItemAnchor_PixelPosition_Callback(QCPItemAnchor_PixelPosition_Callback cb) { qcpitemanchor_pixelposition_callback = cb; }
    inline void setQCPItemAnchor_ToQCPItemPosition_Callback(QCPItemAnchor_ToQCPItemPosition_Callback cb) { qcpitemanchor_toqcpitemposition_callback = cb; }
    inline void setQCPItemAnchor_AddChildX_Callback(QCPItemAnchor_AddChildX_Callback cb) { qcpitemanchor_addchildx_callback = cb; }
    inline void setQCPItemAnchor_RemoveChildX_Callback(QCPItemAnchor_RemoveChildX_Callback cb) { qcpitemanchor_removechildx_callback = cb; }
    inline void setQCPItemAnchor_AddChildY_Callback(QCPItemAnchor_AddChildY_Callback cb) { qcpitemanchor_addchildy_callback = cb; }
    inline void setQCPItemAnchor_RemoveChildY_Callback(QCPItemAnchor_RemoveChildY_Callback cb) { qcpitemanchor_removechildy_callback = cb; }

    // Base flag setters
    inline void setQCPItemAnchor_PixelPosition_IsBase(bool value) const { qcpitemanchor_pixelposition_isbase = value; }
    inline void setQCPItemAnchor_ToQCPItemPosition_IsBase(bool value) const { qcpitemanchor_toqcpitemposition_isbase = value; }
    inline void setQCPItemAnchor_AddChildX_IsBase(bool value) const { qcpitemanchor_addchildx_isbase = value; }
    inline void setQCPItemAnchor_RemoveChildX_IsBase(bool value) const { qcpitemanchor_removechildx_isbase = value; }
    inline void setQCPItemAnchor_AddChildY_IsBase(bool value) const { qcpitemanchor_addchildy_isbase = value; }
    inline void setQCPItemAnchor_RemoveChildY_IsBase(bool value) const { qcpitemanchor_removechildy_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual QPointF pixelPosition() const override {
        if (qcpitemanchor_pixelposition_isbase) {
            qcpitemanchor_pixelposition_isbase = false;
            return QCPItemAnchor::pixelPosition();
        } else if (qcpitemanchor_pixelposition_callback != nullptr) {
            QPointF* callback_ret = qcpitemanchor_pixelposition_callback();
            return *callback_ret;
        } else {
            return QCPItemAnchor::pixelPosition();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPItemPosition* toQCPItemPosition() override {
        if (qcpitemanchor_toqcpitemposition_isbase) {
            qcpitemanchor_toqcpitemposition_isbase = false;
            return QCPItemAnchor::toQCPItemPosition();
        } else if (qcpitemanchor_toqcpitemposition_callback != nullptr) {
            QCPItemPosition* callback_ret = qcpitemanchor_toqcpitemposition_callback();
            return callback_ret;
        } else {
            return QCPItemAnchor::toQCPItemPosition();
        }
    }

    // Virtual method for C ABI access and custom callback
    void addChildX(QCPItemPosition* pos) {
        if (qcpitemanchor_addchildx_isbase) {
            qcpitemanchor_addchildx_isbase = false;
            QCPItemAnchor::addChildX(pos);
        } else if (qcpitemanchor_addchildx_callback != nullptr) {
            QCPItemPosition* cbval1 = pos;

            qcpitemanchor_addchildx_callback(this, cbval1);
        } else {
            QCPItemAnchor::addChildX(pos);
        }
    }

    // Virtual method for C ABI access and custom callback
    void removeChildX(QCPItemPosition* pos) {
        if (qcpitemanchor_removechildx_isbase) {
            qcpitemanchor_removechildx_isbase = false;
            QCPItemAnchor::removeChildX(pos);
        } else if (qcpitemanchor_removechildx_callback != nullptr) {
            QCPItemPosition* cbval1 = pos;

            qcpitemanchor_removechildx_callback(this, cbval1);
        } else {
            QCPItemAnchor::removeChildX(pos);
        }
    }

    // Virtual method for C ABI access and custom callback
    void addChildY(QCPItemPosition* pos) {
        if (qcpitemanchor_addchildy_isbase) {
            qcpitemanchor_addchildy_isbase = false;
            QCPItemAnchor::addChildY(pos);
        } else if (qcpitemanchor_addchildy_callback != nullptr) {
            QCPItemPosition* cbval1 = pos;

            qcpitemanchor_addchildy_callback(this, cbval1);
        } else {
            QCPItemAnchor::addChildY(pos);
        }
    }

    // Virtual method for C ABI access and custom callback
    void removeChildY(QCPItemPosition* pos) {
        if (qcpitemanchor_removechildy_isbase) {
            qcpitemanchor_removechildy_isbase = false;
            QCPItemAnchor::removeChildY(pos);
        } else if (qcpitemanchor_removechildy_callback != nullptr) {
            QCPItemPosition* cbval1 = pos;

            qcpitemanchor_removechildy_callback(this, cbval1);
        } else {
            QCPItemAnchor::removeChildY(pos);
        }
    }

    // Friend functions
    friend QCPItemPosition* QCPItemAnchor_ToQCPItemPosition(QCPItemAnchor* self);
    friend QCPItemPosition* QCPItemAnchor_QBaseToQCPItemPosition(QCPItemAnchor* self);
    friend void QCPItemAnchor_AddChildX(QCPItemAnchor* self, QCPItemPosition* pos);
    friend void QCPItemAnchor_QBaseAddChildX(QCPItemAnchor* self, QCPItemPosition* pos);
    friend void QCPItemAnchor_RemoveChildX(QCPItemAnchor* self, QCPItemPosition* pos);
    friend void QCPItemAnchor_QBaseRemoveChildX(QCPItemAnchor* self, QCPItemPosition* pos);
    friend void QCPItemAnchor_AddChildY(QCPItemAnchor* self, QCPItemPosition* pos);
    friend void QCPItemAnchor_QBaseAddChildY(QCPItemAnchor* self, QCPItemPosition* pos);
    friend void QCPItemAnchor_RemoveChildY(QCPItemAnchor* self, QCPItemPosition* pos);
    friend void QCPItemAnchor_QBaseRemoveChildY(QCPItemAnchor* self, QCPItemPosition* pos);
};

// This class is a subclass of QCPItemPosition so that we can call protected methods
class VirtualQCPItemPosition final : public QCPItemPosition {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPItemPosition = true;

    // Virtual class public types (including callbacks)
    using QCPItemPosition_PixelPosition_Callback = QPointF* (*)();
    using QCPItemPosition_ToQCPItemPosition_Callback = QCPItemPosition* (*)();
    using QCPItemPosition_AddChildX_Callback = void (*)(QCPItemPosition*, QCPItemPosition*);
    using QCPItemPosition_RemoveChildX_Callback = void (*)(QCPItemPosition*, QCPItemPosition*);
    using QCPItemPosition_AddChildY_Callback = void (*)(QCPItemPosition*, QCPItemPosition*);
    using QCPItemPosition_RemoveChildY_Callback = void (*)(QCPItemPosition*, QCPItemPosition*);

  protected:
    // Instance callback storage
    QCPItemPosition_PixelPosition_Callback qcpitemposition_pixelposition_callback = nullptr;
    QCPItemPosition_ToQCPItemPosition_Callback qcpitemposition_toqcpitemposition_callback = nullptr;
    QCPItemPosition_AddChildX_Callback qcpitemposition_addchildx_callback = nullptr;
    QCPItemPosition_RemoveChildX_Callback qcpitemposition_removechildx_callback = nullptr;
    QCPItemPosition_AddChildY_Callback qcpitemposition_addchildy_callback = nullptr;
    QCPItemPosition_RemoveChildY_Callback qcpitemposition_removechildy_callback = nullptr;

    // Instance base flags
    mutable bool qcpitemposition_pixelposition_isbase = false;
    mutable bool qcpitemposition_toqcpitemposition_isbase = false;
    mutable bool qcpitemposition_addchildx_isbase = false;
    mutable bool qcpitemposition_removechildx_isbase = false;
    mutable bool qcpitemposition_addchildy_isbase = false;
    mutable bool qcpitemposition_removechildy_isbase = false;

  public:
    VirtualQCPItemPosition(QCustomPlot* parentPlot, QCPAbstractItem* parentItem, const QString& name) : QCPItemPosition(parentPlot, parentItem, name) {};

    ~VirtualQCPItemPosition() {
        qcpitemposition_pixelposition_callback = nullptr;
        qcpitemposition_toqcpitemposition_callback = nullptr;
        qcpitemposition_addchildx_callback = nullptr;
        qcpitemposition_removechildx_callback = nullptr;
        qcpitemposition_addchildy_callback = nullptr;
        qcpitemposition_removechildy_callback = nullptr;
    }

    // Callback setters
    inline void setQCPItemPosition_PixelPosition_Callback(QCPItemPosition_PixelPosition_Callback cb) { qcpitemposition_pixelposition_callback = cb; }
    inline void setQCPItemPosition_ToQCPItemPosition_Callback(QCPItemPosition_ToQCPItemPosition_Callback cb) { qcpitemposition_toqcpitemposition_callback = cb; }
    inline void setQCPItemPosition_AddChildX_Callback(QCPItemPosition_AddChildX_Callback cb) { qcpitemposition_addchildx_callback = cb; }
    inline void setQCPItemPosition_RemoveChildX_Callback(QCPItemPosition_RemoveChildX_Callback cb) { qcpitemposition_removechildx_callback = cb; }
    inline void setQCPItemPosition_AddChildY_Callback(QCPItemPosition_AddChildY_Callback cb) { qcpitemposition_addchildy_callback = cb; }
    inline void setQCPItemPosition_RemoveChildY_Callback(QCPItemPosition_RemoveChildY_Callback cb) { qcpitemposition_removechildy_callback = cb; }

    // Base flag setters
    inline void setQCPItemPosition_PixelPosition_IsBase(bool value) const { qcpitemposition_pixelposition_isbase = value; }
    inline void setQCPItemPosition_ToQCPItemPosition_IsBase(bool value) const { qcpitemposition_toqcpitemposition_isbase = value; }
    inline void setQCPItemPosition_AddChildX_IsBase(bool value) const { qcpitemposition_addchildx_isbase = value; }
    inline void setQCPItemPosition_RemoveChildX_IsBase(bool value) const { qcpitemposition_removechildx_isbase = value; }
    inline void setQCPItemPosition_AddChildY_IsBase(bool value) const { qcpitemposition_addchildy_isbase = value; }
    inline void setQCPItemPosition_RemoveChildY_IsBase(bool value) const { qcpitemposition_removechildy_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual QPointF pixelPosition() const override {
        if (qcpitemposition_pixelposition_isbase) {
            qcpitemposition_pixelposition_isbase = false;
            return QCPItemPosition::pixelPosition();
        } else if (qcpitemposition_pixelposition_callback != nullptr) {
            QPointF* callback_ret = qcpitemposition_pixelposition_callback();
            return *callback_ret;
        } else {
            return QCPItemPosition::pixelPosition();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPItemPosition* toQCPItemPosition() override {
        if (qcpitemposition_toqcpitemposition_isbase) {
            qcpitemposition_toqcpitemposition_isbase = false;
            return QCPItemPosition::toQCPItemPosition();
        } else if (qcpitemposition_toqcpitemposition_callback != nullptr) {
            QCPItemPosition* callback_ret = qcpitemposition_toqcpitemposition_callback();
            return callback_ret;
        } else {
            return QCPItemPosition::toQCPItemPosition();
        }
    }

    // Virtual method for C ABI access and custom callback
    void addChildX(QCPItemPosition* pos) {
        if (qcpitemposition_addchildx_isbase) {
            qcpitemposition_addchildx_isbase = false;
            QCPItemPosition::addChildX(pos);
        } else if (qcpitemposition_addchildx_callback != nullptr) {
            QCPItemPosition* cbval1 = pos;

            qcpitemposition_addchildx_callback(this, cbval1);
        } else {
            QCPItemPosition::addChildX(pos);
        }
    }

    // Virtual method for C ABI access and custom callback
    void removeChildX(QCPItemPosition* pos) {
        if (qcpitemposition_removechildx_isbase) {
            qcpitemposition_removechildx_isbase = false;
            QCPItemPosition::removeChildX(pos);
        } else if (qcpitemposition_removechildx_callback != nullptr) {
            QCPItemPosition* cbval1 = pos;

            qcpitemposition_removechildx_callback(this, cbval1);
        } else {
            QCPItemPosition::removeChildX(pos);
        }
    }

    // Virtual method for C ABI access and custom callback
    void addChildY(QCPItemPosition* pos) {
        if (qcpitemposition_addchildy_isbase) {
            qcpitemposition_addchildy_isbase = false;
            QCPItemPosition::addChildY(pos);
        } else if (qcpitemposition_addchildy_callback != nullptr) {
            QCPItemPosition* cbval1 = pos;

            qcpitemposition_addchildy_callback(this, cbval1);
        } else {
            QCPItemPosition::addChildY(pos);
        }
    }

    // Virtual method for C ABI access and custom callback
    void removeChildY(QCPItemPosition* pos) {
        if (qcpitemposition_removechildy_isbase) {
            qcpitemposition_removechildy_isbase = false;
            QCPItemPosition::removeChildY(pos);
        } else if (qcpitemposition_removechildy_callback != nullptr) {
            QCPItemPosition* cbval1 = pos;

            qcpitemposition_removechildy_callback(this, cbval1);
        } else {
            QCPItemPosition::removeChildY(pos);
        }
    }

    // Friend functions
    friend QCPItemPosition* QCPItemPosition_ToQCPItemPosition(QCPItemPosition* self);
    friend QCPItemPosition* QCPItemPosition_QBaseToQCPItemPosition(QCPItemPosition* self);
    friend void QCPItemPosition_AddChildX(QCPItemPosition* self, QCPItemPosition* pos);
    friend void QCPItemPosition_QBaseAddChildX(QCPItemPosition* self, QCPItemPosition* pos);
    friend void QCPItemPosition_RemoveChildX(QCPItemPosition* self, QCPItemPosition* pos);
    friend void QCPItemPosition_QBaseRemoveChildX(QCPItemPosition* self, QCPItemPosition* pos);
    friend void QCPItemPosition_AddChildY(QCPItemPosition* self, QCPItemPosition* pos);
    friend void QCPItemPosition_QBaseAddChildY(QCPItemPosition* self, QCPItemPosition* pos);
    friend void QCPItemPosition_RemoveChildY(QCPItemPosition* self, QCPItemPosition* pos);
    friend void QCPItemPosition_QBaseRemoveChildY(QCPItemPosition* self, QCPItemPosition* pos);
};

// This class is a subclass of QCPAbstractItem so that we can call protected methods
class VirtualQCPAbstractItem : public QCPAbstractItem {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPAbstractItem = true;

    // Virtual class public types (including callbacks)
    using QCPAbstractItem_Metacall_Callback = int (*)(QCPAbstractItem*, int, int, void**);
    using QCPAbstractItem_SelectTest_Callback = double (*)(const QCPAbstractItem*, QPointF*, bool, QVariant*);
    using QCPAbstractItem_SelectionCategory_Callback = int (*)();
    using QCPAbstractItem_ClipRect_Callback = QRect* (*)();
    using QCPAbstractItem_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPAbstractItem*, QCPPainter*);
    using QCPAbstractItem_Draw_Callback = void (*)(QCPAbstractItem*, QCPPainter*);
    using QCPAbstractItem_SelectEvent_Callback = void (*)(QCPAbstractItem*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPAbstractItem_DeselectEvent_Callback = void (*)(QCPAbstractItem*, bool*);
    using QCPAbstractItem_AnchorPixelPosition_Callback = QPointF* (*)(const QCPAbstractItem*, int);
    using QCPAbstractItem_ParentPlotInitialized_Callback = void (*)(QCPAbstractItem*, QCustomPlot*);
    using QCPAbstractItem_MousePressEvent_Callback = void (*)(QCPAbstractItem*, QMouseEvent*, QVariant*);
    using QCPAbstractItem_MouseMoveEvent_Callback = void (*)(QCPAbstractItem*, QMouseEvent*, QPointF*);
    using QCPAbstractItem_MouseReleaseEvent_Callback = void (*)(QCPAbstractItem*, QMouseEvent*, QPointF*);
    using QCPAbstractItem_MouseDoubleClickEvent_Callback = void (*)(QCPAbstractItem*, QMouseEvent*, QVariant*);
    using QCPAbstractItem_WheelEvent_Callback = void (*)(QCPAbstractItem*, QWheelEvent*);
    using QCPAbstractItem_Event_Callback = bool (*)(QCPAbstractItem*, QEvent*);
    using QCPAbstractItem_EventFilter_Callback = bool (*)(QCPAbstractItem*, QObject*, QEvent*);
    using QCPAbstractItem_TimerEvent_Callback = void (*)(QCPAbstractItem*, QTimerEvent*);
    using QCPAbstractItem_ChildEvent_Callback = void (*)(QCPAbstractItem*, QChildEvent*);
    using QCPAbstractItem_CustomEvent_Callback = void (*)(QCPAbstractItem*, QEvent*);
    using QCPAbstractItem_ConnectNotify_Callback = void (*)(QCPAbstractItem*, QMetaMethod*);
    using QCPAbstractItem_DisconnectNotify_Callback = void (*)(QCPAbstractItem*, QMetaMethod*);
    using QCPAbstractItem_RectDistance_Callback = double (*)(const QCPAbstractItem*, QRectF*, QPointF*, bool);
    using QCPAbstractItem_CreatePosition_Callback = QCPItemPosition* (*)(QCPAbstractItem*, libqt_string);
    using QCPAbstractItem_CreateAnchor_Callback = QCPItemAnchor* (*)(QCPAbstractItem*, libqt_string, int);
    using QCPAbstractItem_InitializeParentPlot_Callback = void (*)(QCPAbstractItem*, QCustomPlot*);
    using QCPAbstractItem_SetParentLayerable_Callback = void (*)(QCPAbstractItem*, QCPLayerable*);
    using QCPAbstractItem_MoveToLayer_Callback = bool (*)(QCPAbstractItem*, QCPLayer*, bool);
    using QCPAbstractItem_ApplyAntialiasingHint_Callback = void (*)(const QCPAbstractItem*, QCPPainter*, bool, int);
    using QCPAbstractItem_Sender_Callback = QObject* (*)();
    using QCPAbstractItem_SenderSignalIndex_Callback = int (*)();
    using QCPAbstractItem_Receivers_Callback = int (*)(const QCPAbstractItem*, const char*);
    using QCPAbstractItem_IsSignalConnected_Callback = bool (*)(const QCPAbstractItem*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPAbstractItem_Metacall_Callback qcpabstractitem_metacall_callback = nullptr;
    QCPAbstractItem_SelectTest_Callback qcpabstractitem_selecttest_callback = nullptr;
    QCPAbstractItem_SelectionCategory_Callback qcpabstractitem_selectioncategory_callback = nullptr;
    QCPAbstractItem_ClipRect_Callback qcpabstractitem_cliprect_callback = nullptr;
    QCPAbstractItem_ApplyDefaultAntialiasingHint_Callback qcpabstractitem_applydefaultantialiasinghint_callback = nullptr;
    QCPAbstractItem_Draw_Callback qcpabstractitem_draw_callback = nullptr;
    QCPAbstractItem_SelectEvent_Callback qcpabstractitem_selectevent_callback = nullptr;
    QCPAbstractItem_DeselectEvent_Callback qcpabstractitem_deselectevent_callback = nullptr;
    QCPAbstractItem_AnchorPixelPosition_Callback qcpabstractitem_anchorpixelposition_callback = nullptr;
    QCPAbstractItem_ParentPlotInitialized_Callback qcpabstractitem_parentplotinitialized_callback = nullptr;
    QCPAbstractItem_MousePressEvent_Callback qcpabstractitem_mousepressevent_callback = nullptr;
    QCPAbstractItem_MouseMoveEvent_Callback qcpabstractitem_mousemoveevent_callback = nullptr;
    QCPAbstractItem_MouseReleaseEvent_Callback qcpabstractitem_mousereleaseevent_callback = nullptr;
    QCPAbstractItem_MouseDoubleClickEvent_Callback qcpabstractitem_mousedoubleclickevent_callback = nullptr;
    QCPAbstractItem_WheelEvent_Callback qcpabstractitem_wheelevent_callback = nullptr;
    QCPAbstractItem_Event_Callback qcpabstractitem_event_callback = nullptr;
    QCPAbstractItem_EventFilter_Callback qcpabstractitem_eventfilter_callback = nullptr;
    QCPAbstractItem_TimerEvent_Callback qcpabstractitem_timerevent_callback = nullptr;
    QCPAbstractItem_ChildEvent_Callback qcpabstractitem_childevent_callback = nullptr;
    QCPAbstractItem_CustomEvent_Callback qcpabstractitem_customevent_callback = nullptr;
    QCPAbstractItem_ConnectNotify_Callback qcpabstractitem_connectnotify_callback = nullptr;
    QCPAbstractItem_DisconnectNotify_Callback qcpabstractitem_disconnectnotify_callback = nullptr;
    QCPAbstractItem_RectDistance_Callback qcpabstractitem_rectdistance_callback = nullptr;
    QCPAbstractItem_CreatePosition_Callback qcpabstractitem_createposition_callback = nullptr;
    QCPAbstractItem_CreateAnchor_Callback qcpabstractitem_createanchor_callback = nullptr;
    QCPAbstractItem_InitializeParentPlot_Callback qcpabstractitem_initializeparentplot_callback = nullptr;
    QCPAbstractItem_SetParentLayerable_Callback qcpabstractitem_setparentlayerable_callback = nullptr;
    QCPAbstractItem_MoveToLayer_Callback qcpabstractitem_movetolayer_callback = nullptr;
    QCPAbstractItem_ApplyAntialiasingHint_Callback qcpabstractitem_applyantialiasinghint_callback = nullptr;
    QCPAbstractItem_Sender_Callback qcpabstractitem_sender_callback = nullptr;
    QCPAbstractItem_SenderSignalIndex_Callback qcpabstractitem_sendersignalindex_callback = nullptr;
    QCPAbstractItem_Receivers_Callback qcpabstractitem_receivers_callback = nullptr;
    QCPAbstractItem_IsSignalConnected_Callback qcpabstractitem_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpabstractitem_metacall_isbase = false;
    mutable bool qcpabstractitem_selecttest_isbase = false;
    mutable bool qcpabstractitem_selectioncategory_isbase = false;
    mutable bool qcpabstractitem_cliprect_isbase = false;
    mutable bool qcpabstractitem_applydefaultantialiasinghint_isbase = false;
    mutable bool qcpabstractitem_draw_isbase = false;
    mutable bool qcpabstractitem_selectevent_isbase = false;
    mutable bool qcpabstractitem_deselectevent_isbase = false;
    mutable bool qcpabstractitem_anchorpixelposition_isbase = false;
    mutable bool qcpabstractitem_parentplotinitialized_isbase = false;
    mutable bool qcpabstractitem_mousepressevent_isbase = false;
    mutable bool qcpabstractitem_mousemoveevent_isbase = false;
    mutable bool qcpabstractitem_mousereleaseevent_isbase = false;
    mutable bool qcpabstractitem_mousedoubleclickevent_isbase = false;
    mutable bool qcpabstractitem_wheelevent_isbase = false;
    mutable bool qcpabstractitem_event_isbase = false;
    mutable bool qcpabstractitem_eventfilter_isbase = false;
    mutable bool qcpabstractitem_timerevent_isbase = false;
    mutable bool qcpabstractitem_childevent_isbase = false;
    mutable bool qcpabstractitem_customevent_isbase = false;
    mutable bool qcpabstractitem_connectnotify_isbase = false;
    mutable bool qcpabstractitem_disconnectnotify_isbase = false;
    mutable bool qcpabstractitem_rectdistance_isbase = false;
    mutable bool qcpabstractitem_createposition_isbase = false;
    mutable bool qcpabstractitem_createanchor_isbase = false;
    mutable bool qcpabstractitem_initializeparentplot_isbase = false;
    mutable bool qcpabstractitem_setparentlayerable_isbase = false;
    mutable bool qcpabstractitem_movetolayer_isbase = false;
    mutable bool qcpabstractitem_applyantialiasinghint_isbase = false;
    mutable bool qcpabstractitem_sender_isbase = false;
    mutable bool qcpabstractitem_sendersignalindex_isbase = false;
    mutable bool qcpabstractitem_receivers_isbase = false;
    mutable bool qcpabstractitem_issignalconnected_isbase = false;

  public:
    VirtualQCPAbstractItem(QCustomPlot* parentPlot) : QCPAbstractItem(parentPlot) {};

    ~VirtualQCPAbstractItem() {
        qcpabstractitem_metacall_callback = nullptr;
        qcpabstractitem_selecttest_callback = nullptr;
        qcpabstractitem_selectioncategory_callback = nullptr;
        qcpabstractitem_cliprect_callback = nullptr;
        qcpabstractitem_applydefaultantialiasinghint_callback = nullptr;
        qcpabstractitem_draw_callback = nullptr;
        qcpabstractitem_selectevent_callback = nullptr;
        qcpabstractitem_deselectevent_callback = nullptr;
        qcpabstractitem_anchorpixelposition_callback = nullptr;
        qcpabstractitem_parentplotinitialized_callback = nullptr;
        qcpabstractitem_mousepressevent_callback = nullptr;
        qcpabstractitem_mousemoveevent_callback = nullptr;
        qcpabstractitem_mousereleaseevent_callback = nullptr;
        qcpabstractitem_mousedoubleclickevent_callback = nullptr;
        qcpabstractitem_wheelevent_callback = nullptr;
        qcpabstractitem_event_callback = nullptr;
        qcpabstractitem_eventfilter_callback = nullptr;
        qcpabstractitem_timerevent_callback = nullptr;
        qcpabstractitem_childevent_callback = nullptr;
        qcpabstractitem_customevent_callback = nullptr;
        qcpabstractitem_connectnotify_callback = nullptr;
        qcpabstractitem_disconnectnotify_callback = nullptr;
        qcpabstractitem_rectdistance_callback = nullptr;
        qcpabstractitem_createposition_callback = nullptr;
        qcpabstractitem_createanchor_callback = nullptr;
        qcpabstractitem_initializeparentplot_callback = nullptr;
        qcpabstractitem_setparentlayerable_callback = nullptr;
        qcpabstractitem_movetolayer_callback = nullptr;
        qcpabstractitem_applyantialiasinghint_callback = nullptr;
        qcpabstractitem_sender_callback = nullptr;
        qcpabstractitem_sendersignalindex_callback = nullptr;
        qcpabstractitem_receivers_callback = nullptr;
        qcpabstractitem_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPAbstractItem_Metacall_Callback(QCPAbstractItem_Metacall_Callback cb) { qcpabstractitem_metacall_callback = cb; }
    inline void setQCPAbstractItem_SelectTest_Callback(QCPAbstractItem_SelectTest_Callback cb) { qcpabstractitem_selecttest_callback = cb; }
    inline void setQCPAbstractItem_SelectionCategory_Callback(QCPAbstractItem_SelectionCategory_Callback cb) { qcpabstractitem_selectioncategory_callback = cb; }
    inline void setQCPAbstractItem_ClipRect_Callback(QCPAbstractItem_ClipRect_Callback cb) { qcpabstractitem_cliprect_callback = cb; }
    inline void setQCPAbstractItem_ApplyDefaultAntialiasingHint_Callback(QCPAbstractItem_ApplyDefaultAntialiasingHint_Callback cb) { qcpabstractitem_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPAbstractItem_Draw_Callback(QCPAbstractItem_Draw_Callback cb) { qcpabstractitem_draw_callback = cb; }
    inline void setQCPAbstractItem_SelectEvent_Callback(QCPAbstractItem_SelectEvent_Callback cb) { qcpabstractitem_selectevent_callback = cb; }
    inline void setQCPAbstractItem_DeselectEvent_Callback(QCPAbstractItem_DeselectEvent_Callback cb) { qcpabstractitem_deselectevent_callback = cb; }
    inline void setQCPAbstractItem_AnchorPixelPosition_Callback(QCPAbstractItem_AnchorPixelPosition_Callback cb) { qcpabstractitem_anchorpixelposition_callback = cb; }
    inline void setQCPAbstractItem_ParentPlotInitialized_Callback(QCPAbstractItem_ParentPlotInitialized_Callback cb) { qcpabstractitem_parentplotinitialized_callback = cb; }
    inline void setQCPAbstractItem_MousePressEvent_Callback(QCPAbstractItem_MousePressEvent_Callback cb) { qcpabstractitem_mousepressevent_callback = cb; }
    inline void setQCPAbstractItem_MouseMoveEvent_Callback(QCPAbstractItem_MouseMoveEvent_Callback cb) { qcpabstractitem_mousemoveevent_callback = cb; }
    inline void setQCPAbstractItem_MouseReleaseEvent_Callback(QCPAbstractItem_MouseReleaseEvent_Callback cb) { qcpabstractitem_mousereleaseevent_callback = cb; }
    inline void setQCPAbstractItem_MouseDoubleClickEvent_Callback(QCPAbstractItem_MouseDoubleClickEvent_Callback cb) { qcpabstractitem_mousedoubleclickevent_callback = cb; }
    inline void setQCPAbstractItem_WheelEvent_Callback(QCPAbstractItem_WheelEvent_Callback cb) { qcpabstractitem_wheelevent_callback = cb; }
    inline void setQCPAbstractItem_Event_Callback(QCPAbstractItem_Event_Callback cb) { qcpabstractitem_event_callback = cb; }
    inline void setQCPAbstractItem_EventFilter_Callback(QCPAbstractItem_EventFilter_Callback cb) { qcpabstractitem_eventfilter_callback = cb; }
    inline void setQCPAbstractItem_TimerEvent_Callback(QCPAbstractItem_TimerEvent_Callback cb) { qcpabstractitem_timerevent_callback = cb; }
    inline void setQCPAbstractItem_ChildEvent_Callback(QCPAbstractItem_ChildEvent_Callback cb) { qcpabstractitem_childevent_callback = cb; }
    inline void setQCPAbstractItem_CustomEvent_Callback(QCPAbstractItem_CustomEvent_Callback cb) { qcpabstractitem_customevent_callback = cb; }
    inline void setQCPAbstractItem_ConnectNotify_Callback(QCPAbstractItem_ConnectNotify_Callback cb) { qcpabstractitem_connectnotify_callback = cb; }
    inline void setQCPAbstractItem_DisconnectNotify_Callback(QCPAbstractItem_DisconnectNotify_Callback cb) { qcpabstractitem_disconnectnotify_callback = cb; }
    inline void setQCPAbstractItem_RectDistance_Callback(QCPAbstractItem_RectDistance_Callback cb) { qcpabstractitem_rectdistance_callback = cb; }
    inline void setQCPAbstractItem_CreatePosition_Callback(QCPAbstractItem_CreatePosition_Callback cb) { qcpabstractitem_createposition_callback = cb; }
    inline void setQCPAbstractItem_CreateAnchor_Callback(QCPAbstractItem_CreateAnchor_Callback cb) { qcpabstractitem_createanchor_callback = cb; }
    inline void setQCPAbstractItem_InitializeParentPlot_Callback(QCPAbstractItem_InitializeParentPlot_Callback cb) { qcpabstractitem_initializeparentplot_callback = cb; }
    inline void setQCPAbstractItem_SetParentLayerable_Callback(QCPAbstractItem_SetParentLayerable_Callback cb) { qcpabstractitem_setparentlayerable_callback = cb; }
    inline void setQCPAbstractItem_MoveToLayer_Callback(QCPAbstractItem_MoveToLayer_Callback cb) { qcpabstractitem_movetolayer_callback = cb; }
    inline void setQCPAbstractItem_ApplyAntialiasingHint_Callback(QCPAbstractItem_ApplyAntialiasingHint_Callback cb) { qcpabstractitem_applyantialiasinghint_callback = cb; }
    inline void setQCPAbstractItem_Sender_Callback(QCPAbstractItem_Sender_Callback cb) { qcpabstractitem_sender_callback = cb; }
    inline void setQCPAbstractItem_SenderSignalIndex_Callback(QCPAbstractItem_SenderSignalIndex_Callback cb) { qcpabstractitem_sendersignalindex_callback = cb; }
    inline void setQCPAbstractItem_Receivers_Callback(QCPAbstractItem_Receivers_Callback cb) { qcpabstractitem_receivers_callback = cb; }
    inline void setQCPAbstractItem_IsSignalConnected_Callback(QCPAbstractItem_IsSignalConnected_Callback cb) { qcpabstractitem_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPAbstractItem_Metacall_IsBase(bool value) const { qcpabstractitem_metacall_isbase = value; }
    inline void setQCPAbstractItem_SelectTest_IsBase(bool value) const { qcpabstractitem_selecttest_isbase = value; }
    inline void setQCPAbstractItem_SelectionCategory_IsBase(bool value) const { qcpabstractitem_selectioncategory_isbase = value; }
    inline void setQCPAbstractItem_ClipRect_IsBase(bool value) const { qcpabstractitem_cliprect_isbase = value; }
    inline void setQCPAbstractItem_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcpabstractitem_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPAbstractItem_Draw_IsBase(bool value) const { qcpabstractitem_draw_isbase = value; }
    inline void setQCPAbstractItem_SelectEvent_IsBase(bool value) const { qcpabstractitem_selectevent_isbase = value; }
    inline void setQCPAbstractItem_DeselectEvent_IsBase(bool value) const { qcpabstractitem_deselectevent_isbase = value; }
    inline void setQCPAbstractItem_AnchorPixelPosition_IsBase(bool value) const { qcpabstractitem_anchorpixelposition_isbase = value; }
    inline void setQCPAbstractItem_ParentPlotInitialized_IsBase(bool value) const { qcpabstractitem_parentplotinitialized_isbase = value; }
    inline void setQCPAbstractItem_MousePressEvent_IsBase(bool value) const { qcpabstractitem_mousepressevent_isbase = value; }
    inline void setQCPAbstractItem_MouseMoveEvent_IsBase(bool value) const { qcpabstractitem_mousemoveevent_isbase = value; }
    inline void setQCPAbstractItem_MouseReleaseEvent_IsBase(bool value) const { qcpabstractitem_mousereleaseevent_isbase = value; }
    inline void setQCPAbstractItem_MouseDoubleClickEvent_IsBase(bool value) const { qcpabstractitem_mousedoubleclickevent_isbase = value; }
    inline void setQCPAbstractItem_WheelEvent_IsBase(bool value) const { qcpabstractitem_wheelevent_isbase = value; }
    inline void setQCPAbstractItem_Event_IsBase(bool value) const { qcpabstractitem_event_isbase = value; }
    inline void setQCPAbstractItem_EventFilter_IsBase(bool value) const { qcpabstractitem_eventfilter_isbase = value; }
    inline void setQCPAbstractItem_TimerEvent_IsBase(bool value) const { qcpabstractitem_timerevent_isbase = value; }
    inline void setQCPAbstractItem_ChildEvent_IsBase(bool value) const { qcpabstractitem_childevent_isbase = value; }
    inline void setQCPAbstractItem_CustomEvent_IsBase(bool value) const { qcpabstractitem_customevent_isbase = value; }
    inline void setQCPAbstractItem_ConnectNotify_IsBase(bool value) const { qcpabstractitem_connectnotify_isbase = value; }
    inline void setQCPAbstractItem_DisconnectNotify_IsBase(bool value) const { qcpabstractitem_disconnectnotify_isbase = value; }
    inline void setQCPAbstractItem_RectDistance_IsBase(bool value) const { qcpabstractitem_rectdistance_isbase = value; }
    inline void setQCPAbstractItem_CreatePosition_IsBase(bool value) const { qcpabstractitem_createposition_isbase = value; }
    inline void setQCPAbstractItem_CreateAnchor_IsBase(bool value) const { qcpabstractitem_createanchor_isbase = value; }
    inline void setQCPAbstractItem_InitializeParentPlot_IsBase(bool value) const { qcpabstractitem_initializeparentplot_isbase = value; }
    inline void setQCPAbstractItem_SetParentLayerable_IsBase(bool value) const { qcpabstractitem_setparentlayerable_isbase = value; }
    inline void setQCPAbstractItem_MoveToLayer_IsBase(bool value) const { qcpabstractitem_movetolayer_isbase = value; }
    inline void setQCPAbstractItem_ApplyAntialiasingHint_IsBase(bool value) const { qcpabstractitem_applyantialiasinghint_isbase = value; }
    inline void setQCPAbstractItem_Sender_IsBase(bool value) const { qcpabstractitem_sender_isbase = value; }
    inline void setQCPAbstractItem_SenderSignalIndex_IsBase(bool value) const { qcpabstractitem_sendersignalindex_isbase = value; }
    inline void setQCPAbstractItem_Receivers_IsBase(bool value) const { qcpabstractitem_receivers_isbase = value; }
    inline void setQCPAbstractItem_IsSignalConnected_IsBase(bool value) const { qcpabstractitem_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpabstractitem_metacall_isbase) {
            qcpabstractitem_metacall_isbase = false;
            return QCPAbstractItem::qt_metacall(param1, param2, param3);
        } else if (qcpabstractitem_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpabstractitem_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPAbstractItem::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcpabstractitem_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcpabstractitem_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcpabstractitem_selectioncategory_isbase) {
            qcpabstractitem_selectioncategory_isbase = false;
            return QCPAbstractItem::selectionCategory();
        } else if (qcpabstractitem_selectioncategory_callback != nullptr) {
            int callback_ret = qcpabstractitem_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPAbstractItem::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcpabstractitem_cliprect_isbase) {
            qcpabstractitem_cliprect_isbase = false;
            return QCPAbstractItem::clipRect();
        } else if (qcpabstractitem_cliprect_callback != nullptr) {
            QRect* callback_ret = qcpabstractitem_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPAbstractItem::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcpabstractitem_applydefaultantialiasinghint_isbase) {
            qcpabstractitem_applydefaultantialiasinghint_isbase = false;
            QCPAbstractItem::applyDefaultAntialiasingHint(painter);
        } else if (qcpabstractitem_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpabstractitem_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPAbstractItem::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcpabstractitem_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpabstractitem_draw_callback(this, cbval1);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcpabstractitem_selectevent_isbase) {
            qcpabstractitem_selectevent_isbase = false;
            QCPAbstractItem::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcpabstractitem_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcpabstractitem_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPAbstractItem::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcpabstractitem_deselectevent_isbase) {
            qcpabstractitem_deselectevent_isbase = false;
            QCPAbstractItem::deselectEvent(selectionStateChanged);
        } else if (qcpabstractitem_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcpabstractitem_deselectevent_callback(this, cbval1);
        } else {
            QCPAbstractItem::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QPointF anchorPixelPosition(int anchorId) const override {
        if (qcpabstractitem_anchorpixelposition_isbase) {
            qcpabstractitem_anchorpixelposition_isbase = false;
            return QCPAbstractItem::anchorPixelPosition(anchorId);
        } else if (qcpabstractitem_anchorpixelposition_callback != nullptr) {
            int cbval1 = anchorId;

            QPointF* callback_ret = qcpabstractitem_anchorpixelposition_callback(this, cbval1);
            return *callback_ret;
        } else {
            return QCPAbstractItem::anchorPixelPosition(anchorId);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcpabstractitem_parentplotinitialized_isbase) {
            qcpabstractitem_parentplotinitialized_isbase = false;
            QCPAbstractItem::parentPlotInitialized(parentPlot);
        } else if (qcpabstractitem_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpabstractitem_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPAbstractItem::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpabstractitem_mousepressevent_isbase) {
            qcpabstractitem_mousepressevent_isbase = false;
            QCPAbstractItem::mousePressEvent(event, details);
        } else if (qcpabstractitem_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpabstractitem_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPAbstractItem::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpabstractitem_mousemoveevent_isbase) {
            qcpabstractitem_mousemoveevent_isbase = false;
            QCPAbstractItem::mouseMoveEvent(event, startPos);
        } else if (qcpabstractitem_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpabstractitem_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPAbstractItem::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpabstractitem_mousereleaseevent_isbase) {
            qcpabstractitem_mousereleaseevent_isbase = false;
            QCPAbstractItem::mouseReleaseEvent(event, startPos);
        } else if (qcpabstractitem_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpabstractitem_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPAbstractItem::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpabstractitem_mousedoubleclickevent_isbase) {
            qcpabstractitem_mousedoubleclickevent_isbase = false;
            QCPAbstractItem::mouseDoubleClickEvent(event, details);
        } else if (qcpabstractitem_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpabstractitem_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPAbstractItem::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcpabstractitem_wheelevent_isbase) {
            qcpabstractitem_wheelevent_isbase = false;
            QCPAbstractItem::wheelEvent(event);
        } else if (qcpabstractitem_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcpabstractitem_wheelevent_callback(this, cbval1);
        } else {
            QCPAbstractItem::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpabstractitem_event_isbase) {
            qcpabstractitem_event_isbase = false;
            return QCPAbstractItem::event(event);
        } else if (qcpabstractitem_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpabstractitem_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPAbstractItem::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpabstractitem_eventfilter_isbase) {
            qcpabstractitem_eventfilter_isbase = false;
            return QCPAbstractItem::eventFilter(watched, event);
        } else if (qcpabstractitem_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpabstractitem_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPAbstractItem::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpabstractitem_timerevent_isbase) {
            qcpabstractitem_timerevent_isbase = false;
            QCPAbstractItem::timerEvent(event);
        } else if (qcpabstractitem_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpabstractitem_timerevent_callback(this, cbval1);
        } else {
            QCPAbstractItem::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpabstractitem_childevent_isbase) {
            qcpabstractitem_childevent_isbase = false;
            QCPAbstractItem::childEvent(event);
        } else if (qcpabstractitem_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpabstractitem_childevent_callback(this, cbval1);
        } else {
            QCPAbstractItem::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpabstractitem_customevent_isbase) {
            qcpabstractitem_customevent_isbase = false;
            QCPAbstractItem::customEvent(event);
        } else if (qcpabstractitem_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpabstractitem_customevent_callback(this, cbval1);
        } else {
            QCPAbstractItem::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpabstractitem_connectnotify_isbase) {
            qcpabstractitem_connectnotify_isbase = false;
            QCPAbstractItem::connectNotify(signal);
        } else if (qcpabstractitem_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpabstractitem_connectnotify_callback(this, cbval1);
        } else {
            QCPAbstractItem::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpabstractitem_disconnectnotify_isbase) {
            qcpabstractitem_disconnectnotify_isbase = false;
            QCPAbstractItem::disconnectNotify(signal);
        } else if (qcpabstractitem_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpabstractitem_disconnectnotify_callback(this, cbval1);
        } else {
            QCPAbstractItem::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    double rectDistance(const QRectF& rect, const QPointF& pos, bool filledRect) const {
        if (qcpabstractitem_rectdistance_isbase) {
            qcpabstractitem_rectdistance_isbase = false;
            return QCPAbstractItem::rectDistance(rect, pos, filledRect);
        } else if (qcpabstractitem_rectdistance_callback != nullptr) {
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval1 = const_cast<QRectF*>(&rect_ret);
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&pos_ret);
            bool cbval3 = filledRect;

            double callback_ret = qcpabstractitem_rectdistance_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAbstractItem::rectDistance(rect, pos, filledRect);
        }
    }

    // Virtual method for C ABI access and custom callback
    QCPItemPosition* createPosition(const QString& name) {
        if (qcpabstractitem_createposition_isbase) {
            qcpabstractitem_createposition_isbase = false;
            return QCPAbstractItem::createPosition(name);
        } else if (qcpabstractitem_createposition_callback != nullptr) {
            const QString name_ret = name;
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray name_b = name_ret.toUtf8();
            libqt_string name_str;
            name_str.len = name_b.length();
            name_str.data = static_cast<const char*>(malloc(name_str.len + 1));
            memcpy((void*)name_str.data, name_b.data(), name_str.len);
            ((char*)name_str.data)[name_str.len] = '\0';
            libqt_string cbval1 = name_str;

            QCPItemPosition* callback_ret = qcpabstractitem_createposition_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPAbstractItem::createPosition(name);
        }
    }

    // Virtual method for C ABI access and custom callback
    QCPItemAnchor* createAnchor(const QString& name, int anchorId) {
        if (qcpabstractitem_createanchor_isbase) {
            qcpabstractitem_createanchor_isbase = false;
            return QCPAbstractItem::createAnchor(name, anchorId);
        } else if (qcpabstractitem_createanchor_callback != nullptr) {
            const QString name_ret = name;
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray name_b = name_ret.toUtf8();
            libqt_string name_str;
            name_str.len = name_b.length();
            name_str.data = static_cast<const char*>(malloc(name_str.len + 1));
            memcpy((void*)name_str.data, name_b.data(), name_str.len);
            ((char*)name_str.data)[name_str.len] = '\0';
            libqt_string cbval1 = name_str;
            int cbval2 = anchorId;

            QCPItemAnchor* callback_ret = qcpabstractitem_createanchor_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPAbstractItem::createAnchor(name, anchorId);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcpabstractitem_initializeparentplot_isbase) {
            qcpabstractitem_initializeparentplot_isbase = false;
            QCPAbstractItem::initializeParentPlot(parentPlot);
        } else if (qcpabstractitem_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpabstractitem_initializeparentplot_callback(this, cbval1);
        } else {
            QCPAbstractItem::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcpabstractitem_setparentlayerable_isbase) {
            qcpabstractitem_setparentlayerable_isbase = false;
            QCPAbstractItem::setParentLayerable(parentLayerable);
        } else if (qcpabstractitem_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcpabstractitem_setparentlayerable_callback(this, cbval1);
        } else {
            QCPAbstractItem::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcpabstractitem_movetolayer_isbase) {
            qcpabstractitem_movetolayer_isbase = false;
            return QCPAbstractItem::moveToLayer(layer, prepend);
        } else if (qcpabstractitem_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcpabstractitem_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPAbstractItem::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcpabstractitem_applyantialiasinghint_isbase) {
            qcpabstractitem_applyantialiasinghint_isbase = false;
            QCPAbstractItem::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcpabstractitem_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcpabstractitem_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPAbstractItem::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpabstractitem_sender_isbase) {
            qcpabstractitem_sender_isbase = false;
            return QCPAbstractItem::sender();
        } else if (qcpabstractitem_sender_callback != nullptr) {
            QObject* callback_ret = qcpabstractitem_sender_callback();
            return callback_ret;
        } else {
            return QCPAbstractItem::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpabstractitem_sendersignalindex_isbase) {
            qcpabstractitem_sendersignalindex_isbase = false;
            return QCPAbstractItem::senderSignalIndex();
        } else if (qcpabstractitem_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpabstractitem_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPAbstractItem::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpabstractitem_receivers_isbase) {
            qcpabstractitem_receivers_isbase = false;
            return QCPAbstractItem::receivers(signal);
        } else if (qcpabstractitem_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpabstractitem_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPAbstractItem::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpabstractitem_issignalconnected_isbase) {
            qcpabstractitem_issignalconnected_isbase = false;
            return QCPAbstractItem::isSignalConnected(signal);
        } else if (qcpabstractitem_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpabstractitem_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPAbstractItem::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend int QCPAbstractItem_SelectionCategory(const QCPAbstractItem* self);
    friend int QCPAbstractItem_QBaseSelectionCategory(const QCPAbstractItem* self);
    friend QRect* QCPAbstractItem_ClipRect(const QCPAbstractItem* self);
    friend QRect* QCPAbstractItem_QBaseClipRect(const QCPAbstractItem* self);
    friend void QCPAbstractItem_ApplyDefaultAntialiasingHint(const QCPAbstractItem* self, QCPPainter* painter);
    friend void QCPAbstractItem_QBaseApplyDefaultAntialiasingHint(const QCPAbstractItem* self, QCPPainter* painter);
    friend void QCPAbstractItem_Draw(QCPAbstractItem* self, QCPPainter* painter);
    friend void QCPAbstractItem_QBaseDraw(QCPAbstractItem* self, QCPPainter* painter);
    friend void QCPAbstractItem_SelectEvent(QCPAbstractItem* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPAbstractItem_QBaseSelectEvent(QCPAbstractItem* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPAbstractItem_DeselectEvent(QCPAbstractItem* self, bool* selectionStateChanged);
    friend void QCPAbstractItem_QBaseDeselectEvent(QCPAbstractItem* self, bool* selectionStateChanged);
    friend QPointF* QCPAbstractItem_AnchorPixelPosition(const QCPAbstractItem* self, int anchorId);
    friend QPointF* QCPAbstractItem_QBaseAnchorPixelPosition(const QCPAbstractItem* self, int anchorId);
    friend void QCPAbstractItem_ParentPlotInitialized(QCPAbstractItem* self, QCustomPlot* parentPlot);
    friend void QCPAbstractItem_QBaseParentPlotInitialized(QCPAbstractItem* self, QCustomPlot* parentPlot);
    friend void QCPAbstractItem_MousePressEvent(QCPAbstractItem* self, QMouseEvent* event, const QVariant* details);
    friend void QCPAbstractItem_QBaseMousePressEvent(QCPAbstractItem* self, QMouseEvent* event, const QVariant* details);
    friend void QCPAbstractItem_MouseMoveEvent(QCPAbstractItem* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPAbstractItem_QBaseMouseMoveEvent(QCPAbstractItem* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPAbstractItem_MouseReleaseEvent(QCPAbstractItem* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPAbstractItem_QBaseMouseReleaseEvent(QCPAbstractItem* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPAbstractItem_MouseDoubleClickEvent(QCPAbstractItem* self, QMouseEvent* event, const QVariant* details);
    friend void QCPAbstractItem_QBaseMouseDoubleClickEvent(QCPAbstractItem* self, QMouseEvent* event, const QVariant* details);
    friend void QCPAbstractItem_WheelEvent(QCPAbstractItem* self, QWheelEvent* event);
    friend void QCPAbstractItem_QBaseWheelEvent(QCPAbstractItem* self, QWheelEvent* event);
    friend void QCPAbstractItem_TimerEvent(QCPAbstractItem* self, QTimerEvent* event);
    friend void QCPAbstractItem_QBaseTimerEvent(QCPAbstractItem* self, QTimerEvent* event);
    friend void QCPAbstractItem_ChildEvent(QCPAbstractItem* self, QChildEvent* event);
    friend void QCPAbstractItem_QBaseChildEvent(QCPAbstractItem* self, QChildEvent* event);
    friend void QCPAbstractItem_CustomEvent(QCPAbstractItem* self, QEvent* event);
    friend void QCPAbstractItem_QBaseCustomEvent(QCPAbstractItem* self, QEvent* event);
    friend void QCPAbstractItem_ConnectNotify(QCPAbstractItem* self, const QMetaMethod* signal);
    friend void QCPAbstractItem_QBaseConnectNotify(QCPAbstractItem* self, const QMetaMethod* signal);
    friend void QCPAbstractItem_DisconnectNotify(QCPAbstractItem* self, const QMetaMethod* signal);
    friend void QCPAbstractItem_QBaseDisconnectNotify(QCPAbstractItem* self, const QMetaMethod* signal);
    friend double QCPAbstractItem_RectDistance(const QCPAbstractItem* self, const QRectF* rect, const QPointF* pos, bool filledRect);
    friend double QCPAbstractItem_QBaseRectDistance(const QCPAbstractItem* self, const QRectF* rect, const QPointF* pos, bool filledRect);
    friend QCPItemPosition* QCPAbstractItem_CreatePosition(QCPAbstractItem* self, const libqt_string name);
    friend QCPItemPosition* QCPAbstractItem_QBaseCreatePosition(QCPAbstractItem* self, const libqt_string name);
    friend QCPItemAnchor* QCPAbstractItem_CreateAnchor(QCPAbstractItem* self, const libqt_string name, int anchorId);
    friend QCPItemAnchor* QCPAbstractItem_QBaseCreateAnchor(QCPAbstractItem* self, const libqt_string name, int anchorId);
    friend void QCPAbstractItem_InitializeParentPlot(QCPAbstractItem* self, QCustomPlot* parentPlot);
    friend void QCPAbstractItem_QBaseInitializeParentPlot(QCPAbstractItem* self, QCustomPlot* parentPlot);
    friend void QCPAbstractItem_SetParentLayerable(QCPAbstractItem* self, QCPLayerable* parentLayerable);
    friend void QCPAbstractItem_QBaseSetParentLayerable(QCPAbstractItem* self, QCPLayerable* parentLayerable);
    friend bool QCPAbstractItem_MoveToLayer(QCPAbstractItem* self, QCPLayer* layer, bool prepend);
    friend bool QCPAbstractItem_QBaseMoveToLayer(QCPAbstractItem* self, QCPLayer* layer, bool prepend);
    friend void QCPAbstractItem_ApplyAntialiasingHint(const QCPAbstractItem* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPAbstractItem_QBaseApplyAntialiasingHint(const QCPAbstractItem* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPAbstractItem_Sender(const QCPAbstractItem* self);
    friend QObject* QCPAbstractItem_QBaseSender(const QCPAbstractItem* self);
    friend int QCPAbstractItem_SenderSignalIndex(const QCPAbstractItem* self);
    friend int QCPAbstractItem_QBaseSenderSignalIndex(const QCPAbstractItem* self);
    friend int QCPAbstractItem_Receivers(const QCPAbstractItem* self, const char* signal);
    friend int QCPAbstractItem_QBaseReceivers(const QCPAbstractItem* self, const char* signal);
    friend bool QCPAbstractItem_IsSignalConnected(const QCPAbstractItem* self, const QMetaMethod* signal);
    friend bool QCPAbstractItem_QBaseIsSignalConnected(const QCPAbstractItem* self, const QMetaMethod* signal);
};

// This class is a subclass of QCustomPlot so that we can call protected methods
class VirtualQCustomPlot final : public QCustomPlot {

  public:
    // Virtual class boolean flag
    bool isVirtualQCustomPlot = true;

    // Virtual class public types (including callbacks)
    using QCustomPlot_Metacall_Callback = int (*)(QCustomPlot*, int, int, void**);
    using QCustomPlot_MinimumSizeHint_Callback = QSize* (*)();
    using QCustomPlot_SizeHint_Callback = QSize* (*)();
    using QCustomPlot_PaintEvent_Callback = void (*)(QCustomPlot*, QPaintEvent*);
    using QCustomPlot_ResizeEvent_Callback = void (*)(QCustomPlot*, QResizeEvent*);
    using QCustomPlot_MouseDoubleClickEvent_Callback = void (*)(QCustomPlot*, QMouseEvent*);
    using QCustomPlot_MousePressEvent_Callback = void (*)(QCustomPlot*, QMouseEvent*);
    using QCustomPlot_MouseMoveEvent_Callback = void (*)(QCustomPlot*, QMouseEvent*);
    using QCustomPlot_MouseReleaseEvent_Callback = void (*)(QCustomPlot*, QMouseEvent*);
    using QCustomPlot_WheelEvent_Callback = void (*)(QCustomPlot*, QWheelEvent*);
    using QCustomPlot_Draw_Callback = void (*)(QCustomPlot*, QCPPainter*);
    using QCustomPlot_UpdateLayout_Callback = void (*)();
    using QCustomPlot_AxisRemoved_Callback = void (*)(QCustomPlot*, QCPAxis*);
    using QCustomPlot_LegendRemoved_Callback = void (*)(QCustomPlot*, QCPLegend*);
    using QCustomPlot_ProcessRectSelection_Callback = void (*)(QCustomPlot*, QRect*, QMouseEvent*);
    using QCustomPlot_ProcessRectZoom_Callback = void (*)(QCustomPlot*, QRect*, QMouseEvent*);
    using QCustomPlot_ProcessPointSelection_Callback = void (*)(QCustomPlot*, QMouseEvent*);
    using QCustomPlot_DevType_Callback = int (*)();
    using QCustomPlot_SetVisible_Callback = void (*)(QCustomPlot*, bool);
    using QCustomPlot_HeightForWidth_Callback = int (*)(const QCustomPlot*, int);
    using QCustomPlot_HasHeightForWidth_Callback = bool (*)();
    using QCustomPlot_PaintEngine_Callback = QPaintEngine* (*)();
    using QCustomPlot_Event_Callback = bool (*)(QCustomPlot*, QEvent*);
    using QCustomPlot_KeyPressEvent_Callback = void (*)(QCustomPlot*, QKeyEvent*);
    using QCustomPlot_KeyReleaseEvent_Callback = void (*)(QCustomPlot*, QKeyEvent*);
    using QCustomPlot_FocusInEvent_Callback = void (*)(QCustomPlot*, QFocusEvent*);
    using QCustomPlot_FocusOutEvent_Callback = void (*)(QCustomPlot*, QFocusEvent*);
    using QCustomPlot_EnterEvent_Callback = void (*)(QCustomPlot*, QEnterEvent*);
    using QCustomPlot_LeaveEvent_Callback = void (*)(QCustomPlot*, QEvent*);
    using QCustomPlot_MoveEvent_Callback = void (*)(QCustomPlot*, QMoveEvent*);
    using QCustomPlot_CloseEvent_Callback = void (*)(QCustomPlot*, QCloseEvent*);
    using QCustomPlot_ContextMenuEvent_Callback = void (*)(QCustomPlot*, QContextMenuEvent*);
    using QCustomPlot_TabletEvent_Callback = void (*)(QCustomPlot*, QTabletEvent*);
    using QCustomPlot_ActionEvent_Callback = void (*)(QCustomPlot*, QActionEvent*);
    using QCustomPlot_DragEnterEvent_Callback = void (*)(QCustomPlot*, QDragEnterEvent*);
    using QCustomPlot_DragMoveEvent_Callback = void (*)(QCustomPlot*, QDragMoveEvent*);
    using QCustomPlot_DragLeaveEvent_Callback = void (*)(QCustomPlot*, QDragLeaveEvent*);
    using QCustomPlot_DropEvent_Callback = void (*)(QCustomPlot*, QDropEvent*);
    using QCustomPlot_ShowEvent_Callback = void (*)(QCustomPlot*, QShowEvent*);
    using QCustomPlot_HideEvent_Callback = void (*)(QCustomPlot*, QHideEvent*);
    using QCustomPlot_NativeEvent_Callback = bool (*)(QCustomPlot*, libqt_string, void*, intptr_t*);
    using QCustomPlot_ChangeEvent_Callback = void (*)(QCustomPlot*, QEvent*);
    using QCustomPlot_Metric_Callback = int (*)(const QCustomPlot*, int);
    using QCustomPlot_InitPainter_Callback = void (*)(const QCustomPlot*, QPainter*);
    using QCustomPlot_Redirected_Callback = QPaintDevice* (*)(const QCustomPlot*, QPoint*);
    using QCustomPlot_SharedPainter_Callback = QPainter* (*)();
    using QCustomPlot_InputMethodEvent_Callback = void (*)(QCustomPlot*, QInputMethodEvent*);
    using QCustomPlot_InputMethodQuery_Callback = QVariant* (*)(const QCustomPlot*, int);
    using QCustomPlot_FocusNextPrevChild_Callback = bool (*)(QCustomPlot*, bool);
    using QCustomPlot_EventFilter_Callback = bool (*)(QCustomPlot*, QObject*, QEvent*);
    using QCustomPlot_TimerEvent_Callback = void (*)(QCustomPlot*, QTimerEvent*);
    using QCustomPlot_ChildEvent_Callback = void (*)(QCustomPlot*, QChildEvent*);
    using QCustomPlot_CustomEvent_Callback = void (*)(QCustomPlot*, QEvent*);
    using QCustomPlot_ConnectNotify_Callback = void (*)(QCustomPlot*, QMetaMethod*);
    using QCustomPlot_DisconnectNotify_Callback = void (*)(QCustomPlot*, QMetaMethod*);
    using QCustomPlot_RegisterPlottable_Callback = bool (*)(QCustomPlot*, QCPAbstractPlottable*);
    using QCustomPlot_RegisterGraph_Callback = bool (*)(QCustomPlot*, QCPGraph*);
    using QCustomPlot_RegisterItem_Callback = bool (*)(QCustomPlot*, QCPAbstractItem*);
    using QCustomPlot_UpdateLayerIndices_Callback = void (*)();
    using QCustomPlot_LayerableAt_Callback = QCPLayerable* (*)(const QCustomPlot*, QPointF*, bool);
    using QCustomPlot_LayerableListAt_Callback = QCPLayerable** (*)(const QCustomPlot*, QPointF*, bool);
    using QCustomPlot_DrawBackground_Callback = void (*)(QCustomPlot*, QCPPainter*);
    using QCustomPlot_SetupPaintBuffers_Callback = void (*)();
    using QCustomPlot_CreatePaintBuffer_Callback = QCPAbstractPaintBuffer* (*)();
    using QCustomPlot_HasInvalidatedPaintBuffers_Callback = bool (*)();
    using QCustomPlot_SetupOpenGl_Callback = bool (*)();
    using QCustomPlot_FreeOpenGl_Callback = void (*)();
    using QCustomPlot_LayerableAt3_Callback = QCPLayerable* (*)(const QCustomPlot*, QPointF*, bool, QVariant*);
    using QCustomPlot_LayerableListAt3_Callback = QCPLayerable** (*)(const QCustomPlot*, QPointF*, bool, libqt_list /* of QVariant* */);
    using QCustomPlot_UpdateMicroFocus_Callback = void (*)();
    using QCustomPlot_Create_Callback = void (*)();
    using QCustomPlot_Destroy_Callback = void (*)();
    using QCustomPlot_FocusNextChild_Callback = bool (*)();
    using QCustomPlot_FocusPreviousChild_Callback = bool (*)();
    using QCustomPlot_Sender_Callback = QObject* (*)();
    using QCustomPlot_SenderSignalIndex_Callback = int (*)();
    using QCustomPlot_Receivers_Callback = int (*)(const QCustomPlot*, const char*);
    using QCustomPlot_IsSignalConnected_Callback = bool (*)(const QCustomPlot*, QMetaMethod*);
    using QCustomPlot_GetDecodedMetricF_Callback = double (*)(const QCustomPlot*, int, int);

  protected:
    // Instance callback storage
    QCustomPlot_Metacall_Callback qcustomplot_metacall_callback = nullptr;
    QCustomPlot_MinimumSizeHint_Callback qcustomplot_minimumsizehint_callback = nullptr;
    QCustomPlot_SizeHint_Callback qcustomplot_sizehint_callback = nullptr;
    QCustomPlot_PaintEvent_Callback qcustomplot_paintevent_callback = nullptr;
    QCustomPlot_ResizeEvent_Callback qcustomplot_resizeevent_callback = nullptr;
    QCustomPlot_MouseDoubleClickEvent_Callback qcustomplot_mousedoubleclickevent_callback = nullptr;
    QCustomPlot_MousePressEvent_Callback qcustomplot_mousepressevent_callback = nullptr;
    QCustomPlot_MouseMoveEvent_Callback qcustomplot_mousemoveevent_callback = nullptr;
    QCustomPlot_MouseReleaseEvent_Callback qcustomplot_mousereleaseevent_callback = nullptr;
    QCustomPlot_WheelEvent_Callback qcustomplot_wheelevent_callback = nullptr;
    QCustomPlot_Draw_Callback qcustomplot_draw_callback = nullptr;
    QCustomPlot_UpdateLayout_Callback qcustomplot_updatelayout_callback = nullptr;
    QCustomPlot_AxisRemoved_Callback qcustomplot_axisremoved_callback = nullptr;
    QCustomPlot_LegendRemoved_Callback qcustomplot_legendremoved_callback = nullptr;
    QCustomPlot_ProcessRectSelection_Callback qcustomplot_processrectselection_callback = nullptr;
    QCustomPlot_ProcessRectZoom_Callback qcustomplot_processrectzoom_callback = nullptr;
    QCustomPlot_ProcessPointSelection_Callback qcustomplot_processpointselection_callback = nullptr;
    QCustomPlot_DevType_Callback qcustomplot_devtype_callback = nullptr;
    QCustomPlot_SetVisible_Callback qcustomplot_setvisible_callback = nullptr;
    QCustomPlot_HeightForWidth_Callback qcustomplot_heightforwidth_callback = nullptr;
    QCustomPlot_HasHeightForWidth_Callback qcustomplot_hasheightforwidth_callback = nullptr;
    QCustomPlot_PaintEngine_Callback qcustomplot_paintengine_callback = nullptr;
    QCustomPlot_Event_Callback qcustomplot_event_callback = nullptr;
    QCustomPlot_KeyPressEvent_Callback qcustomplot_keypressevent_callback = nullptr;
    QCustomPlot_KeyReleaseEvent_Callback qcustomplot_keyreleaseevent_callback = nullptr;
    QCustomPlot_FocusInEvent_Callback qcustomplot_focusinevent_callback = nullptr;
    QCustomPlot_FocusOutEvent_Callback qcustomplot_focusoutevent_callback = nullptr;
    QCustomPlot_EnterEvent_Callback qcustomplot_enterevent_callback = nullptr;
    QCustomPlot_LeaveEvent_Callback qcustomplot_leaveevent_callback = nullptr;
    QCustomPlot_MoveEvent_Callback qcustomplot_moveevent_callback = nullptr;
    QCustomPlot_CloseEvent_Callback qcustomplot_closeevent_callback = nullptr;
    QCustomPlot_ContextMenuEvent_Callback qcustomplot_contextmenuevent_callback = nullptr;
    QCustomPlot_TabletEvent_Callback qcustomplot_tabletevent_callback = nullptr;
    QCustomPlot_ActionEvent_Callback qcustomplot_actionevent_callback = nullptr;
    QCustomPlot_DragEnterEvent_Callback qcustomplot_dragenterevent_callback = nullptr;
    QCustomPlot_DragMoveEvent_Callback qcustomplot_dragmoveevent_callback = nullptr;
    QCustomPlot_DragLeaveEvent_Callback qcustomplot_dragleaveevent_callback = nullptr;
    QCustomPlot_DropEvent_Callback qcustomplot_dropevent_callback = nullptr;
    QCustomPlot_ShowEvent_Callback qcustomplot_showevent_callback = nullptr;
    QCustomPlot_HideEvent_Callback qcustomplot_hideevent_callback = nullptr;
    QCustomPlot_NativeEvent_Callback qcustomplot_nativeevent_callback = nullptr;
    QCustomPlot_ChangeEvent_Callback qcustomplot_changeevent_callback = nullptr;
    QCustomPlot_Metric_Callback qcustomplot_metric_callback = nullptr;
    QCustomPlot_InitPainter_Callback qcustomplot_initpainter_callback = nullptr;
    QCustomPlot_Redirected_Callback qcustomplot_redirected_callback = nullptr;
    QCustomPlot_SharedPainter_Callback qcustomplot_sharedpainter_callback = nullptr;
    QCustomPlot_InputMethodEvent_Callback qcustomplot_inputmethodevent_callback = nullptr;
    QCustomPlot_InputMethodQuery_Callback qcustomplot_inputmethodquery_callback = nullptr;
    QCustomPlot_FocusNextPrevChild_Callback qcustomplot_focusnextprevchild_callback = nullptr;
    QCustomPlot_EventFilter_Callback qcustomplot_eventfilter_callback = nullptr;
    QCustomPlot_TimerEvent_Callback qcustomplot_timerevent_callback = nullptr;
    QCustomPlot_ChildEvent_Callback qcustomplot_childevent_callback = nullptr;
    QCustomPlot_CustomEvent_Callback qcustomplot_customevent_callback = nullptr;
    QCustomPlot_ConnectNotify_Callback qcustomplot_connectnotify_callback = nullptr;
    QCustomPlot_DisconnectNotify_Callback qcustomplot_disconnectnotify_callback = nullptr;
    QCustomPlot_RegisterPlottable_Callback qcustomplot_registerplottable_callback = nullptr;
    QCustomPlot_RegisterGraph_Callback qcustomplot_registergraph_callback = nullptr;
    QCustomPlot_RegisterItem_Callback qcustomplot_registeritem_callback = nullptr;
    QCustomPlot_UpdateLayerIndices_Callback qcustomplot_updatelayerindices_callback = nullptr;
    QCustomPlot_LayerableAt_Callback qcustomplot_layerableat_callback = nullptr;
    QCustomPlot_LayerableListAt_Callback qcustomplot_layerablelistat_callback = nullptr;
    QCustomPlot_DrawBackground_Callback qcustomplot_drawbackground_callback = nullptr;
    QCustomPlot_SetupPaintBuffers_Callback qcustomplot_setuppaintbuffers_callback = nullptr;
    QCustomPlot_CreatePaintBuffer_Callback qcustomplot_createpaintbuffer_callback = nullptr;
    QCustomPlot_HasInvalidatedPaintBuffers_Callback qcustomplot_hasinvalidatedpaintbuffers_callback = nullptr;
    QCustomPlot_SetupOpenGl_Callback qcustomplot_setupopengl_callback = nullptr;
    QCustomPlot_FreeOpenGl_Callback qcustomplot_freeopengl_callback = nullptr;
    QCustomPlot_LayerableAt3_Callback qcustomplot_layerableat3_callback = nullptr;
    QCustomPlot_LayerableListAt3_Callback qcustomplot_layerablelistat3_callback = nullptr;
    QCustomPlot_UpdateMicroFocus_Callback qcustomplot_updatemicrofocus_callback = nullptr;
    QCustomPlot_Create_Callback qcustomplot_create_callback = nullptr;
    QCustomPlot_Destroy_Callback qcustomplot_destroy_callback = nullptr;
    QCustomPlot_FocusNextChild_Callback qcustomplot_focusnextchild_callback = nullptr;
    QCustomPlot_FocusPreviousChild_Callback qcustomplot_focuspreviouschild_callback = nullptr;
    QCustomPlot_Sender_Callback qcustomplot_sender_callback = nullptr;
    QCustomPlot_SenderSignalIndex_Callback qcustomplot_sendersignalindex_callback = nullptr;
    QCustomPlot_Receivers_Callback qcustomplot_receivers_callback = nullptr;
    QCustomPlot_IsSignalConnected_Callback qcustomplot_issignalconnected_callback = nullptr;
    QCustomPlot_GetDecodedMetricF_Callback qcustomplot_getdecodedmetricf_callback = nullptr;

    // Instance base flags
    mutable bool qcustomplot_metacall_isbase = false;
    mutable bool qcustomplot_minimumsizehint_isbase = false;
    mutable bool qcustomplot_sizehint_isbase = false;
    mutable bool qcustomplot_paintevent_isbase = false;
    mutable bool qcustomplot_resizeevent_isbase = false;
    mutable bool qcustomplot_mousedoubleclickevent_isbase = false;
    mutable bool qcustomplot_mousepressevent_isbase = false;
    mutable bool qcustomplot_mousemoveevent_isbase = false;
    mutable bool qcustomplot_mousereleaseevent_isbase = false;
    mutable bool qcustomplot_wheelevent_isbase = false;
    mutable bool qcustomplot_draw_isbase = false;
    mutable bool qcustomplot_updatelayout_isbase = false;
    mutable bool qcustomplot_axisremoved_isbase = false;
    mutable bool qcustomplot_legendremoved_isbase = false;
    mutable bool qcustomplot_processrectselection_isbase = false;
    mutable bool qcustomplot_processrectzoom_isbase = false;
    mutable bool qcustomplot_processpointselection_isbase = false;
    mutable bool qcustomplot_devtype_isbase = false;
    mutable bool qcustomplot_setvisible_isbase = false;
    mutable bool qcustomplot_heightforwidth_isbase = false;
    mutable bool qcustomplot_hasheightforwidth_isbase = false;
    mutable bool qcustomplot_paintengine_isbase = false;
    mutable bool qcustomplot_event_isbase = false;
    mutable bool qcustomplot_keypressevent_isbase = false;
    mutable bool qcustomplot_keyreleaseevent_isbase = false;
    mutable bool qcustomplot_focusinevent_isbase = false;
    mutable bool qcustomplot_focusoutevent_isbase = false;
    mutable bool qcustomplot_enterevent_isbase = false;
    mutable bool qcustomplot_leaveevent_isbase = false;
    mutable bool qcustomplot_moveevent_isbase = false;
    mutable bool qcustomplot_closeevent_isbase = false;
    mutable bool qcustomplot_contextmenuevent_isbase = false;
    mutable bool qcustomplot_tabletevent_isbase = false;
    mutable bool qcustomplot_actionevent_isbase = false;
    mutable bool qcustomplot_dragenterevent_isbase = false;
    mutable bool qcustomplot_dragmoveevent_isbase = false;
    mutable bool qcustomplot_dragleaveevent_isbase = false;
    mutable bool qcustomplot_dropevent_isbase = false;
    mutable bool qcustomplot_showevent_isbase = false;
    mutable bool qcustomplot_hideevent_isbase = false;
    mutable bool qcustomplot_nativeevent_isbase = false;
    mutable bool qcustomplot_changeevent_isbase = false;
    mutable bool qcustomplot_metric_isbase = false;
    mutable bool qcustomplot_initpainter_isbase = false;
    mutable bool qcustomplot_redirected_isbase = false;
    mutable bool qcustomplot_sharedpainter_isbase = false;
    mutable bool qcustomplot_inputmethodevent_isbase = false;
    mutable bool qcustomplot_inputmethodquery_isbase = false;
    mutable bool qcustomplot_focusnextprevchild_isbase = false;
    mutable bool qcustomplot_eventfilter_isbase = false;
    mutable bool qcustomplot_timerevent_isbase = false;
    mutable bool qcustomplot_childevent_isbase = false;
    mutable bool qcustomplot_customevent_isbase = false;
    mutable bool qcustomplot_connectnotify_isbase = false;
    mutable bool qcustomplot_disconnectnotify_isbase = false;
    mutable bool qcustomplot_registerplottable_isbase = false;
    mutable bool qcustomplot_registergraph_isbase = false;
    mutable bool qcustomplot_registeritem_isbase = false;
    mutable bool qcustomplot_updatelayerindices_isbase = false;
    mutable bool qcustomplot_layerableat_isbase = false;
    mutable bool qcustomplot_layerablelistat_isbase = false;
    mutable bool qcustomplot_drawbackground_isbase = false;
    mutable bool qcustomplot_setuppaintbuffers_isbase = false;
    mutable bool qcustomplot_createpaintbuffer_isbase = false;
    mutable bool qcustomplot_hasinvalidatedpaintbuffers_isbase = false;
    mutable bool qcustomplot_setupopengl_isbase = false;
    mutable bool qcustomplot_freeopengl_isbase = false;
    mutable bool qcustomplot_layerableat3_isbase = false;
    mutable bool qcustomplot_layerablelistat3_isbase = false;
    mutable bool qcustomplot_updatemicrofocus_isbase = false;
    mutable bool qcustomplot_create_isbase = false;
    mutable bool qcustomplot_destroy_isbase = false;
    mutable bool qcustomplot_focusnextchild_isbase = false;
    mutable bool qcustomplot_focuspreviouschild_isbase = false;
    mutable bool qcustomplot_sender_isbase = false;
    mutable bool qcustomplot_sendersignalindex_isbase = false;
    mutable bool qcustomplot_receivers_isbase = false;
    mutable bool qcustomplot_issignalconnected_isbase = false;
    mutable bool qcustomplot_getdecodedmetricf_isbase = false;

  public:
    VirtualQCustomPlot(QWidget* parent) : QCustomPlot(parent) {};
    VirtualQCustomPlot() : QCustomPlot() {};

    ~VirtualQCustomPlot() {
        qcustomplot_metacall_callback = nullptr;
        qcustomplot_minimumsizehint_callback = nullptr;
        qcustomplot_sizehint_callback = nullptr;
        qcustomplot_paintevent_callback = nullptr;
        qcustomplot_resizeevent_callback = nullptr;
        qcustomplot_mousedoubleclickevent_callback = nullptr;
        qcustomplot_mousepressevent_callback = nullptr;
        qcustomplot_mousemoveevent_callback = nullptr;
        qcustomplot_mousereleaseevent_callback = nullptr;
        qcustomplot_wheelevent_callback = nullptr;
        qcustomplot_draw_callback = nullptr;
        qcustomplot_updatelayout_callback = nullptr;
        qcustomplot_axisremoved_callback = nullptr;
        qcustomplot_legendremoved_callback = nullptr;
        qcustomplot_processrectselection_callback = nullptr;
        qcustomplot_processrectzoom_callback = nullptr;
        qcustomplot_processpointselection_callback = nullptr;
        qcustomplot_devtype_callback = nullptr;
        qcustomplot_setvisible_callback = nullptr;
        qcustomplot_heightforwidth_callback = nullptr;
        qcustomplot_hasheightforwidth_callback = nullptr;
        qcustomplot_paintengine_callback = nullptr;
        qcustomplot_event_callback = nullptr;
        qcustomplot_keypressevent_callback = nullptr;
        qcustomplot_keyreleaseevent_callback = nullptr;
        qcustomplot_focusinevent_callback = nullptr;
        qcustomplot_focusoutevent_callback = nullptr;
        qcustomplot_enterevent_callback = nullptr;
        qcustomplot_leaveevent_callback = nullptr;
        qcustomplot_moveevent_callback = nullptr;
        qcustomplot_closeevent_callback = nullptr;
        qcustomplot_contextmenuevent_callback = nullptr;
        qcustomplot_tabletevent_callback = nullptr;
        qcustomplot_actionevent_callback = nullptr;
        qcustomplot_dragenterevent_callback = nullptr;
        qcustomplot_dragmoveevent_callback = nullptr;
        qcustomplot_dragleaveevent_callback = nullptr;
        qcustomplot_dropevent_callback = nullptr;
        qcustomplot_showevent_callback = nullptr;
        qcustomplot_hideevent_callback = nullptr;
        qcustomplot_nativeevent_callback = nullptr;
        qcustomplot_changeevent_callback = nullptr;
        qcustomplot_metric_callback = nullptr;
        qcustomplot_initpainter_callback = nullptr;
        qcustomplot_redirected_callback = nullptr;
        qcustomplot_sharedpainter_callback = nullptr;
        qcustomplot_inputmethodevent_callback = nullptr;
        qcustomplot_inputmethodquery_callback = nullptr;
        qcustomplot_focusnextprevchild_callback = nullptr;
        qcustomplot_eventfilter_callback = nullptr;
        qcustomplot_timerevent_callback = nullptr;
        qcustomplot_childevent_callback = nullptr;
        qcustomplot_customevent_callback = nullptr;
        qcustomplot_connectnotify_callback = nullptr;
        qcustomplot_disconnectnotify_callback = nullptr;
        qcustomplot_registerplottable_callback = nullptr;
        qcustomplot_registergraph_callback = nullptr;
        qcustomplot_registeritem_callback = nullptr;
        qcustomplot_updatelayerindices_callback = nullptr;
        qcustomplot_layerableat_callback = nullptr;
        qcustomplot_layerablelistat_callback = nullptr;
        qcustomplot_drawbackground_callback = nullptr;
        qcustomplot_setuppaintbuffers_callback = nullptr;
        qcustomplot_createpaintbuffer_callback = nullptr;
        qcustomplot_hasinvalidatedpaintbuffers_callback = nullptr;
        qcustomplot_setupopengl_callback = nullptr;
        qcustomplot_freeopengl_callback = nullptr;
        qcustomplot_layerableat3_callback = nullptr;
        qcustomplot_layerablelistat3_callback = nullptr;
        qcustomplot_updatemicrofocus_callback = nullptr;
        qcustomplot_create_callback = nullptr;
        qcustomplot_destroy_callback = nullptr;
        qcustomplot_focusnextchild_callback = nullptr;
        qcustomplot_focuspreviouschild_callback = nullptr;
        qcustomplot_sender_callback = nullptr;
        qcustomplot_sendersignalindex_callback = nullptr;
        qcustomplot_receivers_callback = nullptr;
        qcustomplot_issignalconnected_callback = nullptr;
        qcustomplot_getdecodedmetricf_callback = nullptr;
    }

    // Callback setters
    inline void setQCustomPlot_Metacall_Callback(QCustomPlot_Metacall_Callback cb) { qcustomplot_metacall_callback = cb; }
    inline void setQCustomPlot_MinimumSizeHint_Callback(QCustomPlot_MinimumSizeHint_Callback cb) { qcustomplot_minimumsizehint_callback = cb; }
    inline void setQCustomPlot_SizeHint_Callback(QCustomPlot_SizeHint_Callback cb) { qcustomplot_sizehint_callback = cb; }
    inline void setQCustomPlot_PaintEvent_Callback(QCustomPlot_PaintEvent_Callback cb) { qcustomplot_paintevent_callback = cb; }
    inline void setQCustomPlot_ResizeEvent_Callback(QCustomPlot_ResizeEvent_Callback cb) { qcustomplot_resizeevent_callback = cb; }
    inline void setQCustomPlot_MouseDoubleClickEvent_Callback(QCustomPlot_MouseDoubleClickEvent_Callback cb) { qcustomplot_mousedoubleclickevent_callback = cb; }
    inline void setQCustomPlot_MousePressEvent_Callback(QCustomPlot_MousePressEvent_Callback cb) { qcustomplot_mousepressevent_callback = cb; }
    inline void setQCustomPlot_MouseMoveEvent_Callback(QCustomPlot_MouseMoveEvent_Callback cb) { qcustomplot_mousemoveevent_callback = cb; }
    inline void setQCustomPlot_MouseReleaseEvent_Callback(QCustomPlot_MouseReleaseEvent_Callback cb) { qcustomplot_mousereleaseevent_callback = cb; }
    inline void setQCustomPlot_WheelEvent_Callback(QCustomPlot_WheelEvent_Callback cb) { qcustomplot_wheelevent_callback = cb; }
    inline void setQCustomPlot_Draw_Callback(QCustomPlot_Draw_Callback cb) { qcustomplot_draw_callback = cb; }
    inline void setQCustomPlot_UpdateLayout_Callback(QCustomPlot_UpdateLayout_Callback cb) { qcustomplot_updatelayout_callback = cb; }
    inline void setQCustomPlot_AxisRemoved_Callback(QCustomPlot_AxisRemoved_Callback cb) { qcustomplot_axisremoved_callback = cb; }
    inline void setQCustomPlot_LegendRemoved_Callback(QCustomPlot_LegendRemoved_Callback cb) { qcustomplot_legendremoved_callback = cb; }
    inline void setQCustomPlot_ProcessRectSelection_Callback(QCustomPlot_ProcessRectSelection_Callback cb) { qcustomplot_processrectselection_callback = cb; }
    inline void setQCustomPlot_ProcessRectZoom_Callback(QCustomPlot_ProcessRectZoom_Callback cb) { qcustomplot_processrectzoom_callback = cb; }
    inline void setQCustomPlot_ProcessPointSelection_Callback(QCustomPlot_ProcessPointSelection_Callback cb) { qcustomplot_processpointselection_callback = cb; }
    inline void setQCustomPlot_DevType_Callback(QCustomPlot_DevType_Callback cb) { qcustomplot_devtype_callback = cb; }
    inline void setQCustomPlot_SetVisible_Callback(QCustomPlot_SetVisible_Callback cb) { qcustomplot_setvisible_callback = cb; }
    inline void setQCustomPlot_HeightForWidth_Callback(QCustomPlot_HeightForWidth_Callback cb) { qcustomplot_heightforwidth_callback = cb; }
    inline void setQCustomPlot_HasHeightForWidth_Callback(QCustomPlot_HasHeightForWidth_Callback cb) { qcustomplot_hasheightforwidth_callback = cb; }
    inline void setQCustomPlot_PaintEngine_Callback(QCustomPlot_PaintEngine_Callback cb) { qcustomplot_paintengine_callback = cb; }
    inline void setQCustomPlot_Event_Callback(QCustomPlot_Event_Callback cb) { qcustomplot_event_callback = cb; }
    inline void setQCustomPlot_KeyPressEvent_Callback(QCustomPlot_KeyPressEvent_Callback cb) { qcustomplot_keypressevent_callback = cb; }
    inline void setQCustomPlot_KeyReleaseEvent_Callback(QCustomPlot_KeyReleaseEvent_Callback cb) { qcustomplot_keyreleaseevent_callback = cb; }
    inline void setQCustomPlot_FocusInEvent_Callback(QCustomPlot_FocusInEvent_Callback cb) { qcustomplot_focusinevent_callback = cb; }
    inline void setQCustomPlot_FocusOutEvent_Callback(QCustomPlot_FocusOutEvent_Callback cb) { qcustomplot_focusoutevent_callback = cb; }
    inline void setQCustomPlot_EnterEvent_Callback(QCustomPlot_EnterEvent_Callback cb) { qcustomplot_enterevent_callback = cb; }
    inline void setQCustomPlot_LeaveEvent_Callback(QCustomPlot_LeaveEvent_Callback cb) { qcustomplot_leaveevent_callback = cb; }
    inline void setQCustomPlot_MoveEvent_Callback(QCustomPlot_MoveEvent_Callback cb) { qcustomplot_moveevent_callback = cb; }
    inline void setQCustomPlot_CloseEvent_Callback(QCustomPlot_CloseEvent_Callback cb) { qcustomplot_closeevent_callback = cb; }
    inline void setQCustomPlot_ContextMenuEvent_Callback(QCustomPlot_ContextMenuEvent_Callback cb) { qcustomplot_contextmenuevent_callback = cb; }
    inline void setQCustomPlot_TabletEvent_Callback(QCustomPlot_TabletEvent_Callback cb) { qcustomplot_tabletevent_callback = cb; }
    inline void setQCustomPlot_ActionEvent_Callback(QCustomPlot_ActionEvent_Callback cb) { qcustomplot_actionevent_callback = cb; }
    inline void setQCustomPlot_DragEnterEvent_Callback(QCustomPlot_DragEnterEvent_Callback cb) { qcustomplot_dragenterevent_callback = cb; }
    inline void setQCustomPlot_DragMoveEvent_Callback(QCustomPlot_DragMoveEvent_Callback cb) { qcustomplot_dragmoveevent_callback = cb; }
    inline void setQCustomPlot_DragLeaveEvent_Callback(QCustomPlot_DragLeaveEvent_Callback cb) { qcustomplot_dragleaveevent_callback = cb; }
    inline void setQCustomPlot_DropEvent_Callback(QCustomPlot_DropEvent_Callback cb) { qcustomplot_dropevent_callback = cb; }
    inline void setQCustomPlot_ShowEvent_Callback(QCustomPlot_ShowEvent_Callback cb) { qcustomplot_showevent_callback = cb; }
    inline void setQCustomPlot_HideEvent_Callback(QCustomPlot_HideEvent_Callback cb) { qcustomplot_hideevent_callback = cb; }
    inline void setQCustomPlot_NativeEvent_Callback(QCustomPlot_NativeEvent_Callback cb) { qcustomplot_nativeevent_callback = cb; }
    inline void setQCustomPlot_ChangeEvent_Callback(QCustomPlot_ChangeEvent_Callback cb) { qcustomplot_changeevent_callback = cb; }
    inline void setQCustomPlot_Metric_Callback(QCustomPlot_Metric_Callback cb) { qcustomplot_metric_callback = cb; }
    inline void setQCustomPlot_InitPainter_Callback(QCustomPlot_InitPainter_Callback cb) { qcustomplot_initpainter_callback = cb; }
    inline void setQCustomPlot_Redirected_Callback(QCustomPlot_Redirected_Callback cb) { qcustomplot_redirected_callback = cb; }
    inline void setQCustomPlot_SharedPainter_Callback(QCustomPlot_SharedPainter_Callback cb) { qcustomplot_sharedpainter_callback = cb; }
    inline void setQCustomPlot_InputMethodEvent_Callback(QCustomPlot_InputMethodEvent_Callback cb) { qcustomplot_inputmethodevent_callback = cb; }
    inline void setQCustomPlot_InputMethodQuery_Callback(QCustomPlot_InputMethodQuery_Callback cb) { qcustomplot_inputmethodquery_callback = cb; }
    inline void setQCustomPlot_FocusNextPrevChild_Callback(QCustomPlot_FocusNextPrevChild_Callback cb) { qcustomplot_focusnextprevchild_callback = cb; }
    inline void setQCustomPlot_EventFilter_Callback(QCustomPlot_EventFilter_Callback cb) { qcustomplot_eventfilter_callback = cb; }
    inline void setQCustomPlot_TimerEvent_Callback(QCustomPlot_TimerEvent_Callback cb) { qcustomplot_timerevent_callback = cb; }
    inline void setQCustomPlot_ChildEvent_Callback(QCustomPlot_ChildEvent_Callback cb) { qcustomplot_childevent_callback = cb; }
    inline void setQCustomPlot_CustomEvent_Callback(QCustomPlot_CustomEvent_Callback cb) { qcustomplot_customevent_callback = cb; }
    inline void setQCustomPlot_ConnectNotify_Callback(QCustomPlot_ConnectNotify_Callback cb) { qcustomplot_connectnotify_callback = cb; }
    inline void setQCustomPlot_DisconnectNotify_Callback(QCustomPlot_DisconnectNotify_Callback cb) { qcustomplot_disconnectnotify_callback = cb; }
    inline void setQCustomPlot_RegisterPlottable_Callback(QCustomPlot_RegisterPlottable_Callback cb) { qcustomplot_registerplottable_callback = cb; }
    inline void setQCustomPlot_RegisterGraph_Callback(QCustomPlot_RegisterGraph_Callback cb) { qcustomplot_registergraph_callback = cb; }
    inline void setQCustomPlot_RegisterItem_Callback(QCustomPlot_RegisterItem_Callback cb) { qcustomplot_registeritem_callback = cb; }
    inline void setQCustomPlot_UpdateLayerIndices_Callback(QCustomPlot_UpdateLayerIndices_Callback cb) { qcustomplot_updatelayerindices_callback = cb; }
    inline void setQCustomPlot_LayerableAt_Callback(QCustomPlot_LayerableAt_Callback cb) { qcustomplot_layerableat_callback = cb; }
    inline void setQCustomPlot_LayerableListAt_Callback(QCustomPlot_LayerableListAt_Callback cb) { qcustomplot_layerablelistat_callback = cb; }
    inline void setQCustomPlot_DrawBackground_Callback(QCustomPlot_DrawBackground_Callback cb) { qcustomplot_drawbackground_callback = cb; }
    inline void setQCustomPlot_SetupPaintBuffers_Callback(QCustomPlot_SetupPaintBuffers_Callback cb) { qcustomplot_setuppaintbuffers_callback = cb; }
    inline void setQCustomPlot_CreatePaintBuffer_Callback(QCustomPlot_CreatePaintBuffer_Callback cb) { qcustomplot_createpaintbuffer_callback = cb; }
    inline void setQCustomPlot_HasInvalidatedPaintBuffers_Callback(QCustomPlot_HasInvalidatedPaintBuffers_Callback cb) { qcustomplot_hasinvalidatedpaintbuffers_callback = cb; }
    inline void setQCustomPlot_SetupOpenGl_Callback(QCustomPlot_SetupOpenGl_Callback cb) { qcustomplot_setupopengl_callback = cb; }
    inline void setQCustomPlot_FreeOpenGl_Callback(QCustomPlot_FreeOpenGl_Callback cb) { qcustomplot_freeopengl_callback = cb; }
    inline void setQCustomPlot_LayerableAt3_Callback(QCustomPlot_LayerableAt3_Callback cb) { qcustomplot_layerableat3_callback = cb; }
    inline void setQCustomPlot_LayerableListAt3_Callback(QCustomPlot_LayerableListAt3_Callback cb) { qcustomplot_layerablelistat3_callback = cb; }
    inline void setQCustomPlot_UpdateMicroFocus_Callback(QCustomPlot_UpdateMicroFocus_Callback cb) { qcustomplot_updatemicrofocus_callback = cb; }
    inline void setQCustomPlot_Create_Callback(QCustomPlot_Create_Callback cb) { qcustomplot_create_callback = cb; }
    inline void setQCustomPlot_Destroy_Callback(QCustomPlot_Destroy_Callback cb) { qcustomplot_destroy_callback = cb; }
    inline void setQCustomPlot_FocusNextChild_Callback(QCustomPlot_FocusNextChild_Callback cb) { qcustomplot_focusnextchild_callback = cb; }
    inline void setQCustomPlot_FocusPreviousChild_Callback(QCustomPlot_FocusPreviousChild_Callback cb) { qcustomplot_focuspreviouschild_callback = cb; }
    inline void setQCustomPlot_Sender_Callback(QCustomPlot_Sender_Callback cb) { qcustomplot_sender_callback = cb; }
    inline void setQCustomPlot_SenderSignalIndex_Callback(QCustomPlot_SenderSignalIndex_Callback cb) { qcustomplot_sendersignalindex_callback = cb; }
    inline void setQCustomPlot_Receivers_Callback(QCustomPlot_Receivers_Callback cb) { qcustomplot_receivers_callback = cb; }
    inline void setQCustomPlot_IsSignalConnected_Callback(QCustomPlot_IsSignalConnected_Callback cb) { qcustomplot_issignalconnected_callback = cb; }
    inline void setQCustomPlot_GetDecodedMetricF_Callback(QCustomPlot_GetDecodedMetricF_Callback cb) { qcustomplot_getdecodedmetricf_callback = cb; }

    // Base flag setters
    inline void setQCustomPlot_Metacall_IsBase(bool value) const { qcustomplot_metacall_isbase = value; }
    inline void setQCustomPlot_MinimumSizeHint_IsBase(bool value) const { qcustomplot_minimumsizehint_isbase = value; }
    inline void setQCustomPlot_SizeHint_IsBase(bool value) const { qcustomplot_sizehint_isbase = value; }
    inline void setQCustomPlot_PaintEvent_IsBase(bool value) const { qcustomplot_paintevent_isbase = value; }
    inline void setQCustomPlot_ResizeEvent_IsBase(bool value) const { qcustomplot_resizeevent_isbase = value; }
    inline void setQCustomPlot_MouseDoubleClickEvent_IsBase(bool value) const { qcustomplot_mousedoubleclickevent_isbase = value; }
    inline void setQCustomPlot_MousePressEvent_IsBase(bool value) const { qcustomplot_mousepressevent_isbase = value; }
    inline void setQCustomPlot_MouseMoveEvent_IsBase(bool value) const { qcustomplot_mousemoveevent_isbase = value; }
    inline void setQCustomPlot_MouseReleaseEvent_IsBase(bool value) const { qcustomplot_mousereleaseevent_isbase = value; }
    inline void setQCustomPlot_WheelEvent_IsBase(bool value) const { qcustomplot_wheelevent_isbase = value; }
    inline void setQCustomPlot_Draw_IsBase(bool value) const { qcustomplot_draw_isbase = value; }
    inline void setQCustomPlot_UpdateLayout_IsBase(bool value) const { qcustomplot_updatelayout_isbase = value; }
    inline void setQCustomPlot_AxisRemoved_IsBase(bool value) const { qcustomplot_axisremoved_isbase = value; }
    inline void setQCustomPlot_LegendRemoved_IsBase(bool value) const { qcustomplot_legendremoved_isbase = value; }
    inline void setQCustomPlot_ProcessRectSelection_IsBase(bool value) const { qcustomplot_processrectselection_isbase = value; }
    inline void setQCustomPlot_ProcessRectZoom_IsBase(bool value) const { qcustomplot_processrectzoom_isbase = value; }
    inline void setQCustomPlot_ProcessPointSelection_IsBase(bool value) const { qcustomplot_processpointselection_isbase = value; }
    inline void setQCustomPlot_DevType_IsBase(bool value) const { qcustomplot_devtype_isbase = value; }
    inline void setQCustomPlot_SetVisible_IsBase(bool value) const { qcustomplot_setvisible_isbase = value; }
    inline void setQCustomPlot_HeightForWidth_IsBase(bool value) const { qcustomplot_heightforwidth_isbase = value; }
    inline void setQCustomPlot_HasHeightForWidth_IsBase(bool value) const { qcustomplot_hasheightforwidth_isbase = value; }
    inline void setQCustomPlot_PaintEngine_IsBase(bool value) const { qcustomplot_paintengine_isbase = value; }
    inline void setQCustomPlot_Event_IsBase(bool value) const { qcustomplot_event_isbase = value; }
    inline void setQCustomPlot_KeyPressEvent_IsBase(bool value) const { qcustomplot_keypressevent_isbase = value; }
    inline void setQCustomPlot_KeyReleaseEvent_IsBase(bool value) const { qcustomplot_keyreleaseevent_isbase = value; }
    inline void setQCustomPlot_FocusInEvent_IsBase(bool value) const { qcustomplot_focusinevent_isbase = value; }
    inline void setQCustomPlot_FocusOutEvent_IsBase(bool value) const { qcustomplot_focusoutevent_isbase = value; }
    inline void setQCustomPlot_EnterEvent_IsBase(bool value) const { qcustomplot_enterevent_isbase = value; }
    inline void setQCustomPlot_LeaveEvent_IsBase(bool value) const { qcustomplot_leaveevent_isbase = value; }
    inline void setQCustomPlot_MoveEvent_IsBase(bool value) const { qcustomplot_moveevent_isbase = value; }
    inline void setQCustomPlot_CloseEvent_IsBase(bool value) const { qcustomplot_closeevent_isbase = value; }
    inline void setQCustomPlot_ContextMenuEvent_IsBase(bool value) const { qcustomplot_contextmenuevent_isbase = value; }
    inline void setQCustomPlot_TabletEvent_IsBase(bool value) const { qcustomplot_tabletevent_isbase = value; }
    inline void setQCustomPlot_ActionEvent_IsBase(bool value) const { qcustomplot_actionevent_isbase = value; }
    inline void setQCustomPlot_DragEnterEvent_IsBase(bool value) const { qcustomplot_dragenterevent_isbase = value; }
    inline void setQCustomPlot_DragMoveEvent_IsBase(bool value) const { qcustomplot_dragmoveevent_isbase = value; }
    inline void setQCustomPlot_DragLeaveEvent_IsBase(bool value) const { qcustomplot_dragleaveevent_isbase = value; }
    inline void setQCustomPlot_DropEvent_IsBase(bool value) const { qcustomplot_dropevent_isbase = value; }
    inline void setQCustomPlot_ShowEvent_IsBase(bool value) const { qcustomplot_showevent_isbase = value; }
    inline void setQCustomPlot_HideEvent_IsBase(bool value) const { qcustomplot_hideevent_isbase = value; }
    inline void setQCustomPlot_NativeEvent_IsBase(bool value) const { qcustomplot_nativeevent_isbase = value; }
    inline void setQCustomPlot_ChangeEvent_IsBase(bool value) const { qcustomplot_changeevent_isbase = value; }
    inline void setQCustomPlot_Metric_IsBase(bool value) const { qcustomplot_metric_isbase = value; }
    inline void setQCustomPlot_InitPainter_IsBase(bool value) const { qcustomplot_initpainter_isbase = value; }
    inline void setQCustomPlot_Redirected_IsBase(bool value) const { qcustomplot_redirected_isbase = value; }
    inline void setQCustomPlot_SharedPainter_IsBase(bool value) const { qcustomplot_sharedpainter_isbase = value; }
    inline void setQCustomPlot_InputMethodEvent_IsBase(bool value) const { qcustomplot_inputmethodevent_isbase = value; }
    inline void setQCustomPlot_InputMethodQuery_IsBase(bool value) const { qcustomplot_inputmethodquery_isbase = value; }
    inline void setQCustomPlot_FocusNextPrevChild_IsBase(bool value) const { qcustomplot_focusnextprevchild_isbase = value; }
    inline void setQCustomPlot_EventFilter_IsBase(bool value) const { qcustomplot_eventfilter_isbase = value; }
    inline void setQCustomPlot_TimerEvent_IsBase(bool value) const { qcustomplot_timerevent_isbase = value; }
    inline void setQCustomPlot_ChildEvent_IsBase(bool value) const { qcustomplot_childevent_isbase = value; }
    inline void setQCustomPlot_CustomEvent_IsBase(bool value) const { qcustomplot_customevent_isbase = value; }
    inline void setQCustomPlot_ConnectNotify_IsBase(bool value) const { qcustomplot_connectnotify_isbase = value; }
    inline void setQCustomPlot_DisconnectNotify_IsBase(bool value) const { qcustomplot_disconnectnotify_isbase = value; }
    inline void setQCustomPlot_RegisterPlottable_IsBase(bool value) const { qcustomplot_registerplottable_isbase = value; }
    inline void setQCustomPlot_RegisterGraph_IsBase(bool value) const { qcustomplot_registergraph_isbase = value; }
    inline void setQCustomPlot_RegisterItem_IsBase(bool value) const { qcustomplot_registeritem_isbase = value; }
    inline void setQCustomPlot_UpdateLayerIndices_IsBase(bool value) const { qcustomplot_updatelayerindices_isbase = value; }
    inline void setQCustomPlot_LayerableAt_IsBase(bool value) const { qcustomplot_layerableat_isbase = value; }
    inline void setQCustomPlot_LayerableListAt_IsBase(bool value) const { qcustomplot_layerablelistat_isbase = value; }
    inline void setQCustomPlot_DrawBackground_IsBase(bool value) const { qcustomplot_drawbackground_isbase = value; }
    inline void setQCustomPlot_SetupPaintBuffers_IsBase(bool value) const { qcustomplot_setuppaintbuffers_isbase = value; }
    inline void setQCustomPlot_CreatePaintBuffer_IsBase(bool value) const { qcustomplot_createpaintbuffer_isbase = value; }
    inline void setQCustomPlot_HasInvalidatedPaintBuffers_IsBase(bool value) const { qcustomplot_hasinvalidatedpaintbuffers_isbase = value; }
    inline void setQCustomPlot_SetupOpenGl_IsBase(bool value) const { qcustomplot_setupopengl_isbase = value; }
    inline void setQCustomPlot_FreeOpenGl_IsBase(bool value) const { qcustomplot_freeopengl_isbase = value; }
    inline void setQCustomPlot_LayerableAt3_IsBase(bool value) const { qcustomplot_layerableat3_isbase = value; }
    inline void setQCustomPlot_LayerableListAt3_IsBase(bool value) const { qcustomplot_layerablelistat3_isbase = value; }
    inline void setQCustomPlot_UpdateMicroFocus_IsBase(bool value) const { qcustomplot_updatemicrofocus_isbase = value; }
    inline void setQCustomPlot_Create_IsBase(bool value) const { qcustomplot_create_isbase = value; }
    inline void setQCustomPlot_Destroy_IsBase(bool value) const { qcustomplot_destroy_isbase = value; }
    inline void setQCustomPlot_FocusNextChild_IsBase(bool value) const { qcustomplot_focusnextchild_isbase = value; }
    inline void setQCustomPlot_FocusPreviousChild_IsBase(bool value) const { qcustomplot_focuspreviouschild_isbase = value; }
    inline void setQCustomPlot_Sender_IsBase(bool value) const { qcustomplot_sender_isbase = value; }
    inline void setQCustomPlot_SenderSignalIndex_IsBase(bool value) const { qcustomplot_sendersignalindex_isbase = value; }
    inline void setQCustomPlot_Receivers_IsBase(bool value) const { qcustomplot_receivers_isbase = value; }
    inline void setQCustomPlot_IsSignalConnected_IsBase(bool value) const { qcustomplot_issignalconnected_isbase = value; }
    inline void setQCustomPlot_GetDecodedMetricF_IsBase(bool value) const { qcustomplot_getdecodedmetricf_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcustomplot_metacall_isbase) {
            qcustomplot_metacall_isbase = false;
            return QCustomPlot::qt_metacall(param1, param2, param3);
        } else if (qcustomplot_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcustomplot_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCustomPlot::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize minimumSizeHint() const override {
        if (qcustomplot_minimumsizehint_isbase) {
            qcustomplot_minimumsizehint_isbase = false;
            return QCustomPlot::minimumSizeHint();
        } else if (qcustomplot_minimumsizehint_callback != nullptr) {
            QSize* callback_ret = qcustomplot_minimumsizehint_callback();
            return *callback_ret;
        } else {
            return QCustomPlot::minimumSizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize sizeHint() const override {
        if (qcustomplot_sizehint_isbase) {
            qcustomplot_sizehint_isbase = false;
            return QCustomPlot::sizeHint();
        } else if (qcustomplot_sizehint_callback != nullptr) {
            QSize* callback_ret = qcustomplot_sizehint_callback();
            return *callback_ret;
        } else {
            return QCustomPlot::sizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void paintEvent(QPaintEvent* event) override {
        if (qcustomplot_paintevent_isbase) {
            qcustomplot_paintevent_isbase = false;
            QCustomPlot::paintEvent(event);
        } else if (qcustomplot_paintevent_callback != nullptr) {
            QPaintEvent* cbval1 = event;

            qcustomplot_paintevent_callback(this, cbval1);
        } else {
            QCustomPlot::paintEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void resizeEvent(QResizeEvent* event) override {
        if (qcustomplot_resizeevent_isbase) {
            qcustomplot_resizeevent_isbase = false;
            QCustomPlot::resizeEvent(event);
        } else if (qcustomplot_resizeevent_callback != nullptr) {
            QResizeEvent* cbval1 = event;

            qcustomplot_resizeevent_callback(this, cbval1);
        } else {
            QCustomPlot::resizeEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event) override {
        if (qcustomplot_mousedoubleclickevent_isbase) {
            qcustomplot_mousedoubleclickevent_isbase = false;
            QCustomPlot::mouseDoubleClickEvent(event);
        } else if (qcustomplot_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;

            qcustomplot_mousedoubleclickevent_callback(this, cbval1);
        } else {
            QCustomPlot::mouseDoubleClickEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event) override {
        if (qcustomplot_mousepressevent_isbase) {
            qcustomplot_mousepressevent_isbase = false;
            QCustomPlot::mousePressEvent(event);
        } else if (qcustomplot_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;

            qcustomplot_mousepressevent_callback(this, cbval1);
        } else {
            QCustomPlot::mousePressEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event) override {
        if (qcustomplot_mousemoveevent_isbase) {
            qcustomplot_mousemoveevent_isbase = false;
            QCustomPlot::mouseMoveEvent(event);
        } else if (qcustomplot_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;

            qcustomplot_mousemoveevent_callback(this, cbval1);
        } else {
            QCustomPlot::mouseMoveEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event) override {
        if (qcustomplot_mousereleaseevent_isbase) {
            qcustomplot_mousereleaseevent_isbase = false;
            QCustomPlot::mouseReleaseEvent(event);
        } else if (qcustomplot_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;

            qcustomplot_mousereleaseevent_callback(this, cbval1);
        } else {
            QCustomPlot::mouseReleaseEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcustomplot_wheelevent_isbase) {
            qcustomplot_wheelevent_isbase = false;
            QCustomPlot::wheelEvent(event);
        } else if (qcustomplot_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcustomplot_wheelevent_callback(this, cbval1);
        } else {
            QCustomPlot::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcustomplot_draw_isbase) {
            qcustomplot_draw_isbase = false;
            QCustomPlot::draw(painter);
        } else if (qcustomplot_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcustomplot_draw_callback(this, cbval1);
        } else {
            QCustomPlot::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void updateLayout() override {
        if (qcustomplot_updatelayout_isbase) {
            qcustomplot_updatelayout_isbase = false;
            QCustomPlot::updateLayout();
        } else if (qcustomplot_updatelayout_callback != nullptr) {
            qcustomplot_updatelayout_callback();
        } else {
            QCustomPlot::updateLayout();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void axisRemoved(QCPAxis* axis) override {
        if (qcustomplot_axisremoved_isbase) {
            qcustomplot_axisremoved_isbase = false;
            QCustomPlot::axisRemoved(axis);
        } else if (qcustomplot_axisremoved_callback != nullptr) {
            QCPAxis* cbval1 = axis;

            qcustomplot_axisremoved_callback(this, cbval1);
        } else {
            QCustomPlot::axisRemoved(axis);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void legendRemoved(QCPLegend* legend) override {
        if (qcustomplot_legendremoved_isbase) {
            qcustomplot_legendremoved_isbase = false;
            QCustomPlot::legendRemoved(legend);
        } else if (qcustomplot_legendremoved_callback != nullptr) {
            QCPLegend* cbval1 = legend;

            qcustomplot_legendremoved_callback(this, cbval1);
        } else {
            QCustomPlot::legendRemoved(legend);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void processRectSelection(QRect rect, QMouseEvent* event) override {
        if (qcustomplot_processrectselection_isbase) {
            qcustomplot_processrectselection_isbase = false;
            QCustomPlot::processRectSelection(rect, event);
        } else if (qcustomplot_processrectselection_callback != nullptr) {
            QRect* cbval1 = new QRect(rect);
            QMouseEvent* cbval2 = event;

            qcustomplot_processrectselection_callback(this, cbval1, cbval2);
        } else {
            QCustomPlot::processRectSelection(rect, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void processRectZoom(QRect rect, QMouseEvent* event) override {
        if (qcustomplot_processrectzoom_isbase) {
            qcustomplot_processrectzoom_isbase = false;
            QCustomPlot::processRectZoom(rect, event);
        } else if (qcustomplot_processrectzoom_callback != nullptr) {
            QRect* cbval1 = new QRect(rect);
            QMouseEvent* cbval2 = event;

            qcustomplot_processrectzoom_callback(this, cbval1, cbval2);
        } else {
            QCustomPlot::processRectZoom(rect, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void processPointSelection(QMouseEvent* event) override {
        if (qcustomplot_processpointselection_isbase) {
            qcustomplot_processpointselection_isbase = false;
            QCustomPlot::processPointSelection(event);
        } else if (qcustomplot_processpointselection_callback != nullptr) {
            QMouseEvent* cbval1 = event;

            qcustomplot_processpointselection_callback(this, cbval1);
        } else {
            QCustomPlot::processPointSelection(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int devType() const override {
        if (qcustomplot_devtype_isbase) {
            qcustomplot_devtype_isbase = false;
            return QCustomPlot::devType();
        } else if (qcustomplot_devtype_callback != nullptr) {
            int callback_ret = qcustomplot_devtype_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCustomPlot::devType();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void setVisible(bool visible) override {
        if (qcustomplot_setvisible_isbase) {
            qcustomplot_setvisible_isbase = false;
            QCustomPlot::setVisible(visible);
        } else if (qcustomplot_setvisible_callback != nullptr) {
            bool cbval1 = visible;

            qcustomplot_setvisible_callback(this, cbval1);
        } else {
            QCustomPlot::setVisible(visible);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int heightForWidth(int param1) const override {
        if (qcustomplot_heightforwidth_isbase) {
            qcustomplot_heightforwidth_isbase = false;
            return QCustomPlot::heightForWidth(param1);
        } else if (qcustomplot_heightforwidth_callback != nullptr) {
            int cbval1 = param1;

            int callback_ret = qcustomplot_heightforwidth_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCustomPlot::heightForWidth(param1);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool hasHeightForWidth() const override {
        if (qcustomplot_hasheightforwidth_isbase) {
            qcustomplot_hasheightforwidth_isbase = false;
            return QCustomPlot::hasHeightForWidth();
        } else if (qcustomplot_hasheightforwidth_callback != nullptr) {
            bool callback_ret = qcustomplot_hasheightforwidth_callback();
            return callback_ret;
        } else {
            return QCustomPlot::hasHeightForWidth();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QPaintEngine* paintEngine() const override {
        if (qcustomplot_paintengine_isbase) {
            qcustomplot_paintengine_isbase = false;
            return QCustomPlot::paintEngine();
        } else if (qcustomplot_paintengine_callback != nullptr) {
            QPaintEngine* callback_ret = qcustomplot_paintengine_callback();
            return callback_ret;
        } else {
            return QCustomPlot::paintEngine();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcustomplot_event_isbase) {
            qcustomplot_event_isbase = false;
            return QCustomPlot::event(event);
        } else if (qcustomplot_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcustomplot_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCustomPlot::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void keyPressEvent(QKeyEvent* event) override {
        if (qcustomplot_keypressevent_isbase) {
            qcustomplot_keypressevent_isbase = false;
            QCustomPlot::keyPressEvent(event);
        } else if (qcustomplot_keypressevent_callback != nullptr) {
            QKeyEvent* cbval1 = event;

            qcustomplot_keypressevent_callback(this, cbval1);
        } else {
            QCustomPlot::keyPressEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void keyReleaseEvent(QKeyEvent* event) override {
        if (qcustomplot_keyreleaseevent_isbase) {
            qcustomplot_keyreleaseevent_isbase = false;
            QCustomPlot::keyReleaseEvent(event);
        } else if (qcustomplot_keyreleaseevent_callback != nullptr) {
            QKeyEvent* cbval1 = event;

            qcustomplot_keyreleaseevent_callback(this, cbval1);
        } else {
            QCustomPlot::keyReleaseEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void focusInEvent(QFocusEvent* event) override {
        if (qcustomplot_focusinevent_isbase) {
            qcustomplot_focusinevent_isbase = false;
            QCustomPlot::focusInEvent(event);
        } else if (qcustomplot_focusinevent_callback != nullptr) {
            QFocusEvent* cbval1 = event;

            qcustomplot_focusinevent_callback(this, cbval1);
        } else {
            QCustomPlot::focusInEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void focusOutEvent(QFocusEvent* event) override {
        if (qcustomplot_focusoutevent_isbase) {
            qcustomplot_focusoutevent_isbase = false;
            QCustomPlot::focusOutEvent(event);
        } else if (qcustomplot_focusoutevent_callback != nullptr) {
            QFocusEvent* cbval1 = event;

            qcustomplot_focusoutevent_callback(this, cbval1);
        } else {
            QCustomPlot::focusOutEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void enterEvent(QEnterEvent* event) override {
        if (qcustomplot_enterevent_isbase) {
            qcustomplot_enterevent_isbase = false;
            QCustomPlot::enterEvent(event);
        } else if (qcustomplot_enterevent_callback != nullptr) {
            QEnterEvent* cbval1 = event;

            qcustomplot_enterevent_callback(this, cbval1);
        } else {
            QCustomPlot::enterEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void leaveEvent(QEvent* event) override {
        if (qcustomplot_leaveevent_isbase) {
            qcustomplot_leaveevent_isbase = false;
            QCustomPlot::leaveEvent(event);
        } else if (qcustomplot_leaveevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcustomplot_leaveevent_callback(this, cbval1);
        } else {
            QCustomPlot::leaveEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void moveEvent(QMoveEvent* event) override {
        if (qcustomplot_moveevent_isbase) {
            qcustomplot_moveevent_isbase = false;
            QCustomPlot::moveEvent(event);
        } else if (qcustomplot_moveevent_callback != nullptr) {
            QMoveEvent* cbval1 = event;

            qcustomplot_moveevent_callback(this, cbval1);
        } else {
            QCustomPlot::moveEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void closeEvent(QCloseEvent* event) override {
        if (qcustomplot_closeevent_isbase) {
            qcustomplot_closeevent_isbase = false;
            QCustomPlot::closeEvent(event);
        } else if (qcustomplot_closeevent_callback != nullptr) {
            QCloseEvent* cbval1 = event;

            qcustomplot_closeevent_callback(this, cbval1);
        } else {
            QCustomPlot::closeEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void contextMenuEvent(QContextMenuEvent* event) override {
        if (qcustomplot_contextmenuevent_isbase) {
            qcustomplot_contextmenuevent_isbase = false;
            QCustomPlot::contextMenuEvent(event);
        } else if (qcustomplot_contextmenuevent_callback != nullptr) {
            QContextMenuEvent* cbval1 = event;

            qcustomplot_contextmenuevent_callback(this, cbval1);
        } else {
            QCustomPlot::contextMenuEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void tabletEvent(QTabletEvent* event) override {
        if (qcustomplot_tabletevent_isbase) {
            qcustomplot_tabletevent_isbase = false;
            QCustomPlot::tabletEvent(event);
        } else if (qcustomplot_tabletevent_callback != nullptr) {
            QTabletEvent* cbval1 = event;

            qcustomplot_tabletevent_callback(this, cbval1);
        } else {
            QCustomPlot::tabletEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void actionEvent(QActionEvent* event) override {
        if (qcustomplot_actionevent_isbase) {
            qcustomplot_actionevent_isbase = false;
            QCustomPlot::actionEvent(event);
        } else if (qcustomplot_actionevent_callback != nullptr) {
            QActionEvent* cbval1 = event;

            qcustomplot_actionevent_callback(this, cbval1);
        } else {
            QCustomPlot::actionEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void dragEnterEvent(QDragEnterEvent* event) override {
        if (qcustomplot_dragenterevent_isbase) {
            qcustomplot_dragenterevent_isbase = false;
            QCustomPlot::dragEnterEvent(event);
        } else if (qcustomplot_dragenterevent_callback != nullptr) {
            QDragEnterEvent* cbval1 = event;

            qcustomplot_dragenterevent_callback(this, cbval1);
        } else {
            QCustomPlot::dragEnterEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void dragMoveEvent(QDragMoveEvent* event) override {
        if (qcustomplot_dragmoveevent_isbase) {
            qcustomplot_dragmoveevent_isbase = false;
            QCustomPlot::dragMoveEvent(event);
        } else if (qcustomplot_dragmoveevent_callback != nullptr) {
            QDragMoveEvent* cbval1 = event;

            qcustomplot_dragmoveevent_callback(this, cbval1);
        } else {
            QCustomPlot::dragMoveEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void dragLeaveEvent(QDragLeaveEvent* event) override {
        if (qcustomplot_dragleaveevent_isbase) {
            qcustomplot_dragleaveevent_isbase = false;
            QCustomPlot::dragLeaveEvent(event);
        } else if (qcustomplot_dragleaveevent_callback != nullptr) {
            QDragLeaveEvent* cbval1 = event;

            qcustomplot_dragleaveevent_callback(this, cbval1);
        } else {
            QCustomPlot::dragLeaveEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void dropEvent(QDropEvent* event) override {
        if (qcustomplot_dropevent_isbase) {
            qcustomplot_dropevent_isbase = false;
            QCustomPlot::dropEvent(event);
        } else if (qcustomplot_dropevent_callback != nullptr) {
            QDropEvent* cbval1 = event;

            qcustomplot_dropevent_callback(this, cbval1);
        } else {
            QCustomPlot::dropEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void showEvent(QShowEvent* event) override {
        if (qcustomplot_showevent_isbase) {
            qcustomplot_showevent_isbase = false;
            QCustomPlot::showEvent(event);
        } else if (qcustomplot_showevent_callback != nullptr) {
            QShowEvent* cbval1 = event;

            qcustomplot_showevent_callback(this, cbval1);
        } else {
            QCustomPlot::showEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void hideEvent(QHideEvent* event) override {
        if (qcustomplot_hideevent_isbase) {
            qcustomplot_hideevent_isbase = false;
            QCustomPlot::hideEvent(event);
        } else if (qcustomplot_hideevent_callback != nullptr) {
            QHideEvent* cbval1 = event;

            qcustomplot_hideevent_callback(this, cbval1);
        } else {
            QCustomPlot::hideEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool nativeEvent(const QByteArray& eventType, void* message, qintptr* result) override {
        if (qcustomplot_nativeevent_isbase) {
            qcustomplot_nativeevent_isbase = false;
            return QCustomPlot::nativeEvent(eventType, message, result);
        } else if (qcustomplot_nativeevent_callback != nullptr) {
            const QByteArray eventType_qb = eventType;
            libqt_string eventType_str;
            eventType_str.len = eventType_qb.length();
            eventType_str.data = static_cast<const char*>(malloc(eventType_str.len + 1));
            memcpy((void*)eventType_str.data, eventType_qb.data(), eventType_str.len);
            ((char*)eventType_str.data)[eventType_str.len] = '\0';
            libqt_string cbval1 = eventType_str;
            void* cbval2 = message;
            qintptr* result_ret = result;
            intptr_t* cbval3 = (intptr_t*)(result_ret);

            bool callback_ret = qcustomplot_nativeevent_callback(this, cbval1, cbval2, cbval3);
            return callback_ret;
        } else {
            return QCustomPlot::nativeEvent(eventType, message, result);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void changeEvent(QEvent* param1) override {
        if (qcustomplot_changeevent_isbase) {
            qcustomplot_changeevent_isbase = false;
            QCustomPlot::changeEvent(param1);
        } else if (qcustomplot_changeevent_callback != nullptr) {
            QEvent* cbval1 = param1;

            qcustomplot_changeevent_callback(this, cbval1);
        } else {
            QCustomPlot::changeEvent(param1);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int metric(QPaintDevice::PaintDeviceMetric param1) const override {
        if (qcustomplot_metric_isbase) {
            qcustomplot_metric_isbase = false;
            return QCustomPlot::metric(param1);
        } else if (qcustomplot_metric_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);

            int callback_ret = qcustomplot_metric_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCustomPlot::metric(param1);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void initPainter(QPainter* painter) const override {
        if (qcustomplot_initpainter_isbase) {
            qcustomplot_initpainter_isbase = false;
            QCustomPlot::initPainter(painter);
        } else if (qcustomplot_initpainter_callback != nullptr) {
            QPainter* cbval1 = painter;

            qcustomplot_initpainter_callback(this, cbval1);
        } else {
            QCustomPlot::initPainter(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QPaintDevice* redirected(QPoint* offset) const override {
        if (qcustomplot_redirected_isbase) {
            qcustomplot_redirected_isbase = false;
            return QCustomPlot::redirected(offset);
        } else if (qcustomplot_redirected_callback != nullptr) {
            QPoint* cbval1 = offset;

            QPaintDevice* callback_ret = qcustomplot_redirected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCustomPlot::redirected(offset);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QPainter* sharedPainter() const override {
        if (qcustomplot_sharedpainter_isbase) {
            qcustomplot_sharedpainter_isbase = false;
            return QCustomPlot::sharedPainter();
        } else if (qcustomplot_sharedpainter_callback != nullptr) {
            QPainter* callback_ret = qcustomplot_sharedpainter_callback();
            return callback_ret;
        } else {
            return QCustomPlot::sharedPainter();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void inputMethodEvent(QInputMethodEvent* param1) override {
        if (qcustomplot_inputmethodevent_isbase) {
            qcustomplot_inputmethodevent_isbase = false;
            QCustomPlot::inputMethodEvent(param1);
        } else if (qcustomplot_inputmethodevent_callback != nullptr) {
            QInputMethodEvent* cbval1 = param1;

            qcustomplot_inputmethodevent_callback(this, cbval1);
        } else {
            QCustomPlot::inputMethodEvent(param1);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QVariant inputMethodQuery(Qt::InputMethodQuery param1) const override {
        if (qcustomplot_inputmethodquery_isbase) {
            qcustomplot_inputmethodquery_isbase = false;
            return QCustomPlot::inputMethodQuery(param1);
        } else if (qcustomplot_inputmethodquery_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);

            QVariant* callback_ret = qcustomplot_inputmethodquery_callback(this, cbval1);
            return *callback_ret;
        } else {
            return QCustomPlot::inputMethodQuery(param1);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool focusNextPrevChild(bool next) override {
        if (qcustomplot_focusnextprevchild_isbase) {
            qcustomplot_focusnextprevchild_isbase = false;
            return QCustomPlot::focusNextPrevChild(next);
        } else if (qcustomplot_focusnextprevchild_callback != nullptr) {
            bool cbval1 = next;

            bool callback_ret = qcustomplot_focusnextprevchild_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCustomPlot::focusNextPrevChild(next);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcustomplot_eventfilter_isbase) {
            qcustomplot_eventfilter_isbase = false;
            return QCustomPlot::eventFilter(watched, event);
        } else if (qcustomplot_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcustomplot_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCustomPlot::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcustomplot_timerevent_isbase) {
            qcustomplot_timerevent_isbase = false;
            QCustomPlot::timerEvent(event);
        } else if (qcustomplot_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcustomplot_timerevent_callback(this, cbval1);
        } else {
            QCustomPlot::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcustomplot_childevent_isbase) {
            qcustomplot_childevent_isbase = false;
            QCustomPlot::childEvent(event);
        } else if (qcustomplot_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcustomplot_childevent_callback(this, cbval1);
        } else {
            QCustomPlot::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcustomplot_customevent_isbase) {
            qcustomplot_customevent_isbase = false;
            QCustomPlot::customEvent(event);
        } else if (qcustomplot_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcustomplot_customevent_callback(this, cbval1);
        } else {
            QCustomPlot::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcustomplot_connectnotify_isbase) {
            qcustomplot_connectnotify_isbase = false;
            QCustomPlot::connectNotify(signal);
        } else if (qcustomplot_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcustomplot_connectnotify_callback(this, cbval1);
        } else {
            QCustomPlot::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcustomplot_disconnectnotify_isbase) {
            qcustomplot_disconnectnotify_isbase = false;
            QCustomPlot::disconnectNotify(signal);
        } else if (qcustomplot_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcustomplot_disconnectnotify_callback(this, cbval1);
        } else {
            QCustomPlot::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool registerPlottable(QCPAbstractPlottable* plottable) {
        if (qcustomplot_registerplottable_isbase) {
            qcustomplot_registerplottable_isbase = false;
            return QCustomPlot::registerPlottable(plottable);
        } else if (qcustomplot_registerplottable_callback != nullptr) {
            QCPAbstractPlottable* cbval1 = plottable;

            bool callback_ret = qcustomplot_registerplottable_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCustomPlot::registerPlottable(plottable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool registerGraph(QCPGraph* graph) {
        if (qcustomplot_registergraph_isbase) {
            qcustomplot_registergraph_isbase = false;
            return QCustomPlot::registerGraph(graph);
        } else if (qcustomplot_registergraph_callback != nullptr) {
            QCPGraph* cbval1 = graph;

            bool callback_ret = qcustomplot_registergraph_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCustomPlot::registerGraph(graph);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool registerItem(QCPAbstractItem* item) {
        if (qcustomplot_registeritem_isbase) {
            qcustomplot_registeritem_isbase = false;
            return QCustomPlot::registerItem(item);
        } else if (qcustomplot_registeritem_callback != nullptr) {
            QCPAbstractItem* cbval1 = item;

            bool callback_ret = qcustomplot_registeritem_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCustomPlot::registerItem(item);
        }
    }

    // Virtual method for C ABI access and custom callback
    void updateLayerIndices() const {
        if (qcustomplot_updatelayerindices_isbase) {
            qcustomplot_updatelayerindices_isbase = false;
            QCustomPlot::updateLayerIndices();
        } else if (qcustomplot_updatelayerindices_callback != nullptr) {
            qcustomplot_updatelayerindices_callback();
        } else {
            QCustomPlot::updateLayerIndices();
        }
    }

    // Virtual method for C ABI access and custom callback
    QCPLayerable* layerableAt(const QPointF& pos, bool onlySelectable) const {
        if (qcustomplot_layerableat_isbase) {
            qcustomplot_layerableat_isbase = false;
            return QCustomPlot::layerableAt(pos, onlySelectable);
        } else if (qcustomplot_layerableat_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;

            QCPLayerable* callback_ret = qcustomplot_layerableat_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCustomPlot::layerableAt(pos, onlySelectable);
        }
    }

    // Virtual method for C ABI access and custom callback
    QList<QCPLayerable*> layerableListAt(const QPointF& pos, bool onlySelectable) const {
        if (qcustomplot_layerablelistat_isbase) {
            qcustomplot_layerablelistat_isbase = false;
            return QCustomPlot::layerableListAt(pos, onlySelectable);
        } else if (qcustomplot_layerablelistat_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;

            QCPLayerable** callback_ret = qcustomplot_layerablelistat_callback(this, cbval1, cbval2);
            QList<QCPLayerable*> callback_ret_QList;
            // Iterate until null pointer sentinel
            for (QCPLayerable** ptridx = callback_ret; *ptridx != nullptr; ptridx++) {
                callback_ret_QList.push_back(*ptridx);
            }
            free(callback_ret);
            return callback_ret_QList;
        } else {
            return QCustomPlot::layerableListAt(pos, onlySelectable);
        }
    }

    // Virtual method for C ABI access and custom callback
    void drawBackground(QCPPainter* painter) {
        if (qcustomplot_drawbackground_isbase) {
            qcustomplot_drawbackground_isbase = false;
            QCustomPlot::drawBackground(painter);
        } else if (qcustomplot_drawbackground_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcustomplot_drawbackground_callback(this, cbval1);
        } else {
            QCustomPlot::drawBackground(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setupPaintBuffers() {
        if (qcustomplot_setuppaintbuffers_isbase) {
            qcustomplot_setuppaintbuffers_isbase = false;
            QCustomPlot::setupPaintBuffers();
        } else if (qcustomplot_setuppaintbuffers_callback != nullptr) {
            qcustomplot_setuppaintbuffers_callback();
        } else {
            QCustomPlot::setupPaintBuffers();
        }
    }

    // Virtual method for C ABI access and custom callback
    QCPAbstractPaintBuffer* createPaintBuffer() {
        if (qcustomplot_createpaintbuffer_isbase) {
            qcustomplot_createpaintbuffer_isbase = false;
            return QCustomPlot::createPaintBuffer();
        } else if (qcustomplot_createpaintbuffer_callback != nullptr) {
            QCPAbstractPaintBuffer* callback_ret = qcustomplot_createpaintbuffer_callback();
            return callback_ret;
        } else {
            return QCustomPlot::createPaintBuffer();
        }
    }

    // Virtual method for C ABI access and custom callback
    bool hasInvalidatedPaintBuffers() {
        if (qcustomplot_hasinvalidatedpaintbuffers_isbase) {
            qcustomplot_hasinvalidatedpaintbuffers_isbase = false;
            return QCustomPlot::hasInvalidatedPaintBuffers();
        } else if (qcustomplot_hasinvalidatedpaintbuffers_callback != nullptr) {
            bool callback_ret = qcustomplot_hasinvalidatedpaintbuffers_callback();
            return callback_ret;
        } else {
            return QCustomPlot::hasInvalidatedPaintBuffers();
        }
    }

    // Virtual method for C ABI access and custom callback
    bool setupOpenGl() {
        if (qcustomplot_setupopengl_isbase) {
            qcustomplot_setupopengl_isbase = false;
            return QCustomPlot::setupOpenGl();
        } else if (qcustomplot_setupopengl_callback != nullptr) {
            bool callback_ret = qcustomplot_setupopengl_callback();
            return callback_ret;
        } else {
            return QCustomPlot::setupOpenGl();
        }
    }

    // Virtual method for C ABI access and custom callback
    void freeOpenGl() {
        if (qcustomplot_freeopengl_isbase) {
            qcustomplot_freeopengl_isbase = false;
            QCustomPlot::freeOpenGl();
        } else if (qcustomplot_freeopengl_callback != nullptr) {
            qcustomplot_freeopengl_callback();
        } else {
            QCustomPlot::freeOpenGl();
        }
    }

    // Virtual method for C ABI access and custom callback
    QCPLayerable* layerableAt(const QPointF& pos, bool onlySelectable, QVariant* selectionDetails) const {
        if (qcustomplot_layerableat3_isbase) {
            qcustomplot_layerableat3_isbase = false;
            return QCustomPlot::layerableAt(pos, onlySelectable, selectionDetails);
        } else if (qcustomplot_layerableat3_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = selectionDetails;

            QCPLayerable* callback_ret = qcustomplot_layerableat3_callback(this, cbval1, cbval2, cbval3);
            return callback_ret;
        } else {
            return QCustomPlot::layerableAt(pos, onlySelectable, selectionDetails);
        }
    }

    // Virtual method for C ABI access and custom callback
    QList<QCPLayerable*> layerableListAt(const QPointF& pos, bool onlySelectable, QList<QVariant>* selectionDetails) const {
        if (qcustomplot_layerablelistat3_isbase) {
            qcustomplot_layerablelistat3_isbase = false;
            return QCustomPlot::layerableListAt(pos, onlySelectable, selectionDetails);
        } else if (qcustomplot_layerablelistat3_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QList<QVariant>* selectionDetails_ret = selectionDetails;
            // Convert QList<> from C++ memory to manually-managed C memory
            QVariant** selectionDetails_arr = static_cast<QVariant**>(malloc(sizeof(QVariant*) * (selectionDetails_ret->size() + 1)));
            for (qsizetype i = 0; i < selectionDetails_ret->size(); ++i) {
                selectionDetails_arr[i] = new QVariant((*selectionDetails_ret)[i]);
            }
            libqt_list selectionDetails_out;
            selectionDetails_out.len = selectionDetails_ret->size();
            selectionDetails_out.data = static_cast<void*>(selectionDetails_arr);
            libqt_list /* of QVariant* */ cbval3 = selectionDetails_out;

            QCPLayerable** callback_ret = qcustomplot_layerablelistat3_callback(this, cbval1, cbval2, cbval3);
            QList<QCPLayerable*> callback_ret_QList;
            // Iterate until null pointer sentinel
            for (QCPLayerable** ptridx = callback_ret; *ptridx != nullptr; ptridx++) {
                callback_ret_QList.push_back(*ptridx);
            }
            free(callback_ret);
            return callback_ret_QList;
        } else {
            return QCustomPlot::layerableListAt(pos, onlySelectable, selectionDetails);
        }
    }

    // Virtual method for C ABI access and custom callback
    void updateMicroFocus() {
        if (qcustomplot_updatemicrofocus_isbase) {
            qcustomplot_updatemicrofocus_isbase = false;
            QCustomPlot::updateMicroFocus();
        } else if (qcustomplot_updatemicrofocus_callback != nullptr) {
            qcustomplot_updatemicrofocus_callback();
        } else {
            QCustomPlot::updateMicroFocus();
        }
    }

    // Virtual method for C ABI access and custom callback
    void create() {
        if (qcustomplot_create_isbase) {
            qcustomplot_create_isbase = false;
            QCustomPlot::create();
        } else if (qcustomplot_create_callback != nullptr) {
            qcustomplot_create_callback();
        } else {
            QCustomPlot::create();
        }
    }

    // Virtual method for C ABI access and custom callback
    void destroy() {
        if (qcustomplot_destroy_isbase) {
            qcustomplot_destroy_isbase = false;
            QCustomPlot::destroy();
        } else if (qcustomplot_destroy_callback != nullptr) {
            qcustomplot_destroy_callback();
        } else {
            QCustomPlot::destroy();
        }
    }

    // Virtual method for C ABI access and custom callback
    bool focusNextChild() {
        if (qcustomplot_focusnextchild_isbase) {
            qcustomplot_focusnextchild_isbase = false;
            return QCustomPlot::focusNextChild();
        } else if (qcustomplot_focusnextchild_callback != nullptr) {
            bool callback_ret = qcustomplot_focusnextchild_callback();
            return callback_ret;
        } else {
            return QCustomPlot::focusNextChild();
        }
    }

    // Virtual method for C ABI access and custom callback
    bool focusPreviousChild() {
        if (qcustomplot_focuspreviouschild_isbase) {
            qcustomplot_focuspreviouschild_isbase = false;
            return QCustomPlot::focusPreviousChild();
        } else if (qcustomplot_focuspreviouschild_callback != nullptr) {
            bool callback_ret = qcustomplot_focuspreviouschild_callback();
            return callback_ret;
        } else {
            return QCustomPlot::focusPreviousChild();
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcustomplot_sender_isbase) {
            qcustomplot_sender_isbase = false;
            return QCustomPlot::sender();
        } else if (qcustomplot_sender_callback != nullptr) {
            QObject* callback_ret = qcustomplot_sender_callback();
            return callback_ret;
        } else {
            return QCustomPlot::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcustomplot_sendersignalindex_isbase) {
            qcustomplot_sendersignalindex_isbase = false;
            return QCustomPlot::senderSignalIndex();
        } else if (qcustomplot_sendersignalindex_callback != nullptr) {
            int callback_ret = qcustomplot_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCustomPlot::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcustomplot_receivers_isbase) {
            qcustomplot_receivers_isbase = false;
            return QCustomPlot::receivers(signal);
        } else if (qcustomplot_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcustomplot_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCustomPlot::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcustomplot_issignalconnected_isbase) {
            qcustomplot_issignalconnected_isbase = false;
            return QCustomPlot::isSignalConnected(signal);
        } else if (qcustomplot_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcustomplot_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCustomPlot::isSignalConnected(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    double getDecodedMetricF(QPaintDevice::PaintDeviceMetric metricA, QPaintDevice::PaintDeviceMetric metricB) const {
        if (qcustomplot_getdecodedmetricf_isbase) {
            qcustomplot_getdecodedmetricf_isbase = false;
            return QCustomPlot::getDecodedMetricF(metricA, metricB);
        } else if (qcustomplot_getdecodedmetricf_callback != nullptr) {
            int cbval1 = static_cast<int>(metricA);
            int cbval2 = static_cast<int>(metricB);

            double callback_ret = qcustomplot_getdecodedmetricf_callback(this, cbval1, cbval2);
            return static_cast<double>(callback_ret);
        } else {
            return QCustomPlot::getDecodedMetricF(metricA, metricB);
        }
    }

    // Friend functions
    friend QSize* QCustomPlot_MinimumSizeHint(const QCustomPlot* self);
    friend QSize* QCustomPlot_QBaseMinimumSizeHint(const QCustomPlot* self);
    friend QSize* QCustomPlot_SizeHint(const QCustomPlot* self);
    friend QSize* QCustomPlot_QBaseSizeHint(const QCustomPlot* self);
    friend void QCustomPlot_PaintEvent(QCustomPlot* self, QPaintEvent* event);
    friend void QCustomPlot_QBasePaintEvent(QCustomPlot* self, QPaintEvent* event);
    friend void QCustomPlot_ResizeEvent(QCustomPlot* self, QResizeEvent* event);
    friend void QCustomPlot_QBaseResizeEvent(QCustomPlot* self, QResizeEvent* event);
    friend void QCustomPlot_MouseDoubleClickEvent(QCustomPlot* self, QMouseEvent* event);
    friend void QCustomPlot_QBaseMouseDoubleClickEvent(QCustomPlot* self, QMouseEvent* event);
    friend void QCustomPlot_MousePressEvent(QCustomPlot* self, QMouseEvent* event);
    friend void QCustomPlot_QBaseMousePressEvent(QCustomPlot* self, QMouseEvent* event);
    friend void QCustomPlot_MouseMoveEvent(QCustomPlot* self, QMouseEvent* event);
    friend void QCustomPlot_QBaseMouseMoveEvent(QCustomPlot* self, QMouseEvent* event);
    friend void QCustomPlot_MouseReleaseEvent(QCustomPlot* self, QMouseEvent* event);
    friend void QCustomPlot_QBaseMouseReleaseEvent(QCustomPlot* self, QMouseEvent* event);
    friend void QCustomPlot_WheelEvent(QCustomPlot* self, QWheelEvent* event);
    friend void QCustomPlot_QBaseWheelEvent(QCustomPlot* self, QWheelEvent* event);
    friend void QCustomPlot_Draw(QCustomPlot* self, QCPPainter* painter);
    friend void QCustomPlot_QBaseDraw(QCustomPlot* self, QCPPainter* painter);
    friend void QCustomPlot_UpdateLayout(QCustomPlot* self);
    friend void QCustomPlot_QBaseUpdateLayout(QCustomPlot* self);
    friend void QCustomPlot_AxisRemoved(QCustomPlot* self, QCPAxis* axis);
    friend void QCustomPlot_QBaseAxisRemoved(QCustomPlot* self, QCPAxis* axis);
    friend void QCustomPlot_LegendRemoved(QCustomPlot* self, QCPLegend* legend);
    friend void QCustomPlot_QBaseLegendRemoved(QCustomPlot* self, QCPLegend* legend);
    friend void QCustomPlot_ProcessRectSelection(QCustomPlot* self, QRect* rect, QMouseEvent* event);
    friend void QCustomPlot_QBaseProcessRectSelection(QCustomPlot* self, QRect* rect, QMouseEvent* event);
    friend void QCustomPlot_ProcessRectZoom(QCustomPlot* self, QRect* rect, QMouseEvent* event);
    friend void QCustomPlot_QBaseProcessRectZoom(QCustomPlot* self, QRect* rect, QMouseEvent* event);
    friend void QCustomPlot_ProcessPointSelection(QCustomPlot* self, QMouseEvent* event);
    friend void QCustomPlot_QBaseProcessPointSelection(QCustomPlot* self, QMouseEvent* event);
    friend bool QCustomPlot_Event(QCustomPlot* self, QEvent* event);
    friend bool QCustomPlot_QBaseEvent(QCustomPlot* self, QEvent* event);
    friend void QCustomPlot_KeyPressEvent(QCustomPlot* self, QKeyEvent* event);
    friend void QCustomPlot_QBaseKeyPressEvent(QCustomPlot* self, QKeyEvent* event);
    friend void QCustomPlot_KeyReleaseEvent(QCustomPlot* self, QKeyEvent* event);
    friend void QCustomPlot_QBaseKeyReleaseEvent(QCustomPlot* self, QKeyEvent* event);
    friend void QCustomPlot_FocusInEvent(QCustomPlot* self, QFocusEvent* event);
    friend void QCustomPlot_QBaseFocusInEvent(QCustomPlot* self, QFocusEvent* event);
    friend void QCustomPlot_FocusOutEvent(QCustomPlot* self, QFocusEvent* event);
    friend void QCustomPlot_QBaseFocusOutEvent(QCustomPlot* self, QFocusEvent* event);
    friend void QCustomPlot_EnterEvent(QCustomPlot* self, QEnterEvent* event);
    friend void QCustomPlot_QBaseEnterEvent(QCustomPlot* self, QEnterEvent* event);
    friend void QCustomPlot_LeaveEvent(QCustomPlot* self, QEvent* event);
    friend void QCustomPlot_QBaseLeaveEvent(QCustomPlot* self, QEvent* event);
    friend void QCustomPlot_MoveEvent(QCustomPlot* self, QMoveEvent* event);
    friend void QCustomPlot_QBaseMoveEvent(QCustomPlot* self, QMoveEvent* event);
    friend void QCustomPlot_CloseEvent(QCustomPlot* self, QCloseEvent* event);
    friend void QCustomPlot_QBaseCloseEvent(QCustomPlot* self, QCloseEvent* event);
    friend void QCustomPlot_ContextMenuEvent(QCustomPlot* self, QContextMenuEvent* event);
    friend void QCustomPlot_QBaseContextMenuEvent(QCustomPlot* self, QContextMenuEvent* event);
    friend void QCustomPlot_TabletEvent(QCustomPlot* self, QTabletEvent* event);
    friend void QCustomPlot_QBaseTabletEvent(QCustomPlot* self, QTabletEvent* event);
    friend void QCustomPlot_ActionEvent(QCustomPlot* self, QActionEvent* event);
    friend void QCustomPlot_QBaseActionEvent(QCustomPlot* self, QActionEvent* event);
    friend void QCustomPlot_DragEnterEvent(QCustomPlot* self, QDragEnterEvent* event);
    friend void QCustomPlot_QBaseDragEnterEvent(QCustomPlot* self, QDragEnterEvent* event);
    friend void QCustomPlot_DragMoveEvent(QCustomPlot* self, QDragMoveEvent* event);
    friend void QCustomPlot_QBaseDragMoveEvent(QCustomPlot* self, QDragMoveEvent* event);
    friend void QCustomPlot_DragLeaveEvent(QCustomPlot* self, QDragLeaveEvent* event);
    friend void QCustomPlot_QBaseDragLeaveEvent(QCustomPlot* self, QDragLeaveEvent* event);
    friend void QCustomPlot_DropEvent(QCustomPlot* self, QDropEvent* event);
    friend void QCustomPlot_QBaseDropEvent(QCustomPlot* self, QDropEvent* event);
    friend void QCustomPlot_ShowEvent(QCustomPlot* self, QShowEvent* event);
    friend void QCustomPlot_QBaseShowEvent(QCustomPlot* self, QShowEvent* event);
    friend void QCustomPlot_HideEvent(QCustomPlot* self, QHideEvent* event);
    friend void QCustomPlot_QBaseHideEvent(QCustomPlot* self, QHideEvent* event);
    friend bool QCustomPlot_NativeEvent(QCustomPlot* self, const libqt_string eventType, void* message, intptr_t* result);
    friend bool QCustomPlot_QBaseNativeEvent(QCustomPlot* self, const libqt_string eventType, void* message, intptr_t* result);
    friend void QCustomPlot_ChangeEvent(QCustomPlot* self, QEvent* param1);
    friend void QCustomPlot_QBaseChangeEvent(QCustomPlot* self, QEvent* param1);
    friend int QCustomPlot_Metric(const QCustomPlot* self, int param1);
    friend int QCustomPlot_QBaseMetric(const QCustomPlot* self, int param1);
    friend void QCustomPlot_InitPainter(const QCustomPlot* self, QPainter* painter);
    friend void QCustomPlot_QBaseInitPainter(const QCustomPlot* self, QPainter* painter);
    friend QPaintDevice* QCustomPlot_Redirected(const QCustomPlot* self, QPoint* offset);
    friend QPaintDevice* QCustomPlot_QBaseRedirected(const QCustomPlot* self, QPoint* offset);
    friend QPainter* QCustomPlot_SharedPainter(const QCustomPlot* self);
    friend QPainter* QCustomPlot_QBaseSharedPainter(const QCustomPlot* self);
    friend void QCustomPlot_InputMethodEvent(QCustomPlot* self, QInputMethodEvent* param1);
    friend void QCustomPlot_QBaseInputMethodEvent(QCustomPlot* self, QInputMethodEvent* param1);
    friend bool QCustomPlot_FocusNextPrevChild(QCustomPlot* self, bool next);
    friend bool QCustomPlot_QBaseFocusNextPrevChild(QCustomPlot* self, bool next);
    friend void QCustomPlot_TimerEvent(QCustomPlot* self, QTimerEvent* event);
    friend void QCustomPlot_QBaseTimerEvent(QCustomPlot* self, QTimerEvent* event);
    friend void QCustomPlot_ChildEvent(QCustomPlot* self, QChildEvent* event);
    friend void QCustomPlot_QBaseChildEvent(QCustomPlot* self, QChildEvent* event);
    friend void QCustomPlot_CustomEvent(QCustomPlot* self, QEvent* event);
    friend void QCustomPlot_QBaseCustomEvent(QCustomPlot* self, QEvent* event);
    friend void QCustomPlot_ConnectNotify(QCustomPlot* self, const QMetaMethod* signal);
    friend void QCustomPlot_QBaseConnectNotify(QCustomPlot* self, const QMetaMethod* signal);
    friend void QCustomPlot_DisconnectNotify(QCustomPlot* self, const QMetaMethod* signal);
    friend void QCustomPlot_QBaseDisconnectNotify(QCustomPlot* self, const QMetaMethod* signal);
    friend bool QCustomPlot_RegisterPlottable(QCustomPlot* self, QCPAbstractPlottable* plottable);
    friend bool QCustomPlot_QBaseRegisterPlottable(QCustomPlot* self, QCPAbstractPlottable* plottable);
    friend bool QCustomPlot_RegisterGraph(QCustomPlot* self, QCPGraph* graph);
    friend bool QCustomPlot_QBaseRegisterGraph(QCustomPlot* self, QCPGraph* graph);
    friend bool QCustomPlot_RegisterItem(QCustomPlot* self, QCPAbstractItem* item);
    friend bool QCustomPlot_QBaseRegisterItem(QCustomPlot* self, QCPAbstractItem* item);
    friend void QCustomPlot_UpdateLayerIndices(const QCustomPlot* self);
    friend void QCustomPlot_QBaseUpdateLayerIndices(const QCustomPlot* self);
    friend QCPLayerable* QCustomPlot_LayerableAt(const QCustomPlot* self, const QPointF* pos, bool onlySelectable);
    friend QCPLayerable* QCustomPlot_QBaseLayerableAt(const QCustomPlot* self, const QPointF* pos, bool onlySelectable);
    friend libqt_list /* of QCPLayerable* */ QCustomPlot_LayerableListAt(const QCustomPlot* self, const QPointF* pos, bool onlySelectable);
    friend libqt_list /* of QCPLayerable* */ QCustomPlot_QBaseLayerableListAt(const QCustomPlot* self, const QPointF* pos, bool onlySelectable);
    friend void QCustomPlot_DrawBackground(QCustomPlot* self, QCPPainter* painter);
    friend void QCustomPlot_QBaseDrawBackground(QCustomPlot* self, QCPPainter* painter);
    friend void QCustomPlot_SetupPaintBuffers(QCustomPlot* self);
    friend void QCustomPlot_QBaseSetupPaintBuffers(QCustomPlot* self);
    friend QCPAbstractPaintBuffer* QCustomPlot_CreatePaintBuffer(QCustomPlot* self);
    friend QCPAbstractPaintBuffer* QCustomPlot_QBaseCreatePaintBuffer(QCustomPlot* self);
    friend bool QCustomPlot_HasInvalidatedPaintBuffers(QCustomPlot* self);
    friend bool QCustomPlot_QBaseHasInvalidatedPaintBuffers(QCustomPlot* self);
    friend bool QCustomPlot_SetupOpenGl(QCustomPlot* self);
    friend bool QCustomPlot_QBaseSetupOpenGl(QCustomPlot* self);
    friend void QCustomPlot_FreeOpenGl(QCustomPlot* self);
    friend void QCustomPlot_QBaseFreeOpenGl(QCustomPlot* self);
    friend QCPLayerable* QCustomPlot_LayerableAt3(const QCustomPlot* self, const QPointF* pos, bool onlySelectable, QVariant* selectionDetails);
    friend QCPLayerable* QCustomPlot_QBaseLayerableAt3(const QCustomPlot* self, const QPointF* pos, bool onlySelectable, QVariant* selectionDetails);
    friend libqt_list /* of QCPLayerable* */ QCustomPlot_LayerableListAt3(const QCustomPlot* self, const QPointF* pos, bool onlySelectable, libqt_list /* of QVariant* */ selectionDetails);
    friend libqt_list /* of QCPLayerable* */ QCustomPlot_QBaseLayerableListAt3(const QCustomPlot* self, const QPointF* pos, bool onlySelectable, libqt_list /* of QVariant* */ selectionDetails);
    friend void QCustomPlot_UpdateMicroFocus(QCustomPlot* self);
    friend void QCustomPlot_QBaseUpdateMicroFocus(QCustomPlot* self);
    friend void QCustomPlot_Create(QCustomPlot* self);
    friend void QCustomPlot_QBaseCreate(QCustomPlot* self);
    friend void QCustomPlot_Destroy(QCustomPlot* self);
    friend void QCustomPlot_QBaseDestroy(QCustomPlot* self);
    friend bool QCustomPlot_FocusNextChild(QCustomPlot* self);
    friend bool QCustomPlot_QBaseFocusNextChild(QCustomPlot* self);
    friend bool QCustomPlot_FocusPreviousChild(QCustomPlot* self);
    friend bool QCustomPlot_QBaseFocusPreviousChild(QCustomPlot* self);
    friend QObject* QCustomPlot_Sender(const QCustomPlot* self);
    friend QObject* QCustomPlot_QBaseSender(const QCustomPlot* self);
    friend int QCustomPlot_SenderSignalIndex(const QCustomPlot* self);
    friend int QCustomPlot_QBaseSenderSignalIndex(const QCustomPlot* self);
    friend int QCustomPlot_Receivers(const QCustomPlot* self, const char* signal);
    friend int QCustomPlot_QBaseReceivers(const QCustomPlot* self, const char* signal);
    friend bool QCustomPlot_IsSignalConnected(const QCustomPlot* self, const QMetaMethod* signal);
    friend bool QCustomPlot_QBaseIsSignalConnected(const QCustomPlot* self, const QMetaMethod* signal);
    friend double QCustomPlot_GetDecodedMetricF(const QCustomPlot* self, int metricA, int metricB);
    friend double QCustomPlot_QBaseGetDecodedMetricF(const QCustomPlot* self, int metricA, int metricB);
};

// This class is a subclass of QCPSelectionDecoratorBracket so that we can call protected methods
class VirtualQCPSelectionDecoratorBracket final : public QCPSelectionDecoratorBracket {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPSelectionDecoratorBracket = true;

    // Virtual class public types (including callbacks)
    using QCPSelectionDecoratorBracket_DrawBracket_Callback = void (*)(const QCPSelectionDecoratorBracket*, QCPPainter*, int);
    using QCPSelectionDecoratorBracket_DrawDecoration_Callback = void (*)(QCPSelectionDecoratorBracket*, QCPPainter*, QCPDataSelection*);
    using QCPSelectionDecoratorBracket_CopyFrom_Callback = void (*)(QCPSelectionDecoratorBracket*, QCPSelectionDecorator*);
    using QCPSelectionDecoratorBracket_RegisterWithPlottable_Callback = bool (*)(QCPSelectionDecoratorBracket*, QCPAbstractPlottable*);
    using QCPSelectionDecoratorBracket_GetTangentAngle_Callback = double (*)(const QCPSelectionDecoratorBracket*, QCPPlottableInterface1D*, int, int);
    using QCPSelectionDecoratorBracket_GetPixelCoordinates_Callback = QPointF* (*)(const QCPSelectionDecoratorBracket*, QCPPlottableInterface1D*, int);

  protected:
    // Instance callback storage
    QCPSelectionDecoratorBracket_DrawBracket_Callback qcpselectiondecoratorbracket_drawbracket_callback = nullptr;
    QCPSelectionDecoratorBracket_DrawDecoration_Callback qcpselectiondecoratorbracket_drawdecoration_callback = nullptr;
    QCPSelectionDecoratorBracket_CopyFrom_Callback qcpselectiondecoratorbracket_copyfrom_callback = nullptr;
    QCPSelectionDecoratorBracket_RegisterWithPlottable_Callback qcpselectiondecoratorbracket_registerwithplottable_callback = nullptr;
    QCPSelectionDecoratorBracket_GetTangentAngle_Callback qcpselectiondecoratorbracket_gettangentangle_callback = nullptr;
    QCPSelectionDecoratorBracket_GetPixelCoordinates_Callback qcpselectiondecoratorbracket_getpixelcoordinates_callback = nullptr;

    // Instance base flags
    mutable bool qcpselectiondecoratorbracket_drawbracket_isbase = false;
    mutable bool qcpselectiondecoratorbracket_drawdecoration_isbase = false;
    mutable bool qcpselectiondecoratorbracket_copyfrom_isbase = false;
    mutable bool qcpselectiondecoratorbracket_registerwithplottable_isbase = false;
    mutable bool qcpselectiondecoratorbracket_gettangentangle_isbase = false;
    mutable bool qcpselectiondecoratorbracket_getpixelcoordinates_isbase = false;

  public:
    VirtualQCPSelectionDecoratorBracket() : QCPSelectionDecoratorBracket() {};

    ~VirtualQCPSelectionDecoratorBracket() {
        qcpselectiondecoratorbracket_drawbracket_callback = nullptr;
        qcpselectiondecoratorbracket_drawdecoration_callback = nullptr;
        qcpselectiondecoratorbracket_copyfrom_callback = nullptr;
        qcpselectiondecoratorbracket_registerwithplottable_callback = nullptr;
        qcpselectiondecoratorbracket_gettangentangle_callback = nullptr;
        qcpselectiondecoratorbracket_getpixelcoordinates_callback = nullptr;
    }

    // Callback setters
    inline void setQCPSelectionDecoratorBracket_DrawBracket_Callback(QCPSelectionDecoratorBracket_DrawBracket_Callback cb) { qcpselectiondecoratorbracket_drawbracket_callback = cb; }
    inline void setQCPSelectionDecoratorBracket_DrawDecoration_Callback(QCPSelectionDecoratorBracket_DrawDecoration_Callback cb) { qcpselectiondecoratorbracket_drawdecoration_callback = cb; }
    inline void setQCPSelectionDecoratorBracket_CopyFrom_Callback(QCPSelectionDecoratorBracket_CopyFrom_Callback cb) { qcpselectiondecoratorbracket_copyfrom_callback = cb; }
    inline void setQCPSelectionDecoratorBracket_RegisterWithPlottable_Callback(QCPSelectionDecoratorBracket_RegisterWithPlottable_Callback cb) { qcpselectiondecoratorbracket_registerwithplottable_callback = cb; }
    inline void setQCPSelectionDecoratorBracket_GetTangentAngle_Callback(QCPSelectionDecoratorBracket_GetTangentAngle_Callback cb) { qcpselectiondecoratorbracket_gettangentangle_callback = cb; }
    inline void setQCPSelectionDecoratorBracket_GetPixelCoordinates_Callback(QCPSelectionDecoratorBracket_GetPixelCoordinates_Callback cb) { qcpselectiondecoratorbracket_getpixelcoordinates_callback = cb; }

    // Base flag setters
    inline void setQCPSelectionDecoratorBracket_DrawBracket_IsBase(bool value) const { qcpselectiondecoratorbracket_drawbracket_isbase = value; }
    inline void setQCPSelectionDecoratorBracket_DrawDecoration_IsBase(bool value) const { qcpselectiondecoratorbracket_drawdecoration_isbase = value; }
    inline void setQCPSelectionDecoratorBracket_CopyFrom_IsBase(bool value) const { qcpselectiondecoratorbracket_copyfrom_isbase = value; }
    inline void setQCPSelectionDecoratorBracket_RegisterWithPlottable_IsBase(bool value) const { qcpselectiondecoratorbracket_registerwithplottable_isbase = value; }
    inline void setQCPSelectionDecoratorBracket_GetTangentAngle_IsBase(bool value) const { qcpselectiondecoratorbracket_gettangentangle_isbase = value; }
    inline void setQCPSelectionDecoratorBracket_GetPixelCoordinates_IsBase(bool value) const { qcpselectiondecoratorbracket_getpixelcoordinates_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual void drawBracket(QCPPainter* painter, int direction) const override {
        if (qcpselectiondecoratorbracket_drawbracket_isbase) {
            qcpselectiondecoratorbracket_drawbracket_isbase = false;
            QCPSelectionDecoratorBracket::drawBracket(painter, direction);
        } else if (qcpselectiondecoratorbracket_drawbracket_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            int cbval2 = direction;

            qcpselectiondecoratorbracket_drawbracket_callback(this, cbval1, cbval2);
        } else {
            QCPSelectionDecoratorBracket::drawBracket(painter, direction);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void drawDecoration(QCPPainter* painter, QCPDataSelection selection) override {
        if (qcpselectiondecoratorbracket_drawdecoration_isbase) {
            qcpselectiondecoratorbracket_drawdecoration_isbase = false;
            QCPSelectionDecoratorBracket::drawDecoration(painter, selection);
        } else if (qcpselectiondecoratorbracket_drawdecoration_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            QCPDataSelection* cbval2 = new QCPDataSelection(selection);

            qcpselectiondecoratorbracket_drawdecoration_callback(this, cbval1, cbval2);
        } else {
            QCPSelectionDecoratorBracket::drawDecoration(painter, selection);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void copyFrom(const QCPSelectionDecorator* other) override {
        if (qcpselectiondecoratorbracket_copyfrom_isbase) {
            qcpselectiondecoratorbracket_copyfrom_isbase = false;
            QCPSelectionDecoratorBracket::copyFrom(other);
        } else if (qcpselectiondecoratorbracket_copyfrom_callback != nullptr) {
            QCPSelectionDecorator* cbval1 = (QCPSelectionDecorator*)other;

            qcpselectiondecoratorbracket_copyfrom_callback(this, cbval1);
        } else {
            QCPSelectionDecoratorBracket::copyFrom(other);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool registerWithPlottable(QCPAbstractPlottable* plottable) override {
        if (qcpselectiondecoratorbracket_registerwithplottable_isbase) {
            qcpselectiondecoratorbracket_registerwithplottable_isbase = false;
            return QCPSelectionDecoratorBracket::registerWithPlottable(plottable);
        } else if (qcpselectiondecoratorbracket_registerwithplottable_callback != nullptr) {
            QCPAbstractPlottable* cbval1 = plottable;

            bool callback_ret = qcpselectiondecoratorbracket_registerwithplottable_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPSelectionDecoratorBracket::registerWithPlottable(plottable);
        }
    }

    // Virtual method for C ABI access and custom callback
    double getTangentAngle(const QCPPlottableInterface1D* interface1d, int dataIndex, int direction) const {
        if (qcpselectiondecoratorbracket_gettangentangle_isbase) {
            qcpselectiondecoratorbracket_gettangentangle_isbase = false;
            return QCPSelectionDecoratorBracket::getTangentAngle(interface1d, dataIndex, direction);
        } else if (qcpselectiondecoratorbracket_gettangentangle_callback != nullptr) {
            QCPPlottableInterface1D* cbval1 = (QCPPlottableInterface1D*)interface1d;
            int cbval2 = dataIndex;
            int cbval3 = direction;

            double callback_ret = qcpselectiondecoratorbracket_gettangentangle_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPSelectionDecoratorBracket::getTangentAngle(interface1d, dataIndex, direction);
        }
    }

    // Virtual method for C ABI access and custom callback
    QPointF getPixelCoordinates(const QCPPlottableInterface1D* interface1d, int dataIndex) const {
        if (qcpselectiondecoratorbracket_getpixelcoordinates_isbase) {
            qcpselectiondecoratorbracket_getpixelcoordinates_isbase = false;
            return QCPSelectionDecoratorBracket::getPixelCoordinates(interface1d, dataIndex);
        } else if (qcpselectiondecoratorbracket_getpixelcoordinates_callback != nullptr) {
            QCPPlottableInterface1D* cbval1 = (QCPPlottableInterface1D*)interface1d;
            int cbval2 = dataIndex;

            QPointF* callback_ret = qcpselectiondecoratorbracket_getpixelcoordinates_callback(this, cbval1, cbval2);
            return *callback_ret;
        } else {
            return QCPSelectionDecoratorBracket::getPixelCoordinates(interface1d, dataIndex);
        }
    }

    // Friend functions
    friend bool QCPSelectionDecoratorBracket_RegisterWithPlottable(QCPSelectionDecoratorBracket* self, QCPAbstractPlottable* plottable);
    friend bool QCPSelectionDecoratorBracket_QBaseRegisterWithPlottable(QCPSelectionDecoratorBracket* self, QCPAbstractPlottable* plottable);
    friend double QCPSelectionDecoratorBracket_GetTangentAngle(const QCPSelectionDecoratorBracket* self, const QCPPlottableInterface1D* interface1d, int dataIndex, int direction);
    friend double QCPSelectionDecoratorBracket_QBaseGetTangentAngle(const QCPSelectionDecoratorBracket* self, const QCPPlottableInterface1D* interface1d, int dataIndex, int direction);
    friend QPointF* QCPSelectionDecoratorBracket_GetPixelCoordinates(const QCPSelectionDecoratorBracket* self, const QCPPlottableInterface1D* interface1d, int dataIndex);
    friend QPointF* QCPSelectionDecoratorBracket_QBaseGetPixelCoordinates(const QCPSelectionDecoratorBracket* self, const QCPPlottableInterface1D* interface1d, int dataIndex);
};

// This class is a subclass of QCPAxisRect so that we can call protected methods
class VirtualQCPAxisRect final : public QCPAxisRect {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPAxisRect = true;

    // Virtual class public types (including callbacks)
    using QCPAxisRect_Metacall_Callback = int (*)(QCPAxisRect*, int, int, void**);
    using QCPAxisRect_Update_Callback = void (*)(QCPAxisRect*, int);
    using QCPAxisRect_Elements_Callback = QCPLayoutElement** (*)(const QCPAxisRect*, bool);
    using QCPAxisRect_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPAxisRect*, QCPPainter*);
    using QCPAxisRect_Draw_Callback = void (*)(QCPAxisRect*, QCPPainter*);
    using QCPAxisRect_CalculateAutoMargin_Callback = int (*)(QCPAxisRect*, int);
    using QCPAxisRect_LayoutChanged_Callback = void (*)();
    using QCPAxisRect_MousePressEvent_Callback = void (*)(QCPAxisRect*, QMouseEvent*, QVariant*);
    using QCPAxisRect_MouseMoveEvent_Callback = void (*)(QCPAxisRect*, QMouseEvent*, QPointF*);
    using QCPAxisRect_MouseReleaseEvent_Callback = void (*)(QCPAxisRect*, QMouseEvent*, QPointF*);
    using QCPAxisRect_WheelEvent_Callback = void (*)(QCPAxisRect*, QWheelEvent*);
    using QCPAxisRect_MinimumOuterSizeHint_Callback = QSize* (*)();
    using QCPAxisRect_MaximumOuterSizeHint_Callback = QSize* (*)();
    using QCPAxisRect_SelectTest_Callback = double (*)(const QCPAxisRect*, QPointF*, bool, QVariant*);
    using QCPAxisRect_ParentPlotInitialized_Callback = void (*)(QCPAxisRect*, QCustomPlot*);
    using QCPAxisRect_SelectionCategory_Callback = int (*)();
    using QCPAxisRect_ClipRect_Callback = QRect* (*)();
    using QCPAxisRect_SelectEvent_Callback = void (*)(QCPAxisRect*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPAxisRect_DeselectEvent_Callback = void (*)(QCPAxisRect*, bool*);
    using QCPAxisRect_MouseDoubleClickEvent_Callback = void (*)(QCPAxisRect*, QMouseEvent*, QVariant*);
    using QCPAxisRect_Event_Callback = bool (*)(QCPAxisRect*, QEvent*);
    using QCPAxisRect_EventFilter_Callback = bool (*)(QCPAxisRect*, QObject*, QEvent*);
    using QCPAxisRect_TimerEvent_Callback = void (*)(QCPAxisRect*, QTimerEvent*);
    using QCPAxisRect_ChildEvent_Callback = void (*)(QCPAxisRect*, QChildEvent*);
    using QCPAxisRect_CustomEvent_Callback = void (*)(QCPAxisRect*, QEvent*);
    using QCPAxisRect_ConnectNotify_Callback = void (*)(QCPAxisRect*, QMetaMethod*);
    using QCPAxisRect_DisconnectNotify_Callback = void (*)(QCPAxisRect*, QMetaMethod*);
    using QCPAxisRect_DrawBackground_Callback = void (*)(QCPAxisRect*, QCPPainter*);
    using QCPAxisRect_UpdateAxesOffset_Callback = void (*)(QCPAxisRect*, int);
    using QCPAxisRect_InitializeParentPlot_Callback = void (*)(QCPAxisRect*, QCustomPlot*);
    using QCPAxisRect_SetParentLayerable_Callback = void (*)(QCPAxisRect*, QCPLayerable*);
    using QCPAxisRect_MoveToLayer_Callback = bool (*)(QCPAxisRect*, QCPLayer*, bool);
    using QCPAxisRect_ApplyAntialiasingHint_Callback = void (*)(const QCPAxisRect*, QCPPainter*, bool, int);
    using QCPAxisRect_Sender_Callback = QObject* (*)();
    using QCPAxisRect_SenderSignalIndex_Callback = int (*)();
    using QCPAxisRect_Receivers_Callback = int (*)(const QCPAxisRect*, const char*);
    using QCPAxisRect_IsSignalConnected_Callback = bool (*)(const QCPAxisRect*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPAxisRect_Metacall_Callback qcpaxisrect_metacall_callback = nullptr;
    QCPAxisRect_Update_Callback qcpaxisrect_update_callback = nullptr;
    QCPAxisRect_Elements_Callback qcpaxisrect_elements_callback = nullptr;
    QCPAxisRect_ApplyDefaultAntialiasingHint_Callback qcpaxisrect_applydefaultantialiasinghint_callback = nullptr;
    QCPAxisRect_Draw_Callback qcpaxisrect_draw_callback = nullptr;
    QCPAxisRect_CalculateAutoMargin_Callback qcpaxisrect_calculateautomargin_callback = nullptr;
    QCPAxisRect_LayoutChanged_Callback qcpaxisrect_layoutchanged_callback = nullptr;
    QCPAxisRect_MousePressEvent_Callback qcpaxisrect_mousepressevent_callback = nullptr;
    QCPAxisRect_MouseMoveEvent_Callback qcpaxisrect_mousemoveevent_callback = nullptr;
    QCPAxisRect_MouseReleaseEvent_Callback qcpaxisrect_mousereleaseevent_callback = nullptr;
    QCPAxisRect_WheelEvent_Callback qcpaxisrect_wheelevent_callback = nullptr;
    QCPAxisRect_MinimumOuterSizeHint_Callback qcpaxisrect_minimumoutersizehint_callback = nullptr;
    QCPAxisRect_MaximumOuterSizeHint_Callback qcpaxisrect_maximumoutersizehint_callback = nullptr;
    QCPAxisRect_SelectTest_Callback qcpaxisrect_selecttest_callback = nullptr;
    QCPAxisRect_ParentPlotInitialized_Callback qcpaxisrect_parentplotinitialized_callback = nullptr;
    QCPAxisRect_SelectionCategory_Callback qcpaxisrect_selectioncategory_callback = nullptr;
    QCPAxisRect_ClipRect_Callback qcpaxisrect_cliprect_callback = nullptr;
    QCPAxisRect_SelectEvent_Callback qcpaxisrect_selectevent_callback = nullptr;
    QCPAxisRect_DeselectEvent_Callback qcpaxisrect_deselectevent_callback = nullptr;
    QCPAxisRect_MouseDoubleClickEvent_Callback qcpaxisrect_mousedoubleclickevent_callback = nullptr;
    QCPAxisRect_Event_Callback qcpaxisrect_event_callback = nullptr;
    QCPAxisRect_EventFilter_Callback qcpaxisrect_eventfilter_callback = nullptr;
    QCPAxisRect_TimerEvent_Callback qcpaxisrect_timerevent_callback = nullptr;
    QCPAxisRect_ChildEvent_Callback qcpaxisrect_childevent_callback = nullptr;
    QCPAxisRect_CustomEvent_Callback qcpaxisrect_customevent_callback = nullptr;
    QCPAxisRect_ConnectNotify_Callback qcpaxisrect_connectnotify_callback = nullptr;
    QCPAxisRect_DisconnectNotify_Callback qcpaxisrect_disconnectnotify_callback = nullptr;
    QCPAxisRect_DrawBackground_Callback qcpaxisrect_drawbackground_callback = nullptr;
    QCPAxisRect_UpdateAxesOffset_Callback qcpaxisrect_updateaxesoffset_callback = nullptr;
    QCPAxisRect_InitializeParentPlot_Callback qcpaxisrect_initializeparentplot_callback = nullptr;
    QCPAxisRect_SetParentLayerable_Callback qcpaxisrect_setparentlayerable_callback = nullptr;
    QCPAxisRect_MoveToLayer_Callback qcpaxisrect_movetolayer_callback = nullptr;
    QCPAxisRect_ApplyAntialiasingHint_Callback qcpaxisrect_applyantialiasinghint_callback = nullptr;
    QCPAxisRect_Sender_Callback qcpaxisrect_sender_callback = nullptr;
    QCPAxisRect_SenderSignalIndex_Callback qcpaxisrect_sendersignalindex_callback = nullptr;
    QCPAxisRect_Receivers_Callback qcpaxisrect_receivers_callback = nullptr;
    QCPAxisRect_IsSignalConnected_Callback qcpaxisrect_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpaxisrect_metacall_isbase = false;
    mutable bool qcpaxisrect_update_isbase = false;
    mutable bool qcpaxisrect_elements_isbase = false;
    mutable bool qcpaxisrect_applydefaultantialiasinghint_isbase = false;
    mutable bool qcpaxisrect_draw_isbase = false;
    mutable bool qcpaxisrect_calculateautomargin_isbase = false;
    mutable bool qcpaxisrect_layoutchanged_isbase = false;
    mutable bool qcpaxisrect_mousepressevent_isbase = false;
    mutable bool qcpaxisrect_mousemoveevent_isbase = false;
    mutable bool qcpaxisrect_mousereleaseevent_isbase = false;
    mutable bool qcpaxisrect_wheelevent_isbase = false;
    mutable bool qcpaxisrect_minimumoutersizehint_isbase = false;
    mutable bool qcpaxisrect_maximumoutersizehint_isbase = false;
    mutable bool qcpaxisrect_selecttest_isbase = false;
    mutable bool qcpaxisrect_parentplotinitialized_isbase = false;
    mutable bool qcpaxisrect_selectioncategory_isbase = false;
    mutable bool qcpaxisrect_cliprect_isbase = false;
    mutable bool qcpaxisrect_selectevent_isbase = false;
    mutable bool qcpaxisrect_deselectevent_isbase = false;
    mutable bool qcpaxisrect_mousedoubleclickevent_isbase = false;
    mutable bool qcpaxisrect_event_isbase = false;
    mutable bool qcpaxisrect_eventfilter_isbase = false;
    mutable bool qcpaxisrect_timerevent_isbase = false;
    mutable bool qcpaxisrect_childevent_isbase = false;
    mutable bool qcpaxisrect_customevent_isbase = false;
    mutable bool qcpaxisrect_connectnotify_isbase = false;
    mutable bool qcpaxisrect_disconnectnotify_isbase = false;
    mutable bool qcpaxisrect_drawbackground_isbase = false;
    mutable bool qcpaxisrect_updateaxesoffset_isbase = false;
    mutable bool qcpaxisrect_initializeparentplot_isbase = false;
    mutable bool qcpaxisrect_setparentlayerable_isbase = false;
    mutable bool qcpaxisrect_movetolayer_isbase = false;
    mutable bool qcpaxisrect_applyantialiasinghint_isbase = false;
    mutable bool qcpaxisrect_sender_isbase = false;
    mutable bool qcpaxisrect_sendersignalindex_isbase = false;
    mutable bool qcpaxisrect_receivers_isbase = false;
    mutable bool qcpaxisrect_issignalconnected_isbase = false;

  public:
    VirtualQCPAxisRect(QCustomPlot* parentPlot) : QCPAxisRect(parentPlot) {};
    VirtualQCPAxisRect(QCustomPlot* parentPlot, bool setupDefaultAxes) : QCPAxisRect(parentPlot, setupDefaultAxes) {};

    ~VirtualQCPAxisRect() {
        qcpaxisrect_metacall_callback = nullptr;
        qcpaxisrect_update_callback = nullptr;
        qcpaxisrect_elements_callback = nullptr;
        qcpaxisrect_applydefaultantialiasinghint_callback = nullptr;
        qcpaxisrect_draw_callback = nullptr;
        qcpaxisrect_calculateautomargin_callback = nullptr;
        qcpaxisrect_layoutchanged_callback = nullptr;
        qcpaxisrect_mousepressevent_callback = nullptr;
        qcpaxisrect_mousemoveevent_callback = nullptr;
        qcpaxisrect_mousereleaseevent_callback = nullptr;
        qcpaxisrect_wheelevent_callback = nullptr;
        qcpaxisrect_minimumoutersizehint_callback = nullptr;
        qcpaxisrect_maximumoutersizehint_callback = nullptr;
        qcpaxisrect_selecttest_callback = nullptr;
        qcpaxisrect_parentplotinitialized_callback = nullptr;
        qcpaxisrect_selectioncategory_callback = nullptr;
        qcpaxisrect_cliprect_callback = nullptr;
        qcpaxisrect_selectevent_callback = nullptr;
        qcpaxisrect_deselectevent_callback = nullptr;
        qcpaxisrect_mousedoubleclickevent_callback = nullptr;
        qcpaxisrect_event_callback = nullptr;
        qcpaxisrect_eventfilter_callback = nullptr;
        qcpaxisrect_timerevent_callback = nullptr;
        qcpaxisrect_childevent_callback = nullptr;
        qcpaxisrect_customevent_callback = nullptr;
        qcpaxisrect_connectnotify_callback = nullptr;
        qcpaxisrect_disconnectnotify_callback = nullptr;
        qcpaxisrect_drawbackground_callback = nullptr;
        qcpaxisrect_updateaxesoffset_callback = nullptr;
        qcpaxisrect_initializeparentplot_callback = nullptr;
        qcpaxisrect_setparentlayerable_callback = nullptr;
        qcpaxisrect_movetolayer_callback = nullptr;
        qcpaxisrect_applyantialiasinghint_callback = nullptr;
        qcpaxisrect_sender_callback = nullptr;
        qcpaxisrect_sendersignalindex_callback = nullptr;
        qcpaxisrect_receivers_callback = nullptr;
        qcpaxisrect_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPAxisRect_Metacall_Callback(QCPAxisRect_Metacall_Callback cb) { qcpaxisrect_metacall_callback = cb; }
    inline void setQCPAxisRect_Update_Callback(QCPAxisRect_Update_Callback cb) { qcpaxisrect_update_callback = cb; }
    inline void setQCPAxisRect_Elements_Callback(QCPAxisRect_Elements_Callback cb) { qcpaxisrect_elements_callback = cb; }
    inline void setQCPAxisRect_ApplyDefaultAntialiasingHint_Callback(QCPAxisRect_ApplyDefaultAntialiasingHint_Callback cb) { qcpaxisrect_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPAxisRect_Draw_Callback(QCPAxisRect_Draw_Callback cb) { qcpaxisrect_draw_callback = cb; }
    inline void setQCPAxisRect_CalculateAutoMargin_Callback(QCPAxisRect_CalculateAutoMargin_Callback cb) { qcpaxisrect_calculateautomargin_callback = cb; }
    inline void setQCPAxisRect_LayoutChanged_Callback(QCPAxisRect_LayoutChanged_Callback cb) { qcpaxisrect_layoutchanged_callback = cb; }
    inline void setQCPAxisRect_MousePressEvent_Callback(QCPAxisRect_MousePressEvent_Callback cb) { qcpaxisrect_mousepressevent_callback = cb; }
    inline void setQCPAxisRect_MouseMoveEvent_Callback(QCPAxisRect_MouseMoveEvent_Callback cb) { qcpaxisrect_mousemoveevent_callback = cb; }
    inline void setQCPAxisRect_MouseReleaseEvent_Callback(QCPAxisRect_MouseReleaseEvent_Callback cb) { qcpaxisrect_mousereleaseevent_callback = cb; }
    inline void setQCPAxisRect_WheelEvent_Callback(QCPAxisRect_WheelEvent_Callback cb) { qcpaxisrect_wheelevent_callback = cb; }
    inline void setQCPAxisRect_MinimumOuterSizeHint_Callback(QCPAxisRect_MinimumOuterSizeHint_Callback cb) { qcpaxisrect_minimumoutersizehint_callback = cb; }
    inline void setQCPAxisRect_MaximumOuterSizeHint_Callback(QCPAxisRect_MaximumOuterSizeHint_Callback cb) { qcpaxisrect_maximumoutersizehint_callback = cb; }
    inline void setQCPAxisRect_SelectTest_Callback(QCPAxisRect_SelectTest_Callback cb) { qcpaxisrect_selecttest_callback = cb; }
    inline void setQCPAxisRect_ParentPlotInitialized_Callback(QCPAxisRect_ParentPlotInitialized_Callback cb) { qcpaxisrect_parentplotinitialized_callback = cb; }
    inline void setQCPAxisRect_SelectionCategory_Callback(QCPAxisRect_SelectionCategory_Callback cb) { qcpaxisrect_selectioncategory_callback = cb; }
    inline void setQCPAxisRect_ClipRect_Callback(QCPAxisRect_ClipRect_Callback cb) { qcpaxisrect_cliprect_callback = cb; }
    inline void setQCPAxisRect_SelectEvent_Callback(QCPAxisRect_SelectEvent_Callback cb) { qcpaxisrect_selectevent_callback = cb; }
    inline void setQCPAxisRect_DeselectEvent_Callback(QCPAxisRect_DeselectEvent_Callback cb) { qcpaxisrect_deselectevent_callback = cb; }
    inline void setQCPAxisRect_MouseDoubleClickEvent_Callback(QCPAxisRect_MouseDoubleClickEvent_Callback cb) { qcpaxisrect_mousedoubleclickevent_callback = cb; }
    inline void setQCPAxisRect_Event_Callback(QCPAxisRect_Event_Callback cb) { qcpaxisrect_event_callback = cb; }
    inline void setQCPAxisRect_EventFilter_Callback(QCPAxisRect_EventFilter_Callback cb) { qcpaxisrect_eventfilter_callback = cb; }
    inline void setQCPAxisRect_TimerEvent_Callback(QCPAxisRect_TimerEvent_Callback cb) { qcpaxisrect_timerevent_callback = cb; }
    inline void setQCPAxisRect_ChildEvent_Callback(QCPAxisRect_ChildEvent_Callback cb) { qcpaxisrect_childevent_callback = cb; }
    inline void setQCPAxisRect_CustomEvent_Callback(QCPAxisRect_CustomEvent_Callback cb) { qcpaxisrect_customevent_callback = cb; }
    inline void setQCPAxisRect_ConnectNotify_Callback(QCPAxisRect_ConnectNotify_Callback cb) { qcpaxisrect_connectnotify_callback = cb; }
    inline void setQCPAxisRect_DisconnectNotify_Callback(QCPAxisRect_DisconnectNotify_Callback cb) { qcpaxisrect_disconnectnotify_callback = cb; }
    inline void setQCPAxisRect_DrawBackground_Callback(QCPAxisRect_DrawBackground_Callback cb) { qcpaxisrect_drawbackground_callback = cb; }
    inline void setQCPAxisRect_UpdateAxesOffset_Callback(QCPAxisRect_UpdateAxesOffset_Callback cb) { qcpaxisrect_updateaxesoffset_callback = cb; }
    inline void setQCPAxisRect_InitializeParentPlot_Callback(QCPAxisRect_InitializeParentPlot_Callback cb) { qcpaxisrect_initializeparentplot_callback = cb; }
    inline void setQCPAxisRect_SetParentLayerable_Callback(QCPAxisRect_SetParentLayerable_Callback cb) { qcpaxisrect_setparentlayerable_callback = cb; }
    inline void setQCPAxisRect_MoveToLayer_Callback(QCPAxisRect_MoveToLayer_Callback cb) { qcpaxisrect_movetolayer_callback = cb; }
    inline void setQCPAxisRect_ApplyAntialiasingHint_Callback(QCPAxisRect_ApplyAntialiasingHint_Callback cb) { qcpaxisrect_applyantialiasinghint_callback = cb; }
    inline void setQCPAxisRect_Sender_Callback(QCPAxisRect_Sender_Callback cb) { qcpaxisrect_sender_callback = cb; }
    inline void setQCPAxisRect_SenderSignalIndex_Callback(QCPAxisRect_SenderSignalIndex_Callback cb) { qcpaxisrect_sendersignalindex_callback = cb; }
    inline void setQCPAxisRect_Receivers_Callback(QCPAxisRect_Receivers_Callback cb) { qcpaxisrect_receivers_callback = cb; }
    inline void setQCPAxisRect_IsSignalConnected_Callback(QCPAxisRect_IsSignalConnected_Callback cb) { qcpaxisrect_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPAxisRect_Metacall_IsBase(bool value) const { qcpaxisrect_metacall_isbase = value; }
    inline void setQCPAxisRect_Update_IsBase(bool value) const { qcpaxisrect_update_isbase = value; }
    inline void setQCPAxisRect_Elements_IsBase(bool value) const { qcpaxisrect_elements_isbase = value; }
    inline void setQCPAxisRect_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcpaxisrect_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPAxisRect_Draw_IsBase(bool value) const { qcpaxisrect_draw_isbase = value; }
    inline void setQCPAxisRect_CalculateAutoMargin_IsBase(bool value) const { qcpaxisrect_calculateautomargin_isbase = value; }
    inline void setQCPAxisRect_LayoutChanged_IsBase(bool value) const { qcpaxisrect_layoutchanged_isbase = value; }
    inline void setQCPAxisRect_MousePressEvent_IsBase(bool value) const { qcpaxisrect_mousepressevent_isbase = value; }
    inline void setQCPAxisRect_MouseMoveEvent_IsBase(bool value) const { qcpaxisrect_mousemoveevent_isbase = value; }
    inline void setQCPAxisRect_MouseReleaseEvent_IsBase(bool value) const { qcpaxisrect_mousereleaseevent_isbase = value; }
    inline void setQCPAxisRect_WheelEvent_IsBase(bool value) const { qcpaxisrect_wheelevent_isbase = value; }
    inline void setQCPAxisRect_MinimumOuterSizeHint_IsBase(bool value) const { qcpaxisrect_minimumoutersizehint_isbase = value; }
    inline void setQCPAxisRect_MaximumOuterSizeHint_IsBase(bool value) const { qcpaxisrect_maximumoutersizehint_isbase = value; }
    inline void setQCPAxisRect_SelectTest_IsBase(bool value) const { qcpaxisrect_selecttest_isbase = value; }
    inline void setQCPAxisRect_ParentPlotInitialized_IsBase(bool value) const { qcpaxisrect_parentplotinitialized_isbase = value; }
    inline void setQCPAxisRect_SelectionCategory_IsBase(bool value) const { qcpaxisrect_selectioncategory_isbase = value; }
    inline void setQCPAxisRect_ClipRect_IsBase(bool value) const { qcpaxisrect_cliprect_isbase = value; }
    inline void setQCPAxisRect_SelectEvent_IsBase(bool value) const { qcpaxisrect_selectevent_isbase = value; }
    inline void setQCPAxisRect_DeselectEvent_IsBase(bool value) const { qcpaxisrect_deselectevent_isbase = value; }
    inline void setQCPAxisRect_MouseDoubleClickEvent_IsBase(bool value) const { qcpaxisrect_mousedoubleclickevent_isbase = value; }
    inline void setQCPAxisRect_Event_IsBase(bool value) const { qcpaxisrect_event_isbase = value; }
    inline void setQCPAxisRect_EventFilter_IsBase(bool value) const { qcpaxisrect_eventfilter_isbase = value; }
    inline void setQCPAxisRect_TimerEvent_IsBase(bool value) const { qcpaxisrect_timerevent_isbase = value; }
    inline void setQCPAxisRect_ChildEvent_IsBase(bool value) const { qcpaxisrect_childevent_isbase = value; }
    inline void setQCPAxisRect_CustomEvent_IsBase(bool value) const { qcpaxisrect_customevent_isbase = value; }
    inline void setQCPAxisRect_ConnectNotify_IsBase(bool value) const { qcpaxisrect_connectnotify_isbase = value; }
    inline void setQCPAxisRect_DisconnectNotify_IsBase(bool value) const { qcpaxisrect_disconnectnotify_isbase = value; }
    inline void setQCPAxisRect_DrawBackground_IsBase(bool value) const { qcpaxisrect_drawbackground_isbase = value; }
    inline void setQCPAxisRect_UpdateAxesOffset_IsBase(bool value) const { qcpaxisrect_updateaxesoffset_isbase = value; }
    inline void setQCPAxisRect_InitializeParentPlot_IsBase(bool value) const { qcpaxisrect_initializeparentplot_isbase = value; }
    inline void setQCPAxisRect_SetParentLayerable_IsBase(bool value) const { qcpaxisrect_setparentlayerable_isbase = value; }
    inline void setQCPAxisRect_MoveToLayer_IsBase(bool value) const { qcpaxisrect_movetolayer_isbase = value; }
    inline void setQCPAxisRect_ApplyAntialiasingHint_IsBase(bool value) const { qcpaxisrect_applyantialiasinghint_isbase = value; }
    inline void setQCPAxisRect_Sender_IsBase(bool value) const { qcpaxisrect_sender_isbase = value; }
    inline void setQCPAxisRect_SenderSignalIndex_IsBase(bool value) const { qcpaxisrect_sendersignalindex_isbase = value; }
    inline void setQCPAxisRect_Receivers_IsBase(bool value) const { qcpaxisrect_receivers_isbase = value; }
    inline void setQCPAxisRect_IsSignalConnected_IsBase(bool value) const { qcpaxisrect_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpaxisrect_metacall_isbase) {
            qcpaxisrect_metacall_isbase = false;
            return QCPAxisRect::qt_metacall(param1, param2, param3);
        } else if (qcpaxisrect_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpaxisrect_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPAxisRect::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void update(QCPLayoutElement::UpdatePhase phase) override {
        if (qcpaxisrect_update_isbase) {
            qcpaxisrect_update_isbase = false;
            QCPAxisRect::update(phase);
        } else if (qcpaxisrect_update_callback != nullptr) {
            int cbval1 = static_cast<int>(phase);

            qcpaxisrect_update_callback(this, cbval1);
        } else {
            QCPAxisRect::update(phase);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QList<QCPLayoutElement*> elements(bool recursive) const override {
        if (qcpaxisrect_elements_isbase) {
            qcpaxisrect_elements_isbase = false;
            return QCPAxisRect::elements(recursive);
        } else if (qcpaxisrect_elements_callback != nullptr) {
            bool cbval1 = recursive;

            QCPLayoutElement** callback_ret = qcpaxisrect_elements_callback(this, cbval1);
            QList<QCPLayoutElement*> callback_ret_QList;
            // Iterate until null pointer sentinel
            for (QCPLayoutElement** ptridx = callback_ret; *ptridx != nullptr; ptridx++) {
                callback_ret_QList.push_back(*ptridx);
            }
            free(callback_ret);
            return callback_ret_QList;
        } else {
            return QCPAxisRect::elements(recursive);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcpaxisrect_applydefaultantialiasinghint_isbase) {
            qcpaxisrect_applydefaultantialiasinghint_isbase = false;
            QCPAxisRect::applyDefaultAntialiasingHint(painter);
        } else if (qcpaxisrect_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpaxisrect_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPAxisRect::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcpaxisrect_draw_isbase) {
            qcpaxisrect_draw_isbase = false;
            QCPAxisRect::draw(painter);
        } else if (qcpaxisrect_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpaxisrect_draw_callback(this, cbval1);
        } else {
            QCPAxisRect::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int calculateAutoMargin(QCP::MarginSide side) override {
        if (qcpaxisrect_calculateautomargin_isbase) {
            qcpaxisrect_calculateautomargin_isbase = false;
            return QCPAxisRect::calculateAutoMargin(side);
        } else if (qcpaxisrect_calculateautomargin_callback != nullptr) {
            int cbval1 = static_cast<int>(side);

            int callback_ret = qcpaxisrect_calculateautomargin_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPAxisRect::calculateAutoMargin(side);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void layoutChanged() override {
        if (qcpaxisrect_layoutchanged_isbase) {
            qcpaxisrect_layoutchanged_isbase = false;
            QCPAxisRect::layoutChanged();
        } else if (qcpaxisrect_layoutchanged_callback != nullptr) {
            qcpaxisrect_layoutchanged_callback();
        } else {
            QCPAxisRect::layoutChanged();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpaxisrect_mousepressevent_isbase) {
            qcpaxisrect_mousepressevent_isbase = false;
            QCPAxisRect::mousePressEvent(event, details);
        } else if (qcpaxisrect_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpaxisrect_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPAxisRect::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpaxisrect_mousemoveevent_isbase) {
            qcpaxisrect_mousemoveevent_isbase = false;
            QCPAxisRect::mouseMoveEvent(event, startPos);
        } else if (qcpaxisrect_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpaxisrect_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPAxisRect::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpaxisrect_mousereleaseevent_isbase) {
            qcpaxisrect_mousereleaseevent_isbase = false;
            QCPAxisRect::mouseReleaseEvent(event, startPos);
        } else if (qcpaxisrect_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpaxisrect_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPAxisRect::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcpaxisrect_wheelevent_isbase) {
            qcpaxisrect_wheelevent_isbase = false;
            QCPAxisRect::wheelEvent(event);
        } else if (qcpaxisrect_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcpaxisrect_wheelevent_callback(this, cbval1);
        } else {
            QCPAxisRect::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize minimumOuterSizeHint() const override {
        if (qcpaxisrect_minimumoutersizehint_isbase) {
            qcpaxisrect_minimumoutersizehint_isbase = false;
            return QCPAxisRect::minimumOuterSizeHint();
        } else if (qcpaxisrect_minimumoutersizehint_callback != nullptr) {
            QSize* callback_ret = qcpaxisrect_minimumoutersizehint_callback();
            return *callback_ret;
        } else {
            return QCPAxisRect::minimumOuterSizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize maximumOuterSizeHint() const override {
        if (qcpaxisrect_maximumoutersizehint_isbase) {
            qcpaxisrect_maximumoutersizehint_isbase = false;
            return QCPAxisRect::maximumOuterSizeHint();
        } else if (qcpaxisrect_maximumoutersizehint_callback != nullptr) {
            QSize* callback_ret = qcpaxisrect_maximumoutersizehint_callback();
            return *callback_ret;
        } else {
            return QCPAxisRect::maximumOuterSizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcpaxisrect_selecttest_isbase) {
            qcpaxisrect_selecttest_isbase = false;
            return QCPAxisRect::selectTest(pos, onlySelectable, details);
        } else if (qcpaxisrect_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcpaxisrect_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAxisRect::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcpaxisrect_parentplotinitialized_isbase) {
            qcpaxisrect_parentplotinitialized_isbase = false;
            QCPAxisRect::parentPlotInitialized(parentPlot);
        } else if (qcpaxisrect_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpaxisrect_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPAxisRect::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcpaxisrect_selectioncategory_isbase) {
            qcpaxisrect_selectioncategory_isbase = false;
            return QCPAxisRect::selectionCategory();
        } else if (qcpaxisrect_selectioncategory_callback != nullptr) {
            int callback_ret = qcpaxisrect_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPAxisRect::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcpaxisrect_cliprect_isbase) {
            qcpaxisrect_cliprect_isbase = false;
            return QCPAxisRect::clipRect();
        } else if (qcpaxisrect_cliprect_callback != nullptr) {
            QRect* callback_ret = qcpaxisrect_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPAxisRect::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcpaxisrect_selectevent_isbase) {
            qcpaxisrect_selectevent_isbase = false;
            QCPAxisRect::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcpaxisrect_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcpaxisrect_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPAxisRect::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcpaxisrect_deselectevent_isbase) {
            qcpaxisrect_deselectevent_isbase = false;
            QCPAxisRect::deselectEvent(selectionStateChanged);
        } else if (qcpaxisrect_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcpaxisrect_deselectevent_callback(this, cbval1);
        } else {
            QCPAxisRect::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpaxisrect_mousedoubleclickevent_isbase) {
            qcpaxisrect_mousedoubleclickevent_isbase = false;
            QCPAxisRect::mouseDoubleClickEvent(event, details);
        } else if (qcpaxisrect_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpaxisrect_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPAxisRect::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpaxisrect_event_isbase) {
            qcpaxisrect_event_isbase = false;
            return QCPAxisRect::event(event);
        } else if (qcpaxisrect_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpaxisrect_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPAxisRect::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpaxisrect_eventfilter_isbase) {
            qcpaxisrect_eventfilter_isbase = false;
            return QCPAxisRect::eventFilter(watched, event);
        } else if (qcpaxisrect_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpaxisrect_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPAxisRect::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpaxisrect_timerevent_isbase) {
            qcpaxisrect_timerevent_isbase = false;
            QCPAxisRect::timerEvent(event);
        } else if (qcpaxisrect_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpaxisrect_timerevent_callback(this, cbval1);
        } else {
            QCPAxisRect::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpaxisrect_childevent_isbase) {
            qcpaxisrect_childevent_isbase = false;
            QCPAxisRect::childEvent(event);
        } else if (qcpaxisrect_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpaxisrect_childevent_callback(this, cbval1);
        } else {
            QCPAxisRect::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpaxisrect_customevent_isbase) {
            qcpaxisrect_customevent_isbase = false;
            QCPAxisRect::customEvent(event);
        } else if (qcpaxisrect_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpaxisrect_customevent_callback(this, cbval1);
        } else {
            QCPAxisRect::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpaxisrect_connectnotify_isbase) {
            qcpaxisrect_connectnotify_isbase = false;
            QCPAxisRect::connectNotify(signal);
        } else if (qcpaxisrect_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpaxisrect_connectnotify_callback(this, cbval1);
        } else {
            QCPAxisRect::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpaxisrect_disconnectnotify_isbase) {
            qcpaxisrect_disconnectnotify_isbase = false;
            QCPAxisRect::disconnectNotify(signal);
        } else if (qcpaxisrect_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpaxisrect_disconnectnotify_callback(this, cbval1);
        } else {
            QCPAxisRect::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    void drawBackground(QCPPainter* painter) {
        if (qcpaxisrect_drawbackground_isbase) {
            qcpaxisrect_drawbackground_isbase = false;
            QCPAxisRect::drawBackground(painter);
        } else if (qcpaxisrect_drawbackground_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpaxisrect_drawbackground_callback(this, cbval1);
        } else {
            QCPAxisRect::drawBackground(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    void updateAxesOffset(QCPAxis::AxisType typeVal) {
        if (qcpaxisrect_updateaxesoffset_isbase) {
            qcpaxisrect_updateaxesoffset_isbase = false;
            QCPAxisRect::updateAxesOffset(typeVal);
        } else if (qcpaxisrect_updateaxesoffset_callback != nullptr) {
            int cbval1 = static_cast<int>(typeVal);

            qcpaxisrect_updateaxesoffset_callback(this, cbval1);
        } else {
            QCPAxisRect::updateAxesOffset(typeVal);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcpaxisrect_initializeparentplot_isbase) {
            qcpaxisrect_initializeparentplot_isbase = false;
            QCPAxisRect::initializeParentPlot(parentPlot);
        } else if (qcpaxisrect_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpaxisrect_initializeparentplot_callback(this, cbval1);
        } else {
            QCPAxisRect::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcpaxisrect_setparentlayerable_isbase) {
            qcpaxisrect_setparentlayerable_isbase = false;
            QCPAxisRect::setParentLayerable(parentLayerable);
        } else if (qcpaxisrect_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcpaxisrect_setparentlayerable_callback(this, cbval1);
        } else {
            QCPAxisRect::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcpaxisrect_movetolayer_isbase) {
            qcpaxisrect_movetolayer_isbase = false;
            return QCPAxisRect::moveToLayer(layer, prepend);
        } else if (qcpaxisrect_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcpaxisrect_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPAxisRect::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcpaxisrect_applyantialiasinghint_isbase) {
            qcpaxisrect_applyantialiasinghint_isbase = false;
            QCPAxisRect::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcpaxisrect_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcpaxisrect_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPAxisRect::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpaxisrect_sender_isbase) {
            qcpaxisrect_sender_isbase = false;
            return QCPAxisRect::sender();
        } else if (qcpaxisrect_sender_callback != nullptr) {
            QObject* callback_ret = qcpaxisrect_sender_callback();
            return callback_ret;
        } else {
            return QCPAxisRect::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpaxisrect_sendersignalindex_isbase) {
            qcpaxisrect_sendersignalindex_isbase = false;
            return QCPAxisRect::senderSignalIndex();
        } else if (qcpaxisrect_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpaxisrect_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPAxisRect::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpaxisrect_receivers_isbase) {
            qcpaxisrect_receivers_isbase = false;
            return QCPAxisRect::receivers(signal);
        } else if (qcpaxisrect_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpaxisrect_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPAxisRect::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpaxisrect_issignalconnected_isbase) {
            qcpaxisrect_issignalconnected_isbase = false;
            return QCPAxisRect::isSignalConnected(signal);
        } else if (qcpaxisrect_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpaxisrect_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPAxisRect::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPAxisRect_ApplyDefaultAntialiasingHint(const QCPAxisRect* self, QCPPainter* painter);
    friend void QCPAxisRect_QBaseApplyDefaultAntialiasingHint(const QCPAxisRect* self, QCPPainter* painter);
    friend void QCPAxisRect_Draw(QCPAxisRect* self, QCPPainter* painter);
    friend void QCPAxisRect_QBaseDraw(QCPAxisRect* self, QCPPainter* painter);
    friend int QCPAxisRect_CalculateAutoMargin(QCPAxisRect* self, int side);
    friend int QCPAxisRect_QBaseCalculateAutoMargin(QCPAxisRect* self, int side);
    friend void QCPAxisRect_LayoutChanged(QCPAxisRect* self);
    friend void QCPAxisRect_QBaseLayoutChanged(QCPAxisRect* self);
    friend void QCPAxisRect_MousePressEvent(QCPAxisRect* self, QMouseEvent* event, const QVariant* details);
    friend void QCPAxisRect_QBaseMousePressEvent(QCPAxisRect* self, QMouseEvent* event, const QVariant* details);
    friend void QCPAxisRect_MouseMoveEvent(QCPAxisRect* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPAxisRect_QBaseMouseMoveEvent(QCPAxisRect* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPAxisRect_MouseReleaseEvent(QCPAxisRect* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPAxisRect_QBaseMouseReleaseEvent(QCPAxisRect* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPAxisRect_WheelEvent(QCPAxisRect* self, QWheelEvent* event);
    friend void QCPAxisRect_QBaseWheelEvent(QCPAxisRect* self, QWheelEvent* event);
    friend void QCPAxisRect_ParentPlotInitialized(QCPAxisRect* self, QCustomPlot* parentPlot);
    friend void QCPAxisRect_QBaseParentPlotInitialized(QCPAxisRect* self, QCustomPlot* parentPlot);
    friend int QCPAxisRect_SelectionCategory(const QCPAxisRect* self);
    friend int QCPAxisRect_QBaseSelectionCategory(const QCPAxisRect* self);
    friend QRect* QCPAxisRect_ClipRect(const QCPAxisRect* self);
    friend QRect* QCPAxisRect_QBaseClipRect(const QCPAxisRect* self);
    friend void QCPAxisRect_SelectEvent(QCPAxisRect* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPAxisRect_QBaseSelectEvent(QCPAxisRect* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPAxisRect_DeselectEvent(QCPAxisRect* self, bool* selectionStateChanged);
    friend void QCPAxisRect_QBaseDeselectEvent(QCPAxisRect* self, bool* selectionStateChanged);
    friend void QCPAxisRect_MouseDoubleClickEvent(QCPAxisRect* self, QMouseEvent* event, const QVariant* details);
    friend void QCPAxisRect_QBaseMouseDoubleClickEvent(QCPAxisRect* self, QMouseEvent* event, const QVariant* details);
    friend void QCPAxisRect_TimerEvent(QCPAxisRect* self, QTimerEvent* event);
    friend void QCPAxisRect_QBaseTimerEvent(QCPAxisRect* self, QTimerEvent* event);
    friend void QCPAxisRect_ChildEvent(QCPAxisRect* self, QChildEvent* event);
    friend void QCPAxisRect_QBaseChildEvent(QCPAxisRect* self, QChildEvent* event);
    friend void QCPAxisRect_CustomEvent(QCPAxisRect* self, QEvent* event);
    friend void QCPAxisRect_QBaseCustomEvent(QCPAxisRect* self, QEvent* event);
    friend void QCPAxisRect_ConnectNotify(QCPAxisRect* self, const QMetaMethod* signal);
    friend void QCPAxisRect_QBaseConnectNotify(QCPAxisRect* self, const QMetaMethod* signal);
    friend void QCPAxisRect_DisconnectNotify(QCPAxisRect* self, const QMetaMethod* signal);
    friend void QCPAxisRect_QBaseDisconnectNotify(QCPAxisRect* self, const QMetaMethod* signal);
    friend void QCPAxisRect_DrawBackground(QCPAxisRect* self, QCPPainter* painter);
    friend void QCPAxisRect_QBaseDrawBackground(QCPAxisRect* self, QCPPainter* painter);
    friend void QCPAxisRect_UpdateAxesOffset(QCPAxisRect* self, int typeVal);
    friend void QCPAxisRect_QBaseUpdateAxesOffset(QCPAxisRect* self, int typeVal);
    friend void QCPAxisRect_InitializeParentPlot(QCPAxisRect* self, QCustomPlot* parentPlot);
    friend void QCPAxisRect_QBaseInitializeParentPlot(QCPAxisRect* self, QCustomPlot* parentPlot);
    friend void QCPAxisRect_SetParentLayerable(QCPAxisRect* self, QCPLayerable* parentLayerable);
    friend void QCPAxisRect_QBaseSetParentLayerable(QCPAxisRect* self, QCPLayerable* parentLayerable);
    friend bool QCPAxisRect_MoveToLayer(QCPAxisRect* self, QCPLayer* layer, bool prepend);
    friend bool QCPAxisRect_QBaseMoveToLayer(QCPAxisRect* self, QCPLayer* layer, bool prepend);
    friend void QCPAxisRect_ApplyAntialiasingHint(const QCPAxisRect* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPAxisRect_QBaseApplyAntialiasingHint(const QCPAxisRect* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPAxisRect_Sender(const QCPAxisRect* self);
    friend QObject* QCPAxisRect_QBaseSender(const QCPAxisRect* self);
    friend int QCPAxisRect_SenderSignalIndex(const QCPAxisRect* self);
    friend int QCPAxisRect_QBaseSenderSignalIndex(const QCPAxisRect* self);
    friend int QCPAxisRect_Receivers(const QCPAxisRect* self, const char* signal);
    friend int QCPAxisRect_QBaseReceivers(const QCPAxisRect* self, const char* signal);
    friend bool QCPAxisRect_IsSignalConnected(const QCPAxisRect* self, const QMetaMethod* signal);
    friend bool QCPAxisRect_QBaseIsSignalConnected(const QCPAxisRect* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPAbstractLegendItem so that we can call protected methods
class VirtualQCPAbstractLegendItem : public QCPAbstractLegendItem {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPAbstractLegendItem = true;

    // Virtual class public types (including callbacks)
    using QCPAbstractLegendItem_Metacall_Callback = int (*)(QCPAbstractLegendItem*, int, int, void**);
    using QCPAbstractLegendItem_SelectTest_Callback = double (*)(const QCPAbstractLegendItem*, QPointF*, bool, QVariant*);
    using QCPAbstractLegendItem_SelectionCategory_Callback = int (*)();
    using QCPAbstractLegendItem_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPAbstractLegendItem*, QCPPainter*);
    using QCPAbstractLegendItem_ClipRect_Callback = QRect* (*)();
    using QCPAbstractLegendItem_Draw_Callback = void (*)(QCPAbstractLegendItem*, QCPPainter*);
    using QCPAbstractLegendItem_SelectEvent_Callback = void (*)(QCPAbstractLegendItem*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPAbstractLegendItem_DeselectEvent_Callback = void (*)(QCPAbstractLegendItem*, bool*);
    using QCPAbstractLegendItem_Update_Callback = void (*)(QCPAbstractLegendItem*, int);
    using QCPAbstractLegendItem_MinimumOuterSizeHint_Callback = QSize* (*)();
    using QCPAbstractLegendItem_MaximumOuterSizeHint_Callback = QSize* (*)();
    using QCPAbstractLegendItem_Elements_Callback = QCPLayoutElement** (*)(const QCPAbstractLegendItem*, bool);
    using QCPAbstractLegendItem_CalculateAutoMargin_Callback = int (*)(QCPAbstractLegendItem*, int);
    using QCPAbstractLegendItem_LayoutChanged_Callback = void (*)();
    using QCPAbstractLegendItem_ParentPlotInitialized_Callback = void (*)(QCPAbstractLegendItem*, QCustomPlot*);
    using QCPAbstractLegendItem_MousePressEvent_Callback = void (*)(QCPAbstractLegendItem*, QMouseEvent*, QVariant*);
    using QCPAbstractLegendItem_MouseMoveEvent_Callback = void (*)(QCPAbstractLegendItem*, QMouseEvent*, QPointF*);
    using QCPAbstractLegendItem_MouseReleaseEvent_Callback = void (*)(QCPAbstractLegendItem*, QMouseEvent*, QPointF*);
    using QCPAbstractLegendItem_MouseDoubleClickEvent_Callback = void (*)(QCPAbstractLegendItem*, QMouseEvent*, QVariant*);
    using QCPAbstractLegendItem_WheelEvent_Callback = void (*)(QCPAbstractLegendItem*, QWheelEvent*);
    using QCPAbstractLegendItem_Event_Callback = bool (*)(QCPAbstractLegendItem*, QEvent*);
    using QCPAbstractLegendItem_EventFilter_Callback = bool (*)(QCPAbstractLegendItem*, QObject*, QEvent*);
    using QCPAbstractLegendItem_TimerEvent_Callback = void (*)(QCPAbstractLegendItem*, QTimerEvent*);
    using QCPAbstractLegendItem_ChildEvent_Callback = void (*)(QCPAbstractLegendItem*, QChildEvent*);
    using QCPAbstractLegendItem_CustomEvent_Callback = void (*)(QCPAbstractLegendItem*, QEvent*);
    using QCPAbstractLegendItem_ConnectNotify_Callback = void (*)(QCPAbstractLegendItem*, QMetaMethod*);
    using QCPAbstractLegendItem_DisconnectNotify_Callback = void (*)(QCPAbstractLegendItem*, QMetaMethod*);
    using QCPAbstractLegendItem_InitializeParentPlot_Callback = void (*)(QCPAbstractLegendItem*, QCustomPlot*);
    using QCPAbstractLegendItem_SetParentLayerable_Callback = void (*)(QCPAbstractLegendItem*, QCPLayerable*);
    using QCPAbstractLegendItem_MoveToLayer_Callback = bool (*)(QCPAbstractLegendItem*, QCPLayer*, bool);
    using QCPAbstractLegendItem_ApplyAntialiasingHint_Callback = void (*)(const QCPAbstractLegendItem*, QCPPainter*, bool, int);
    using QCPAbstractLegendItem_Sender_Callback = QObject* (*)();
    using QCPAbstractLegendItem_SenderSignalIndex_Callback = int (*)();
    using QCPAbstractLegendItem_Receivers_Callback = int (*)(const QCPAbstractLegendItem*, const char*);
    using QCPAbstractLegendItem_IsSignalConnected_Callback = bool (*)(const QCPAbstractLegendItem*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPAbstractLegendItem_Metacall_Callback qcpabstractlegenditem_metacall_callback = nullptr;
    QCPAbstractLegendItem_SelectTest_Callback qcpabstractlegenditem_selecttest_callback = nullptr;
    QCPAbstractLegendItem_SelectionCategory_Callback qcpabstractlegenditem_selectioncategory_callback = nullptr;
    QCPAbstractLegendItem_ApplyDefaultAntialiasingHint_Callback qcpabstractlegenditem_applydefaultantialiasinghint_callback = nullptr;
    QCPAbstractLegendItem_ClipRect_Callback qcpabstractlegenditem_cliprect_callback = nullptr;
    QCPAbstractLegendItem_Draw_Callback qcpabstractlegenditem_draw_callback = nullptr;
    QCPAbstractLegendItem_SelectEvent_Callback qcpabstractlegenditem_selectevent_callback = nullptr;
    QCPAbstractLegendItem_DeselectEvent_Callback qcpabstractlegenditem_deselectevent_callback = nullptr;
    QCPAbstractLegendItem_Update_Callback qcpabstractlegenditem_update_callback = nullptr;
    QCPAbstractLegendItem_MinimumOuterSizeHint_Callback qcpabstractlegenditem_minimumoutersizehint_callback = nullptr;
    QCPAbstractLegendItem_MaximumOuterSizeHint_Callback qcpabstractlegenditem_maximumoutersizehint_callback = nullptr;
    QCPAbstractLegendItem_Elements_Callback qcpabstractlegenditem_elements_callback = nullptr;
    QCPAbstractLegendItem_CalculateAutoMargin_Callback qcpabstractlegenditem_calculateautomargin_callback = nullptr;
    QCPAbstractLegendItem_LayoutChanged_Callback qcpabstractlegenditem_layoutchanged_callback = nullptr;
    QCPAbstractLegendItem_ParentPlotInitialized_Callback qcpabstractlegenditem_parentplotinitialized_callback = nullptr;
    QCPAbstractLegendItem_MousePressEvent_Callback qcpabstractlegenditem_mousepressevent_callback = nullptr;
    QCPAbstractLegendItem_MouseMoveEvent_Callback qcpabstractlegenditem_mousemoveevent_callback = nullptr;
    QCPAbstractLegendItem_MouseReleaseEvent_Callback qcpabstractlegenditem_mousereleaseevent_callback = nullptr;
    QCPAbstractLegendItem_MouseDoubleClickEvent_Callback qcpabstractlegenditem_mousedoubleclickevent_callback = nullptr;
    QCPAbstractLegendItem_WheelEvent_Callback qcpabstractlegenditem_wheelevent_callback = nullptr;
    QCPAbstractLegendItem_Event_Callback qcpabstractlegenditem_event_callback = nullptr;
    QCPAbstractLegendItem_EventFilter_Callback qcpabstractlegenditem_eventfilter_callback = nullptr;
    QCPAbstractLegendItem_TimerEvent_Callback qcpabstractlegenditem_timerevent_callback = nullptr;
    QCPAbstractLegendItem_ChildEvent_Callback qcpabstractlegenditem_childevent_callback = nullptr;
    QCPAbstractLegendItem_CustomEvent_Callback qcpabstractlegenditem_customevent_callback = nullptr;
    QCPAbstractLegendItem_ConnectNotify_Callback qcpabstractlegenditem_connectnotify_callback = nullptr;
    QCPAbstractLegendItem_DisconnectNotify_Callback qcpabstractlegenditem_disconnectnotify_callback = nullptr;
    QCPAbstractLegendItem_InitializeParentPlot_Callback qcpabstractlegenditem_initializeparentplot_callback = nullptr;
    QCPAbstractLegendItem_SetParentLayerable_Callback qcpabstractlegenditem_setparentlayerable_callback = nullptr;
    QCPAbstractLegendItem_MoveToLayer_Callback qcpabstractlegenditem_movetolayer_callback = nullptr;
    QCPAbstractLegendItem_ApplyAntialiasingHint_Callback qcpabstractlegenditem_applyantialiasinghint_callback = nullptr;
    QCPAbstractLegendItem_Sender_Callback qcpabstractlegenditem_sender_callback = nullptr;
    QCPAbstractLegendItem_SenderSignalIndex_Callback qcpabstractlegenditem_sendersignalindex_callback = nullptr;
    QCPAbstractLegendItem_Receivers_Callback qcpabstractlegenditem_receivers_callback = nullptr;
    QCPAbstractLegendItem_IsSignalConnected_Callback qcpabstractlegenditem_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpabstractlegenditem_metacall_isbase = false;
    mutable bool qcpabstractlegenditem_selecttest_isbase = false;
    mutable bool qcpabstractlegenditem_selectioncategory_isbase = false;
    mutable bool qcpabstractlegenditem_applydefaultantialiasinghint_isbase = false;
    mutable bool qcpabstractlegenditem_cliprect_isbase = false;
    mutable bool qcpabstractlegenditem_draw_isbase = false;
    mutable bool qcpabstractlegenditem_selectevent_isbase = false;
    mutable bool qcpabstractlegenditem_deselectevent_isbase = false;
    mutable bool qcpabstractlegenditem_update_isbase = false;
    mutable bool qcpabstractlegenditem_minimumoutersizehint_isbase = false;
    mutable bool qcpabstractlegenditem_maximumoutersizehint_isbase = false;
    mutable bool qcpabstractlegenditem_elements_isbase = false;
    mutable bool qcpabstractlegenditem_calculateautomargin_isbase = false;
    mutable bool qcpabstractlegenditem_layoutchanged_isbase = false;
    mutable bool qcpabstractlegenditem_parentplotinitialized_isbase = false;
    mutable bool qcpabstractlegenditem_mousepressevent_isbase = false;
    mutable bool qcpabstractlegenditem_mousemoveevent_isbase = false;
    mutable bool qcpabstractlegenditem_mousereleaseevent_isbase = false;
    mutable bool qcpabstractlegenditem_mousedoubleclickevent_isbase = false;
    mutable bool qcpabstractlegenditem_wheelevent_isbase = false;
    mutable bool qcpabstractlegenditem_event_isbase = false;
    mutable bool qcpabstractlegenditem_eventfilter_isbase = false;
    mutable bool qcpabstractlegenditem_timerevent_isbase = false;
    mutable bool qcpabstractlegenditem_childevent_isbase = false;
    mutable bool qcpabstractlegenditem_customevent_isbase = false;
    mutable bool qcpabstractlegenditem_connectnotify_isbase = false;
    mutable bool qcpabstractlegenditem_disconnectnotify_isbase = false;
    mutable bool qcpabstractlegenditem_initializeparentplot_isbase = false;
    mutable bool qcpabstractlegenditem_setparentlayerable_isbase = false;
    mutable bool qcpabstractlegenditem_movetolayer_isbase = false;
    mutable bool qcpabstractlegenditem_applyantialiasinghint_isbase = false;
    mutable bool qcpabstractlegenditem_sender_isbase = false;
    mutable bool qcpabstractlegenditem_sendersignalindex_isbase = false;
    mutable bool qcpabstractlegenditem_receivers_isbase = false;
    mutable bool qcpabstractlegenditem_issignalconnected_isbase = false;

  public:
    VirtualQCPAbstractLegendItem(QCPLegend* parent) : QCPAbstractLegendItem(parent) {};

    ~VirtualQCPAbstractLegendItem() {
        qcpabstractlegenditem_metacall_callback = nullptr;
        qcpabstractlegenditem_selecttest_callback = nullptr;
        qcpabstractlegenditem_selectioncategory_callback = nullptr;
        qcpabstractlegenditem_applydefaultantialiasinghint_callback = nullptr;
        qcpabstractlegenditem_cliprect_callback = nullptr;
        qcpabstractlegenditem_draw_callback = nullptr;
        qcpabstractlegenditem_selectevent_callback = nullptr;
        qcpabstractlegenditem_deselectevent_callback = nullptr;
        qcpabstractlegenditem_update_callback = nullptr;
        qcpabstractlegenditem_minimumoutersizehint_callback = nullptr;
        qcpabstractlegenditem_maximumoutersizehint_callback = nullptr;
        qcpabstractlegenditem_elements_callback = nullptr;
        qcpabstractlegenditem_calculateautomargin_callback = nullptr;
        qcpabstractlegenditem_layoutchanged_callback = nullptr;
        qcpabstractlegenditem_parentplotinitialized_callback = nullptr;
        qcpabstractlegenditem_mousepressevent_callback = nullptr;
        qcpabstractlegenditem_mousemoveevent_callback = nullptr;
        qcpabstractlegenditem_mousereleaseevent_callback = nullptr;
        qcpabstractlegenditem_mousedoubleclickevent_callback = nullptr;
        qcpabstractlegenditem_wheelevent_callback = nullptr;
        qcpabstractlegenditem_event_callback = nullptr;
        qcpabstractlegenditem_eventfilter_callback = nullptr;
        qcpabstractlegenditem_timerevent_callback = nullptr;
        qcpabstractlegenditem_childevent_callback = nullptr;
        qcpabstractlegenditem_customevent_callback = nullptr;
        qcpabstractlegenditem_connectnotify_callback = nullptr;
        qcpabstractlegenditem_disconnectnotify_callback = nullptr;
        qcpabstractlegenditem_initializeparentplot_callback = nullptr;
        qcpabstractlegenditem_setparentlayerable_callback = nullptr;
        qcpabstractlegenditem_movetolayer_callback = nullptr;
        qcpabstractlegenditem_applyantialiasinghint_callback = nullptr;
        qcpabstractlegenditem_sender_callback = nullptr;
        qcpabstractlegenditem_sendersignalindex_callback = nullptr;
        qcpabstractlegenditem_receivers_callback = nullptr;
        qcpabstractlegenditem_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPAbstractLegendItem_Metacall_Callback(QCPAbstractLegendItem_Metacall_Callback cb) { qcpabstractlegenditem_metacall_callback = cb; }
    inline void setQCPAbstractLegendItem_SelectTest_Callback(QCPAbstractLegendItem_SelectTest_Callback cb) { qcpabstractlegenditem_selecttest_callback = cb; }
    inline void setQCPAbstractLegendItem_SelectionCategory_Callback(QCPAbstractLegendItem_SelectionCategory_Callback cb) { qcpabstractlegenditem_selectioncategory_callback = cb; }
    inline void setQCPAbstractLegendItem_ApplyDefaultAntialiasingHint_Callback(QCPAbstractLegendItem_ApplyDefaultAntialiasingHint_Callback cb) { qcpabstractlegenditem_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPAbstractLegendItem_ClipRect_Callback(QCPAbstractLegendItem_ClipRect_Callback cb) { qcpabstractlegenditem_cliprect_callback = cb; }
    inline void setQCPAbstractLegendItem_Draw_Callback(QCPAbstractLegendItem_Draw_Callback cb) { qcpabstractlegenditem_draw_callback = cb; }
    inline void setQCPAbstractLegendItem_SelectEvent_Callback(QCPAbstractLegendItem_SelectEvent_Callback cb) { qcpabstractlegenditem_selectevent_callback = cb; }
    inline void setQCPAbstractLegendItem_DeselectEvent_Callback(QCPAbstractLegendItem_DeselectEvent_Callback cb) { qcpabstractlegenditem_deselectevent_callback = cb; }
    inline void setQCPAbstractLegendItem_Update_Callback(QCPAbstractLegendItem_Update_Callback cb) { qcpabstractlegenditem_update_callback = cb; }
    inline void setQCPAbstractLegendItem_MinimumOuterSizeHint_Callback(QCPAbstractLegendItem_MinimumOuterSizeHint_Callback cb) { qcpabstractlegenditem_minimumoutersizehint_callback = cb; }
    inline void setQCPAbstractLegendItem_MaximumOuterSizeHint_Callback(QCPAbstractLegendItem_MaximumOuterSizeHint_Callback cb) { qcpabstractlegenditem_maximumoutersizehint_callback = cb; }
    inline void setQCPAbstractLegendItem_Elements_Callback(QCPAbstractLegendItem_Elements_Callback cb) { qcpabstractlegenditem_elements_callback = cb; }
    inline void setQCPAbstractLegendItem_CalculateAutoMargin_Callback(QCPAbstractLegendItem_CalculateAutoMargin_Callback cb) { qcpabstractlegenditem_calculateautomargin_callback = cb; }
    inline void setQCPAbstractLegendItem_LayoutChanged_Callback(QCPAbstractLegendItem_LayoutChanged_Callback cb) { qcpabstractlegenditem_layoutchanged_callback = cb; }
    inline void setQCPAbstractLegendItem_ParentPlotInitialized_Callback(QCPAbstractLegendItem_ParentPlotInitialized_Callback cb) { qcpabstractlegenditem_parentplotinitialized_callback = cb; }
    inline void setQCPAbstractLegendItem_MousePressEvent_Callback(QCPAbstractLegendItem_MousePressEvent_Callback cb) { qcpabstractlegenditem_mousepressevent_callback = cb; }
    inline void setQCPAbstractLegendItem_MouseMoveEvent_Callback(QCPAbstractLegendItem_MouseMoveEvent_Callback cb) { qcpabstractlegenditem_mousemoveevent_callback = cb; }
    inline void setQCPAbstractLegendItem_MouseReleaseEvent_Callback(QCPAbstractLegendItem_MouseReleaseEvent_Callback cb) { qcpabstractlegenditem_mousereleaseevent_callback = cb; }
    inline void setQCPAbstractLegendItem_MouseDoubleClickEvent_Callback(QCPAbstractLegendItem_MouseDoubleClickEvent_Callback cb) { qcpabstractlegenditem_mousedoubleclickevent_callback = cb; }
    inline void setQCPAbstractLegendItem_WheelEvent_Callback(QCPAbstractLegendItem_WheelEvent_Callback cb) { qcpabstractlegenditem_wheelevent_callback = cb; }
    inline void setQCPAbstractLegendItem_Event_Callback(QCPAbstractLegendItem_Event_Callback cb) { qcpabstractlegenditem_event_callback = cb; }
    inline void setQCPAbstractLegendItem_EventFilter_Callback(QCPAbstractLegendItem_EventFilter_Callback cb) { qcpabstractlegenditem_eventfilter_callback = cb; }
    inline void setQCPAbstractLegendItem_TimerEvent_Callback(QCPAbstractLegendItem_TimerEvent_Callback cb) { qcpabstractlegenditem_timerevent_callback = cb; }
    inline void setQCPAbstractLegendItem_ChildEvent_Callback(QCPAbstractLegendItem_ChildEvent_Callback cb) { qcpabstractlegenditem_childevent_callback = cb; }
    inline void setQCPAbstractLegendItem_CustomEvent_Callback(QCPAbstractLegendItem_CustomEvent_Callback cb) { qcpabstractlegenditem_customevent_callback = cb; }
    inline void setQCPAbstractLegendItem_ConnectNotify_Callback(QCPAbstractLegendItem_ConnectNotify_Callback cb) { qcpabstractlegenditem_connectnotify_callback = cb; }
    inline void setQCPAbstractLegendItem_DisconnectNotify_Callback(QCPAbstractLegendItem_DisconnectNotify_Callback cb) { qcpabstractlegenditem_disconnectnotify_callback = cb; }
    inline void setQCPAbstractLegendItem_InitializeParentPlot_Callback(QCPAbstractLegendItem_InitializeParentPlot_Callback cb) { qcpabstractlegenditem_initializeparentplot_callback = cb; }
    inline void setQCPAbstractLegendItem_SetParentLayerable_Callback(QCPAbstractLegendItem_SetParentLayerable_Callback cb) { qcpabstractlegenditem_setparentlayerable_callback = cb; }
    inline void setQCPAbstractLegendItem_MoveToLayer_Callback(QCPAbstractLegendItem_MoveToLayer_Callback cb) { qcpabstractlegenditem_movetolayer_callback = cb; }
    inline void setQCPAbstractLegendItem_ApplyAntialiasingHint_Callback(QCPAbstractLegendItem_ApplyAntialiasingHint_Callback cb) { qcpabstractlegenditem_applyantialiasinghint_callback = cb; }
    inline void setQCPAbstractLegendItem_Sender_Callback(QCPAbstractLegendItem_Sender_Callback cb) { qcpabstractlegenditem_sender_callback = cb; }
    inline void setQCPAbstractLegendItem_SenderSignalIndex_Callback(QCPAbstractLegendItem_SenderSignalIndex_Callback cb) { qcpabstractlegenditem_sendersignalindex_callback = cb; }
    inline void setQCPAbstractLegendItem_Receivers_Callback(QCPAbstractLegendItem_Receivers_Callback cb) { qcpabstractlegenditem_receivers_callback = cb; }
    inline void setQCPAbstractLegendItem_IsSignalConnected_Callback(QCPAbstractLegendItem_IsSignalConnected_Callback cb) { qcpabstractlegenditem_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPAbstractLegendItem_Metacall_IsBase(bool value) const { qcpabstractlegenditem_metacall_isbase = value; }
    inline void setQCPAbstractLegendItem_SelectTest_IsBase(bool value) const { qcpabstractlegenditem_selecttest_isbase = value; }
    inline void setQCPAbstractLegendItem_SelectionCategory_IsBase(bool value) const { qcpabstractlegenditem_selectioncategory_isbase = value; }
    inline void setQCPAbstractLegendItem_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcpabstractlegenditem_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPAbstractLegendItem_ClipRect_IsBase(bool value) const { qcpabstractlegenditem_cliprect_isbase = value; }
    inline void setQCPAbstractLegendItem_Draw_IsBase(bool value) const { qcpabstractlegenditem_draw_isbase = value; }
    inline void setQCPAbstractLegendItem_SelectEvent_IsBase(bool value) const { qcpabstractlegenditem_selectevent_isbase = value; }
    inline void setQCPAbstractLegendItem_DeselectEvent_IsBase(bool value) const { qcpabstractlegenditem_deselectevent_isbase = value; }
    inline void setQCPAbstractLegendItem_Update_IsBase(bool value) const { qcpabstractlegenditem_update_isbase = value; }
    inline void setQCPAbstractLegendItem_MinimumOuterSizeHint_IsBase(bool value) const { qcpabstractlegenditem_minimumoutersizehint_isbase = value; }
    inline void setQCPAbstractLegendItem_MaximumOuterSizeHint_IsBase(bool value) const { qcpabstractlegenditem_maximumoutersizehint_isbase = value; }
    inline void setQCPAbstractLegendItem_Elements_IsBase(bool value) const { qcpabstractlegenditem_elements_isbase = value; }
    inline void setQCPAbstractLegendItem_CalculateAutoMargin_IsBase(bool value) const { qcpabstractlegenditem_calculateautomargin_isbase = value; }
    inline void setQCPAbstractLegendItem_LayoutChanged_IsBase(bool value) const { qcpabstractlegenditem_layoutchanged_isbase = value; }
    inline void setQCPAbstractLegendItem_ParentPlotInitialized_IsBase(bool value) const { qcpabstractlegenditem_parentplotinitialized_isbase = value; }
    inline void setQCPAbstractLegendItem_MousePressEvent_IsBase(bool value) const { qcpabstractlegenditem_mousepressevent_isbase = value; }
    inline void setQCPAbstractLegendItem_MouseMoveEvent_IsBase(bool value) const { qcpabstractlegenditem_mousemoveevent_isbase = value; }
    inline void setQCPAbstractLegendItem_MouseReleaseEvent_IsBase(bool value) const { qcpabstractlegenditem_mousereleaseevent_isbase = value; }
    inline void setQCPAbstractLegendItem_MouseDoubleClickEvent_IsBase(bool value) const { qcpabstractlegenditem_mousedoubleclickevent_isbase = value; }
    inline void setQCPAbstractLegendItem_WheelEvent_IsBase(bool value) const { qcpabstractlegenditem_wheelevent_isbase = value; }
    inline void setQCPAbstractLegendItem_Event_IsBase(bool value) const { qcpabstractlegenditem_event_isbase = value; }
    inline void setQCPAbstractLegendItem_EventFilter_IsBase(bool value) const { qcpabstractlegenditem_eventfilter_isbase = value; }
    inline void setQCPAbstractLegendItem_TimerEvent_IsBase(bool value) const { qcpabstractlegenditem_timerevent_isbase = value; }
    inline void setQCPAbstractLegendItem_ChildEvent_IsBase(bool value) const { qcpabstractlegenditem_childevent_isbase = value; }
    inline void setQCPAbstractLegendItem_CustomEvent_IsBase(bool value) const { qcpabstractlegenditem_customevent_isbase = value; }
    inline void setQCPAbstractLegendItem_ConnectNotify_IsBase(bool value) const { qcpabstractlegenditem_connectnotify_isbase = value; }
    inline void setQCPAbstractLegendItem_DisconnectNotify_IsBase(bool value) const { qcpabstractlegenditem_disconnectnotify_isbase = value; }
    inline void setQCPAbstractLegendItem_InitializeParentPlot_IsBase(bool value) const { qcpabstractlegenditem_initializeparentplot_isbase = value; }
    inline void setQCPAbstractLegendItem_SetParentLayerable_IsBase(bool value) const { qcpabstractlegenditem_setparentlayerable_isbase = value; }
    inline void setQCPAbstractLegendItem_MoveToLayer_IsBase(bool value) const { qcpabstractlegenditem_movetolayer_isbase = value; }
    inline void setQCPAbstractLegendItem_ApplyAntialiasingHint_IsBase(bool value) const { qcpabstractlegenditem_applyantialiasinghint_isbase = value; }
    inline void setQCPAbstractLegendItem_Sender_IsBase(bool value) const { qcpabstractlegenditem_sender_isbase = value; }
    inline void setQCPAbstractLegendItem_SenderSignalIndex_IsBase(bool value) const { qcpabstractlegenditem_sendersignalindex_isbase = value; }
    inline void setQCPAbstractLegendItem_Receivers_IsBase(bool value) const { qcpabstractlegenditem_receivers_isbase = value; }
    inline void setQCPAbstractLegendItem_IsSignalConnected_IsBase(bool value) const { qcpabstractlegenditem_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpabstractlegenditem_metacall_isbase) {
            qcpabstractlegenditem_metacall_isbase = false;
            return QCPAbstractLegendItem::qt_metacall(param1, param2, param3);
        } else if (qcpabstractlegenditem_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpabstractlegenditem_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPAbstractLegendItem::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcpabstractlegenditem_selecttest_isbase) {
            qcpabstractlegenditem_selecttest_isbase = false;
            return QCPAbstractLegendItem::selectTest(pos, onlySelectable, details);
        } else if (qcpabstractlegenditem_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcpabstractlegenditem_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPAbstractLegendItem::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcpabstractlegenditem_selectioncategory_isbase) {
            qcpabstractlegenditem_selectioncategory_isbase = false;
            return QCPAbstractLegendItem::selectionCategory();
        } else if (qcpabstractlegenditem_selectioncategory_callback != nullptr) {
            int callback_ret = qcpabstractlegenditem_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPAbstractLegendItem::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcpabstractlegenditem_applydefaultantialiasinghint_isbase) {
            qcpabstractlegenditem_applydefaultantialiasinghint_isbase = false;
            QCPAbstractLegendItem::applyDefaultAntialiasingHint(painter);
        } else if (qcpabstractlegenditem_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpabstractlegenditem_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPAbstractLegendItem::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcpabstractlegenditem_cliprect_isbase) {
            qcpabstractlegenditem_cliprect_isbase = false;
            return QCPAbstractLegendItem::clipRect();
        } else if (qcpabstractlegenditem_cliprect_callback != nullptr) {
            QRect* callback_ret = qcpabstractlegenditem_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPAbstractLegendItem::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcpabstractlegenditem_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpabstractlegenditem_draw_callback(this, cbval1);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcpabstractlegenditem_selectevent_isbase) {
            qcpabstractlegenditem_selectevent_isbase = false;
            QCPAbstractLegendItem::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcpabstractlegenditem_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcpabstractlegenditem_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPAbstractLegendItem::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcpabstractlegenditem_deselectevent_isbase) {
            qcpabstractlegenditem_deselectevent_isbase = false;
            QCPAbstractLegendItem::deselectEvent(selectionStateChanged);
        } else if (qcpabstractlegenditem_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcpabstractlegenditem_deselectevent_callback(this, cbval1);
        } else {
            QCPAbstractLegendItem::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void update(QCPLayoutElement::UpdatePhase phase) override {
        if (qcpabstractlegenditem_update_isbase) {
            qcpabstractlegenditem_update_isbase = false;
            QCPAbstractLegendItem::update(phase);
        } else if (qcpabstractlegenditem_update_callback != nullptr) {
            int cbval1 = static_cast<int>(phase);

            qcpabstractlegenditem_update_callback(this, cbval1);
        } else {
            QCPAbstractLegendItem::update(phase);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize minimumOuterSizeHint() const override {
        if (qcpabstractlegenditem_minimumoutersizehint_isbase) {
            qcpabstractlegenditem_minimumoutersizehint_isbase = false;
            return QCPAbstractLegendItem::minimumOuterSizeHint();
        } else if (qcpabstractlegenditem_minimumoutersizehint_callback != nullptr) {
            QSize* callback_ret = qcpabstractlegenditem_minimumoutersizehint_callback();
            return *callback_ret;
        } else {
            return QCPAbstractLegendItem::minimumOuterSizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize maximumOuterSizeHint() const override {
        if (qcpabstractlegenditem_maximumoutersizehint_isbase) {
            qcpabstractlegenditem_maximumoutersizehint_isbase = false;
            return QCPAbstractLegendItem::maximumOuterSizeHint();
        } else if (qcpabstractlegenditem_maximumoutersizehint_callback != nullptr) {
            QSize* callback_ret = qcpabstractlegenditem_maximumoutersizehint_callback();
            return *callback_ret;
        } else {
            return QCPAbstractLegendItem::maximumOuterSizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QList<QCPLayoutElement*> elements(bool recursive) const override {
        if (qcpabstractlegenditem_elements_isbase) {
            qcpabstractlegenditem_elements_isbase = false;
            return QCPAbstractLegendItem::elements(recursive);
        } else if (qcpabstractlegenditem_elements_callback != nullptr) {
            bool cbval1 = recursive;

            QCPLayoutElement** callback_ret = qcpabstractlegenditem_elements_callback(this, cbval1);
            QList<QCPLayoutElement*> callback_ret_QList;
            // Iterate until null pointer sentinel
            for (QCPLayoutElement** ptridx = callback_ret; *ptridx != nullptr; ptridx++) {
                callback_ret_QList.push_back(*ptridx);
            }
            free(callback_ret);
            return callback_ret_QList;
        } else {
            return QCPAbstractLegendItem::elements(recursive);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int calculateAutoMargin(QCP::MarginSide side) override {
        if (qcpabstractlegenditem_calculateautomargin_isbase) {
            qcpabstractlegenditem_calculateautomargin_isbase = false;
            return QCPAbstractLegendItem::calculateAutoMargin(side);
        } else if (qcpabstractlegenditem_calculateautomargin_callback != nullptr) {
            int cbval1 = static_cast<int>(side);

            int callback_ret = qcpabstractlegenditem_calculateautomargin_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPAbstractLegendItem::calculateAutoMargin(side);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void layoutChanged() override {
        if (qcpabstractlegenditem_layoutchanged_isbase) {
            qcpabstractlegenditem_layoutchanged_isbase = false;
            QCPAbstractLegendItem::layoutChanged();
        } else if (qcpabstractlegenditem_layoutchanged_callback != nullptr) {
            qcpabstractlegenditem_layoutchanged_callback();
        } else {
            QCPAbstractLegendItem::layoutChanged();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcpabstractlegenditem_parentplotinitialized_isbase) {
            qcpabstractlegenditem_parentplotinitialized_isbase = false;
            QCPAbstractLegendItem::parentPlotInitialized(parentPlot);
        } else if (qcpabstractlegenditem_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpabstractlegenditem_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPAbstractLegendItem::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpabstractlegenditem_mousepressevent_isbase) {
            qcpabstractlegenditem_mousepressevent_isbase = false;
            QCPAbstractLegendItem::mousePressEvent(event, details);
        } else if (qcpabstractlegenditem_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpabstractlegenditem_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPAbstractLegendItem::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpabstractlegenditem_mousemoveevent_isbase) {
            qcpabstractlegenditem_mousemoveevent_isbase = false;
            QCPAbstractLegendItem::mouseMoveEvent(event, startPos);
        } else if (qcpabstractlegenditem_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpabstractlegenditem_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPAbstractLegendItem::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpabstractlegenditem_mousereleaseevent_isbase) {
            qcpabstractlegenditem_mousereleaseevent_isbase = false;
            QCPAbstractLegendItem::mouseReleaseEvent(event, startPos);
        } else if (qcpabstractlegenditem_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpabstractlegenditem_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPAbstractLegendItem::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpabstractlegenditem_mousedoubleclickevent_isbase) {
            qcpabstractlegenditem_mousedoubleclickevent_isbase = false;
            QCPAbstractLegendItem::mouseDoubleClickEvent(event, details);
        } else if (qcpabstractlegenditem_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpabstractlegenditem_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPAbstractLegendItem::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcpabstractlegenditem_wheelevent_isbase) {
            qcpabstractlegenditem_wheelevent_isbase = false;
            QCPAbstractLegendItem::wheelEvent(event);
        } else if (qcpabstractlegenditem_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcpabstractlegenditem_wheelevent_callback(this, cbval1);
        } else {
            QCPAbstractLegendItem::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpabstractlegenditem_event_isbase) {
            qcpabstractlegenditem_event_isbase = false;
            return QCPAbstractLegendItem::event(event);
        } else if (qcpabstractlegenditem_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpabstractlegenditem_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPAbstractLegendItem::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpabstractlegenditem_eventfilter_isbase) {
            qcpabstractlegenditem_eventfilter_isbase = false;
            return QCPAbstractLegendItem::eventFilter(watched, event);
        } else if (qcpabstractlegenditem_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpabstractlegenditem_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPAbstractLegendItem::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpabstractlegenditem_timerevent_isbase) {
            qcpabstractlegenditem_timerevent_isbase = false;
            QCPAbstractLegendItem::timerEvent(event);
        } else if (qcpabstractlegenditem_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpabstractlegenditem_timerevent_callback(this, cbval1);
        } else {
            QCPAbstractLegendItem::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpabstractlegenditem_childevent_isbase) {
            qcpabstractlegenditem_childevent_isbase = false;
            QCPAbstractLegendItem::childEvent(event);
        } else if (qcpabstractlegenditem_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpabstractlegenditem_childevent_callback(this, cbval1);
        } else {
            QCPAbstractLegendItem::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpabstractlegenditem_customevent_isbase) {
            qcpabstractlegenditem_customevent_isbase = false;
            QCPAbstractLegendItem::customEvent(event);
        } else if (qcpabstractlegenditem_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpabstractlegenditem_customevent_callback(this, cbval1);
        } else {
            QCPAbstractLegendItem::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpabstractlegenditem_connectnotify_isbase) {
            qcpabstractlegenditem_connectnotify_isbase = false;
            QCPAbstractLegendItem::connectNotify(signal);
        } else if (qcpabstractlegenditem_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpabstractlegenditem_connectnotify_callback(this, cbval1);
        } else {
            QCPAbstractLegendItem::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpabstractlegenditem_disconnectnotify_isbase) {
            qcpabstractlegenditem_disconnectnotify_isbase = false;
            QCPAbstractLegendItem::disconnectNotify(signal);
        } else if (qcpabstractlegenditem_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpabstractlegenditem_disconnectnotify_callback(this, cbval1);
        } else {
            QCPAbstractLegendItem::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcpabstractlegenditem_initializeparentplot_isbase) {
            qcpabstractlegenditem_initializeparentplot_isbase = false;
            QCPAbstractLegendItem::initializeParentPlot(parentPlot);
        } else if (qcpabstractlegenditem_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpabstractlegenditem_initializeparentplot_callback(this, cbval1);
        } else {
            QCPAbstractLegendItem::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcpabstractlegenditem_setparentlayerable_isbase) {
            qcpabstractlegenditem_setparentlayerable_isbase = false;
            QCPAbstractLegendItem::setParentLayerable(parentLayerable);
        } else if (qcpabstractlegenditem_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcpabstractlegenditem_setparentlayerable_callback(this, cbval1);
        } else {
            QCPAbstractLegendItem::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcpabstractlegenditem_movetolayer_isbase) {
            qcpabstractlegenditem_movetolayer_isbase = false;
            return QCPAbstractLegendItem::moveToLayer(layer, prepend);
        } else if (qcpabstractlegenditem_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcpabstractlegenditem_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPAbstractLegendItem::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcpabstractlegenditem_applyantialiasinghint_isbase) {
            qcpabstractlegenditem_applyantialiasinghint_isbase = false;
            QCPAbstractLegendItem::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcpabstractlegenditem_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcpabstractlegenditem_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPAbstractLegendItem::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpabstractlegenditem_sender_isbase) {
            qcpabstractlegenditem_sender_isbase = false;
            return QCPAbstractLegendItem::sender();
        } else if (qcpabstractlegenditem_sender_callback != nullptr) {
            QObject* callback_ret = qcpabstractlegenditem_sender_callback();
            return callback_ret;
        } else {
            return QCPAbstractLegendItem::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpabstractlegenditem_sendersignalindex_isbase) {
            qcpabstractlegenditem_sendersignalindex_isbase = false;
            return QCPAbstractLegendItem::senderSignalIndex();
        } else if (qcpabstractlegenditem_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpabstractlegenditem_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPAbstractLegendItem::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpabstractlegenditem_receivers_isbase) {
            qcpabstractlegenditem_receivers_isbase = false;
            return QCPAbstractLegendItem::receivers(signal);
        } else if (qcpabstractlegenditem_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpabstractlegenditem_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPAbstractLegendItem::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpabstractlegenditem_issignalconnected_isbase) {
            qcpabstractlegenditem_issignalconnected_isbase = false;
            return QCPAbstractLegendItem::isSignalConnected(signal);
        } else if (qcpabstractlegenditem_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpabstractlegenditem_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPAbstractLegendItem::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend int QCPAbstractLegendItem_SelectionCategory(const QCPAbstractLegendItem* self);
    friend int QCPAbstractLegendItem_QBaseSelectionCategory(const QCPAbstractLegendItem* self);
    friend void QCPAbstractLegendItem_ApplyDefaultAntialiasingHint(const QCPAbstractLegendItem* self, QCPPainter* painter);
    friend void QCPAbstractLegendItem_QBaseApplyDefaultAntialiasingHint(const QCPAbstractLegendItem* self, QCPPainter* painter);
    friend QRect* QCPAbstractLegendItem_ClipRect(const QCPAbstractLegendItem* self);
    friend QRect* QCPAbstractLegendItem_QBaseClipRect(const QCPAbstractLegendItem* self);
    friend void QCPAbstractLegendItem_Draw(QCPAbstractLegendItem* self, QCPPainter* painter);
    friend void QCPAbstractLegendItem_QBaseDraw(QCPAbstractLegendItem* self, QCPPainter* painter);
    friend void QCPAbstractLegendItem_SelectEvent(QCPAbstractLegendItem* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPAbstractLegendItem_QBaseSelectEvent(QCPAbstractLegendItem* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPAbstractLegendItem_DeselectEvent(QCPAbstractLegendItem* self, bool* selectionStateChanged);
    friend void QCPAbstractLegendItem_QBaseDeselectEvent(QCPAbstractLegendItem* self, bool* selectionStateChanged);
    friend int QCPAbstractLegendItem_CalculateAutoMargin(QCPAbstractLegendItem* self, int side);
    friend int QCPAbstractLegendItem_QBaseCalculateAutoMargin(QCPAbstractLegendItem* self, int side);
    friend void QCPAbstractLegendItem_LayoutChanged(QCPAbstractLegendItem* self);
    friend void QCPAbstractLegendItem_QBaseLayoutChanged(QCPAbstractLegendItem* self);
    friend void QCPAbstractLegendItem_ParentPlotInitialized(QCPAbstractLegendItem* self, QCustomPlot* parentPlot);
    friend void QCPAbstractLegendItem_QBaseParentPlotInitialized(QCPAbstractLegendItem* self, QCustomPlot* parentPlot);
    friend void QCPAbstractLegendItem_MousePressEvent(QCPAbstractLegendItem* self, QMouseEvent* event, const QVariant* details);
    friend void QCPAbstractLegendItem_QBaseMousePressEvent(QCPAbstractLegendItem* self, QMouseEvent* event, const QVariant* details);
    friend void QCPAbstractLegendItem_MouseMoveEvent(QCPAbstractLegendItem* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPAbstractLegendItem_QBaseMouseMoveEvent(QCPAbstractLegendItem* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPAbstractLegendItem_MouseReleaseEvent(QCPAbstractLegendItem* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPAbstractLegendItem_QBaseMouseReleaseEvent(QCPAbstractLegendItem* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPAbstractLegendItem_MouseDoubleClickEvent(QCPAbstractLegendItem* self, QMouseEvent* event, const QVariant* details);
    friend void QCPAbstractLegendItem_QBaseMouseDoubleClickEvent(QCPAbstractLegendItem* self, QMouseEvent* event, const QVariant* details);
    friend void QCPAbstractLegendItem_WheelEvent(QCPAbstractLegendItem* self, QWheelEvent* event);
    friend void QCPAbstractLegendItem_QBaseWheelEvent(QCPAbstractLegendItem* self, QWheelEvent* event);
    friend void QCPAbstractLegendItem_TimerEvent(QCPAbstractLegendItem* self, QTimerEvent* event);
    friend void QCPAbstractLegendItem_QBaseTimerEvent(QCPAbstractLegendItem* self, QTimerEvent* event);
    friend void QCPAbstractLegendItem_ChildEvent(QCPAbstractLegendItem* self, QChildEvent* event);
    friend void QCPAbstractLegendItem_QBaseChildEvent(QCPAbstractLegendItem* self, QChildEvent* event);
    friend void QCPAbstractLegendItem_CustomEvent(QCPAbstractLegendItem* self, QEvent* event);
    friend void QCPAbstractLegendItem_QBaseCustomEvent(QCPAbstractLegendItem* self, QEvent* event);
    friend void QCPAbstractLegendItem_ConnectNotify(QCPAbstractLegendItem* self, const QMetaMethod* signal);
    friend void QCPAbstractLegendItem_QBaseConnectNotify(QCPAbstractLegendItem* self, const QMetaMethod* signal);
    friend void QCPAbstractLegendItem_DisconnectNotify(QCPAbstractLegendItem* self, const QMetaMethod* signal);
    friend void QCPAbstractLegendItem_QBaseDisconnectNotify(QCPAbstractLegendItem* self, const QMetaMethod* signal);
    friend void QCPAbstractLegendItem_InitializeParentPlot(QCPAbstractLegendItem* self, QCustomPlot* parentPlot);
    friend void QCPAbstractLegendItem_QBaseInitializeParentPlot(QCPAbstractLegendItem* self, QCustomPlot* parentPlot);
    friend void QCPAbstractLegendItem_SetParentLayerable(QCPAbstractLegendItem* self, QCPLayerable* parentLayerable);
    friend void QCPAbstractLegendItem_QBaseSetParentLayerable(QCPAbstractLegendItem* self, QCPLayerable* parentLayerable);
    friend bool QCPAbstractLegendItem_MoveToLayer(QCPAbstractLegendItem* self, QCPLayer* layer, bool prepend);
    friend bool QCPAbstractLegendItem_QBaseMoveToLayer(QCPAbstractLegendItem* self, QCPLayer* layer, bool prepend);
    friend void QCPAbstractLegendItem_ApplyAntialiasingHint(const QCPAbstractLegendItem* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPAbstractLegendItem_QBaseApplyAntialiasingHint(const QCPAbstractLegendItem* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPAbstractLegendItem_Sender(const QCPAbstractLegendItem* self);
    friend QObject* QCPAbstractLegendItem_QBaseSender(const QCPAbstractLegendItem* self);
    friend int QCPAbstractLegendItem_SenderSignalIndex(const QCPAbstractLegendItem* self);
    friend int QCPAbstractLegendItem_QBaseSenderSignalIndex(const QCPAbstractLegendItem* self);
    friend int QCPAbstractLegendItem_Receivers(const QCPAbstractLegendItem* self, const char* signal);
    friend int QCPAbstractLegendItem_QBaseReceivers(const QCPAbstractLegendItem* self, const char* signal);
    friend bool QCPAbstractLegendItem_IsSignalConnected(const QCPAbstractLegendItem* self, const QMetaMethod* signal);
    friend bool QCPAbstractLegendItem_QBaseIsSignalConnected(const QCPAbstractLegendItem* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPPlottableLegendItem so that we can call protected methods
class VirtualQCPPlottableLegendItem final : public QCPPlottableLegendItem {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPPlottableLegendItem = true;

    // Virtual class public types (including callbacks)
    using QCPPlottableLegendItem_Metacall_Callback = int (*)(QCPPlottableLegendItem*, int, int, void**);
    using QCPPlottableLegendItem_Draw_Callback = void (*)(QCPPlottableLegendItem*, QCPPainter*);
    using QCPPlottableLegendItem_MinimumOuterSizeHint_Callback = QSize* (*)();
    using QCPPlottableLegendItem_SelectTest_Callback = double (*)(const QCPPlottableLegendItem*, QPointF*, bool, QVariant*);
    using QCPPlottableLegendItem_SelectionCategory_Callback = int (*)();
    using QCPPlottableLegendItem_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPPlottableLegendItem*, QCPPainter*);
    using QCPPlottableLegendItem_ClipRect_Callback = QRect* (*)();
    using QCPPlottableLegendItem_SelectEvent_Callback = void (*)(QCPPlottableLegendItem*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPPlottableLegendItem_DeselectEvent_Callback = void (*)(QCPPlottableLegendItem*, bool*);
    using QCPPlottableLegendItem_Update_Callback = void (*)(QCPPlottableLegendItem*, int);
    using QCPPlottableLegendItem_MaximumOuterSizeHint_Callback = QSize* (*)();
    using QCPPlottableLegendItem_Elements_Callback = QCPLayoutElement** (*)(const QCPPlottableLegendItem*, bool);
    using QCPPlottableLegendItem_CalculateAutoMargin_Callback = int (*)(QCPPlottableLegendItem*, int);
    using QCPPlottableLegendItem_LayoutChanged_Callback = void (*)();
    using QCPPlottableLegendItem_ParentPlotInitialized_Callback = void (*)(QCPPlottableLegendItem*, QCustomPlot*);
    using QCPPlottableLegendItem_MousePressEvent_Callback = void (*)(QCPPlottableLegendItem*, QMouseEvent*, QVariant*);
    using QCPPlottableLegendItem_MouseMoveEvent_Callback = void (*)(QCPPlottableLegendItem*, QMouseEvent*, QPointF*);
    using QCPPlottableLegendItem_MouseReleaseEvent_Callback = void (*)(QCPPlottableLegendItem*, QMouseEvent*, QPointF*);
    using QCPPlottableLegendItem_MouseDoubleClickEvent_Callback = void (*)(QCPPlottableLegendItem*, QMouseEvent*, QVariant*);
    using QCPPlottableLegendItem_WheelEvent_Callback = void (*)(QCPPlottableLegendItem*, QWheelEvent*);
    using QCPPlottableLegendItem_Event_Callback = bool (*)(QCPPlottableLegendItem*, QEvent*);
    using QCPPlottableLegendItem_EventFilter_Callback = bool (*)(QCPPlottableLegendItem*, QObject*, QEvent*);
    using QCPPlottableLegendItem_TimerEvent_Callback = void (*)(QCPPlottableLegendItem*, QTimerEvent*);
    using QCPPlottableLegendItem_ChildEvent_Callback = void (*)(QCPPlottableLegendItem*, QChildEvent*);
    using QCPPlottableLegendItem_CustomEvent_Callback = void (*)(QCPPlottableLegendItem*, QEvent*);
    using QCPPlottableLegendItem_ConnectNotify_Callback = void (*)(QCPPlottableLegendItem*, QMetaMethod*);
    using QCPPlottableLegendItem_DisconnectNotify_Callback = void (*)(QCPPlottableLegendItem*, QMetaMethod*);
    using QCPPlottableLegendItem_GetIconBorderPen_Callback = QPen* (*)();
    using QCPPlottableLegendItem_GetTextColor_Callback = QColor* (*)();
    using QCPPlottableLegendItem_GetFont_Callback = QFont* (*)();
    using QCPPlottableLegendItem_InitializeParentPlot_Callback = void (*)(QCPPlottableLegendItem*, QCustomPlot*);
    using QCPPlottableLegendItem_SetParentLayerable_Callback = void (*)(QCPPlottableLegendItem*, QCPLayerable*);
    using QCPPlottableLegendItem_MoveToLayer_Callback = bool (*)(QCPPlottableLegendItem*, QCPLayer*, bool);
    using QCPPlottableLegendItem_ApplyAntialiasingHint_Callback = void (*)(const QCPPlottableLegendItem*, QCPPainter*, bool, int);
    using QCPPlottableLegendItem_Sender_Callback = QObject* (*)();
    using QCPPlottableLegendItem_SenderSignalIndex_Callback = int (*)();
    using QCPPlottableLegendItem_Receivers_Callback = int (*)(const QCPPlottableLegendItem*, const char*);
    using QCPPlottableLegendItem_IsSignalConnected_Callback = bool (*)(const QCPPlottableLegendItem*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPPlottableLegendItem_Metacall_Callback qcpplottablelegenditem_metacall_callback = nullptr;
    QCPPlottableLegendItem_Draw_Callback qcpplottablelegenditem_draw_callback = nullptr;
    QCPPlottableLegendItem_MinimumOuterSizeHint_Callback qcpplottablelegenditem_minimumoutersizehint_callback = nullptr;
    QCPPlottableLegendItem_SelectTest_Callback qcpplottablelegenditem_selecttest_callback = nullptr;
    QCPPlottableLegendItem_SelectionCategory_Callback qcpplottablelegenditem_selectioncategory_callback = nullptr;
    QCPPlottableLegendItem_ApplyDefaultAntialiasingHint_Callback qcpplottablelegenditem_applydefaultantialiasinghint_callback = nullptr;
    QCPPlottableLegendItem_ClipRect_Callback qcpplottablelegenditem_cliprect_callback = nullptr;
    QCPPlottableLegendItem_SelectEvent_Callback qcpplottablelegenditem_selectevent_callback = nullptr;
    QCPPlottableLegendItem_DeselectEvent_Callback qcpplottablelegenditem_deselectevent_callback = nullptr;
    QCPPlottableLegendItem_Update_Callback qcpplottablelegenditem_update_callback = nullptr;
    QCPPlottableLegendItem_MaximumOuterSizeHint_Callback qcpplottablelegenditem_maximumoutersizehint_callback = nullptr;
    QCPPlottableLegendItem_Elements_Callback qcpplottablelegenditem_elements_callback = nullptr;
    QCPPlottableLegendItem_CalculateAutoMargin_Callback qcpplottablelegenditem_calculateautomargin_callback = nullptr;
    QCPPlottableLegendItem_LayoutChanged_Callback qcpplottablelegenditem_layoutchanged_callback = nullptr;
    QCPPlottableLegendItem_ParentPlotInitialized_Callback qcpplottablelegenditem_parentplotinitialized_callback = nullptr;
    QCPPlottableLegendItem_MousePressEvent_Callback qcpplottablelegenditem_mousepressevent_callback = nullptr;
    QCPPlottableLegendItem_MouseMoveEvent_Callback qcpplottablelegenditem_mousemoveevent_callback = nullptr;
    QCPPlottableLegendItem_MouseReleaseEvent_Callback qcpplottablelegenditem_mousereleaseevent_callback = nullptr;
    QCPPlottableLegendItem_MouseDoubleClickEvent_Callback qcpplottablelegenditem_mousedoubleclickevent_callback = nullptr;
    QCPPlottableLegendItem_WheelEvent_Callback qcpplottablelegenditem_wheelevent_callback = nullptr;
    QCPPlottableLegendItem_Event_Callback qcpplottablelegenditem_event_callback = nullptr;
    QCPPlottableLegendItem_EventFilter_Callback qcpplottablelegenditem_eventfilter_callback = nullptr;
    QCPPlottableLegendItem_TimerEvent_Callback qcpplottablelegenditem_timerevent_callback = nullptr;
    QCPPlottableLegendItem_ChildEvent_Callback qcpplottablelegenditem_childevent_callback = nullptr;
    QCPPlottableLegendItem_CustomEvent_Callback qcpplottablelegenditem_customevent_callback = nullptr;
    QCPPlottableLegendItem_ConnectNotify_Callback qcpplottablelegenditem_connectnotify_callback = nullptr;
    QCPPlottableLegendItem_DisconnectNotify_Callback qcpplottablelegenditem_disconnectnotify_callback = nullptr;
    QCPPlottableLegendItem_GetIconBorderPen_Callback qcpplottablelegenditem_geticonborderpen_callback = nullptr;
    QCPPlottableLegendItem_GetTextColor_Callback qcpplottablelegenditem_gettextcolor_callback = nullptr;
    QCPPlottableLegendItem_GetFont_Callback qcpplottablelegenditem_getfont_callback = nullptr;
    QCPPlottableLegendItem_InitializeParentPlot_Callback qcpplottablelegenditem_initializeparentplot_callback = nullptr;
    QCPPlottableLegendItem_SetParentLayerable_Callback qcpplottablelegenditem_setparentlayerable_callback = nullptr;
    QCPPlottableLegendItem_MoveToLayer_Callback qcpplottablelegenditem_movetolayer_callback = nullptr;
    QCPPlottableLegendItem_ApplyAntialiasingHint_Callback qcpplottablelegenditem_applyantialiasinghint_callback = nullptr;
    QCPPlottableLegendItem_Sender_Callback qcpplottablelegenditem_sender_callback = nullptr;
    QCPPlottableLegendItem_SenderSignalIndex_Callback qcpplottablelegenditem_sendersignalindex_callback = nullptr;
    QCPPlottableLegendItem_Receivers_Callback qcpplottablelegenditem_receivers_callback = nullptr;
    QCPPlottableLegendItem_IsSignalConnected_Callback qcpplottablelegenditem_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpplottablelegenditem_metacall_isbase = false;
    mutable bool qcpplottablelegenditem_draw_isbase = false;
    mutable bool qcpplottablelegenditem_minimumoutersizehint_isbase = false;
    mutable bool qcpplottablelegenditem_selecttest_isbase = false;
    mutable bool qcpplottablelegenditem_selectioncategory_isbase = false;
    mutable bool qcpplottablelegenditem_applydefaultantialiasinghint_isbase = false;
    mutable bool qcpplottablelegenditem_cliprect_isbase = false;
    mutable bool qcpplottablelegenditem_selectevent_isbase = false;
    mutable bool qcpplottablelegenditem_deselectevent_isbase = false;
    mutable bool qcpplottablelegenditem_update_isbase = false;
    mutable bool qcpplottablelegenditem_maximumoutersizehint_isbase = false;
    mutable bool qcpplottablelegenditem_elements_isbase = false;
    mutable bool qcpplottablelegenditem_calculateautomargin_isbase = false;
    mutable bool qcpplottablelegenditem_layoutchanged_isbase = false;
    mutable bool qcpplottablelegenditem_parentplotinitialized_isbase = false;
    mutable bool qcpplottablelegenditem_mousepressevent_isbase = false;
    mutable bool qcpplottablelegenditem_mousemoveevent_isbase = false;
    mutable bool qcpplottablelegenditem_mousereleaseevent_isbase = false;
    mutable bool qcpplottablelegenditem_mousedoubleclickevent_isbase = false;
    mutable bool qcpplottablelegenditem_wheelevent_isbase = false;
    mutable bool qcpplottablelegenditem_event_isbase = false;
    mutable bool qcpplottablelegenditem_eventfilter_isbase = false;
    mutable bool qcpplottablelegenditem_timerevent_isbase = false;
    mutable bool qcpplottablelegenditem_childevent_isbase = false;
    mutable bool qcpplottablelegenditem_customevent_isbase = false;
    mutable bool qcpplottablelegenditem_connectnotify_isbase = false;
    mutable bool qcpplottablelegenditem_disconnectnotify_isbase = false;
    mutable bool qcpplottablelegenditem_geticonborderpen_isbase = false;
    mutable bool qcpplottablelegenditem_gettextcolor_isbase = false;
    mutable bool qcpplottablelegenditem_getfont_isbase = false;
    mutable bool qcpplottablelegenditem_initializeparentplot_isbase = false;
    mutable bool qcpplottablelegenditem_setparentlayerable_isbase = false;
    mutable bool qcpplottablelegenditem_movetolayer_isbase = false;
    mutable bool qcpplottablelegenditem_applyantialiasinghint_isbase = false;
    mutable bool qcpplottablelegenditem_sender_isbase = false;
    mutable bool qcpplottablelegenditem_sendersignalindex_isbase = false;
    mutable bool qcpplottablelegenditem_receivers_isbase = false;
    mutable bool qcpplottablelegenditem_issignalconnected_isbase = false;

  public:
    VirtualQCPPlottableLegendItem(QCPLegend* parent, QCPAbstractPlottable* plottable) : QCPPlottableLegendItem(parent, plottable) {};

    ~VirtualQCPPlottableLegendItem() {
        qcpplottablelegenditem_metacall_callback = nullptr;
        qcpplottablelegenditem_draw_callback = nullptr;
        qcpplottablelegenditem_minimumoutersizehint_callback = nullptr;
        qcpplottablelegenditem_selecttest_callback = nullptr;
        qcpplottablelegenditem_selectioncategory_callback = nullptr;
        qcpplottablelegenditem_applydefaultantialiasinghint_callback = nullptr;
        qcpplottablelegenditem_cliprect_callback = nullptr;
        qcpplottablelegenditem_selectevent_callback = nullptr;
        qcpplottablelegenditem_deselectevent_callback = nullptr;
        qcpplottablelegenditem_update_callback = nullptr;
        qcpplottablelegenditem_maximumoutersizehint_callback = nullptr;
        qcpplottablelegenditem_elements_callback = nullptr;
        qcpplottablelegenditem_calculateautomargin_callback = nullptr;
        qcpplottablelegenditem_layoutchanged_callback = nullptr;
        qcpplottablelegenditem_parentplotinitialized_callback = nullptr;
        qcpplottablelegenditem_mousepressevent_callback = nullptr;
        qcpplottablelegenditem_mousemoveevent_callback = nullptr;
        qcpplottablelegenditem_mousereleaseevent_callback = nullptr;
        qcpplottablelegenditem_mousedoubleclickevent_callback = nullptr;
        qcpplottablelegenditem_wheelevent_callback = nullptr;
        qcpplottablelegenditem_event_callback = nullptr;
        qcpplottablelegenditem_eventfilter_callback = nullptr;
        qcpplottablelegenditem_timerevent_callback = nullptr;
        qcpplottablelegenditem_childevent_callback = nullptr;
        qcpplottablelegenditem_customevent_callback = nullptr;
        qcpplottablelegenditem_connectnotify_callback = nullptr;
        qcpplottablelegenditem_disconnectnotify_callback = nullptr;
        qcpplottablelegenditem_geticonborderpen_callback = nullptr;
        qcpplottablelegenditem_gettextcolor_callback = nullptr;
        qcpplottablelegenditem_getfont_callback = nullptr;
        qcpplottablelegenditem_initializeparentplot_callback = nullptr;
        qcpplottablelegenditem_setparentlayerable_callback = nullptr;
        qcpplottablelegenditem_movetolayer_callback = nullptr;
        qcpplottablelegenditem_applyantialiasinghint_callback = nullptr;
        qcpplottablelegenditem_sender_callback = nullptr;
        qcpplottablelegenditem_sendersignalindex_callback = nullptr;
        qcpplottablelegenditem_receivers_callback = nullptr;
        qcpplottablelegenditem_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPPlottableLegendItem_Metacall_Callback(QCPPlottableLegendItem_Metacall_Callback cb) { qcpplottablelegenditem_metacall_callback = cb; }
    inline void setQCPPlottableLegendItem_Draw_Callback(QCPPlottableLegendItem_Draw_Callback cb) { qcpplottablelegenditem_draw_callback = cb; }
    inline void setQCPPlottableLegendItem_MinimumOuterSizeHint_Callback(QCPPlottableLegendItem_MinimumOuterSizeHint_Callback cb) { qcpplottablelegenditem_minimumoutersizehint_callback = cb; }
    inline void setQCPPlottableLegendItem_SelectTest_Callback(QCPPlottableLegendItem_SelectTest_Callback cb) { qcpplottablelegenditem_selecttest_callback = cb; }
    inline void setQCPPlottableLegendItem_SelectionCategory_Callback(QCPPlottableLegendItem_SelectionCategory_Callback cb) { qcpplottablelegenditem_selectioncategory_callback = cb; }
    inline void setQCPPlottableLegendItem_ApplyDefaultAntialiasingHint_Callback(QCPPlottableLegendItem_ApplyDefaultAntialiasingHint_Callback cb) { qcpplottablelegenditem_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPPlottableLegendItem_ClipRect_Callback(QCPPlottableLegendItem_ClipRect_Callback cb) { qcpplottablelegenditem_cliprect_callback = cb; }
    inline void setQCPPlottableLegendItem_SelectEvent_Callback(QCPPlottableLegendItem_SelectEvent_Callback cb) { qcpplottablelegenditem_selectevent_callback = cb; }
    inline void setQCPPlottableLegendItem_DeselectEvent_Callback(QCPPlottableLegendItem_DeselectEvent_Callback cb) { qcpplottablelegenditem_deselectevent_callback = cb; }
    inline void setQCPPlottableLegendItem_Update_Callback(QCPPlottableLegendItem_Update_Callback cb) { qcpplottablelegenditem_update_callback = cb; }
    inline void setQCPPlottableLegendItem_MaximumOuterSizeHint_Callback(QCPPlottableLegendItem_MaximumOuterSizeHint_Callback cb) { qcpplottablelegenditem_maximumoutersizehint_callback = cb; }
    inline void setQCPPlottableLegendItem_Elements_Callback(QCPPlottableLegendItem_Elements_Callback cb) { qcpplottablelegenditem_elements_callback = cb; }
    inline void setQCPPlottableLegendItem_CalculateAutoMargin_Callback(QCPPlottableLegendItem_CalculateAutoMargin_Callback cb) { qcpplottablelegenditem_calculateautomargin_callback = cb; }
    inline void setQCPPlottableLegendItem_LayoutChanged_Callback(QCPPlottableLegendItem_LayoutChanged_Callback cb) { qcpplottablelegenditem_layoutchanged_callback = cb; }
    inline void setQCPPlottableLegendItem_ParentPlotInitialized_Callback(QCPPlottableLegendItem_ParentPlotInitialized_Callback cb) { qcpplottablelegenditem_parentplotinitialized_callback = cb; }
    inline void setQCPPlottableLegendItem_MousePressEvent_Callback(QCPPlottableLegendItem_MousePressEvent_Callback cb) { qcpplottablelegenditem_mousepressevent_callback = cb; }
    inline void setQCPPlottableLegendItem_MouseMoveEvent_Callback(QCPPlottableLegendItem_MouseMoveEvent_Callback cb) { qcpplottablelegenditem_mousemoveevent_callback = cb; }
    inline void setQCPPlottableLegendItem_MouseReleaseEvent_Callback(QCPPlottableLegendItem_MouseReleaseEvent_Callback cb) { qcpplottablelegenditem_mousereleaseevent_callback = cb; }
    inline void setQCPPlottableLegendItem_MouseDoubleClickEvent_Callback(QCPPlottableLegendItem_MouseDoubleClickEvent_Callback cb) { qcpplottablelegenditem_mousedoubleclickevent_callback = cb; }
    inline void setQCPPlottableLegendItem_WheelEvent_Callback(QCPPlottableLegendItem_WheelEvent_Callback cb) { qcpplottablelegenditem_wheelevent_callback = cb; }
    inline void setQCPPlottableLegendItem_Event_Callback(QCPPlottableLegendItem_Event_Callback cb) { qcpplottablelegenditem_event_callback = cb; }
    inline void setQCPPlottableLegendItem_EventFilter_Callback(QCPPlottableLegendItem_EventFilter_Callback cb) { qcpplottablelegenditem_eventfilter_callback = cb; }
    inline void setQCPPlottableLegendItem_TimerEvent_Callback(QCPPlottableLegendItem_TimerEvent_Callback cb) { qcpplottablelegenditem_timerevent_callback = cb; }
    inline void setQCPPlottableLegendItem_ChildEvent_Callback(QCPPlottableLegendItem_ChildEvent_Callback cb) { qcpplottablelegenditem_childevent_callback = cb; }
    inline void setQCPPlottableLegendItem_CustomEvent_Callback(QCPPlottableLegendItem_CustomEvent_Callback cb) { qcpplottablelegenditem_customevent_callback = cb; }
    inline void setQCPPlottableLegendItem_ConnectNotify_Callback(QCPPlottableLegendItem_ConnectNotify_Callback cb) { qcpplottablelegenditem_connectnotify_callback = cb; }
    inline void setQCPPlottableLegendItem_DisconnectNotify_Callback(QCPPlottableLegendItem_DisconnectNotify_Callback cb) { qcpplottablelegenditem_disconnectnotify_callback = cb; }
    inline void setQCPPlottableLegendItem_GetIconBorderPen_Callback(QCPPlottableLegendItem_GetIconBorderPen_Callback cb) { qcpplottablelegenditem_geticonborderpen_callback = cb; }
    inline void setQCPPlottableLegendItem_GetTextColor_Callback(QCPPlottableLegendItem_GetTextColor_Callback cb) { qcpplottablelegenditem_gettextcolor_callback = cb; }
    inline void setQCPPlottableLegendItem_GetFont_Callback(QCPPlottableLegendItem_GetFont_Callback cb) { qcpplottablelegenditem_getfont_callback = cb; }
    inline void setQCPPlottableLegendItem_InitializeParentPlot_Callback(QCPPlottableLegendItem_InitializeParentPlot_Callback cb) { qcpplottablelegenditem_initializeparentplot_callback = cb; }
    inline void setQCPPlottableLegendItem_SetParentLayerable_Callback(QCPPlottableLegendItem_SetParentLayerable_Callback cb) { qcpplottablelegenditem_setparentlayerable_callback = cb; }
    inline void setQCPPlottableLegendItem_MoveToLayer_Callback(QCPPlottableLegendItem_MoveToLayer_Callback cb) { qcpplottablelegenditem_movetolayer_callback = cb; }
    inline void setQCPPlottableLegendItem_ApplyAntialiasingHint_Callback(QCPPlottableLegendItem_ApplyAntialiasingHint_Callback cb) { qcpplottablelegenditem_applyantialiasinghint_callback = cb; }
    inline void setQCPPlottableLegendItem_Sender_Callback(QCPPlottableLegendItem_Sender_Callback cb) { qcpplottablelegenditem_sender_callback = cb; }
    inline void setQCPPlottableLegendItem_SenderSignalIndex_Callback(QCPPlottableLegendItem_SenderSignalIndex_Callback cb) { qcpplottablelegenditem_sendersignalindex_callback = cb; }
    inline void setQCPPlottableLegendItem_Receivers_Callback(QCPPlottableLegendItem_Receivers_Callback cb) { qcpplottablelegenditem_receivers_callback = cb; }
    inline void setQCPPlottableLegendItem_IsSignalConnected_Callback(QCPPlottableLegendItem_IsSignalConnected_Callback cb) { qcpplottablelegenditem_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPPlottableLegendItem_Metacall_IsBase(bool value) const { qcpplottablelegenditem_metacall_isbase = value; }
    inline void setQCPPlottableLegendItem_Draw_IsBase(bool value) const { qcpplottablelegenditem_draw_isbase = value; }
    inline void setQCPPlottableLegendItem_MinimumOuterSizeHint_IsBase(bool value) const { qcpplottablelegenditem_minimumoutersizehint_isbase = value; }
    inline void setQCPPlottableLegendItem_SelectTest_IsBase(bool value) const { qcpplottablelegenditem_selecttest_isbase = value; }
    inline void setQCPPlottableLegendItem_SelectionCategory_IsBase(bool value) const { qcpplottablelegenditem_selectioncategory_isbase = value; }
    inline void setQCPPlottableLegendItem_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcpplottablelegenditem_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPPlottableLegendItem_ClipRect_IsBase(bool value) const { qcpplottablelegenditem_cliprect_isbase = value; }
    inline void setQCPPlottableLegendItem_SelectEvent_IsBase(bool value) const { qcpplottablelegenditem_selectevent_isbase = value; }
    inline void setQCPPlottableLegendItem_DeselectEvent_IsBase(bool value) const { qcpplottablelegenditem_deselectevent_isbase = value; }
    inline void setQCPPlottableLegendItem_Update_IsBase(bool value) const { qcpplottablelegenditem_update_isbase = value; }
    inline void setQCPPlottableLegendItem_MaximumOuterSizeHint_IsBase(bool value) const { qcpplottablelegenditem_maximumoutersizehint_isbase = value; }
    inline void setQCPPlottableLegendItem_Elements_IsBase(bool value) const { qcpplottablelegenditem_elements_isbase = value; }
    inline void setQCPPlottableLegendItem_CalculateAutoMargin_IsBase(bool value) const { qcpplottablelegenditem_calculateautomargin_isbase = value; }
    inline void setQCPPlottableLegendItem_LayoutChanged_IsBase(bool value) const { qcpplottablelegenditem_layoutchanged_isbase = value; }
    inline void setQCPPlottableLegendItem_ParentPlotInitialized_IsBase(bool value) const { qcpplottablelegenditem_parentplotinitialized_isbase = value; }
    inline void setQCPPlottableLegendItem_MousePressEvent_IsBase(bool value) const { qcpplottablelegenditem_mousepressevent_isbase = value; }
    inline void setQCPPlottableLegendItem_MouseMoveEvent_IsBase(bool value) const { qcpplottablelegenditem_mousemoveevent_isbase = value; }
    inline void setQCPPlottableLegendItem_MouseReleaseEvent_IsBase(bool value) const { qcpplottablelegenditem_mousereleaseevent_isbase = value; }
    inline void setQCPPlottableLegendItem_MouseDoubleClickEvent_IsBase(bool value) const { qcpplottablelegenditem_mousedoubleclickevent_isbase = value; }
    inline void setQCPPlottableLegendItem_WheelEvent_IsBase(bool value) const { qcpplottablelegenditem_wheelevent_isbase = value; }
    inline void setQCPPlottableLegendItem_Event_IsBase(bool value) const { qcpplottablelegenditem_event_isbase = value; }
    inline void setQCPPlottableLegendItem_EventFilter_IsBase(bool value) const { qcpplottablelegenditem_eventfilter_isbase = value; }
    inline void setQCPPlottableLegendItem_TimerEvent_IsBase(bool value) const { qcpplottablelegenditem_timerevent_isbase = value; }
    inline void setQCPPlottableLegendItem_ChildEvent_IsBase(bool value) const { qcpplottablelegenditem_childevent_isbase = value; }
    inline void setQCPPlottableLegendItem_CustomEvent_IsBase(bool value) const { qcpplottablelegenditem_customevent_isbase = value; }
    inline void setQCPPlottableLegendItem_ConnectNotify_IsBase(bool value) const { qcpplottablelegenditem_connectnotify_isbase = value; }
    inline void setQCPPlottableLegendItem_DisconnectNotify_IsBase(bool value) const { qcpplottablelegenditem_disconnectnotify_isbase = value; }
    inline void setQCPPlottableLegendItem_GetIconBorderPen_IsBase(bool value) const { qcpplottablelegenditem_geticonborderpen_isbase = value; }
    inline void setQCPPlottableLegendItem_GetTextColor_IsBase(bool value) const { qcpplottablelegenditem_gettextcolor_isbase = value; }
    inline void setQCPPlottableLegendItem_GetFont_IsBase(bool value) const { qcpplottablelegenditem_getfont_isbase = value; }
    inline void setQCPPlottableLegendItem_InitializeParentPlot_IsBase(bool value) const { qcpplottablelegenditem_initializeparentplot_isbase = value; }
    inline void setQCPPlottableLegendItem_SetParentLayerable_IsBase(bool value) const { qcpplottablelegenditem_setparentlayerable_isbase = value; }
    inline void setQCPPlottableLegendItem_MoveToLayer_IsBase(bool value) const { qcpplottablelegenditem_movetolayer_isbase = value; }
    inline void setQCPPlottableLegendItem_ApplyAntialiasingHint_IsBase(bool value) const { qcpplottablelegenditem_applyantialiasinghint_isbase = value; }
    inline void setQCPPlottableLegendItem_Sender_IsBase(bool value) const { qcpplottablelegenditem_sender_isbase = value; }
    inline void setQCPPlottableLegendItem_SenderSignalIndex_IsBase(bool value) const { qcpplottablelegenditem_sendersignalindex_isbase = value; }
    inline void setQCPPlottableLegendItem_Receivers_IsBase(bool value) const { qcpplottablelegenditem_receivers_isbase = value; }
    inline void setQCPPlottableLegendItem_IsSignalConnected_IsBase(bool value) const { qcpplottablelegenditem_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpplottablelegenditem_metacall_isbase) {
            qcpplottablelegenditem_metacall_isbase = false;
            return QCPPlottableLegendItem::qt_metacall(param1, param2, param3);
        } else if (qcpplottablelegenditem_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpplottablelegenditem_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPPlottableLegendItem::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcpplottablelegenditem_draw_isbase) {
            qcpplottablelegenditem_draw_isbase = false;
            QCPPlottableLegendItem::draw(painter);
        } else if (qcpplottablelegenditem_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpplottablelegenditem_draw_callback(this, cbval1);
        } else {
            QCPPlottableLegendItem::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize minimumOuterSizeHint() const override {
        if (qcpplottablelegenditem_minimumoutersizehint_isbase) {
            qcpplottablelegenditem_minimumoutersizehint_isbase = false;
            return QCPPlottableLegendItem::minimumOuterSizeHint();
        } else if (qcpplottablelegenditem_minimumoutersizehint_callback != nullptr) {
            QSize* callback_ret = qcpplottablelegenditem_minimumoutersizehint_callback();
            return *callback_ret;
        } else {
            return QCPPlottableLegendItem::minimumOuterSizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcpplottablelegenditem_selecttest_isbase) {
            qcpplottablelegenditem_selecttest_isbase = false;
            return QCPPlottableLegendItem::selectTest(pos, onlySelectable, details);
        } else if (qcpplottablelegenditem_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcpplottablelegenditem_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPPlottableLegendItem::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcpplottablelegenditem_selectioncategory_isbase) {
            qcpplottablelegenditem_selectioncategory_isbase = false;
            return QCPPlottableLegendItem::selectionCategory();
        } else if (qcpplottablelegenditem_selectioncategory_callback != nullptr) {
            int callback_ret = qcpplottablelegenditem_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPPlottableLegendItem::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcpplottablelegenditem_applydefaultantialiasinghint_isbase) {
            qcpplottablelegenditem_applydefaultantialiasinghint_isbase = false;
            QCPPlottableLegendItem::applyDefaultAntialiasingHint(painter);
        } else if (qcpplottablelegenditem_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpplottablelegenditem_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPPlottableLegendItem::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcpplottablelegenditem_cliprect_isbase) {
            qcpplottablelegenditem_cliprect_isbase = false;
            return QCPPlottableLegendItem::clipRect();
        } else if (qcpplottablelegenditem_cliprect_callback != nullptr) {
            QRect* callback_ret = qcpplottablelegenditem_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPPlottableLegendItem::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcpplottablelegenditem_selectevent_isbase) {
            qcpplottablelegenditem_selectevent_isbase = false;
            QCPPlottableLegendItem::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcpplottablelegenditem_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcpplottablelegenditem_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPPlottableLegendItem::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcpplottablelegenditem_deselectevent_isbase) {
            qcpplottablelegenditem_deselectevent_isbase = false;
            QCPPlottableLegendItem::deselectEvent(selectionStateChanged);
        } else if (qcpplottablelegenditem_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcpplottablelegenditem_deselectevent_callback(this, cbval1);
        } else {
            QCPPlottableLegendItem::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void update(QCPLayoutElement::UpdatePhase phase) override {
        if (qcpplottablelegenditem_update_isbase) {
            qcpplottablelegenditem_update_isbase = false;
            QCPPlottableLegendItem::update(phase);
        } else if (qcpplottablelegenditem_update_callback != nullptr) {
            int cbval1 = static_cast<int>(phase);

            qcpplottablelegenditem_update_callback(this, cbval1);
        } else {
            QCPPlottableLegendItem::update(phase);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize maximumOuterSizeHint() const override {
        if (qcpplottablelegenditem_maximumoutersizehint_isbase) {
            qcpplottablelegenditem_maximumoutersizehint_isbase = false;
            return QCPPlottableLegendItem::maximumOuterSizeHint();
        } else if (qcpplottablelegenditem_maximumoutersizehint_callback != nullptr) {
            QSize* callback_ret = qcpplottablelegenditem_maximumoutersizehint_callback();
            return *callback_ret;
        } else {
            return QCPPlottableLegendItem::maximumOuterSizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QList<QCPLayoutElement*> elements(bool recursive) const override {
        if (qcpplottablelegenditem_elements_isbase) {
            qcpplottablelegenditem_elements_isbase = false;
            return QCPPlottableLegendItem::elements(recursive);
        } else if (qcpplottablelegenditem_elements_callback != nullptr) {
            bool cbval1 = recursive;

            QCPLayoutElement** callback_ret = qcpplottablelegenditem_elements_callback(this, cbval1);
            QList<QCPLayoutElement*> callback_ret_QList;
            // Iterate until null pointer sentinel
            for (QCPLayoutElement** ptridx = callback_ret; *ptridx != nullptr; ptridx++) {
                callback_ret_QList.push_back(*ptridx);
            }
            free(callback_ret);
            return callback_ret_QList;
        } else {
            return QCPPlottableLegendItem::elements(recursive);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int calculateAutoMargin(QCP::MarginSide side) override {
        if (qcpplottablelegenditem_calculateautomargin_isbase) {
            qcpplottablelegenditem_calculateautomargin_isbase = false;
            return QCPPlottableLegendItem::calculateAutoMargin(side);
        } else if (qcpplottablelegenditem_calculateautomargin_callback != nullptr) {
            int cbval1 = static_cast<int>(side);

            int callback_ret = qcpplottablelegenditem_calculateautomargin_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPPlottableLegendItem::calculateAutoMargin(side);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void layoutChanged() override {
        if (qcpplottablelegenditem_layoutchanged_isbase) {
            qcpplottablelegenditem_layoutchanged_isbase = false;
            QCPPlottableLegendItem::layoutChanged();
        } else if (qcpplottablelegenditem_layoutchanged_callback != nullptr) {
            qcpplottablelegenditem_layoutchanged_callback();
        } else {
            QCPPlottableLegendItem::layoutChanged();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcpplottablelegenditem_parentplotinitialized_isbase) {
            qcpplottablelegenditem_parentplotinitialized_isbase = false;
            QCPPlottableLegendItem::parentPlotInitialized(parentPlot);
        } else if (qcpplottablelegenditem_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpplottablelegenditem_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPPlottableLegendItem::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpplottablelegenditem_mousepressevent_isbase) {
            qcpplottablelegenditem_mousepressevent_isbase = false;
            QCPPlottableLegendItem::mousePressEvent(event, details);
        } else if (qcpplottablelegenditem_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpplottablelegenditem_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPPlottableLegendItem::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpplottablelegenditem_mousemoveevent_isbase) {
            qcpplottablelegenditem_mousemoveevent_isbase = false;
            QCPPlottableLegendItem::mouseMoveEvent(event, startPos);
        } else if (qcpplottablelegenditem_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpplottablelegenditem_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPPlottableLegendItem::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpplottablelegenditem_mousereleaseevent_isbase) {
            qcpplottablelegenditem_mousereleaseevent_isbase = false;
            QCPPlottableLegendItem::mouseReleaseEvent(event, startPos);
        } else if (qcpplottablelegenditem_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpplottablelegenditem_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPPlottableLegendItem::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpplottablelegenditem_mousedoubleclickevent_isbase) {
            qcpplottablelegenditem_mousedoubleclickevent_isbase = false;
            QCPPlottableLegendItem::mouseDoubleClickEvent(event, details);
        } else if (qcpplottablelegenditem_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpplottablelegenditem_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPPlottableLegendItem::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcpplottablelegenditem_wheelevent_isbase) {
            qcpplottablelegenditem_wheelevent_isbase = false;
            QCPPlottableLegendItem::wheelEvent(event);
        } else if (qcpplottablelegenditem_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcpplottablelegenditem_wheelevent_callback(this, cbval1);
        } else {
            QCPPlottableLegendItem::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpplottablelegenditem_event_isbase) {
            qcpplottablelegenditem_event_isbase = false;
            return QCPPlottableLegendItem::event(event);
        } else if (qcpplottablelegenditem_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpplottablelegenditem_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPPlottableLegendItem::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpplottablelegenditem_eventfilter_isbase) {
            qcpplottablelegenditem_eventfilter_isbase = false;
            return QCPPlottableLegendItem::eventFilter(watched, event);
        } else if (qcpplottablelegenditem_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpplottablelegenditem_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPPlottableLegendItem::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpplottablelegenditem_timerevent_isbase) {
            qcpplottablelegenditem_timerevent_isbase = false;
            QCPPlottableLegendItem::timerEvent(event);
        } else if (qcpplottablelegenditem_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpplottablelegenditem_timerevent_callback(this, cbval1);
        } else {
            QCPPlottableLegendItem::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpplottablelegenditem_childevent_isbase) {
            qcpplottablelegenditem_childevent_isbase = false;
            QCPPlottableLegendItem::childEvent(event);
        } else if (qcpplottablelegenditem_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpplottablelegenditem_childevent_callback(this, cbval1);
        } else {
            QCPPlottableLegendItem::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpplottablelegenditem_customevent_isbase) {
            qcpplottablelegenditem_customevent_isbase = false;
            QCPPlottableLegendItem::customEvent(event);
        } else if (qcpplottablelegenditem_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpplottablelegenditem_customevent_callback(this, cbval1);
        } else {
            QCPPlottableLegendItem::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpplottablelegenditem_connectnotify_isbase) {
            qcpplottablelegenditem_connectnotify_isbase = false;
            QCPPlottableLegendItem::connectNotify(signal);
        } else if (qcpplottablelegenditem_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpplottablelegenditem_connectnotify_callback(this, cbval1);
        } else {
            QCPPlottableLegendItem::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpplottablelegenditem_disconnectnotify_isbase) {
            qcpplottablelegenditem_disconnectnotify_isbase = false;
            QCPPlottableLegendItem::disconnectNotify(signal);
        } else if (qcpplottablelegenditem_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpplottablelegenditem_disconnectnotify_callback(this, cbval1);
        } else {
            QCPPlottableLegendItem::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    QPen getIconBorderPen() const {
        if (qcpplottablelegenditem_geticonborderpen_isbase) {
            qcpplottablelegenditem_geticonborderpen_isbase = false;
            return QCPPlottableLegendItem::getIconBorderPen();
        } else if (qcpplottablelegenditem_geticonborderpen_callback != nullptr) {
            QPen* callback_ret = qcpplottablelegenditem_geticonborderpen_callback();
            return *callback_ret;
        } else {
            return QCPPlottableLegendItem::getIconBorderPen();
        }
    }

    // Virtual method for C ABI access and custom callback
    QColor getTextColor() const {
        if (qcpplottablelegenditem_gettextcolor_isbase) {
            qcpplottablelegenditem_gettextcolor_isbase = false;
            return QCPPlottableLegendItem::getTextColor();
        } else if (qcpplottablelegenditem_gettextcolor_callback != nullptr) {
            QColor* callback_ret = qcpplottablelegenditem_gettextcolor_callback();
            return *callback_ret;
        } else {
            return QCPPlottableLegendItem::getTextColor();
        }
    }

    // Virtual method for C ABI access and custom callback
    QFont getFont() const {
        if (qcpplottablelegenditem_getfont_isbase) {
            qcpplottablelegenditem_getfont_isbase = false;
            return QCPPlottableLegendItem::getFont();
        } else if (qcpplottablelegenditem_getfont_callback != nullptr) {
            QFont* callback_ret = qcpplottablelegenditem_getfont_callback();
            return *callback_ret;
        } else {
            return QCPPlottableLegendItem::getFont();
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcpplottablelegenditem_initializeparentplot_isbase) {
            qcpplottablelegenditem_initializeparentplot_isbase = false;
            QCPPlottableLegendItem::initializeParentPlot(parentPlot);
        } else if (qcpplottablelegenditem_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpplottablelegenditem_initializeparentplot_callback(this, cbval1);
        } else {
            QCPPlottableLegendItem::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcpplottablelegenditem_setparentlayerable_isbase) {
            qcpplottablelegenditem_setparentlayerable_isbase = false;
            QCPPlottableLegendItem::setParentLayerable(parentLayerable);
        } else if (qcpplottablelegenditem_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcpplottablelegenditem_setparentlayerable_callback(this, cbval1);
        } else {
            QCPPlottableLegendItem::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcpplottablelegenditem_movetolayer_isbase) {
            qcpplottablelegenditem_movetolayer_isbase = false;
            return QCPPlottableLegendItem::moveToLayer(layer, prepend);
        } else if (qcpplottablelegenditem_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcpplottablelegenditem_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPPlottableLegendItem::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcpplottablelegenditem_applyantialiasinghint_isbase) {
            qcpplottablelegenditem_applyantialiasinghint_isbase = false;
            QCPPlottableLegendItem::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcpplottablelegenditem_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcpplottablelegenditem_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPPlottableLegendItem::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpplottablelegenditem_sender_isbase) {
            qcpplottablelegenditem_sender_isbase = false;
            return QCPPlottableLegendItem::sender();
        } else if (qcpplottablelegenditem_sender_callback != nullptr) {
            QObject* callback_ret = qcpplottablelegenditem_sender_callback();
            return callback_ret;
        } else {
            return QCPPlottableLegendItem::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpplottablelegenditem_sendersignalindex_isbase) {
            qcpplottablelegenditem_sendersignalindex_isbase = false;
            return QCPPlottableLegendItem::senderSignalIndex();
        } else if (qcpplottablelegenditem_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpplottablelegenditem_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPPlottableLegendItem::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpplottablelegenditem_receivers_isbase) {
            qcpplottablelegenditem_receivers_isbase = false;
            return QCPPlottableLegendItem::receivers(signal);
        } else if (qcpplottablelegenditem_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpplottablelegenditem_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPPlottableLegendItem::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpplottablelegenditem_issignalconnected_isbase) {
            qcpplottablelegenditem_issignalconnected_isbase = false;
            return QCPPlottableLegendItem::isSignalConnected(signal);
        } else if (qcpplottablelegenditem_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpplottablelegenditem_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPPlottableLegendItem::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPPlottableLegendItem_Draw(QCPPlottableLegendItem* self, QCPPainter* painter);
    friend void QCPPlottableLegendItem_QBaseDraw(QCPPlottableLegendItem* self, QCPPainter* painter);
    friend QSize* QCPPlottableLegendItem_MinimumOuterSizeHint(const QCPPlottableLegendItem* self);
    friend QSize* QCPPlottableLegendItem_QBaseMinimumOuterSizeHint(const QCPPlottableLegendItem* self);
    friend int QCPPlottableLegendItem_SelectionCategory(const QCPPlottableLegendItem* self);
    friend int QCPPlottableLegendItem_QBaseSelectionCategory(const QCPPlottableLegendItem* self);
    friend void QCPPlottableLegendItem_ApplyDefaultAntialiasingHint(const QCPPlottableLegendItem* self, QCPPainter* painter);
    friend void QCPPlottableLegendItem_QBaseApplyDefaultAntialiasingHint(const QCPPlottableLegendItem* self, QCPPainter* painter);
    friend QRect* QCPPlottableLegendItem_ClipRect(const QCPPlottableLegendItem* self);
    friend QRect* QCPPlottableLegendItem_QBaseClipRect(const QCPPlottableLegendItem* self);
    friend void QCPPlottableLegendItem_SelectEvent(QCPPlottableLegendItem* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPPlottableLegendItem_QBaseSelectEvent(QCPPlottableLegendItem* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPPlottableLegendItem_DeselectEvent(QCPPlottableLegendItem* self, bool* selectionStateChanged);
    friend void QCPPlottableLegendItem_QBaseDeselectEvent(QCPPlottableLegendItem* self, bool* selectionStateChanged);
    friend int QCPPlottableLegendItem_CalculateAutoMargin(QCPPlottableLegendItem* self, int side);
    friend int QCPPlottableLegendItem_QBaseCalculateAutoMargin(QCPPlottableLegendItem* self, int side);
    friend void QCPPlottableLegendItem_LayoutChanged(QCPPlottableLegendItem* self);
    friend void QCPPlottableLegendItem_QBaseLayoutChanged(QCPPlottableLegendItem* self);
    friend void QCPPlottableLegendItem_ParentPlotInitialized(QCPPlottableLegendItem* self, QCustomPlot* parentPlot);
    friend void QCPPlottableLegendItem_QBaseParentPlotInitialized(QCPPlottableLegendItem* self, QCustomPlot* parentPlot);
    friend void QCPPlottableLegendItem_MousePressEvent(QCPPlottableLegendItem* self, QMouseEvent* event, const QVariant* details);
    friend void QCPPlottableLegendItem_QBaseMousePressEvent(QCPPlottableLegendItem* self, QMouseEvent* event, const QVariant* details);
    friend void QCPPlottableLegendItem_MouseMoveEvent(QCPPlottableLegendItem* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPPlottableLegendItem_QBaseMouseMoveEvent(QCPPlottableLegendItem* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPPlottableLegendItem_MouseReleaseEvent(QCPPlottableLegendItem* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPPlottableLegendItem_QBaseMouseReleaseEvent(QCPPlottableLegendItem* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPPlottableLegendItem_MouseDoubleClickEvent(QCPPlottableLegendItem* self, QMouseEvent* event, const QVariant* details);
    friend void QCPPlottableLegendItem_QBaseMouseDoubleClickEvent(QCPPlottableLegendItem* self, QMouseEvent* event, const QVariant* details);
    friend void QCPPlottableLegendItem_WheelEvent(QCPPlottableLegendItem* self, QWheelEvent* event);
    friend void QCPPlottableLegendItem_QBaseWheelEvent(QCPPlottableLegendItem* self, QWheelEvent* event);
    friend void QCPPlottableLegendItem_TimerEvent(QCPPlottableLegendItem* self, QTimerEvent* event);
    friend void QCPPlottableLegendItem_QBaseTimerEvent(QCPPlottableLegendItem* self, QTimerEvent* event);
    friend void QCPPlottableLegendItem_ChildEvent(QCPPlottableLegendItem* self, QChildEvent* event);
    friend void QCPPlottableLegendItem_QBaseChildEvent(QCPPlottableLegendItem* self, QChildEvent* event);
    friend void QCPPlottableLegendItem_CustomEvent(QCPPlottableLegendItem* self, QEvent* event);
    friend void QCPPlottableLegendItem_QBaseCustomEvent(QCPPlottableLegendItem* self, QEvent* event);
    friend void QCPPlottableLegendItem_ConnectNotify(QCPPlottableLegendItem* self, const QMetaMethod* signal);
    friend void QCPPlottableLegendItem_QBaseConnectNotify(QCPPlottableLegendItem* self, const QMetaMethod* signal);
    friend void QCPPlottableLegendItem_DisconnectNotify(QCPPlottableLegendItem* self, const QMetaMethod* signal);
    friend void QCPPlottableLegendItem_QBaseDisconnectNotify(QCPPlottableLegendItem* self, const QMetaMethod* signal);
    friend QPen* QCPPlottableLegendItem_GetIconBorderPen(const QCPPlottableLegendItem* self);
    friend QPen* QCPPlottableLegendItem_QBaseGetIconBorderPen(const QCPPlottableLegendItem* self);
    friend QColor* QCPPlottableLegendItem_GetTextColor(const QCPPlottableLegendItem* self);
    friend QColor* QCPPlottableLegendItem_QBaseGetTextColor(const QCPPlottableLegendItem* self);
    friend QFont* QCPPlottableLegendItem_GetFont(const QCPPlottableLegendItem* self);
    friend QFont* QCPPlottableLegendItem_QBaseGetFont(const QCPPlottableLegendItem* self);
    friend void QCPPlottableLegendItem_InitializeParentPlot(QCPPlottableLegendItem* self, QCustomPlot* parentPlot);
    friend void QCPPlottableLegendItem_QBaseInitializeParentPlot(QCPPlottableLegendItem* self, QCustomPlot* parentPlot);
    friend void QCPPlottableLegendItem_SetParentLayerable(QCPPlottableLegendItem* self, QCPLayerable* parentLayerable);
    friend void QCPPlottableLegendItem_QBaseSetParentLayerable(QCPPlottableLegendItem* self, QCPLayerable* parentLayerable);
    friend bool QCPPlottableLegendItem_MoveToLayer(QCPPlottableLegendItem* self, QCPLayer* layer, bool prepend);
    friend bool QCPPlottableLegendItem_QBaseMoveToLayer(QCPPlottableLegendItem* self, QCPLayer* layer, bool prepend);
    friend void QCPPlottableLegendItem_ApplyAntialiasingHint(const QCPPlottableLegendItem* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPPlottableLegendItem_QBaseApplyAntialiasingHint(const QCPPlottableLegendItem* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPPlottableLegendItem_Sender(const QCPPlottableLegendItem* self);
    friend QObject* QCPPlottableLegendItem_QBaseSender(const QCPPlottableLegendItem* self);
    friend int QCPPlottableLegendItem_SenderSignalIndex(const QCPPlottableLegendItem* self);
    friend int QCPPlottableLegendItem_QBaseSenderSignalIndex(const QCPPlottableLegendItem* self);
    friend int QCPPlottableLegendItem_Receivers(const QCPPlottableLegendItem* self, const char* signal);
    friend int QCPPlottableLegendItem_QBaseReceivers(const QCPPlottableLegendItem* self, const char* signal);
    friend bool QCPPlottableLegendItem_IsSignalConnected(const QCPPlottableLegendItem* self, const QMetaMethod* signal);
    friend bool QCPPlottableLegendItem_QBaseIsSignalConnected(const QCPPlottableLegendItem* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPLegend so that we can call protected methods
class VirtualQCPLegend final : public QCPLegend {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPLegend = true;

    // Virtual class public types (including callbacks)
    using QCPLegend_Metacall_Callback = int (*)(QCPLegend*, int, int, void**);
    using QCPLegend_SelectTest_Callback = double (*)(const QCPLegend*, QPointF*, bool, QVariant*);
    using QCPLegend_ParentPlotInitialized_Callback = void (*)(QCPLegend*, QCustomPlot*);
    using QCPLegend_SelectionCategory_Callback = int (*)();
    using QCPLegend_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPLegend*, QCPPainter*);
    using QCPLegend_Draw_Callback = void (*)(QCPLegend*, QCPPainter*);
    using QCPLegend_SelectEvent_Callback = void (*)(QCPLegend*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPLegend_DeselectEvent_Callback = void (*)(QCPLegend*, bool*);
    using QCPLegend_UpdateLayout_Callback = void (*)();
    using QCPLegend_ElementCount_Callback = int (*)();
    using QCPLegend_ElementAt_Callback = QCPLayoutElement* (*)(const QCPLegend*, int);
    using QCPLegend_TakeAt_Callback = QCPLayoutElement* (*)(QCPLegend*, int);
    using QCPLegend_Take_Callback = bool (*)(QCPLegend*, QCPLayoutElement*);
    using QCPLegend_Elements_Callback = QCPLayoutElement** (*)(const QCPLegend*, bool);
    using QCPLegend_Simplify_Callback = void (*)();
    using QCPLegend_MinimumOuterSizeHint_Callback = QSize* (*)();
    using QCPLegend_MaximumOuterSizeHint_Callback = QSize* (*)();
    using QCPLegend_Update_Callback = void (*)(QCPLegend*, int);
    using QCPLegend_CalculateAutoMargin_Callback = int (*)(QCPLegend*, int);
    using QCPLegend_LayoutChanged_Callback = void (*)();
    using QCPLegend_ClipRect_Callback = QRect* (*)();
    using QCPLegend_MousePressEvent_Callback = void (*)(QCPLegend*, QMouseEvent*, QVariant*);
    using QCPLegend_MouseMoveEvent_Callback = void (*)(QCPLegend*, QMouseEvent*, QPointF*);
    using QCPLegend_MouseReleaseEvent_Callback = void (*)(QCPLegend*, QMouseEvent*, QPointF*);
    using QCPLegend_MouseDoubleClickEvent_Callback = void (*)(QCPLegend*, QMouseEvent*, QVariant*);
    using QCPLegend_WheelEvent_Callback = void (*)(QCPLegend*, QWheelEvent*);
    using QCPLegend_Event_Callback = bool (*)(QCPLegend*, QEvent*);
    using QCPLegend_EventFilter_Callback = bool (*)(QCPLegend*, QObject*, QEvent*);
    using QCPLegend_TimerEvent_Callback = void (*)(QCPLegend*, QTimerEvent*);
    using QCPLegend_ChildEvent_Callback = void (*)(QCPLegend*, QChildEvent*);
    using QCPLegend_CustomEvent_Callback = void (*)(QCPLegend*, QEvent*);
    using QCPLegend_ConnectNotify_Callback = void (*)(QCPLegend*, QMetaMethod*);
    using QCPLegend_DisconnectNotify_Callback = void (*)(QCPLegend*, QMetaMethod*);
    using QCPLegend_GetBorderPen_Callback = QPen* (*)();
    using QCPLegend_GetBrush_Callback = QBrush* (*)();
    using QCPLegend_GetMinimumRowColSizes_Callback = void (*)(const QCPLegend*, libqt_list /* of int */, libqt_list /* of int */);
    using QCPLegend_GetMaximumRowColSizes_Callback = void (*)(const QCPLegend*, libqt_list /* of int */, libqt_list /* of int */);
    using QCPLegend_SizeConstraintsChanged_Callback = void (*)();
    using QCPLegend_AdoptElement_Callback = void (*)(QCPLegend*, QCPLayoutElement*);
    using QCPLegend_ReleaseElement_Callback = void (*)(QCPLegend*, QCPLayoutElement*);
    using QCPLegend_GetSectionSizes_Callback = int* (*)(const QCPLegend*, libqt_list /* of int */, libqt_list /* of int */, libqt_list /* of double */, int);
    using QCPLegend_InitializeParentPlot_Callback = void (*)(QCPLegend*, QCustomPlot*);
    using QCPLegend_SetParentLayerable_Callback = void (*)(QCPLegend*, QCPLayerable*);
    using QCPLegend_MoveToLayer_Callback = bool (*)(QCPLegend*, QCPLayer*, bool);
    using QCPLegend_ApplyAntialiasingHint_Callback = void (*)(const QCPLegend*, QCPPainter*, bool, int);
    using QCPLegend_Sender_Callback = QObject* (*)();
    using QCPLegend_SenderSignalIndex_Callback = int (*)();
    using QCPLegend_Receivers_Callback = int (*)(const QCPLegend*, const char*);
    using QCPLegend_IsSignalConnected_Callback = bool (*)(const QCPLegend*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPLegend_Metacall_Callback qcplegend_metacall_callback = nullptr;
    QCPLegend_SelectTest_Callback qcplegend_selecttest_callback = nullptr;
    QCPLegend_ParentPlotInitialized_Callback qcplegend_parentplotinitialized_callback = nullptr;
    QCPLegend_SelectionCategory_Callback qcplegend_selectioncategory_callback = nullptr;
    QCPLegend_ApplyDefaultAntialiasingHint_Callback qcplegend_applydefaultantialiasinghint_callback = nullptr;
    QCPLegend_Draw_Callback qcplegend_draw_callback = nullptr;
    QCPLegend_SelectEvent_Callback qcplegend_selectevent_callback = nullptr;
    QCPLegend_DeselectEvent_Callback qcplegend_deselectevent_callback = nullptr;
    QCPLegend_UpdateLayout_Callback qcplegend_updatelayout_callback = nullptr;
    QCPLegend_ElementCount_Callback qcplegend_elementcount_callback = nullptr;
    QCPLegend_ElementAt_Callback qcplegend_elementat_callback = nullptr;
    QCPLegend_TakeAt_Callback qcplegend_takeat_callback = nullptr;
    QCPLegend_Take_Callback qcplegend_take_callback = nullptr;
    QCPLegend_Elements_Callback qcplegend_elements_callback = nullptr;
    QCPLegend_Simplify_Callback qcplegend_simplify_callback = nullptr;
    QCPLegend_MinimumOuterSizeHint_Callback qcplegend_minimumoutersizehint_callback = nullptr;
    QCPLegend_MaximumOuterSizeHint_Callback qcplegend_maximumoutersizehint_callback = nullptr;
    QCPLegend_Update_Callback qcplegend_update_callback = nullptr;
    QCPLegend_CalculateAutoMargin_Callback qcplegend_calculateautomargin_callback = nullptr;
    QCPLegend_LayoutChanged_Callback qcplegend_layoutchanged_callback = nullptr;
    QCPLegend_ClipRect_Callback qcplegend_cliprect_callback = nullptr;
    QCPLegend_MousePressEvent_Callback qcplegend_mousepressevent_callback = nullptr;
    QCPLegend_MouseMoveEvent_Callback qcplegend_mousemoveevent_callback = nullptr;
    QCPLegend_MouseReleaseEvent_Callback qcplegend_mousereleaseevent_callback = nullptr;
    QCPLegend_MouseDoubleClickEvent_Callback qcplegend_mousedoubleclickevent_callback = nullptr;
    QCPLegend_WheelEvent_Callback qcplegend_wheelevent_callback = nullptr;
    QCPLegend_Event_Callback qcplegend_event_callback = nullptr;
    QCPLegend_EventFilter_Callback qcplegend_eventfilter_callback = nullptr;
    QCPLegend_TimerEvent_Callback qcplegend_timerevent_callback = nullptr;
    QCPLegend_ChildEvent_Callback qcplegend_childevent_callback = nullptr;
    QCPLegend_CustomEvent_Callback qcplegend_customevent_callback = nullptr;
    QCPLegend_ConnectNotify_Callback qcplegend_connectnotify_callback = nullptr;
    QCPLegend_DisconnectNotify_Callback qcplegend_disconnectnotify_callback = nullptr;
    QCPLegend_GetBorderPen_Callback qcplegend_getborderpen_callback = nullptr;
    QCPLegend_GetBrush_Callback qcplegend_getbrush_callback = nullptr;
    QCPLegend_GetMinimumRowColSizes_Callback qcplegend_getminimumrowcolsizes_callback = nullptr;
    QCPLegend_GetMaximumRowColSizes_Callback qcplegend_getmaximumrowcolsizes_callback = nullptr;
    QCPLegend_SizeConstraintsChanged_Callback qcplegend_sizeconstraintschanged_callback = nullptr;
    QCPLegend_AdoptElement_Callback qcplegend_adoptelement_callback = nullptr;
    QCPLegend_ReleaseElement_Callback qcplegend_releaseelement_callback = nullptr;
    QCPLegend_GetSectionSizes_Callback qcplegend_getsectionsizes_callback = nullptr;
    QCPLegend_InitializeParentPlot_Callback qcplegend_initializeparentplot_callback = nullptr;
    QCPLegend_SetParentLayerable_Callback qcplegend_setparentlayerable_callback = nullptr;
    QCPLegend_MoveToLayer_Callback qcplegend_movetolayer_callback = nullptr;
    QCPLegend_ApplyAntialiasingHint_Callback qcplegend_applyantialiasinghint_callback = nullptr;
    QCPLegend_Sender_Callback qcplegend_sender_callback = nullptr;
    QCPLegend_SenderSignalIndex_Callback qcplegend_sendersignalindex_callback = nullptr;
    QCPLegend_Receivers_Callback qcplegend_receivers_callback = nullptr;
    QCPLegend_IsSignalConnected_Callback qcplegend_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcplegend_metacall_isbase = false;
    mutable bool qcplegend_selecttest_isbase = false;
    mutable bool qcplegend_parentplotinitialized_isbase = false;
    mutable bool qcplegend_selectioncategory_isbase = false;
    mutable bool qcplegend_applydefaultantialiasinghint_isbase = false;
    mutable bool qcplegend_draw_isbase = false;
    mutable bool qcplegend_selectevent_isbase = false;
    mutable bool qcplegend_deselectevent_isbase = false;
    mutable bool qcplegend_updatelayout_isbase = false;
    mutable bool qcplegend_elementcount_isbase = false;
    mutable bool qcplegend_elementat_isbase = false;
    mutable bool qcplegend_takeat_isbase = false;
    mutable bool qcplegend_take_isbase = false;
    mutable bool qcplegend_elements_isbase = false;
    mutable bool qcplegend_simplify_isbase = false;
    mutable bool qcplegend_minimumoutersizehint_isbase = false;
    mutable bool qcplegend_maximumoutersizehint_isbase = false;
    mutable bool qcplegend_update_isbase = false;
    mutable bool qcplegend_calculateautomargin_isbase = false;
    mutable bool qcplegend_layoutchanged_isbase = false;
    mutable bool qcplegend_cliprect_isbase = false;
    mutable bool qcplegend_mousepressevent_isbase = false;
    mutable bool qcplegend_mousemoveevent_isbase = false;
    mutable bool qcplegend_mousereleaseevent_isbase = false;
    mutable bool qcplegend_mousedoubleclickevent_isbase = false;
    mutable bool qcplegend_wheelevent_isbase = false;
    mutable bool qcplegend_event_isbase = false;
    mutable bool qcplegend_eventfilter_isbase = false;
    mutable bool qcplegend_timerevent_isbase = false;
    mutable bool qcplegend_childevent_isbase = false;
    mutable bool qcplegend_customevent_isbase = false;
    mutable bool qcplegend_connectnotify_isbase = false;
    mutable bool qcplegend_disconnectnotify_isbase = false;
    mutable bool qcplegend_getborderpen_isbase = false;
    mutable bool qcplegend_getbrush_isbase = false;
    mutable bool qcplegend_getminimumrowcolsizes_isbase = false;
    mutable bool qcplegend_getmaximumrowcolsizes_isbase = false;
    mutable bool qcplegend_sizeconstraintschanged_isbase = false;
    mutable bool qcplegend_adoptelement_isbase = false;
    mutable bool qcplegend_releaseelement_isbase = false;
    mutable bool qcplegend_getsectionsizes_isbase = false;
    mutable bool qcplegend_initializeparentplot_isbase = false;
    mutable bool qcplegend_setparentlayerable_isbase = false;
    mutable bool qcplegend_movetolayer_isbase = false;
    mutable bool qcplegend_applyantialiasinghint_isbase = false;
    mutable bool qcplegend_sender_isbase = false;
    mutable bool qcplegend_sendersignalindex_isbase = false;
    mutable bool qcplegend_receivers_isbase = false;
    mutable bool qcplegend_issignalconnected_isbase = false;

  public:
    VirtualQCPLegend() : QCPLegend() {};

    ~VirtualQCPLegend() {
        qcplegend_metacall_callback = nullptr;
        qcplegend_selecttest_callback = nullptr;
        qcplegend_parentplotinitialized_callback = nullptr;
        qcplegend_selectioncategory_callback = nullptr;
        qcplegend_applydefaultantialiasinghint_callback = nullptr;
        qcplegend_draw_callback = nullptr;
        qcplegend_selectevent_callback = nullptr;
        qcplegend_deselectevent_callback = nullptr;
        qcplegend_updatelayout_callback = nullptr;
        qcplegend_elementcount_callback = nullptr;
        qcplegend_elementat_callback = nullptr;
        qcplegend_takeat_callback = nullptr;
        qcplegend_take_callback = nullptr;
        qcplegend_elements_callback = nullptr;
        qcplegend_simplify_callback = nullptr;
        qcplegend_minimumoutersizehint_callback = nullptr;
        qcplegend_maximumoutersizehint_callback = nullptr;
        qcplegend_update_callback = nullptr;
        qcplegend_calculateautomargin_callback = nullptr;
        qcplegend_layoutchanged_callback = nullptr;
        qcplegend_cliprect_callback = nullptr;
        qcplegend_mousepressevent_callback = nullptr;
        qcplegend_mousemoveevent_callback = nullptr;
        qcplegend_mousereleaseevent_callback = nullptr;
        qcplegend_mousedoubleclickevent_callback = nullptr;
        qcplegend_wheelevent_callback = nullptr;
        qcplegend_event_callback = nullptr;
        qcplegend_eventfilter_callback = nullptr;
        qcplegend_timerevent_callback = nullptr;
        qcplegend_childevent_callback = nullptr;
        qcplegend_customevent_callback = nullptr;
        qcplegend_connectnotify_callback = nullptr;
        qcplegend_disconnectnotify_callback = nullptr;
        qcplegend_getborderpen_callback = nullptr;
        qcplegend_getbrush_callback = nullptr;
        qcplegend_getminimumrowcolsizes_callback = nullptr;
        qcplegend_getmaximumrowcolsizes_callback = nullptr;
        qcplegend_sizeconstraintschanged_callback = nullptr;
        qcplegend_adoptelement_callback = nullptr;
        qcplegend_releaseelement_callback = nullptr;
        qcplegend_getsectionsizes_callback = nullptr;
        qcplegend_initializeparentplot_callback = nullptr;
        qcplegend_setparentlayerable_callback = nullptr;
        qcplegend_movetolayer_callback = nullptr;
        qcplegend_applyantialiasinghint_callback = nullptr;
        qcplegend_sender_callback = nullptr;
        qcplegend_sendersignalindex_callback = nullptr;
        qcplegend_receivers_callback = nullptr;
        qcplegend_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPLegend_Metacall_Callback(QCPLegend_Metacall_Callback cb) { qcplegend_metacall_callback = cb; }
    inline void setQCPLegend_SelectTest_Callback(QCPLegend_SelectTest_Callback cb) { qcplegend_selecttest_callback = cb; }
    inline void setQCPLegend_ParentPlotInitialized_Callback(QCPLegend_ParentPlotInitialized_Callback cb) { qcplegend_parentplotinitialized_callback = cb; }
    inline void setQCPLegend_SelectionCategory_Callback(QCPLegend_SelectionCategory_Callback cb) { qcplegend_selectioncategory_callback = cb; }
    inline void setQCPLegend_ApplyDefaultAntialiasingHint_Callback(QCPLegend_ApplyDefaultAntialiasingHint_Callback cb) { qcplegend_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPLegend_Draw_Callback(QCPLegend_Draw_Callback cb) { qcplegend_draw_callback = cb; }
    inline void setQCPLegend_SelectEvent_Callback(QCPLegend_SelectEvent_Callback cb) { qcplegend_selectevent_callback = cb; }
    inline void setQCPLegend_DeselectEvent_Callback(QCPLegend_DeselectEvent_Callback cb) { qcplegend_deselectevent_callback = cb; }
    inline void setQCPLegend_UpdateLayout_Callback(QCPLegend_UpdateLayout_Callback cb) { qcplegend_updatelayout_callback = cb; }
    inline void setQCPLegend_ElementCount_Callback(QCPLegend_ElementCount_Callback cb) { qcplegend_elementcount_callback = cb; }
    inline void setQCPLegend_ElementAt_Callback(QCPLegend_ElementAt_Callback cb) { qcplegend_elementat_callback = cb; }
    inline void setQCPLegend_TakeAt_Callback(QCPLegend_TakeAt_Callback cb) { qcplegend_takeat_callback = cb; }
    inline void setQCPLegend_Take_Callback(QCPLegend_Take_Callback cb) { qcplegend_take_callback = cb; }
    inline void setQCPLegend_Elements_Callback(QCPLegend_Elements_Callback cb) { qcplegend_elements_callback = cb; }
    inline void setQCPLegend_Simplify_Callback(QCPLegend_Simplify_Callback cb) { qcplegend_simplify_callback = cb; }
    inline void setQCPLegend_MinimumOuterSizeHint_Callback(QCPLegend_MinimumOuterSizeHint_Callback cb) { qcplegend_minimumoutersizehint_callback = cb; }
    inline void setQCPLegend_MaximumOuterSizeHint_Callback(QCPLegend_MaximumOuterSizeHint_Callback cb) { qcplegend_maximumoutersizehint_callback = cb; }
    inline void setQCPLegend_Update_Callback(QCPLegend_Update_Callback cb) { qcplegend_update_callback = cb; }
    inline void setQCPLegend_CalculateAutoMargin_Callback(QCPLegend_CalculateAutoMargin_Callback cb) { qcplegend_calculateautomargin_callback = cb; }
    inline void setQCPLegend_LayoutChanged_Callback(QCPLegend_LayoutChanged_Callback cb) { qcplegend_layoutchanged_callback = cb; }
    inline void setQCPLegend_ClipRect_Callback(QCPLegend_ClipRect_Callback cb) { qcplegend_cliprect_callback = cb; }
    inline void setQCPLegend_MousePressEvent_Callback(QCPLegend_MousePressEvent_Callback cb) { qcplegend_mousepressevent_callback = cb; }
    inline void setQCPLegend_MouseMoveEvent_Callback(QCPLegend_MouseMoveEvent_Callback cb) { qcplegend_mousemoveevent_callback = cb; }
    inline void setQCPLegend_MouseReleaseEvent_Callback(QCPLegend_MouseReleaseEvent_Callback cb) { qcplegend_mousereleaseevent_callback = cb; }
    inline void setQCPLegend_MouseDoubleClickEvent_Callback(QCPLegend_MouseDoubleClickEvent_Callback cb) { qcplegend_mousedoubleclickevent_callback = cb; }
    inline void setQCPLegend_WheelEvent_Callback(QCPLegend_WheelEvent_Callback cb) { qcplegend_wheelevent_callback = cb; }
    inline void setQCPLegend_Event_Callback(QCPLegend_Event_Callback cb) { qcplegend_event_callback = cb; }
    inline void setQCPLegend_EventFilter_Callback(QCPLegend_EventFilter_Callback cb) { qcplegend_eventfilter_callback = cb; }
    inline void setQCPLegend_TimerEvent_Callback(QCPLegend_TimerEvent_Callback cb) { qcplegend_timerevent_callback = cb; }
    inline void setQCPLegend_ChildEvent_Callback(QCPLegend_ChildEvent_Callback cb) { qcplegend_childevent_callback = cb; }
    inline void setQCPLegend_CustomEvent_Callback(QCPLegend_CustomEvent_Callback cb) { qcplegend_customevent_callback = cb; }
    inline void setQCPLegend_ConnectNotify_Callback(QCPLegend_ConnectNotify_Callback cb) { qcplegend_connectnotify_callback = cb; }
    inline void setQCPLegend_DisconnectNotify_Callback(QCPLegend_DisconnectNotify_Callback cb) { qcplegend_disconnectnotify_callback = cb; }
    inline void setQCPLegend_GetBorderPen_Callback(QCPLegend_GetBorderPen_Callback cb) { qcplegend_getborderpen_callback = cb; }
    inline void setQCPLegend_GetBrush_Callback(QCPLegend_GetBrush_Callback cb) { qcplegend_getbrush_callback = cb; }
    inline void setQCPLegend_GetMinimumRowColSizes_Callback(QCPLegend_GetMinimumRowColSizes_Callback cb) { qcplegend_getminimumrowcolsizes_callback = cb; }
    inline void setQCPLegend_GetMaximumRowColSizes_Callback(QCPLegend_GetMaximumRowColSizes_Callback cb) { qcplegend_getmaximumrowcolsizes_callback = cb; }
    inline void setQCPLegend_SizeConstraintsChanged_Callback(QCPLegend_SizeConstraintsChanged_Callback cb) { qcplegend_sizeconstraintschanged_callback = cb; }
    inline void setQCPLegend_AdoptElement_Callback(QCPLegend_AdoptElement_Callback cb) { qcplegend_adoptelement_callback = cb; }
    inline void setQCPLegend_ReleaseElement_Callback(QCPLegend_ReleaseElement_Callback cb) { qcplegend_releaseelement_callback = cb; }
    inline void setQCPLegend_GetSectionSizes_Callback(QCPLegend_GetSectionSizes_Callback cb) { qcplegend_getsectionsizes_callback = cb; }
    inline void setQCPLegend_InitializeParentPlot_Callback(QCPLegend_InitializeParentPlot_Callback cb) { qcplegend_initializeparentplot_callback = cb; }
    inline void setQCPLegend_SetParentLayerable_Callback(QCPLegend_SetParentLayerable_Callback cb) { qcplegend_setparentlayerable_callback = cb; }
    inline void setQCPLegend_MoveToLayer_Callback(QCPLegend_MoveToLayer_Callback cb) { qcplegend_movetolayer_callback = cb; }
    inline void setQCPLegend_ApplyAntialiasingHint_Callback(QCPLegend_ApplyAntialiasingHint_Callback cb) { qcplegend_applyantialiasinghint_callback = cb; }
    inline void setQCPLegend_Sender_Callback(QCPLegend_Sender_Callback cb) { qcplegend_sender_callback = cb; }
    inline void setQCPLegend_SenderSignalIndex_Callback(QCPLegend_SenderSignalIndex_Callback cb) { qcplegend_sendersignalindex_callback = cb; }
    inline void setQCPLegend_Receivers_Callback(QCPLegend_Receivers_Callback cb) { qcplegend_receivers_callback = cb; }
    inline void setQCPLegend_IsSignalConnected_Callback(QCPLegend_IsSignalConnected_Callback cb) { qcplegend_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPLegend_Metacall_IsBase(bool value) const { qcplegend_metacall_isbase = value; }
    inline void setQCPLegend_SelectTest_IsBase(bool value) const { qcplegend_selecttest_isbase = value; }
    inline void setQCPLegend_ParentPlotInitialized_IsBase(bool value) const { qcplegend_parentplotinitialized_isbase = value; }
    inline void setQCPLegend_SelectionCategory_IsBase(bool value) const { qcplegend_selectioncategory_isbase = value; }
    inline void setQCPLegend_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcplegend_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPLegend_Draw_IsBase(bool value) const { qcplegend_draw_isbase = value; }
    inline void setQCPLegend_SelectEvent_IsBase(bool value) const { qcplegend_selectevent_isbase = value; }
    inline void setQCPLegend_DeselectEvent_IsBase(bool value) const { qcplegend_deselectevent_isbase = value; }
    inline void setQCPLegend_UpdateLayout_IsBase(bool value) const { qcplegend_updatelayout_isbase = value; }
    inline void setQCPLegend_ElementCount_IsBase(bool value) const { qcplegend_elementcount_isbase = value; }
    inline void setQCPLegend_ElementAt_IsBase(bool value) const { qcplegend_elementat_isbase = value; }
    inline void setQCPLegend_TakeAt_IsBase(bool value) const { qcplegend_takeat_isbase = value; }
    inline void setQCPLegend_Take_IsBase(bool value) const { qcplegend_take_isbase = value; }
    inline void setQCPLegend_Elements_IsBase(bool value) const { qcplegend_elements_isbase = value; }
    inline void setQCPLegend_Simplify_IsBase(bool value) const { qcplegend_simplify_isbase = value; }
    inline void setQCPLegend_MinimumOuterSizeHint_IsBase(bool value) const { qcplegend_minimumoutersizehint_isbase = value; }
    inline void setQCPLegend_MaximumOuterSizeHint_IsBase(bool value) const { qcplegend_maximumoutersizehint_isbase = value; }
    inline void setQCPLegend_Update_IsBase(bool value) const { qcplegend_update_isbase = value; }
    inline void setQCPLegend_CalculateAutoMargin_IsBase(bool value) const { qcplegend_calculateautomargin_isbase = value; }
    inline void setQCPLegend_LayoutChanged_IsBase(bool value) const { qcplegend_layoutchanged_isbase = value; }
    inline void setQCPLegend_ClipRect_IsBase(bool value) const { qcplegend_cliprect_isbase = value; }
    inline void setQCPLegend_MousePressEvent_IsBase(bool value) const { qcplegend_mousepressevent_isbase = value; }
    inline void setQCPLegend_MouseMoveEvent_IsBase(bool value) const { qcplegend_mousemoveevent_isbase = value; }
    inline void setQCPLegend_MouseReleaseEvent_IsBase(bool value) const { qcplegend_mousereleaseevent_isbase = value; }
    inline void setQCPLegend_MouseDoubleClickEvent_IsBase(bool value) const { qcplegend_mousedoubleclickevent_isbase = value; }
    inline void setQCPLegend_WheelEvent_IsBase(bool value) const { qcplegend_wheelevent_isbase = value; }
    inline void setQCPLegend_Event_IsBase(bool value) const { qcplegend_event_isbase = value; }
    inline void setQCPLegend_EventFilter_IsBase(bool value) const { qcplegend_eventfilter_isbase = value; }
    inline void setQCPLegend_TimerEvent_IsBase(bool value) const { qcplegend_timerevent_isbase = value; }
    inline void setQCPLegend_ChildEvent_IsBase(bool value) const { qcplegend_childevent_isbase = value; }
    inline void setQCPLegend_CustomEvent_IsBase(bool value) const { qcplegend_customevent_isbase = value; }
    inline void setQCPLegend_ConnectNotify_IsBase(bool value) const { qcplegend_connectnotify_isbase = value; }
    inline void setQCPLegend_DisconnectNotify_IsBase(bool value) const { qcplegend_disconnectnotify_isbase = value; }
    inline void setQCPLegend_GetBorderPen_IsBase(bool value) const { qcplegend_getborderpen_isbase = value; }
    inline void setQCPLegend_GetBrush_IsBase(bool value) const { qcplegend_getbrush_isbase = value; }
    inline void setQCPLegend_GetMinimumRowColSizes_IsBase(bool value) const { qcplegend_getminimumrowcolsizes_isbase = value; }
    inline void setQCPLegend_GetMaximumRowColSizes_IsBase(bool value) const { qcplegend_getmaximumrowcolsizes_isbase = value; }
    inline void setQCPLegend_SizeConstraintsChanged_IsBase(bool value) const { qcplegend_sizeconstraintschanged_isbase = value; }
    inline void setQCPLegend_AdoptElement_IsBase(bool value) const { qcplegend_adoptelement_isbase = value; }
    inline void setQCPLegend_ReleaseElement_IsBase(bool value) const { qcplegend_releaseelement_isbase = value; }
    inline void setQCPLegend_GetSectionSizes_IsBase(bool value) const { qcplegend_getsectionsizes_isbase = value; }
    inline void setQCPLegend_InitializeParentPlot_IsBase(bool value) const { qcplegend_initializeparentplot_isbase = value; }
    inline void setQCPLegend_SetParentLayerable_IsBase(bool value) const { qcplegend_setparentlayerable_isbase = value; }
    inline void setQCPLegend_MoveToLayer_IsBase(bool value) const { qcplegend_movetolayer_isbase = value; }
    inline void setQCPLegend_ApplyAntialiasingHint_IsBase(bool value) const { qcplegend_applyantialiasinghint_isbase = value; }
    inline void setQCPLegend_Sender_IsBase(bool value) const { qcplegend_sender_isbase = value; }
    inline void setQCPLegend_SenderSignalIndex_IsBase(bool value) const { qcplegend_sendersignalindex_isbase = value; }
    inline void setQCPLegend_Receivers_IsBase(bool value) const { qcplegend_receivers_isbase = value; }
    inline void setQCPLegend_IsSignalConnected_IsBase(bool value) const { qcplegend_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcplegend_metacall_isbase) {
            qcplegend_metacall_isbase = false;
            return QCPLegend::qt_metacall(param1, param2, param3);
        } else if (qcplegend_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcplegend_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPLegend::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcplegend_selecttest_isbase) {
            qcplegend_selecttest_isbase = false;
            return QCPLegend::selectTest(pos, onlySelectable, details);
        } else if (qcplegend_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcplegend_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPLegend::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcplegend_parentplotinitialized_isbase) {
            qcplegend_parentplotinitialized_isbase = false;
            QCPLegend::parentPlotInitialized(parentPlot);
        } else if (qcplegend_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcplegend_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPLegend::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcplegend_selectioncategory_isbase) {
            qcplegend_selectioncategory_isbase = false;
            return QCPLegend::selectionCategory();
        } else if (qcplegend_selectioncategory_callback != nullptr) {
            int callback_ret = qcplegend_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPLegend::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcplegend_applydefaultantialiasinghint_isbase) {
            qcplegend_applydefaultantialiasinghint_isbase = false;
            QCPLegend::applyDefaultAntialiasingHint(painter);
        } else if (qcplegend_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcplegend_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPLegend::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcplegend_draw_isbase) {
            qcplegend_draw_isbase = false;
            QCPLegend::draw(painter);
        } else if (qcplegend_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcplegend_draw_callback(this, cbval1);
        } else {
            QCPLegend::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcplegend_selectevent_isbase) {
            qcplegend_selectevent_isbase = false;
            QCPLegend::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcplegend_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcplegend_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPLegend::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcplegend_deselectevent_isbase) {
            qcplegend_deselectevent_isbase = false;
            QCPLegend::deselectEvent(selectionStateChanged);
        } else if (qcplegend_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcplegend_deselectevent_callback(this, cbval1);
        } else {
            QCPLegend::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void updateLayout() override {
        if (qcplegend_updatelayout_isbase) {
            qcplegend_updatelayout_isbase = false;
            QCPLegend::updateLayout();
        } else if (qcplegend_updatelayout_callback != nullptr) {
            qcplegend_updatelayout_callback();
        } else {
            QCPLegend::updateLayout();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int elementCount() const override {
        if (qcplegend_elementcount_isbase) {
            qcplegend_elementcount_isbase = false;
            return QCPLegend::elementCount();
        } else if (qcplegend_elementcount_callback != nullptr) {
            int callback_ret = qcplegend_elementcount_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPLegend::elementCount();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPLayoutElement* elementAt(int index) const override {
        if (qcplegend_elementat_isbase) {
            qcplegend_elementat_isbase = false;
            return QCPLegend::elementAt(index);
        } else if (qcplegend_elementat_callback != nullptr) {
            int cbval1 = index;

            QCPLayoutElement* callback_ret = qcplegend_elementat_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPLegend::elementAt(index);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPLayoutElement* takeAt(int index) override {
        if (qcplegend_takeat_isbase) {
            qcplegend_takeat_isbase = false;
            return QCPLegend::takeAt(index);
        } else if (qcplegend_takeat_callback != nullptr) {
            int cbval1 = index;

            QCPLayoutElement* callback_ret = qcplegend_takeat_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPLegend::takeAt(index);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool take(QCPLayoutElement* element) override {
        if (qcplegend_take_isbase) {
            qcplegend_take_isbase = false;
            return QCPLegend::take(element);
        } else if (qcplegend_take_callback != nullptr) {
            QCPLayoutElement* cbval1 = element;

            bool callback_ret = qcplegend_take_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPLegend::take(element);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QList<QCPLayoutElement*> elements(bool recursive) const override {
        if (qcplegend_elements_isbase) {
            qcplegend_elements_isbase = false;
            return QCPLegend::elements(recursive);
        } else if (qcplegend_elements_callback != nullptr) {
            bool cbval1 = recursive;

            QCPLayoutElement** callback_ret = qcplegend_elements_callback(this, cbval1);
            QList<QCPLayoutElement*> callback_ret_QList;
            // Iterate until null pointer sentinel
            for (QCPLayoutElement** ptridx = callback_ret; *ptridx != nullptr; ptridx++) {
                callback_ret_QList.push_back(*ptridx);
            }
            free(callback_ret);
            return callback_ret_QList;
        } else {
            return QCPLegend::elements(recursive);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void simplify() override {
        if (qcplegend_simplify_isbase) {
            qcplegend_simplify_isbase = false;
            QCPLegend::simplify();
        } else if (qcplegend_simplify_callback != nullptr) {
            qcplegend_simplify_callback();
        } else {
            QCPLegend::simplify();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize minimumOuterSizeHint() const override {
        if (qcplegend_minimumoutersizehint_isbase) {
            qcplegend_minimumoutersizehint_isbase = false;
            return QCPLegend::minimumOuterSizeHint();
        } else if (qcplegend_minimumoutersizehint_callback != nullptr) {
            QSize* callback_ret = qcplegend_minimumoutersizehint_callback();
            return *callback_ret;
        } else {
            return QCPLegend::minimumOuterSizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize maximumOuterSizeHint() const override {
        if (qcplegend_maximumoutersizehint_isbase) {
            qcplegend_maximumoutersizehint_isbase = false;
            return QCPLegend::maximumOuterSizeHint();
        } else if (qcplegend_maximumoutersizehint_callback != nullptr) {
            QSize* callback_ret = qcplegend_maximumoutersizehint_callback();
            return *callback_ret;
        } else {
            return QCPLegend::maximumOuterSizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void update(QCPLayoutElement::UpdatePhase phase) override {
        if (qcplegend_update_isbase) {
            qcplegend_update_isbase = false;
            QCPLegend::update(phase);
        } else if (qcplegend_update_callback != nullptr) {
            int cbval1 = static_cast<int>(phase);

            qcplegend_update_callback(this, cbval1);
        } else {
            QCPLegend::update(phase);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int calculateAutoMargin(QCP::MarginSide side) override {
        if (qcplegend_calculateautomargin_isbase) {
            qcplegend_calculateautomargin_isbase = false;
            return QCPLegend::calculateAutoMargin(side);
        } else if (qcplegend_calculateautomargin_callback != nullptr) {
            int cbval1 = static_cast<int>(side);

            int callback_ret = qcplegend_calculateautomargin_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPLegend::calculateAutoMargin(side);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void layoutChanged() override {
        if (qcplegend_layoutchanged_isbase) {
            qcplegend_layoutchanged_isbase = false;
            QCPLegend::layoutChanged();
        } else if (qcplegend_layoutchanged_callback != nullptr) {
            qcplegend_layoutchanged_callback();
        } else {
            QCPLegend::layoutChanged();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcplegend_cliprect_isbase) {
            qcplegend_cliprect_isbase = false;
            return QCPLegend::clipRect();
        } else if (qcplegend_cliprect_callback != nullptr) {
            QRect* callback_ret = qcplegend_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPLegend::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcplegend_mousepressevent_isbase) {
            qcplegend_mousepressevent_isbase = false;
            QCPLegend::mousePressEvent(event, details);
        } else if (qcplegend_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcplegend_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPLegend::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcplegend_mousemoveevent_isbase) {
            qcplegend_mousemoveevent_isbase = false;
            QCPLegend::mouseMoveEvent(event, startPos);
        } else if (qcplegend_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcplegend_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPLegend::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcplegend_mousereleaseevent_isbase) {
            qcplegend_mousereleaseevent_isbase = false;
            QCPLegend::mouseReleaseEvent(event, startPos);
        } else if (qcplegend_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcplegend_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPLegend::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcplegend_mousedoubleclickevent_isbase) {
            qcplegend_mousedoubleclickevent_isbase = false;
            QCPLegend::mouseDoubleClickEvent(event, details);
        } else if (qcplegend_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcplegend_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPLegend::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcplegend_wheelevent_isbase) {
            qcplegend_wheelevent_isbase = false;
            QCPLegend::wheelEvent(event);
        } else if (qcplegend_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcplegend_wheelevent_callback(this, cbval1);
        } else {
            QCPLegend::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcplegend_event_isbase) {
            qcplegend_event_isbase = false;
            return QCPLegend::event(event);
        } else if (qcplegend_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcplegend_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPLegend::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcplegend_eventfilter_isbase) {
            qcplegend_eventfilter_isbase = false;
            return QCPLegend::eventFilter(watched, event);
        } else if (qcplegend_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcplegend_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPLegend::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcplegend_timerevent_isbase) {
            qcplegend_timerevent_isbase = false;
            QCPLegend::timerEvent(event);
        } else if (qcplegend_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcplegend_timerevent_callback(this, cbval1);
        } else {
            QCPLegend::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcplegend_childevent_isbase) {
            qcplegend_childevent_isbase = false;
            QCPLegend::childEvent(event);
        } else if (qcplegend_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcplegend_childevent_callback(this, cbval1);
        } else {
            QCPLegend::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcplegend_customevent_isbase) {
            qcplegend_customevent_isbase = false;
            QCPLegend::customEvent(event);
        } else if (qcplegend_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcplegend_customevent_callback(this, cbval1);
        } else {
            QCPLegend::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcplegend_connectnotify_isbase) {
            qcplegend_connectnotify_isbase = false;
            QCPLegend::connectNotify(signal);
        } else if (qcplegend_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcplegend_connectnotify_callback(this, cbval1);
        } else {
            QCPLegend::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcplegend_disconnectnotify_isbase) {
            qcplegend_disconnectnotify_isbase = false;
            QCPLegend::disconnectNotify(signal);
        } else if (qcplegend_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcplegend_disconnectnotify_callback(this, cbval1);
        } else {
            QCPLegend::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    QPen getBorderPen() const {
        if (qcplegend_getborderpen_isbase) {
            qcplegend_getborderpen_isbase = false;
            return QCPLegend::getBorderPen();
        } else if (qcplegend_getborderpen_callback != nullptr) {
            QPen* callback_ret = qcplegend_getborderpen_callback();
            return *callback_ret;
        } else {
            return QCPLegend::getBorderPen();
        }
    }

    // Virtual method for C ABI access and custom callback
    QBrush getBrush() const {
        if (qcplegend_getbrush_isbase) {
            qcplegend_getbrush_isbase = false;
            return QCPLegend::getBrush();
        } else if (qcplegend_getbrush_callback != nullptr) {
            QBrush* callback_ret = qcplegend_getbrush_callback();
            return *callback_ret;
        } else {
            return QCPLegend::getBrush();
        }
    }

    // Virtual method for C ABI access and custom callback
    void getMinimumRowColSizes(QVector<int>* minColWidths, QVector<int>* minRowHeights) const {
        if (qcplegend_getminimumrowcolsizes_isbase) {
            qcplegend_getminimumrowcolsizes_isbase = false;
            QCPLegend::getMinimumRowColSizes(minColWidths, minRowHeights);
        } else if (qcplegend_getminimumrowcolsizes_callback != nullptr) {
            QVector<int>* minColWidths_ret = minColWidths;
            // Convert QVector<> from C++ memory to manually-managed C memory
            int* minColWidths_arr = static_cast<int*>(malloc(sizeof(int) * (minColWidths_ret->size() + 1)));
            for (qsizetype i = 0; i < minColWidths_ret->size(); ++i) {
                minColWidths_arr[i] = (*minColWidths_ret)[i];
            }
            libqt_list minColWidths_out;
            minColWidths_out.len = minColWidths_ret->size();
            minColWidths_out.data = static_cast<void*>(minColWidths_arr);
            libqt_list /* of int */ cbval1 = minColWidths_out;
            QVector<int>* minRowHeights_ret = minRowHeights;
            // Convert QVector<> from C++ memory to manually-managed C memory
            int* minRowHeights_arr = static_cast<int*>(malloc(sizeof(int) * (minRowHeights_ret->size() + 1)));
            for (qsizetype i = 0; i < minRowHeights_ret->size(); ++i) {
                minRowHeights_arr[i] = (*minRowHeights_ret)[i];
            }
            libqt_list minRowHeights_out;
            minRowHeights_out.len = minRowHeights_ret->size();
            minRowHeights_out.data = static_cast<void*>(minRowHeights_arr);
            libqt_list /* of int */ cbval2 = minRowHeights_out;

            qcplegend_getminimumrowcolsizes_callback(this, cbval1, cbval2);
        } else {
            QCPLegend::getMinimumRowColSizes(minColWidths, minRowHeights);
        }
    }

    // Virtual method for C ABI access and custom callback
    void getMaximumRowColSizes(QVector<int>* maxColWidths, QVector<int>* maxRowHeights) const {
        if (qcplegend_getmaximumrowcolsizes_isbase) {
            qcplegend_getmaximumrowcolsizes_isbase = false;
            QCPLegend::getMaximumRowColSizes(maxColWidths, maxRowHeights);
        } else if (qcplegend_getmaximumrowcolsizes_callback != nullptr) {
            QVector<int>* maxColWidths_ret = maxColWidths;
            // Convert QVector<> from C++ memory to manually-managed C memory
            int* maxColWidths_arr = static_cast<int*>(malloc(sizeof(int) * (maxColWidths_ret->size() + 1)));
            for (qsizetype i = 0; i < maxColWidths_ret->size(); ++i) {
                maxColWidths_arr[i] = (*maxColWidths_ret)[i];
            }
            libqt_list maxColWidths_out;
            maxColWidths_out.len = maxColWidths_ret->size();
            maxColWidths_out.data = static_cast<void*>(maxColWidths_arr);
            libqt_list /* of int */ cbval1 = maxColWidths_out;
            QVector<int>* maxRowHeights_ret = maxRowHeights;
            // Convert QVector<> from C++ memory to manually-managed C memory
            int* maxRowHeights_arr = static_cast<int*>(malloc(sizeof(int) * (maxRowHeights_ret->size() + 1)));
            for (qsizetype i = 0; i < maxRowHeights_ret->size(); ++i) {
                maxRowHeights_arr[i] = (*maxRowHeights_ret)[i];
            }
            libqt_list maxRowHeights_out;
            maxRowHeights_out.len = maxRowHeights_ret->size();
            maxRowHeights_out.data = static_cast<void*>(maxRowHeights_arr);
            libqt_list /* of int */ cbval2 = maxRowHeights_out;

            qcplegend_getmaximumrowcolsizes_callback(this, cbval1, cbval2);
        } else {
            QCPLegend::getMaximumRowColSizes(maxColWidths, maxRowHeights);
        }
    }

    // Virtual method for C ABI access and custom callback
    void sizeConstraintsChanged() const {
        if (qcplegend_sizeconstraintschanged_isbase) {
            qcplegend_sizeconstraintschanged_isbase = false;
            QCPLegend::sizeConstraintsChanged();
        } else if (qcplegend_sizeconstraintschanged_callback != nullptr) {
            qcplegend_sizeconstraintschanged_callback();
        } else {
            QCPLegend::sizeConstraintsChanged();
        }
    }

    // Virtual method for C ABI access and custom callback
    void adoptElement(QCPLayoutElement* el) {
        if (qcplegend_adoptelement_isbase) {
            qcplegend_adoptelement_isbase = false;
            QCPLegend::adoptElement(el);
        } else if (qcplegend_adoptelement_callback != nullptr) {
            QCPLayoutElement* cbval1 = el;

            qcplegend_adoptelement_callback(this, cbval1);
        } else {
            QCPLegend::adoptElement(el);
        }
    }

    // Virtual method for C ABI access and custom callback
    void releaseElement(QCPLayoutElement* el) {
        if (qcplegend_releaseelement_isbase) {
            qcplegend_releaseelement_isbase = false;
            QCPLegend::releaseElement(el);
        } else if (qcplegend_releaseelement_callback != nullptr) {
            QCPLayoutElement* cbval1 = el;

            qcplegend_releaseelement_callback(this, cbval1);
        } else {
            QCPLegend::releaseElement(el);
        }
    }

    // Virtual method for C ABI access and custom callback
    QVector<int> getSectionSizes(QVector<int> maxSizes, QVector<int> minSizes, QVector<double> stretchFactors, int totalSize) const {
        if (qcplegend_getsectionsizes_isbase) {
            qcplegend_getsectionsizes_isbase = false;
            return QCPLegend::getSectionSizes(maxSizes, minSizes, stretchFactors, totalSize);
        } else if (qcplegend_getsectionsizes_callback != nullptr) {
            QVector<int> maxSizes_ret = maxSizes;
            // Convert QVector<> from C++ memory to manually-managed C memory
            int* maxSizes_arr = static_cast<int*>(malloc(sizeof(int) * (maxSizes_ret.size() + 1)));
            for (qsizetype i = 0; i < maxSizes_ret.size(); ++i) {
                maxSizes_arr[i] = maxSizes_ret[i];
            }
            libqt_list maxSizes_out;
            maxSizes_out.len = maxSizes_ret.size();
            maxSizes_out.data = static_cast<void*>(maxSizes_arr);
            libqt_list /* of int */ cbval1 = maxSizes_out;
            QVector<int> minSizes_ret = minSizes;
            // Convert QVector<> from C++ memory to manually-managed C memory
            int* minSizes_arr = static_cast<int*>(malloc(sizeof(int) * (minSizes_ret.size() + 1)));
            for (qsizetype i = 0; i < minSizes_ret.size(); ++i) {
                minSizes_arr[i] = minSizes_ret[i];
            }
            libqt_list minSizes_out;
            minSizes_out.len = minSizes_ret.size();
            minSizes_out.data = static_cast<void*>(minSizes_arr);
            libqt_list /* of int */ cbval2 = minSizes_out;
            QVector<double> stretchFactors_ret = stretchFactors;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* stretchFactors_arr = static_cast<double*>(malloc(sizeof(double) * (stretchFactors_ret.size() + 1)));
            for (qsizetype i = 0; i < stretchFactors_ret.size(); ++i) {
                stretchFactors_arr[i] = stretchFactors_ret[i];
            }
            libqt_list stretchFactors_out;
            stretchFactors_out.len = stretchFactors_ret.size();
            stretchFactors_out.data = static_cast<void*>(stretchFactors_arr);
            libqt_list /* of double */ cbval3 = stretchFactors_out;
            int cbval4 = totalSize;

            int* callback_ret = qcplegend_getsectionsizes_callback(this, cbval1, cbval2, cbval3, cbval4);
            QVector<int> callback_ret_QVector;
            for (int* ptr = callback_ret; *ptr != -1; ++ptr) {
                callback_ret_QVector.push_back(*ptr);
            }
            return callback_ret_QVector;
        } else {
            return QCPLegend::getSectionSizes(maxSizes, minSizes, stretchFactors, totalSize);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcplegend_initializeparentplot_isbase) {
            qcplegend_initializeparentplot_isbase = false;
            QCPLegend::initializeParentPlot(parentPlot);
        } else if (qcplegend_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcplegend_initializeparentplot_callback(this, cbval1);
        } else {
            QCPLegend::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcplegend_setparentlayerable_isbase) {
            qcplegend_setparentlayerable_isbase = false;
            QCPLegend::setParentLayerable(parentLayerable);
        } else if (qcplegend_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcplegend_setparentlayerable_callback(this, cbval1);
        } else {
            QCPLegend::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcplegend_movetolayer_isbase) {
            qcplegend_movetolayer_isbase = false;
            return QCPLegend::moveToLayer(layer, prepend);
        } else if (qcplegend_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcplegend_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPLegend::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcplegend_applyantialiasinghint_isbase) {
            qcplegend_applyantialiasinghint_isbase = false;
            QCPLegend::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcplegend_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcplegend_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPLegend::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcplegend_sender_isbase) {
            qcplegend_sender_isbase = false;
            return QCPLegend::sender();
        } else if (qcplegend_sender_callback != nullptr) {
            QObject* callback_ret = qcplegend_sender_callback();
            return callback_ret;
        } else {
            return QCPLegend::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcplegend_sendersignalindex_isbase) {
            qcplegend_sendersignalindex_isbase = false;
            return QCPLegend::senderSignalIndex();
        } else if (qcplegend_sendersignalindex_callback != nullptr) {
            int callback_ret = qcplegend_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPLegend::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcplegend_receivers_isbase) {
            qcplegend_receivers_isbase = false;
            return QCPLegend::receivers(signal);
        } else if (qcplegend_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcplegend_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPLegend::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcplegend_issignalconnected_isbase) {
            qcplegend_issignalconnected_isbase = false;
            return QCPLegend::isSignalConnected(signal);
        } else if (qcplegend_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcplegend_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPLegend::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPLegend_ParentPlotInitialized(QCPLegend* self, QCustomPlot* parentPlot);
    friend void QCPLegend_QBaseParentPlotInitialized(QCPLegend* self, QCustomPlot* parentPlot);
    friend int QCPLegend_SelectionCategory(const QCPLegend* self);
    friend int QCPLegend_QBaseSelectionCategory(const QCPLegend* self);
    friend void QCPLegend_ApplyDefaultAntialiasingHint(const QCPLegend* self, QCPPainter* painter);
    friend void QCPLegend_QBaseApplyDefaultAntialiasingHint(const QCPLegend* self, QCPPainter* painter);
    friend void QCPLegend_Draw(QCPLegend* self, QCPPainter* painter);
    friend void QCPLegend_QBaseDraw(QCPLegend* self, QCPPainter* painter);
    friend void QCPLegend_SelectEvent(QCPLegend* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPLegend_QBaseSelectEvent(QCPLegend* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPLegend_DeselectEvent(QCPLegend* self, bool* selectionStateChanged);
    friend void QCPLegend_QBaseDeselectEvent(QCPLegend* self, bool* selectionStateChanged);
    friend int QCPLegend_CalculateAutoMargin(QCPLegend* self, int side);
    friend int QCPLegend_QBaseCalculateAutoMargin(QCPLegend* self, int side);
    friend void QCPLegend_LayoutChanged(QCPLegend* self);
    friend void QCPLegend_QBaseLayoutChanged(QCPLegend* self);
    friend QRect* QCPLegend_ClipRect(const QCPLegend* self);
    friend QRect* QCPLegend_QBaseClipRect(const QCPLegend* self);
    friend void QCPLegend_MousePressEvent(QCPLegend* self, QMouseEvent* event, const QVariant* details);
    friend void QCPLegend_QBaseMousePressEvent(QCPLegend* self, QMouseEvent* event, const QVariant* details);
    friend void QCPLegend_MouseMoveEvent(QCPLegend* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPLegend_QBaseMouseMoveEvent(QCPLegend* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPLegend_MouseReleaseEvent(QCPLegend* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPLegend_QBaseMouseReleaseEvent(QCPLegend* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPLegend_MouseDoubleClickEvent(QCPLegend* self, QMouseEvent* event, const QVariant* details);
    friend void QCPLegend_QBaseMouseDoubleClickEvent(QCPLegend* self, QMouseEvent* event, const QVariant* details);
    friend void QCPLegend_WheelEvent(QCPLegend* self, QWheelEvent* event);
    friend void QCPLegend_QBaseWheelEvent(QCPLegend* self, QWheelEvent* event);
    friend void QCPLegend_TimerEvent(QCPLegend* self, QTimerEvent* event);
    friend void QCPLegend_QBaseTimerEvent(QCPLegend* self, QTimerEvent* event);
    friend void QCPLegend_ChildEvent(QCPLegend* self, QChildEvent* event);
    friend void QCPLegend_QBaseChildEvent(QCPLegend* self, QChildEvent* event);
    friend void QCPLegend_CustomEvent(QCPLegend* self, QEvent* event);
    friend void QCPLegend_QBaseCustomEvent(QCPLegend* self, QEvent* event);
    friend void QCPLegend_ConnectNotify(QCPLegend* self, const QMetaMethod* signal);
    friend void QCPLegend_QBaseConnectNotify(QCPLegend* self, const QMetaMethod* signal);
    friend void QCPLegend_DisconnectNotify(QCPLegend* self, const QMetaMethod* signal);
    friend void QCPLegend_QBaseDisconnectNotify(QCPLegend* self, const QMetaMethod* signal);
    friend QPen* QCPLegend_GetBorderPen(const QCPLegend* self);
    friend QPen* QCPLegend_QBaseGetBorderPen(const QCPLegend* self);
    friend QBrush* QCPLegend_GetBrush(const QCPLegend* self);
    friend QBrush* QCPLegend_QBaseGetBrush(const QCPLegend* self);
    friend void QCPLegend_GetMinimumRowColSizes(const QCPLegend* self, libqt_list /* of int */ minColWidths, libqt_list /* of int */ minRowHeights);
    friend void QCPLegend_QBaseGetMinimumRowColSizes(const QCPLegend* self, libqt_list /* of int */ minColWidths, libqt_list /* of int */ minRowHeights);
    friend void QCPLegend_GetMaximumRowColSizes(const QCPLegend* self, libqt_list /* of int */ maxColWidths, libqt_list /* of int */ maxRowHeights);
    friend void QCPLegend_QBaseGetMaximumRowColSizes(const QCPLegend* self, libqt_list /* of int */ maxColWidths, libqt_list /* of int */ maxRowHeights);
    friend void QCPLegend_SizeConstraintsChanged(const QCPLegend* self);
    friend void QCPLegend_QBaseSizeConstraintsChanged(const QCPLegend* self);
    friend void QCPLegend_AdoptElement(QCPLegend* self, QCPLayoutElement* el);
    friend void QCPLegend_QBaseAdoptElement(QCPLegend* self, QCPLayoutElement* el);
    friend void QCPLegend_ReleaseElement(QCPLegend* self, QCPLayoutElement* el);
    friend void QCPLegend_QBaseReleaseElement(QCPLegend* self, QCPLayoutElement* el);
    friend libqt_list /* of int */ QCPLegend_GetSectionSizes(const QCPLegend* self, libqt_list /* of int */ maxSizes, libqt_list /* of int */ minSizes, libqt_list /* of double */ stretchFactors, int totalSize);
    friend libqt_list /* of int */ QCPLegend_QBaseGetSectionSizes(const QCPLegend* self, libqt_list /* of int */ maxSizes, libqt_list /* of int */ minSizes, libqt_list /* of double */ stretchFactors, int totalSize);
    friend void QCPLegend_InitializeParentPlot(QCPLegend* self, QCustomPlot* parentPlot);
    friend void QCPLegend_QBaseInitializeParentPlot(QCPLegend* self, QCustomPlot* parentPlot);
    friend void QCPLegend_SetParentLayerable(QCPLegend* self, QCPLayerable* parentLayerable);
    friend void QCPLegend_QBaseSetParentLayerable(QCPLegend* self, QCPLayerable* parentLayerable);
    friend bool QCPLegend_MoveToLayer(QCPLegend* self, QCPLayer* layer, bool prepend);
    friend bool QCPLegend_QBaseMoveToLayer(QCPLegend* self, QCPLayer* layer, bool prepend);
    friend void QCPLegend_ApplyAntialiasingHint(const QCPLegend* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPLegend_QBaseApplyAntialiasingHint(const QCPLegend* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPLegend_Sender(const QCPLegend* self);
    friend QObject* QCPLegend_QBaseSender(const QCPLegend* self);
    friend int QCPLegend_SenderSignalIndex(const QCPLegend* self);
    friend int QCPLegend_QBaseSenderSignalIndex(const QCPLegend* self);
    friend int QCPLegend_Receivers(const QCPLegend* self, const char* signal);
    friend int QCPLegend_QBaseReceivers(const QCPLegend* self, const char* signal);
    friend bool QCPLegend_IsSignalConnected(const QCPLegend* self, const QMetaMethod* signal);
    friend bool QCPLegend_QBaseIsSignalConnected(const QCPLegend* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPTextElement so that we can call protected methods
class VirtualQCPTextElement final : public QCPTextElement {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPTextElement = true;

    // Virtual class public types (including callbacks)
    using QCPTextElement_Metacall_Callback = int (*)(QCPTextElement*, int, int, void**);
    using QCPTextElement_SelectTest_Callback = double (*)(const QCPTextElement*, QPointF*, bool, QVariant*);
    using QCPTextElement_MousePressEvent_Callback = void (*)(QCPTextElement*, QMouseEvent*, QVariant*);
    using QCPTextElement_MouseReleaseEvent_Callback = void (*)(QCPTextElement*, QMouseEvent*, QPointF*);
    using QCPTextElement_MouseDoubleClickEvent_Callback = void (*)(QCPTextElement*, QMouseEvent*, QVariant*);
    using QCPTextElement_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPTextElement*, QCPPainter*);
    using QCPTextElement_Draw_Callback = void (*)(QCPTextElement*, QCPPainter*);
    using QCPTextElement_MinimumOuterSizeHint_Callback = QSize* (*)();
    using QCPTextElement_MaximumOuterSizeHint_Callback = QSize* (*)();
    using QCPTextElement_SelectEvent_Callback = void (*)(QCPTextElement*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPTextElement_DeselectEvent_Callback = void (*)(QCPTextElement*, bool*);
    using QCPTextElement_Update_Callback = void (*)(QCPTextElement*, int);
    using QCPTextElement_Elements_Callback = QCPLayoutElement** (*)(const QCPTextElement*, bool);
    using QCPTextElement_CalculateAutoMargin_Callback = int (*)(QCPTextElement*, int);
    using QCPTextElement_LayoutChanged_Callback = void (*)();
    using QCPTextElement_ParentPlotInitialized_Callback = void (*)(QCPTextElement*, QCustomPlot*);
    using QCPTextElement_SelectionCategory_Callback = int (*)();
    using QCPTextElement_ClipRect_Callback = QRect* (*)();
    using QCPTextElement_MouseMoveEvent_Callback = void (*)(QCPTextElement*, QMouseEvent*, QPointF*);
    using QCPTextElement_WheelEvent_Callback = void (*)(QCPTextElement*, QWheelEvent*);
    using QCPTextElement_Event_Callback = bool (*)(QCPTextElement*, QEvent*);
    using QCPTextElement_EventFilter_Callback = bool (*)(QCPTextElement*, QObject*, QEvent*);
    using QCPTextElement_TimerEvent_Callback = void (*)(QCPTextElement*, QTimerEvent*);
    using QCPTextElement_ChildEvent_Callback = void (*)(QCPTextElement*, QChildEvent*);
    using QCPTextElement_CustomEvent_Callback = void (*)(QCPTextElement*, QEvent*);
    using QCPTextElement_ConnectNotify_Callback = void (*)(QCPTextElement*, QMetaMethod*);
    using QCPTextElement_DisconnectNotify_Callback = void (*)(QCPTextElement*, QMetaMethod*);
    using QCPTextElement_MainFont_Callback = QFont* (*)();
    using QCPTextElement_MainTextColor_Callback = QColor* (*)();
    using QCPTextElement_InitializeParentPlot_Callback = void (*)(QCPTextElement*, QCustomPlot*);
    using QCPTextElement_SetParentLayerable_Callback = void (*)(QCPTextElement*, QCPLayerable*);
    using QCPTextElement_MoveToLayer_Callback = bool (*)(QCPTextElement*, QCPLayer*, bool);
    using QCPTextElement_ApplyAntialiasingHint_Callback = void (*)(const QCPTextElement*, QCPPainter*, bool, int);
    using QCPTextElement_Sender_Callback = QObject* (*)();
    using QCPTextElement_SenderSignalIndex_Callback = int (*)();
    using QCPTextElement_Receivers_Callback = int (*)(const QCPTextElement*, const char*);
    using QCPTextElement_IsSignalConnected_Callback = bool (*)(const QCPTextElement*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPTextElement_Metacall_Callback qcptextelement_metacall_callback = nullptr;
    QCPTextElement_SelectTest_Callback qcptextelement_selecttest_callback = nullptr;
    QCPTextElement_MousePressEvent_Callback qcptextelement_mousepressevent_callback = nullptr;
    QCPTextElement_MouseReleaseEvent_Callback qcptextelement_mousereleaseevent_callback = nullptr;
    QCPTextElement_MouseDoubleClickEvent_Callback qcptextelement_mousedoubleclickevent_callback = nullptr;
    QCPTextElement_ApplyDefaultAntialiasingHint_Callback qcptextelement_applydefaultantialiasinghint_callback = nullptr;
    QCPTextElement_Draw_Callback qcptextelement_draw_callback = nullptr;
    QCPTextElement_MinimumOuterSizeHint_Callback qcptextelement_minimumoutersizehint_callback = nullptr;
    QCPTextElement_MaximumOuterSizeHint_Callback qcptextelement_maximumoutersizehint_callback = nullptr;
    QCPTextElement_SelectEvent_Callback qcptextelement_selectevent_callback = nullptr;
    QCPTextElement_DeselectEvent_Callback qcptextelement_deselectevent_callback = nullptr;
    QCPTextElement_Update_Callback qcptextelement_update_callback = nullptr;
    QCPTextElement_Elements_Callback qcptextelement_elements_callback = nullptr;
    QCPTextElement_CalculateAutoMargin_Callback qcptextelement_calculateautomargin_callback = nullptr;
    QCPTextElement_LayoutChanged_Callback qcptextelement_layoutchanged_callback = nullptr;
    QCPTextElement_ParentPlotInitialized_Callback qcptextelement_parentplotinitialized_callback = nullptr;
    QCPTextElement_SelectionCategory_Callback qcptextelement_selectioncategory_callback = nullptr;
    QCPTextElement_ClipRect_Callback qcptextelement_cliprect_callback = nullptr;
    QCPTextElement_MouseMoveEvent_Callback qcptextelement_mousemoveevent_callback = nullptr;
    QCPTextElement_WheelEvent_Callback qcptextelement_wheelevent_callback = nullptr;
    QCPTextElement_Event_Callback qcptextelement_event_callback = nullptr;
    QCPTextElement_EventFilter_Callback qcptextelement_eventfilter_callback = nullptr;
    QCPTextElement_TimerEvent_Callback qcptextelement_timerevent_callback = nullptr;
    QCPTextElement_ChildEvent_Callback qcptextelement_childevent_callback = nullptr;
    QCPTextElement_CustomEvent_Callback qcptextelement_customevent_callback = nullptr;
    QCPTextElement_ConnectNotify_Callback qcptextelement_connectnotify_callback = nullptr;
    QCPTextElement_DisconnectNotify_Callback qcptextelement_disconnectnotify_callback = nullptr;
    QCPTextElement_MainFont_Callback qcptextelement_mainfont_callback = nullptr;
    QCPTextElement_MainTextColor_Callback qcptextelement_maintextcolor_callback = nullptr;
    QCPTextElement_InitializeParentPlot_Callback qcptextelement_initializeparentplot_callback = nullptr;
    QCPTextElement_SetParentLayerable_Callback qcptextelement_setparentlayerable_callback = nullptr;
    QCPTextElement_MoveToLayer_Callback qcptextelement_movetolayer_callback = nullptr;
    QCPTextElement_ApplyAntialiasingHint_Callback qcptextelement_applyantialiasinghint_callback = nullptr;
    QCPTextElement_Sender_Callback qcptextelement_sender_callback = nullptr;
    QCPTextElement_SenderSignalIndex_Callback qcptextelement_sendersignalindex_callback = nullptr;
    QCPTextElement_Receivers_Callback qcptextelement_receivers_callback = nullptr;
    QCPTextElement_IsSignalConnected_Callback qcptextelement_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcptextelement_metacall_isbase = false;
    mutable bool qcptextelement_selecttest_isbase = false;
    mutable bool qcptextelement_mousepressevent_isbase = false;
    mutable bool qcptextelement_mousereleaseevent_isbase = false;
    mutable bool qcptextelement_mousedoubleclickevent_isbase = false;
    mutable bool qcptextelement_applydefaultantialiasinghint_isbase = false;
    mutable bool qcptextelement_draw_isbase = false;
    mutable bool qcptextelement_minimumoutersizehint_isbase = false;
    mutable bool qcptextelement_maximumoutersizehint_isbase = false;
    mutable bool qcptextelement_selectevent_isbase = false;
    mutable bool qcptextelement_deselectevent_isbase = false;
    mutable bool qcptextelement_update_isbase = false;
    mutable bool qcptextelement_elements_isbase = false;
    mutable bool qcptextelement_calculateautomargin_isbase = false;
    mutable bool qcptextelement_layoutchanged_isbase = false;
    mutable bool qcptextelement_parentplotinitialized_isbase = false;
    mutable bool qcptextelement_selectioncategory_isbase = false;
    mutable bool qcptextelement_cliprect_isbase = false;
    mutable bool qcptextelement_mousemoveevent_isbase = false;
    mutable bool qcptextelement_wheelevent_isbase = false;
    mutable bool qcptextelement_event_isbase = false;
    mutable bool qcptextelement_eventfilter_isbase = false;
    mutable bool qcptextelement_timerevent_isbase = false;
    mutable bool qcptextelement_childevent_isbase = false;
    mutable bool qcptextelement_customevent_isbase = false;
    mutable bool qcptextelement_connectnotify_isbase = false;
    mutable bool qcptextelement_disconnectnotify_isbase = false;
    mutable bool qcptextelement_mainfont_isbase = false;
    mutable bool qcptextelement_maintextcolor_isbase = false;
    mutable bool qcptextelement_initializeparentplot_isbase = false;
    mutable bool qcptextelement_setparentlayerable_isbase = false;
    mutable bool qcptextelement_movetolayer_isbase = false;
    mutable bool qcptextelement_applyantialiasinghint_isbase = false;
    mutable bool qcptextelement_sender_isbase = false;
    mutable bool qcptextelement_sendersignalindex_isbase = false;
    mutable bool qcptextelement_receivers_isbase = false;
    mutable bool qcptextelement_issignalconnected_isbase = false;

  public:
    VirtualQCPTextElement(QCustomPlot* parentPlot) : QCPTextElement(parentPlot) {};
    VirtualQCPTextElement(QCustomPlot* parentPlot, const QString& text) : QCPTextElement(parentPlot, text) {};
    VirtualQCPTextElement(QCustomPlot* parentPlot, const QString& text, double pointSize) : QCPTextElement(parentPlot, text, pointSize) {};
    VirtualQCPTextElement(QCustomPlot* parentPlot, const QString& text, const QString& fontFamily, double pointSize) : QCPTextElement(parentPlot, text, fontFamily, pointSize) {};
    VirtualQCPTextElement(QCustomPlot* parentPlot, const QString& text, const QFont& font) : QCPTextElement(parentPlot, text, font) {};

    ~VirtualQCPTextElement() {
        qcptextelement_metacall_callback = nullptr;
        qcptextelement_selecttest_callback = nullptr;
        qcptextelement_mousepressevent_callback = nullptr;
        qcptextelement_mousereleaseevent_callback = nullptr;
        qcptextelement_mousedoubleclickevent_callback = nullptr;
        qcptextelement_applydefaultantialiasinghint_callback = nullptr;
        qcptextelement_draw_callback = nullptr;
        qcptextelement_minimumoutersizehint_callback = nullptr;
        qcptextelement_maximumoutersizehint_callback = nullptr;
        qcptextelement_selectevent_callback = nullptr;
        qcptextelement_deselectevent_callback = nullptr;
        qcptextelement_update_callback = nullptr;
        qcptextelement_elements_callback = nullptr;
        qcptextelement_calculateautomargin_callback = nullptr;
        qcptextelement_layoutchanged_callback = nullptr;
        qcptextelement_parentplotinitialized_callback = nullptr;
        qcptextelement_selectioncategory_callback = nullptr;
        qcptextelement_cliprect_callback = nullptr;
        qcptextelement_mousemoveevent_callback = nullptr;
        qcptextelement_wheelevent_callback = nullptr;
        qcptextelement_event_callback = nullptr;
        qcptextelement_eventfilter_callback = nullptr;
        qcptextelement_timerevent_callback = nullptr;
        qcptextelement_childevent_callback = nullptr;
        qcptextelement_customevent_callback = nullptr;
        qcptextelement_connectnotify_callback = nullptr;
        qcptextelement_disconnectnotify_callback = nullptr;
        qcptextelement_mainfont_callback = nullptr;
        qcptextelement_maintextcolor_callback = nullptr;
        qcptextelement_initializeparentplot_callback = nullptr;
        qcptextelement_setparentlayerable_callback = nullptr;
        qcptextelement_movetolayer_callback = nullptr;
        qcptextelement_applyantialiasinghint_callback = nullptr;
        qcptextelement_sender_callback = nullptr;
        qcptextelement_sendersignalindex_callback = nullptr;
        qcptextelement_receivers_callback = nullptr;
        qcptextelement_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPTextElement_Metacall_Callback(QCPTextElement_Metacall_Callback cb) { qcptextelement_metacall_callback = cb; }
    inline void setQCPTextElement_SelectTest_Callback(QCPTextElement_SelectTest_Callback cb) { qcptextelement_selecttest_callback = cb; }
    inline void setQCPTextElement_MousePressEvent_Callback(QCPTextElement_MousePressEvent_Callback cb) { qcptextelement_mousepressevent_callback = cb; }
    inline void setQCPTextElement_MouseReleaseEvent_Callback(QCPTextElement_MouseReleaseEvent_Callback cb) { qcptextelement_mousereleaseevent_callback = cb; }
    inline void setQCPTextElement_MouseDoubleClickEvent_Callback(QCPTextElement_MouseDoubleClickEvent_Callback cb) { qcptextelement_mousedoubleclickevent_callback = cb; }
    inline void setQCPTextElement_ApplyDefaultAntialiasingHint_Callback(QCPTextElement_ApplyDefaultAntialiasingHint_Callback cb) { qcptextelement_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPTextElement_Draw_Callback(QCPTextElement_Draw_Callback cb) { qcptextelement_draw_callback = cb; }
    inline void setQCPTextElement_MinimumOuterSizeHint_Callback(QCPTextElement_MinimumOuterSizeHint_Callback cb) { qcptextelement_minimumoutersizehint_callback = cb; }
    inline void setQCPTextElement_MaximumOuterSizeHint_Callback(QCPTextElement_MaximumOuterSizeHint_Callback cb) { qcptextelement_maximumoutersizehint_callback = cb; }
    inline void setQCPTextElement_SelectEvent_Callback(QCPTextElement_SelectEvent_Callback cb) { qcptextelement_selectevent_callback = cb; }
    inline void setQCPTextElement_DeselectEvent_Callback(QCPTextElement_DeselectEvent_Callback cb) { qcptextelement_deselectevent_callback = cb; }
    inline void setQCPTextElement_Update_Callback(QCPTextElement_Update_Callback cb) { qcptextelement_update_callback = cb; }
    inline void setQCPTextElement_Elements_Callback(QCPTextElement_Elements_Callback cb) { qcptextelement_elements_callback = cb; }
    inline void setQCPTextElement_CalculateAutoMargin_Callback(QCPTextElement_CalculateAutoMargin_Callback cb) { qcptextelement_calculateautomargin_callback = cb; }
    inline void setQCPTextElement_LayoutChanged_Callback(QCPTextElement_LayoutChanged_Callback cb) { qcptextelement_layoutchanged_callback = cb; }
    inline void setQCPTextElement_ParentPlotInitialized_Callback(QCPTextElement_ParentPlotInitialized_Callback cb) { qcptextelement_parentplotinitialized_callback = cb; }
    inline void setQCPTextElement_SelectionCategory_Callback(QCPTextElement_SelectionCategory_Callback cb) { qcptextelement_selectioncategory_callback = cb; }
    inline void setQCPTextElement_ClipRect_Callback(QCPTextElement_ClipRect_Callback cb) { qcptextelement_cliprect_callback = cb; }
    inline void setQCPTextElement_MouseMoveEvent_Callback(QCPTextElement_MouseMoveEvent_Callback cb) { qcptextelement_mousemoveevent_callback = cb; }
    inline void setQCPTextElement_WheelEvent_Callback(QCPTextElement_WheelEvent_Callback cb) { qcptextelement_wheelevent_callback = cb; }
    inline void setQCPTextElement_Event_Callback(QCPTextElement_Event_Callback cb) { qcptextelement_event_callback = cb; }
    inline void setQCPTextElement_EventFilter_Callback(QCPTextElement_EventFilter_Callback cb) { qcptextelement_eventfilter_callback = cb; }
    inline void setQCPTextElement_TimerEvent_Callback(QCPTextElement_TimerEvent_Callback cb) { qcptextelement_timerevent_callback = cb; }
    inline void setQCPTextElement_ChildEvent_Callback(QCPTextElement_ChildEvent_Callback cb) { qcptextelement_childevent_callback = cb; }
    inline void setQCPTextElement_CustomEvent_Callback(QCPTextElement_CustomEvent_Callback cb) { qcptextelement_customevent_callback = cb; }
    inline void setQCPTextElement_ConnectNotify_Callback(QCPTextElement_ConnectNotify_Callback cb) { qcptextelement_connectnotify_callback = cb; }
    inline void setQCPTextElement_DisconnectNotify_Callback(QCPTextElement_DisconnectNotify_Callback cb) { qcptextelement_disconnectnotify_callback = cb; }
    inline void setQCPTextElement_MainFont_Callback(QCPTextElement_MainFont_Callback cb) { qcptextelement_mainfont_callback = cb; }
    inline void setQCPTextElement_MainTextColor_Callback(QCPTextElement_MainTextColor_Callback cb) { qcptextelement_maintextcolor_callback = cb; }
    inline void setQCPTextElement_InitializeParentPlot_Callback(QCPTextElement_InitializeParentPlot_Callback cb) { qcptextelement_initializeparentplot_callback = cb; }
    inline void setQCPTextElement_SetParentLayerable_Callback(QCPTextElement_SetParentLayerable_Callback cb) { qcptextelement_setparentlayerable_callback = cb; }
    inline void setQCPTextElement_MoveToLayer_Callback(QCPTextElement_MoveToLayer_Callback cb) { qcptextelement_movetolayer_callback = cb; }
    inline void setQCPTextElement_ApplyAntialiasingHint_Callback(QCPTextElement_ApplyAntialiasingHint_Callback cb) { qcptextelement_applyantialiasinghint_callback = cb; }
    inline void setQCPTextElement_Sender_Callback(QCPTextElement_Sender_Callback cb) { qcptextelement_sender_callback = cb; }
    inline void setQCPTextElement_SenderSignalIndex_Callback(QCPTextElement_SenderSignalIndex_Callback cb) { qcptextelement_sendersignalindex_callback = cb; }
    inline void setQCPTextElement_Receivers_Callback(QCPTextElement_Receivers_Callback cb) { qcptextelement_receivers_callback = cb; }
    inline void setQCPTextElement_IsSignalConnected_Callback(QCPTextElement_IsSignalConnected_Callback cb) { qcptextelement_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPTextElement_Metacall_IsBase(bool value) const { qcptextelement_metacall_isbase = value; }
    inline void setQCPTextElement_SelectTest_IsBase(bool value) const { qcptextelement_selecttest_isbase = value; }
    inline void setQCPTextElement_MousePressEvent_IsBase(bool value) const { qcptextelement_mousepressevent_isbase = value; }
    inline void setQCPTextElement_MouseReleaseEvent_IsBase(bool value) const { qcptextelement_mousereleaseevent_isbase = value; }
    inline void setQCPTextElement_MouseDoubleClickEvent_IsBase(bool value) const { qcptextelement_mousedoubleclickevent_isbase = value; }
    inline void setQCPTextElement_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcptextelement_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPTextElement_Draw_IsBase(bool value) const { qcptextelement_draw_isbase = value; }
    inline void setQCPTextElement_MinimumOuterSizeHint_IsBase(bool value) const { qcptextelement_minimumoutersizehint_isbase = value; }
    inline void setQCPTextElement_MaximumOuterSizeHint_IsBase(bool value) const { qcptextelement_maximumoutersizehint_isbase = value; }
    inline void setQCPTextElement_SelectEvent_IsBase(bool value) const { qcptextelement_selectevent_isbase = value; }
    inline void setQCPTextElement_DeselectEvent_IsBase(bool value) const { qcptextelement_deselectevent_isbase = value; }
    inline void setQCPTextElement_Update_IsBase(bool value) const { qcptextelement_update_isbase = value; }
    inline void setQCPTextElement_Elements_IsBase(bool value) const { qcptextelement_elements_isbase = value; }
    inline void setQCPTextElement_CalculateAutoMargin_IsBase(bool value) const { qcptextelement_calculateautomargin_isbase = value; }
    inline void setQCPTextElement_LayoutChanged_IsBase(bool value) const { qcptextelement_layoutchanged_isbase = value; }
    inline void setQCPTextElement_ParentPlotInitialized_IsBase(bool value) const { qcptextelement_parentplotinitialized_isbase = value; }
    inline void setQCPTextElement_SelectionCategory_IsBase(bool value) const { qcptextelement_selectioncategory_isbase = value; }
    inline void setQCPTextElement_ClipRect_IsBase(bool value) const { qcptextelement_cliprect_isbase = value; }
    inline void setQCPTextElement_MouseMoveEvent_IsBase(bool value) const { qcptextelement_mousemoveevent_isbase = value; }
    inline void setQCPTextElement_WheelEvent_IsBase(bool value) const { qcptextelement_wheelevent_isbase = value; }
    inline void setQCPTextElement_Event_IsBase(bool value) const { qcptextelement_event_isbase = value; }
    inline void setQCPTextElement_EventFilter_IsBase(bool value) const { qcptextelement_eventfilter_isbase = value; }
    inline void setQCPTextElement_TimerEvent_IsBase(bool value) const { qcptextelement_timerevent_isbase = value; }
    inline void setQCPTextElement_ChildEvent_IsBase(bool value) const { qcptextelement_childevent_isbase = value; }
    inline void setQCPTextElement_CustomEvent_IsBase(bool value) const { qcptextelement_customevent_isbase = value; }
    inline void setQCPTextElement_ConnectNotify_IsBase(bool value) const { qcptextelement_connectnotify_isbase = value; }
    inline void setQCPTextElement_DisconnectNotify_IsBase(bool value) const { qcptextelement_disconnectnotify_isbase = value; }
    inline void setQCPTextElement_MainFont_IsBase(bool value) const { qcptextelement_mainfont_isbase = value; }
    inline void setQCPTextElement_MainTextColor_IsBase(bool value) const { qcptextelement_maintextcolor_isbase = value; }
    inline void setQCPTextElement_InitializeParentPlot_IsBase(bool value) const { qcptextelement_initializeparentplot_isbase = value; }
    inline void setQCPTextElement_SetParentLayerable_IsBase(bool value) const { qcptextelement_setparentlayerable_isbase = value; }
    inline void setQCPTextElement_MoveToLayer_IsBase(bool value) const { qcptextelement_movetolayer_isbase = value; }
    inline void setQCPTextElement_ApplyAntialiasingHint_IsBase(bool value) const { qcptextelement_applyantialiasinghint_isbase = value; }
    inline void setQCPTextElement_Sender_IsBase(bool value) const { qcptextelement_sender_isbase = value; }
    inline void setQCPTextElement_SenderSignalIndex_IsBase(bool value) const { qcptextelement_sendersignalindex_isbase = value; }
    inline void setQCPTextElement_Receivers_IsBase(bool value) const { qcptextelement_receivers_isbase = value; }
    inline void setQCPTextElement_IsSignalConnected_IsBase(bool value) const { qcptextelement_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcptextelement_metacall_isbase) {
            qcptextelement_metacall_isbase = false;
            return QCPTextElement::qt_metacall(param1, param2, param3);
        } else if (qcptextelement_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcptextelement_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPTextElement::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcptextelement_selecttest_isbase) {
            qcptextelement_selecttest_isbase = false;
            return QCPTextElement::selectTest(pos, onlySelectable, details);
        } else if (qcptextelement_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcptextelement_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPTextElement::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcptextelement_mousepressevent_isbase) {
            qcptextelement_mousepressevent_isbase = false;
            QCPTextElement::mousePressEvent(event, details);
        } else if (qcptextelement_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcptextelement_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPTextElement::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcptextelement_mousereleaseevent_isbase) {
            qcptextelement_mousereleaseevent_isbase = false;
            QCPTextElement::mouseReleaseEvent(event, startPos);
        } else if (qcptextelement_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcptextelement_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPTextElement::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcptextelement_mousedoubleclickevent_isbase) {
            qcptextelement_mousedoubleclickevent_isbase = false;
            QCPTextElement::mouseDoubleClickEvent(event, details);
        } else if (qcptextelement_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcptextelement_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPTextElement::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcptextelement_applydefaultantialiasinghint_isbase) {
            qcptextelement_applydefaultantialiasinghint_isbase = false;
            QCPTextElement::applyDefaultAntialiasingHint(painter);
        } else if (qcptextelement_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcptextelement_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPTextElement::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcptextelement_draw_isbase) {
            qcptextelement_draw_isbase = false;
            QCPTextElement::draw(painter);
        } else if (qcptextelement_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcptextelement_draw_callback(this, cbval1);
        } else {
            QCPTextElement::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize minimumOuterSizeHint() const override {
        if (qcptextelement_minimumoutersizehint_isbase) {
            qcptextelement_minimumoutersizehint_isbase = false;
            return QCPTextElement::minimumOuterSizeHint();
        } else if (qcptextelement_minimumoutersizehint_callback != nullptr) {
            QSize* callback_ret = qcptextelement_minimumoutersizehint_callback();
            return *callback_ret;
        } else {
            return QCPTextElement::minimumOuterSizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize maximumOuterSizeHint() const override {
        if (qcptextelement_maximumoutersizehint_isbase) {
            qcptextelement_maximumoutersizehint_isbase = false;
            return QCPTextElement::maximumOuterSizeHint();
        } else if (qcptextelement_maximumoutersizehint_callback != nullptr) {
            QSize* callback_ret = qcptextelement_maximumoutersizehint_callback();
            return *callback_ret;
        } else {
            return QCPTextElement::maximumOuterSizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcptextelement_selectevent_isbase) {
            qcptextelement_selectevent_isbase = false;
            QCPTextElement::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcptextelement_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcptextelement_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPTextElement::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcptextelement_deselectevent_isbase) {
            qcptextelement_deselectevent_isbase = false;
            QCPTextElement::deselectEvent(selectionStateChanged);
        } else if (qcptextelement_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcptextelement_deselectevent_callback(this, cbval1);
        } else {
            QCPTextElement::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void update(QCPLayoutElement::UpdatePhase phase) override {
        if (qcptextelement_update_isbase) {
            qcptextelement_update_isbase = false;
            QCPTextElement::update(phase);
        } else if (qcptextelement_update_callback != nullptr) {
            int cbval1 = static_cast<int>(phase);

            qcptextelement_update_callback(this, cbval1);
        } else {
            QCPTextElement::update(phase);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QList<QCPLayoutElement*> elements(bool recursive) const override {
        if (qcptextelement_elements_isbase) {
            qcptextelement_elements_isbase = false;
            return QCPTextElement::elements(recursive);
        } else if (qcptextelement_elements_callback != nullptr) {
            bool cbval1 = recursive;

            QCPLayoutElement** callback_ret = qcptextelement_elements_callback(this, cbval1);
            QList<QCPLayoutElement*> callback_ret_QList;
            // Iterate until null pointer sentinel
            for (QCPLayoutElement** ptridx = callback_ret; *ptridx != nullptr; ptridx++) {
                callback_ret_QList.push_back(*ptridx);
            }
            free(callback_ret);
            return callback_ret_QList;
        } else {
            return QCPTextElement::elements(recursive);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int calculateAutoMargin(QCP::MarginSide side) override {
        if (qcptextelement_calculateautomargin_isbase) {
            qcptextelement_calculateautomargin_isbase = false;
            return QCPTextElement::calculateAutoMargin(side);
        } else if (qcptextelement_calculateautomargin_callback != nullptr) {
            int cbval1 = static_cast<int>(side);

            int callback_ret = qcptextelement_calculateautomargin_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPTextElement::calculateAutoMargin(side);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void layoutChanged() override {
        if (qcptextelement_layoutchanged_isbase) {
            qcptextelement_layoutchanged_isbase = false;
            QCPTextElement::layoutChanged();
        } else if (qcptextelement_layoutchanged_callback != nullptr) {
            qcptextelement_layoutchanged_callback();
        } else {
            QCPTextElement::layoutChanged();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcptextelement_parentplotinitialized_isbase) {
            qcptextelement_parentplotinitialized_isbase = false;
            QCPTextElement::parentPlotInitialized(parentPlot);
        } else if (qcptextelement_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcptextelement_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPTextElement::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcptextelement_selectioncategory_isbase) {
            qcptextelement_selectioncategory_isbase = false;
            return QCPTextElement::selectionCategory();
        } else if (qcptextelement_selectioncategory_callback != nullptr) {
            int callback_ret = qcptextelement_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPTextElement::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcptextelement_cliprect_isbase) {
            qcptextelement_cliprect_isbase = false;
            return QCPTextElement::clipRect();
        } else if (qcptextelement_cliprect_callback != nullptr) {
            QRect* callback_ret = qcptextelement_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPTextElement::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcptextelement_mousemoveevent_isbase) {
            qcptextelement_mousemoveevent_isbase = false;
            QCPTextElement::mouseMoveEvent(event, startPos);
        } else if (qcptextelement_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcptextelement_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPTextElement::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcptextelement_wheelevent_isbase) {
            qcptextelement_wheelevent_isbase = false;
            QCPTextElement::wheelEvent(event);
        } else if (qcptextelement_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcptextelement_wheelevent_callback(this, cbval1);
        } else {
            QCPTextElement::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcptextelement_event_isbase) {
            qcptextelement_event_isbase = false;
            return QCPTextElement::event(event);
        } else if (qcptextelement_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcptextelement_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPTextElement::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcptextelement_eventfilter_isbase) {
            qcptextelement_eventfilter_isbase = false;
            return QCPTextElement::eventFilter(watched, event);
        } else if (qcptextelement_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcptextelement_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPTextElement::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcptextelement_timerevent_isbase) {
            qcptextelement_timerevent_isbase = false;
            QCPTextElement::timerEvent(event);
        } else if (qcptextelement_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcptextelement_timerevent_callback(this, cbval1);
        } else {
            QCPTextElement::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcptextelement_childevent_isbase) {
            qcptextelement_childevent_isbase = false;
            QCPTextElement::childEvent(event);
        } else if (qcptextelement_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcptextelement_childevent_callback(this, cbval1);
        } else {
            QCPTextElement::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcptextelement_customevent_isbase) {
            qcptextelement_customevent_isbase = false;
            QCPTextElement::customEvent(event);
        } else if (qcptextelement_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcptextelement_customevent_callback(this, cbval1);
        } else {
            QCPTextElement::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcptextelement_connectnotify_isbase) {
            qcptextelement_connectnotify_isbase = false;
            QCPTextElement::connectNotify(signal);
        } else if (qcptextelement_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcptextelement_connectnotify_callback(this, cbval1);
        } else {
            QCPTextElement::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcptextelement_disconnectnotify_isbase) {
            qcptextelement_disconnectnotify_isbase = false;
            QCPTextElement::disconnectNotify(signal);
        } else if (qcptextelement_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcptextelement_disconnectnotify_callback(this, cbval1);
        } else {
            QCPTextElement::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    QFont mainFont() const {
        if (qcptextelement_mainfont_isbase) {
            qcptextelement_mainfont_isbase = false;
            return QCPTextElement::mainFont();
        } else if (qcptextelement_mainfont_callback != nullptr) {
            QFont* callback_ret = qcptextelement_mainfont_callback();
            return *callback_ret;
        } else {
            return QCPTextElement::mainFont();
        }
    }

    // Virtual method for C ABI access and custom callback
    QColor mainTextColor() const {
        if (qcptextelement_maintextcolor_isbase) {
            qcptextelement_maintextcolor_isbase = false;
            return QCPTextElement::mainTextColor();
        } else if (qcptextelement_maintextcolor_callback != nullptr) {
            QColor* callback_ret = qcptextelement_maintextcolor_callback();
            return *callback_ret;
        } else {
            return QCPTextElement::mainTextColor();
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcptextelement_initializeparentplot_isbase) {
            qcptextelement_initializeparentplot_isbase = false;
            QCPTextElement::initializeParentPlot(parentPlot);
        } else if (qcptextelement_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcptextelement_initializeparentplot_callback(this, cbval1);
        } else {
            QCPTextElement::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcptextelement_setparentlayerable_isbase) {
            qcptextelement_setparentlayerable_isbase = false;
            QCPTextElement::setParentLayerable(parentLayerable);
        } else if (qcptextelement_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcptextelement_setparentlayerable_callback(this, cbval1);
        } else {
            QCPTextElement::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcptextelement_movetolayer_isbase) {
            qcptextelement_movetolayer_isbase = false;
            return QCPTextElement::moveToLayer(layer, prepend);
        } else if (qcptextelement_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcptextelement_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPTextElement::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcptextelement_applyantialiasinghint_isbase) {
            qcptextelement_applyantialiasinghint_isbase = false;
            QCPTextElement::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcptextelement_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcptextelement_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPTextElement::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcptextelement_sender_isbase) {
            qcptextelement_sender_isbase = false;
            return QCPTextElement::sender();
        } else if (qcptextelement_sender_callback != nullptr) {
            QObject* callback_ret = qcptextelement_sender_callback();
            return callback_ret;
        } else {
            return QCPTextElement::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcptextelement_sendersignalindex_isbase) {
            qcptextelement_sendersignalindex_isbase = false;
            return QCPTextElement::senderSignalIndex();
        } else if (qcptextelement_sendersignalindex_callback != nullptr) {
            int callback_ret = qcptextelement_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPTextElement::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcptextelement_receivers_isbase) {
            qcptextelement_receivers_isbase = false;
            return QCPTextElement::receivers(signal);
        } else if (qcptextelement_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcptextelement_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPTextElement::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcptextelement_issignalconnected_isbase) {
            qcptextelement_issignalconnected_isbase = false;
            return QCPTextElement::isSignalConnected(signal);
        } else if (qcptextelement_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcptextelement_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPTextElement::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPTextElement_ApplyDefaultAntialiasingHint(const QCPTextElement* self, QCPPainter* painter);
    friend void QCPTextElement_QBaseApplyDefaultAntialiasingHint(const QCPTextElement* self, QCPPainter* painter);
    friend void QCPTextElement_Draw(QCPTextElement* self, QCPPainter* painter);
    friend void QCPTextElement_QBaseDraw(QCPTextElement* self, QCPPainter* painter);
    friend QSize* QCPTextElement_MinimumOuterSizeHint(const QCPTextElement* self);
    friend QSize* QCPTextElement_QBaseMinimumOuterSizeHint(const QCPTextElement* self);
    friend QSize* QCPTextElement_MaximumOuterSizeHint(const QCPTextElement* self);
    friend QSize* QCPTextElement_QBaseMaximumOuterSizeHint(const QCPTextElement* self);
    friend void QCPTextElement_SelectEvent(QCPTextElement* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPTextElement_QBaseSelectEvent(QCPTextElement* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPTextElement_DeselectEvent(QCPTextElement* self, bool* selectionStateChanged);
    friend void QCPTextElement_QBaseDeselectEvent(QCPTextElement* self, bool* selectionStateChanged);
    friend int QCPTextElement_CalculateAutoMargin(QCPTextElement* self, int side);
    friend int QCPTextElement_QBaseCalculateAutoMargin(QCPTextElement* self, int side);
    friend void QCPTextElement_LayoutChanged(QCPTextElement* self);
    friend void QCPTextElement_QBaseLayoutChanged(QCPTextElement* self);
    friend void QCPTextElement_ParentPlotInitialized(QCPTextElement* self, QCustomPlot* parentPlot);
    friend void QCPTextElement_QBaseParentPlotInitialized(QCPTextElement* self, QCustomPlot* parentPlot);
    friend int QCPTextElement_SelectionCategory(const QCPTextElement* self);
    friend int QCPTextElement_QBaseSelectionCategory(const QCPTextElement* self);
    friend QRect* QCPTextElement_ClipRect(const QCPTextElement* self);
    friend QRect* QCPTextElement_QBaseClipRect(const QCPTextElement* self);
    friend void QCPTextElement_MouseMoveEvent(QCPTextElement* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPTextElement_QBaseMouseMoveEvent(QCPTextElement* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPTextElement_WheelEvent(QCPTextElement* self, QWheelEvent* event);
    friend void QCPTextElement_QBaseWheelEvent(QCPTextElement* self, QWheelEvent* event);
    friend void QCPTextElement_TimerEvent(QCPTextElement* self, QTimerEvent* event);
    friend void QCPTextElement_QBaseTimerEvent(QCPTextElement* self, QTimerEvent* event);
    friend void QCPTextElement_ChildEvent(QCPTextElement* self, QChildEvent* event);
    friend void QCPTextElement_QBaseChildEvent(QCPTextElement* self, QChildEvent* event);
    friend void QCPTextElement_CustomEvent(QCPTextElement* self, QEvent* event);
    friend void QCPTextElement_QBaseCustomEvent(QCPTextElement* self, QEvent* event);
    friend void QCPTextElement_ConnectNotify(QCPTextElement* self, const QMetaMethod* signal);
    friend void QCPTextElement_QBaseConnectNotify(QCPTextElement* self, const QMetaMethod* signal);
    friend void QCPTextElement_DisconnectNotify(QCPTextElement* self, const QMetaMethod* signal);
    friend void QCPTextElement_QBaseDisconnectNotify(QCPTextElement* self, const QMetaMethod* signal);
    friend QFont* QCPTextElement_MainFont(const QCPTextElement* self);
    friend QFont* QCPTextElement_QBaseMainFont(const QCPTextElement* self);
    friend QColor* QCPTextElement_MainTextColor(const QCPTextElement* self);
    friend QColor* QCPTextElement_QBaseMainTextColor(const QCPTextElement* self);
    friend void QCPTextElement_InitializeParentPlot(QCPTextElement* self, QCustomPlot* parentPlot);
    friend void QCPTextElement_QBaseInitializeParentPlot(QCPTextElement* self, QCustomPlot* parentPlot);
    friend void QCPTextElement_SetParentLayerable(QCPTextElement* self, QCPLayerable* parentLayerable);
    friend void QCPTextElement_QBaseSetParentLayerable(QCPTextElement* self, QCPLayerable* parentLayerable);
    friend bool QCPTextElement_MoveToLayer(QCPTextElement* self, QCPLayer* layer, bool prepend);
    friend bool QCPTextElement_QBaseMoveToLayer(QCPTextElement* self, QCPLayer* layer, bool prepend);
    friend void QCPTextElement_ApplyAntialiasingHint(const QCPTextElement* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPTextElement_QBaseApplyAntialiasingHint(const QCPTextElement* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPTextElement_Sender(const QCPTextElement* self);
    friend QObject* QCPTextElement_QBaseSender(const QCPTextElement* self);
    friend int QCPTextElement_SenderSignalIndex(const QCPTextElement* self);
    friend int QCPTextElement_QBaseSenderSignalIndex(const QCPTextElement* self);
    friend int QCPTextElement_Receivers(const QCPTextElement* self, const char* signal);
    friend int QCPTextElement_QBaseReceivers(const QCPTextElement* self, const char* signal);
    friend bool QCPTextElement_IsSignalConnected(const QCPTextElement* self, const QMetaMethod* signal);
    friend bool QCPTextElement_QBaseIsSignalConnected(const QCPTextElement* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPColorScale so that we can call protected methods
class VirtualQCPColorScale final : public QCPColorScale {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPColorScale = true;

    // Virtual class public types (including callbacks)
    using QCPColorScale_Metacall_Callback = int (*)(QCPColorScale*, int, int, void**);
    using QCPColorScale_Update_Callback = void (*)(QCPColorScale*, int);
    using QCPColorScale_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPColorScale*, QCPPainter*);
    using QCPColorScale_MousePressEvent_Callback = void (*)(QCPColorScale*, QMouseEvent*, QVariant*);
    using QCPColorScale_MouseMoveEvent_Callback = void (*)(QCPColorScale*, QMouseEvent*, QPointF*);
    using QCPColorScale_MouseReleaseEvent_Callback = void (*)(QCPColorScale*, QMouseEvent*, QPointF*);
    using QCPColorScale_WheelEvent_Callback = void (*)(QCPColorScale*, QWheelEvent*);
    using QCPColorScale_MinimumOuterSizeHint_Callback = QSize* (*)();
    using QCPColorScale_MaximumOuterSizeHint_Callback = QSize* (*)();
    using QCPColorScale_Elements_Callback = QCPLayoutElement** (*)(const QCPColorScale*, bool);
    using QCPColorScale_SelectTest_Callback = double (*)(const QCPColorScale*, QPointF*, bool, QVariant*);
    using QCPColorScale_CalculateAutoMargin_Callback = int (*)(QCPColorScale*, int);
    using QCPColorScale_LayoutChanged_Callback = void (*)();
    using QCPColorScale_Draw_Callback = void (*)(QCPColorScale*, QCPPainter*);
    using QCPColorScale_ParentPlotInitialized_Callback = void (*)(QCPColorScale*, QCustomPlot*);
    using QCPColorScale_SelectionCategory_Callback = int (*)();
    using QCPColorScale_ClipRect_Callback = QRect* (*)();
    using QCPColorScale_SelectEvent_Callback = void (*)(QCPColorScale*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPColorScale_DeselectEvent_Callback = void (*)(QCPColorScale*, bool*);
    using QCPColorScale_MouseDoubleClickEvent_Callback = void (*)(QCPColorScale*, QMouseEvent*, QVariant*);
    using QCPColorScale_Event_Callback = bool (*)(QCPColorScale*, QEvent*);
    using QCPColorScale_EventFilter_Callback = bool (*)(QCPColorScale*, QObject*, QEvent*);
    using QCPColorScale_TimerEvent_Callback = void (*)(QCPColorScale*, QTimerEvent*);
    using QCPColorScale_ChildEvent_Callback = void (*)(QCPColorScale*, QChildEvent*);
    using QCPColorScale_CustomEvent_Callback = void (*)(QCPColorScale*, QEvent*);
    using QCPColorScale_ConnectNotify_Callback = void (*)(QCPColorScale*, QMetaMethod*);
    using QCPColorScale_DisconnectNotify_Callback = void (*)(QCPColorScale*, QMetaMethod*);
    using QCPColorScale_InitializeParentPlot_Callback = void (*)(QCPColorScale*, QCustomPlot*);
    using QCPColorScale_SetParentLayerable_Callback = void (*)(QCPColorScale*, QCPLayerable*);
    using QCPColorScale_MoveToLayer_Callback = bool (*)(QCPColorScale*, QCPLayer*, bool);
    using QCPColorScale_ApplyAntialiasingHint_Callback = void (*)(const QCPColorScale*, QCPPainter*, bool, int);
    using QCPColorScale_Sender_Callback = QObject* (*)();
    using QCPColorScale_SenderSignalIndex_Callback = int (*)();
    using QCPColorScale_Receivers_Callback = int (*)(const QCPColorScale*, const char*);
    using QCPColorScale_IsSignalConnected_Callback = bool (*)(const QCPColorScale*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPColorScale_Metacall_Callback qcpcolorscale_metacall_callback = nullptr;
    QCPColorScale_Update_Callback qcpcolorscale_update_callback = nullptr;
    QCPColorScale_ApplyDefaultAntialiasingHint_Callback qcpcolorscale_applydefaultantialiasinghint_callback = nullptr;
    QCPColorScale_MousePressEvent_Callback qcpcolorscale_mousepressevent_callback = nullptr;
    QCPColorScale_MouseMoveEvent_Callback qcpcolorscale_mousemoveevent_callback = nullptr;
    QCPColorScale_MouseReleaseEvent_Callback qcpcolorscale_mousereleaseevent_callback = nullptr;
    QCPColorScale_WheelEvent_Callback qcpcolorscale_wheelevent_callback = nullptr;
    QCPColorScale_MinimumOuterSizeHint_Callback qcpcolorscale_minimumoutersizehint_callback = nullptr;
    QCPColorScale_MaximumOuterSizeHint_Callback qcpcolorscale_maximumoutersizehint_callback = nullptr;
    QCPColorScale_Elements_Callback qcpcolorscale_elements_callback = nullptr;
    QCPColorScale_SelectTest_Callback qcpcolorscale_selecttest_callback = nullptr;
    QCPColorScale_CalculateAutoMargin_Callback qcpcolorscale_calculateautomargin_callback = nullptr;
    QCPColorScale_LayoutChanged_Callback qcpcolorscale_layoutchanged_callback = nullptr;
    QCPColorScale_Draw_Callback qcpcolorscale_draw_callback = nullptr;
    QCPColorScale_ParentPlotInitialized_Callback qcpcolorscale_parentplotinitialized_callback = nullptr;
    QCPColorScale_SelectionCategory_Callback qcpcolorscale_selectioncategory_callback = nullptr;
    QCPColorScale_ClipRect_Callback qcpcolorscale_cliprect_callback = nullptr;
    QCPColorScale_SelectEvent_Callback qcpcolorscale_selectevent_callback = nullptr;
    QCPColorScale_DeselectEvent_Callback qcpcolorscale_deselectevent_callback = nullptr;
    QCPColorScale_MouseDoubleClickEvent_Callback qcpcolorscale_mousedoubleclickevent_callback = nullptr;
    QCPColorScale_Event_Callback qcpcolorscale_event_callback = nullptr;
    QCPColorScale_EventFilter_Callback qcpcolorscale_eventfilter_callback = nullptr;
    QCPColorScale_TimerEvent_Callback qcpcolorscale_timerevent_callback = nullptr;
    QCPColorScale_ChildEvent_Callback qcpcolorscale_childevent_callback = nullptr;
    QCPColorScale_CustomEvent_Callback qcpcolorscale_customevent_callback = nullptr;
    QCPColorScale_ConnectNotify_Callback qcpcolorscale_connectnotify_callback = nullptr;
    QCPColorScale_DisconnectNotify_Callback qcpcolorscale_disconnectnotify_callback = nullptr;
    QCPColorScale_InitializeParentPlot_Callback qcpcolorscale_initializeparentplot_callback = nullptr;
    QCPColorScale_SetParentLayerable_Callback qcpcolorscale_setparentlayerable_callback = nullptr;
    QCPColorScale_MoveToLayer_Callback qcpcolorscale_movetolayer_callback = nullptr;
    QCPColorScale_ApplyAntialiasingHint_Callback qcpcolorscale_applyantialiasinghint_callback = nullptr;
    QCPColorScale_Sender_Callback qcpcolorscale_sender_callback = nullptr;
    QCPColorScale_SenderSignalIndex_Callback qcpcolorscale_sendersignalindex_callback = nullptr;
    QCPColorScale_Receivers_Callback qcpcolorscale_receivers_callback = nullptr;
    QCPColorScale_IsSignalConnected_Callback qcpcolorscale_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpcolorscale_metacall_isbase = false;
    mutable bool qcpcolorscale_update_isbase = false;
    mutable bool qcpcolorscale_applydefaultantialiasinghint_isbase = false;
    mutable bool qcpcolorscale_mousepressevent_isbase = false;
    mutable bool qcpcolorscale_mousemoveevent_isbase = false;
    mutable bool qcpcolorscale_mousereleaseevent_isbase = false;
    mutable bool qcpcolorscale_wheelevent_isbase = false;
    mutable bool qcpcolorscale_minimumoutersizehint_isbase = false;
    mutable bool qcpcolorscale_maximumoutersizehint_isbase = false;
    mutable bool qcpcolorscale_elements_isbase = false;
    mutable bool qcpcolorscale_selecttest_isbase = false;
    mutable bool qcpcolorscale_calculateautomargin_isbase = false;
    mutable bool qcpcolorscale_layoutchanged_isbase = false;
    mutable bool qcpcolorscale_draw_isbase = false;
    mutable bool qcpcolorscale_parentplotinitialized_isbase = false;
    mutable bool qcpcolorscale_selectioncategory_isbase = false;
    mutable bool qcpcolorscale_cliprect_isbase = false;
    mutable bool qcpcolorscale_selectevent_isbase = false;
    mutable bool qcpcolorscale_deselectevent_isbase = false;
    mutable bool qcpcolorscale_mousedoubleclickevent_isbase = false;
    mutable bool qcpcolorscale_event_isbase = false;
    mutable bool qcpcolorscale_eventfilter_isbase = false;
    mutable bool qcpcolorscale_timerevent_isbase = false;
    mutable bool qcpcolorscale_childevent_isbase = false;
    mutable bool qcpcolorscale_customevent_isbase = false;
    mutable bool qcpcolorscale_connectnotify_isbase = false;
    mutable bool qcpcolorscale_disconnectnotify_isbase = false;
    mutable bool qcpcolorscale_initializeparentplot_isbase = false;
    mutable bool qcpcolorscale_setparentlayerable_isbase = false;
    mutable bool qcpcolorscale_movetolayer_isbase = false;
    mutable bool qcpcolorscale_applyantialiasinghint_isbase = false;
    mutable bool qcpcolorscale_sender_isbase = false;
    mutable bool qcpcolorscale_sendersignalindex_isbase = false;
    mutable bool qcpcolorscale_receivers_isbase = false;
    mutable bool qcpcolorscale_issignalconnected_isbase = false;

  public:
    VirtualQCPColorScale(QCustomPlot* parentPlot) : QCPColorScale(parentPlot) {};

    ~VirtualQCPColorScale() {
        qcpcolorscale_metacall_callback = nullptr;
        qcpcolorscale_update_callback = nullptr;
        qcpcolorscale_applydefaultantialiasinghint_callback = nullptr;
        qcpcolorscale_mousepressevent_callback = nullptr;
        qcpcolorscale_mousemoveevent_callback = nullptr;
        qcpcolorscale_mousereleaseevent_callback = nullptr;
        qcpcolorscale_wheelevent_callback = nullptr;
        qcpcolorscale_minimumoutersizehint_callback = nullptr;
        qcpcolorscale_maximumoutersizehint_callback = nullptr;
        qcpcolorscale_elements_callback = nullptr;
        qcpcolorscale_selecttest_callback = nullptr;
        qcpcolorscale_calculateautomargin_callback = nullptr;
        qcpcolorscale_layoutchanged_callback = nullptr;
        qcpcolorscale_draw_callback = nullptr;
        qcpcolorscale_parentplotinitialized_callback = nullptr;
        qcpcolorscale_selectioncategory_callback = nullptr;
        qcpcolorscale_cliprect_callback = nullptr;
        qcpcolorscale_selectevent_callback = nullptr;
        qcpcolorscale_deselectevent_callback = nullptr;
        qcpcolorscale_mousedoubleclickevent_callback = nullptr;
        qcpcolorscale_event_callback = nullptr;
        qcpcolorscale_eventfilter_callback = nullptr;
        qcpcolorscale_timerevent_callback = nullptr;
        qcpcolorscale_childevent_callback = nullptr;
        qcpcolorscale_customevent_callback = nullptr;
        qcpcolorscale_connectnotify_callback = nullptr;
        qcpcolorscale_disconnectnotify_callback = nullptr;
        qcpcolorscale_initializeparentplot_callback = nullptr;
        qcpcolorscale_setparentlayerable_callback = nullptr;
        qcpcolorscale_movetolayer_callback = nullptr;
        qcpcolorscale_applyantialiasinghint_callback = nullptr;
        qcpcolorscale_sender_callback = nullptr;
        qcpcolorscale_sendersignalindex_callback = nullptr;
        qcpcolorscale_receivers_callback = nullptr;
        qcpcolorscale_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPColorScale_Metacall_Callback(QCPColorScale_Metacall_Callback cb) { qcpcolorscale_metacall_callback = cb; }
    inline void setQCPColorScale_Update_Callback(QCPColorScale_Update_Callback cb) { qcpcolorscale_update_callback = cb; }
    inline void setQCPColorScale_ApplyDefaultAntialiasingHint_Callback(QCPColorScale_ApplyDefaultAntialiasingHint_Callback cb) { qcpcolorscale_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPColorScale_MousePressEvent_Callback(QCPColorScale_MousePressEvent_Callback cb) { qcpcolorscale_mousepressevent_callback = cb; }
    inline void setQCPColorScale_MouseMoveEvent_Callback(QCPColorScale_MouseMoveEvent_Callback cb) { qcpcolorscale_mousemoveevent_callback = cb; }
    inline void setQCPColorScale_MouseReleaseEvent_Callback(QCPColorScale_MouseReleaseEvent_Callback cb) { qcpcolorscale_mousereleaseevent_callback = cb; }
    inline void setQCPColorScale_WheelEvent_Callback(QCPColorScale_WheelEvent_Callback cb) { qcpcolorscale_wheelevent_callback = cb; }
    inline void setQCPColorScale_MinimumOuterSizeHint_Callback(QCPColorScale_MinimumOuterSizeHint_Callback cb) { qcpcolorscale_minimumoutersizehint_callback = cb; }
    inline void setQCPColorScale_MaximumOuterSizeHint_Callback(QCPColorScale_MaximumOuterSizeHint_Callback cb) { qcpcolorscale_maximumoutersizehint_callback = cb; }
    inline void setQCPColorScale_Elements_Callback(QCPColorScale_Elements_Callback cb) { qcpcolorscale_elements_callback = cb; }
    inline void setQCPColorScale_SelectTest_Callback(QCPColorScale_SelectTest_Callback cb) { qcpcolorscale_selecttest_callback = cb; }
    inline void setQCPColorScale_CalculateAutoMargin_Callback(QCPColorScale_CalculateAutoMargin_Callback cb) { qcpcolorscale_calculateautomargin_callback = cb; }
    inline void setQCPColorScale_LayoutChanged_Callback(QCPColorScale_LayoutChanged_Callback cb) { qcpcolorscale_layoutchanged_callback = cb; }
    inline void setQCPColorScale_Draw_Callback(QCPColorScale_Draw_Callback cb) { qcpcolorscale_draw_callback = cb; }
    inline void setQCPColorScale_ParentPlotInitialized_Callback(QCPColorScale_ParentPlotInitialized_Callback cb) { qcpcolorscale_parentplotinitialized_callback = cb; }
    inline void setQCPColorScale_SelectionCategory_Callback(QCPColorScale_SelectionCategory_Callback cb) { qcpcolorscale_selectioncategory_callback = cb; }
    inline void setQCPColorScale_ClipRect_Callback(QCPColorScale_ClipRect_Callback cb) { qcpcolorscale_cliprect_callback = cb; }
    inline void setQCPColorScale_SelectEvent_Callback(QCPColorScale_SelectEvent_Callback cb) { qcpcolorscale_selectevent_callback = cb; }
    inline void setQCPColorScale_DeselectEvent_Callback(QCPColorScale_DeselectEvent_Callback cb) { qcpcolorscale_deselectevent_callback = cb; }
    inline void setQCPColorScale_MouseDoubleClickEvent_Callback(QCPColorScale_MouseDoubleClickEvent_Callback cb) { qcpcolorscale_mousedoubleclickevent_callback = cb; }
    inline void setQCPColorScale_Event_Callback(QCPColorScale_Event_Callback cb) { qcpcolorscale_event_callback = cb; }
    inline void setQCPColorScale_EventFilter_Callback(QCPColorScale_EventFilter_Callback cb) { qcpcolorscale_eventfilter_callback = cb; }
    inline void setQCPColorScale_TimerEvent_Callback(QCPColorScale_TimerEvent_Callback cb) { qcpcolorscale_timerevent_callback = cb; }
    inline void setQCPColorScale_ChildEvent_Callback(QCPColorScale_ChildEvent_Callback cb) { qcpcolorscale_childevent_callback = cb; }
    inline void setQCPColorScale_CustomEvent_Callback(QCPColorScale_CustomEvent_Callback cb) { qcpcolorscale_customevent_callback = cb; }
    inline void setQCPColorScale_ConnectNotify_Callback(QCPColorScale_ConnectNotify_Callback cb) { qcpcolorscale_connectnotify_callback = cb; }
    inline void setQCPColorScale_DisconnectNotify_Callback(QCPColorScale_DisconnectNotify_Callback cb) { qcpcolorscale_disconnectnotify_callback = cb; }
    inline void setQCPColorScale_InitializeParentPlot_Callback(QCPColorScale_InitializeParentPlot_Callback cb) { qcpcolorscale_initializeparentplot_callback = cb; }
    inline void setQCPColorScale_SetParentLayerable_Callback(QCPColorScale_SetParentLayerable_Callback cb) { qcpcolorscale_setparentlayerable_callback = cb; }
    inline void setQCPColorScale_MoveToLayer_Callback(QCPColorScale_MoveToLayer_Callback cb) { qcpcolorscale_movetolayer_callback = cb; }
    inline void setQCPColorScale_ApplyAntialiasingHint_Callback(QCPColorScale_ApplyAntialiasingHint_Callback cb) { qcpcolorscale_applyantialiasinghint_callback = cb; }
    inline void setQCPColorScale_Sender_Callback(QCPColorScale_Sender_Callback cb) { qcpcolorscale_sender_callback = cb; }
    inline void setQCPColorScale_SenderSignalIndex_Callback(QCPColorScale_SenderSignalIndex_Callback cb) { qcpcolorscale_sendersignalindex_callback = cb; }
    inline void setQCPColorScale_Receivers_Callback(QCPColorScale_Receivers_Callback cb) { qcpcolorscale_receivers_callback = cb; }
    inline void setQCPColorScale_IsSignalConnected_Callback(QCPColorScale_IsSignalConnected_Callback cb) { qcpcolorscale_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPColorScale_Metacall_IsBase(bool value) const { qcpcolorscale_metacall_isbase = value; }
    inline void setQCPColorScale_Update_IsBase(bool value) const { qcpcolorscale_update_isbase = value; }
    inline void setQCPColorScale_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcpcolorscale_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPColorScale_MousePressEvent_IsBase(bool value) const { qcpcolorscale_mousepressevent_isbase = value; }
    inline void setQCPColorScale_MouseMoveEvent_IsBase(bool value) const { qcpcolorscale_mousemoveevent_isbase = value; }
    inline void setQCPColorScale_MouseReleaseEvent_IsBase(bool value) const { qcpcolorscale_mousereleaseevent_isbase = value; }
    inline void setQCPColorScale_WheelEvent_IsBase(bool value) const { qcpcolorscale_wheelevent_isbase = value; }
    inline void setQCPColorScale_MinimumOuterSizeHint_IsBase(bool value) const { qcpcolorscale_minimumoutersizehint_isbase = value; }
    inline void setQCPColorScale_MaximumOuterSizeHint_IsBase(bool value) const { qcpcolorscale_maximumoutersizehint_isbase = value; }
    inline void setQCPColorScale_Elements_IsBase(bool value) const { qcpcolorscale_elements_isbase = value; }
    inline void setQCPColorScale_SelectTest_IsBase(bool value) const { qcpcolorscale_selecttest_isbase = value; }
    inline void setQCPColorScale_CalculateAutoMargin_IsBase(bool value) const { qcpcolorscale_calculateautomargin_isbase = value; }
    inline void setQCPColorScale_LayoutChanged_IsBase(bool value) const { qcpcolorscale_layoutchanged_isbase = value; }
    inline void setQCPColorScale_Draw_IsBase(bool value) const { qcpcolorscale_draw_isbase = value; }
    inline void setQCPColorScale_ParentPlotInitialized_IsBase(bool value) const { qcpcolorscale_parentplotinitialized_isbase = value; }
    inline void setQCPColorScale_SelectionCategory_IsBase(bool value) const { qcpcolorscale_selectioncategory_isbase = value; }
    inline void setQCPColorScale_ClipRect_IsBase(bool value) const { qcpcolorscale_cliprect_isbase = value; }
    inline void setQCPColorScale_SelectEvent_IsBase(bool value) const { qcpcolorscale_selectevent_isbase = value; }
    inline void setQCPColorScale_DeselectEvent_IsBase(bool value) const { qcpcolorscale_deselectevent_isbase = value; }
    inline void setQCPColorScale_MouseDoubleClickEvent_IsBase(bool value) const { qcpcolorscale_mousedoubleclickevent_isbase = value; }
    inline void setQCPColorScale_Event_IsBase(bool value) const { qcpcolorscale_event_isbase = value; }
    inline void setQCPColorScale_EventFilter_IsBase(bool value) const { qcpcolorscale_eventfilter_isbase = value; }
    inline void setQCPColorScale_TimerEvent_IsBase(bool value) const { qcpcolorscale_timerevent_isbase = value; }
    inline void setQCPColorScale_ChildEvent_IsBase(bool value) const { qcpcolorscale_childevent_isbase = value; }
    inline void setQCPColorScale_CustomEvent_IsBase(bool value) const { qcpcolorscale_customevent_isbase = value; }
    inline void setQCPColorScale_ConnectNotify_IsBase(bool value) const { qcpcolorscale_connectnotify_isbase = value; }
    inline void setQCPColorScale_DisconnectNotify_IsBase(bool value) const { qcpcolorscale_disconnectnotify_isbase = value; }
    inline void setQCPColorScale_InitializeParentPlot_IsBase(bool value) const { qcpcolorscale_initializeparentplot_isbase = value; }
    inline void setQCPColorScale_SetParentLayerable_IsBase(bool value) const { qcpcolorscale_setparentlayerable_isbase = value; }
    inline void setQCPColorScale_MoveToLayer_IsBase(bool value) const { qcpcolorscale_movetolayer_isbase = value; }
    inline void setQCPColorScale_ApplyAntialiasingHint_IsBase(bool value) const { qcpcolorscale_applyantialiasinghint_isbase = value; }
    inline void setQCPColorScale_Sender_IsBase(bool value) const { qcpcolorscale_sender_isbase = value; }
    inline void setQCPColorScale_SenderSignalIndex_IsBase(bool value) const { qcpcolorscale_sendersignalindex_isbase = value; }
    inline void setQCPColorScale_Receivers_IsBase(bool value) const { qcpcolorscale_receivers_isbase = value; }
    inline void setQCPColorScale_IsSignalConnected_IsBase(bool value) const { qcpcolorscale_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpcolorscale_metacall_isbase) {
            qcpcolorscale_metacall_isbase = false;
            return QCPColorScale::qt_metacall(param1, param2, param3);
        } else if (qcpcolorscale_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpcolorscale_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPColorScale::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void update(QCPLayoutElement::UpdatePhase phase) override {
        if (qcpcolorscale_update_isbase) {
            qcpcolorscale_update_isbase = false;
            QCPColorScale::update(phase);
        } else if (qcpcolorscale_update_callback != nullptr) {
            int cbval1 = static_cast<int>(phase);

            qcpcolorscale_update_callback(this, cbval1);
        } else {
            QCPColorScale::update(phase);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcpcolorscale_applydefaultantialiasinghint_isbase) {
            qcpcolorscale_applydefaultantialiasinghint_isbase = false;
            QCPColorScale::applyDefaultAntialiasingHint(painter);
        } else if (qcpcolorscale_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpcolorscale_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPColorScale::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpcolorscale_mousepressevent_isbase) {
            qcpcolorscale_mousepressevent_isbase = false;
            QCPColorScale::mousePressEvent(event, details);
        } else if (qcpcolorscale_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpcolorscale_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPColorScale::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpcolorscale_mousemoveevent_isbase) {
            qcpcolorscale_mousemoveevent_isbase = false;
            QCPColorScale::mouseMoveEvent(event, startPos);
        } else if (qcpcolorscale_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpcolorscale_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPColorScale::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpcolorscale_mousereleaseevent_isbase) {
            qcpcolorscale_mousereleaseevent_isbase = false;
            QCPColorScale::mouseReleaseEvent(event, startPos);
        } else if (qcpcolorscale_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpcolorscale_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPColorScale::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcpcolorscale_wheelevent_isbase) {
            qcpcolorscale_wheelevent_isbase = false;
            QCPColorScale::wheelEvent(event);
        } else if (qcpcolorscale_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcpcolorscale_wheelevent_callback(this, cbval1);
        } else {
            QCPColorScale::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize minimumOuterSizeHint() const override {
        if (qcpcolorscale_minimumoutersizehint_isbase) {
            qcpcolorscale_minimumoutersizehint_isbase = false;
            return QCPColorScale::minimumOuterSizeHint();
        } else if (qcpcolorscale_minimumoutersizehint_callback != nullptr) {
            QSize* callback_ret = qcpcolorscale_minimumoutersizehint_callback();
            return *callback_ret;
        } else {
            return QCPColorScale::minimumOuterSizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize maximumOuterSizeHint() const override {
        if (qcpcolorscale_maximumoutersizehint_isbase) {
            qcpcolorscale_maximumoutersizehint_isbase = false;
            return QCPColorScale::maximumOuterSizeHint();
        } else if (qcpcolorscale_maximumoutersizehint_callback != nullptr) {
            QSize* callback_ret = qcpcolorscale_maximumoutersizehint_callback();
            return *callback_ret;
        } else {
            return QCPColorScale::maximumOuterSizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QList<QCPLayoutElement*> elements(bool recursive) const override {
        if (qcpcolorscale_elements_isbase) {
            qcpcolorscale_elements_isbase = false;
            return QCPColorScale::elements(recursive);
        } else if (qcpcolorscale_elements_callback != nullptr) {
            bool cbval1 = recursive;

            QCPLayoutElement** callback_ret = qcpcolorscale_elements_callback(this, cbval1);
            QList<QCPLayoutElement*> callback_ret_QList;
            // Iterate until null pointer sentinel
            for (QCPLayoutElement** ptridx = callback_ret; *ptridx != nullptr; ptridx++) {
                callback_ret_QList.push_back(*ptridx);
            }
            free(callback_ret);
            return callback_ret_QList;
        } else {
            return QCPColorScale::elements(recursive);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcpcolorscale_selecttest_isbase) {
            qcpcolorscale_selecttest_isbase = false;
            return QCPColorScale::selectTest(pos, onlySelectable, details);
        } else if (qcpcolorscale_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcpcolorscale_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPColorScale::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int calculateAutoMargin(QCP::MarginSide side) override {
        if (qcpcolorscale_calculateautomargin_isbase) {
            qcpcolorscale_calculateautomargin_isbase = false;
            return QCPColorScale::calculateAutoMargin(side);
        } else if (qcpcolorscale_calculateautomargin_callback != nullptr) {
            int cbval1 = static_cast<int>(side);

            int callback_ret = qcpcolorscale_calculateautomargin_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPColorScale::calculateAutoMargin(side);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void layoutChanged() override {
        if (qcpcolorscale_layoutchanged_isbase) {
            qcpcolorscale_layoutchanged_isbase = false;
            QCPColorScale::layoutChanged();
        } else if (qcpcolorscale_layoutchanged_callback != nullptr) {
            qcpcolorscale_layoutchanged_callback();
        } else {
            QCPColorScale::layoutChanged();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcpcolorscale_draw_isbase) {
            qcpcolorscale_draw_isbase = false;
            QCPColorScale::draw(painter);
        } else if (qcpcolorscale_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpcolorscale_draw_callback(this, cbval1);
        } else {
            QCPColorScale::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcpcolorscale_parentplotinitialized_isbase) {
            qcpcolorscale_parentplotinitialized_isbase = false;
            QCPColorScale::parentPlotInitialized(parentPlot);
        } else if (qcpcolorscale_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpcolorscale_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPColorScale::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcpcolorscale_selectioncategory_isbase) {
            qcpcolorscale_selectioncategory_isbase = false;
            return QCPColorScale::selectionCategory();
        } else if (qcpcolorscale_selectioncategory_callback != nullptr) {
            int callback_ret = qcpcolorscale_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPColorScale::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcpcolorscale_cliprect_isbase) {
            qcpcolorscale_cliprect_isbase = false;
            return QCPColorScale::clipRect();
        } else if (qcpcolorscale_cliprect_callback != nullptr) {
            QRect* callback_ret = qcpcolorscale_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPColorScale::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcpcolorscale_selectevent_isbase) {
            qcpcolorscale_selectevent_isbase = false;
            QCPColorScale::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcpcolorscale_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcpcolorscale_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPColorScale::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcpcolorscale_deselectevent_isbase) {
            qcpcolorscale_deselectevent_isbase = false;
            QCPColorScale::deselectEvent(selectionStateChanged);
        } else if (qcpcolorscale_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcpcolorscale_deselectevent_callback(this, cbval1);
        } else {
            QCPColorScale::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpcolorscale_mousedoubleclickevent_isbase) {
            qcpcolorscale_mousedoubleclickevent_isbase = false;
            QCPColorScale::mouseDoubleClickEvent(event, details);
        } else if (qcpcolorscale_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpcolorscale_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPColorScale::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpcolorscale_event_isbase) {
            qcpcolorscale_event_isbase = false;
            return QCPColorScale::event(event);
        } else if (qcpcolorscale_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpcolorscale_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPColorScale::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpcolorscale_eventfilter_isbase) {
            qcpcolorscale_eventfilter_isbase = false;
            return QCPColorScale::eventFilter(watched, event);
        } else if (qcpcolorscale_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpcolorscale_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPColorScale::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpcolorscale_timerevent_isbase) {
            qcpcolorscale_timerevent_isbase = false;
            QCPColorScale::timerEvent(event);
        } else if (qcpcolorscale_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpcolorscale_timerevent_callback(this, cbval1);
        } else {
            QCPColorScale::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpcolorscale_childevent_isbase) {
            qcpcolorscale_childevent_isbase = false;
            QCPColorScale::childEvent(event);
        } else if (qcpcolorscale_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpcolorscale_childevent_callback(this, cbval1);
        } else {
            QCPColorScale::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpcolorscale_customevent_isbase) {
            qcpcolorscale_customevent_isbase = false;
            QCPColorScale::customEvent(event);
        } else if (qcpcolorscale_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpcolorscale_customevent_callback(this, cbval1);
        } else {
            QCPColorScale::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpcolorscale_connectnotify_isbase) {
            qcpcolorscale_connectnotify_isbase = false;
            QCPColorScale::connectNotify(signal);
        } else if (qcpcolorscale_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpcolorscale_connectnotify_callback(this, cbval1);
        } else {
            QCPColorScale::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpcolorscale_disconnectnotify_isbase) {
            qcpcolorscale_disconnectnotify_isbase = false;
            QCPColorScale::disconnectNotify(signal);
        } else if (qcpcolorscale_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpcolorscale_disconnectnotify_callback(this, cbval1);
        } else {
            QCPColorScale::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcpcolorscale_initializeparentplot_isbase) {
            qcpcolorscale_initializeparentplot_isbase = false;
            QCPColorScale::initializeParentPlot(parentPlot);
        } else if (qcpcolorscale_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpcolorscale_initializeparentplot_callback(this, cbval1);
        } else {
            QCPColorScale::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcpcolorscale_setparentlayerable_isbase) {
            qcpcolorscale_setparentlayerable_isbase = false;
            QCPColorScale::setParentLayerable(parentLayerable);
        } else if (qcpcolorscale_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcpcolorscale_setparentlayerable_callback(this, cbval1);
        } else {
            QCPColorScale::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcpcolorscale_movetolayer_isbase) {
            qcpcolorscale_movetolayer_isbase = false;
            return QCPColorScale::moveToLayer(layer, prepend);
        } else if (qcpcolorscale_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcpcolorscale_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPColorScale::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcpcolorscale_applyantialiasinghint_isbase) {
            qcpcolorscale_applyantialiasinghint_isbase = false;
            QCPColorScale::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcpcolorscale_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcpcolorscale_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPColorScale::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpcolorscale_sender_isbase) {
            qcpcolorscale_sender_isbase = false;
            return QCPColorScale::sender();
        } else if (qcpcolorscale_sender_callback != nullptr) {
            QObject* callback_ret = qcpcolorscale_sender_callback();
            return callback_ret;
        } else {
            return QCPColorScale::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpcolorscale_sendersignalindex_isbase) {
            qcpcolorscale_sendersignalindex_isbase = false;
            return QCPColorScale::senderSignalIndex();
        } else if (qcpcolorscale_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpcolorscale_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPColorScale::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpcolorscale_receivers_isbase) {
            qcpcolorscale_receivers_isbase = false;
            return QCPColorScale::receivers(signal);
        } else if (qcpcolorscale_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpcolorscale_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPColorScale::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpcolorscale_issignalconnected_isbase) {
            qcpcolorscale_issignalconnected_isbase = false;
            return QCPColorScale::isSignalConnected(signal);
        } else if (qcpcolorscale_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpcolorscale_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPColorScale::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPColorScale_ApplyDefaultAntialiasingHint(const QCPColorScale* self, QCPPainter* painter);
    friend void QCPColorScale_QBaseApplyDefaultAntialiasingHint(const QCPColorScale* self, QCPPainter* painter);
    friend void QCPColorScale_MousePressEvent(QCPColorScale* self, QMouseEvent* event, const QVariant* details);
    friend void QCPColorScale_QBaseMousePressEvent(QCPColorScale* self, QMouseEvent* event, const QVariant* details);
    friend void QCPColorScale_MouseMoveEvent(QCPColorScale* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPColorScale_QBaseMouseMoveEvent(QCPColorScale* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPColorScale_MouseReleaseEvent(QCPColorScale* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPColorScale_QBaseMouseReleaseEvent(QCPColorScale* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPColorScale_WheelEvent(QCPColorScale* self, QWheelEvent* event);
    friend void QCPColorScale_QBaseWheelEvent(QCPColorScale* self, QWheelEvent* event);
    friend int QCPColorScale_CalculateAutoMargin(QCPColorScale* self, int side);
    friend int QCPColorScale_QBaseCalculateAutoMargin(QCPColorScale* self, int side);
    friend void QCPColorScale_LayoutChanged(QCPColorScale* self);
    friend void QCPColorScale_QBaseLayoutChanged(QCPColorScale* self);
    friend void QCPColorScale_Draw(QCPColorScale* self, QCPPainter* painter);
    friend void QCPColorScale_QBaseDraw(QCPColorScale* self, QCPPainter* painter);
    friend void QCPColorScale_ParentPlotInitialized(QCPColorScale* self, QCustomPlot* parentPlot);
    friend void QCPColorScale_QBaseParentPlotInitialized(QCPColorScale* self, QCustomPlot* parentPlot);
    friend int QCPColorScale_SelectionCategory(const QCPColorScale* self);
    friend int QCPColorScale_QBaseSelectionCategory(const QCPColorScale* self);
    friend QRect* QCPColorScale_ClipRect(const QCPColorScale* self);
    friend QRect* QCPColorScale_QBaseClipRect(const QCPColorScale* self);
    friend void QCPColorScale_SelectEvent(QCPColorScale* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPColorScale_QBaseSelectEvent(QCPColorScale* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPColorScale_DeselectEvent(QCPColorScale* self, bool* selectionStateChanged);
    friend void QCPColorScale_QBaseDeselectEvent(QCPColorScale* self, bool* selectionStateChanged);
    friend void QCPColorScale_MouseDoubleClickEvent(QCPColorScale* self, QMouseEvent* event, const QVariant* details);
    friend void QCPColorScale_QBaseMouseDoubleClickEvent(QCPColorScale* self, QMouseEvent* event, const QVariant* details);
    friend void QCPColorScale_TimerEvent(QCPColorScale* self, QTimerEvent* event);
    friend void QCPColorScale_QBaseTimerEvent(QCPColorScale* self, QTimerEvent* event);
    friend void QCPColorScale_ChildEvent(QCPColorScale* self, QChildEvent* event);
    friend void QCPColorScale_QBaseChildEvent(QCPColorScale* self, QChildEvent* event);
    friend void QCPColorScale_CustomEvent(QCPColorScale* self, QEvent* event);
    friend void QCPColorScale_QBaseCustomEvent(QCPColorScale* self, QEvent* event);
    friend void QCPColorScale_ConnectNotify(QCPColorScale* self, const QMetaMethod* signal);
    friend void QCPColorScale_QBaseConnectNotify(QCPColorScale* self, const QMetaMethod* signal);
    friend void QCPColorScale_DisconnectNotify(QCPColorScale* self, const QMetaMethod* signal);
    friend void QCPColorScale_QBaseDisconnectNotify(QCPColorScale* self, const QMetaMethod* signal);
    friend void QCPColorScale_InitializeParentPlot(QCPColorScale* self, QCustomPlot* parentPlot);
    friend void QCPColorScale_QBaseInitializeParentPlot(QCPColorScale* self, QCustomPlot* parentPlot);
    friend void QCPColorScale_SetParentLayerable(QCPColorScale* self, QCPLayerable* parentLayerable);
    friend void QCPColorScale_QBaseSetParentLayerable(QCPColorScale* self, QCPLayerable* parentLayerable);
    friend bool QCPColorScale_MoveToLayer(QCPColorScale* self, QCPLayer* layer, bool prepend);
    friend bool QCPColorScale_QBaseMoveToLayer(QCPColorScale* self, QCPLayer* layer, bool prepend);
    friend void QCPColorScale_ApplyAntialiasingHint(const QCPColorScale* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPColorScale_QBaseApplyAntialiasingHint(const QCPColorScale* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPColorScale_Sender(const QCPColorScale* self);
    friend QObject* QCPColorScale_QBaseSender(const QCPColorScale* self);
    friend int QCPColorScale_SenderSignalIndex(const QCPColorScale* self);
    friend int QCPColorScale_QBaseSenderSignalIndex(const QCPColorScale* self);
    friend int QCPColorScale_Receivers(const QCPColorScale* self, const char* signal);
    friend int QCPColorScale_QBaseReceivers(const QCPColorScale* self, const char* signal);
    friend bool QCPColorScale_IsSignalConnected(const QCPColorScale* self, const QMetaMethod* signal);
    friend bool QCPColorScale_QBaseIsSignalConnected(const QCPColorScale* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPGraph so that we can call protected methods
class VirtualQCPGraph final : public QCPGraph {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPGraph = true;

    // Virtual class public types (including callbacks)
    using QCPGraph_Metacall_Callback = int (*)(QCPGraph*, int, int, void**);
    using QCPGraph_SelectTest_Callback = double (*)(const QCPGraph*, QPointF*, bool, QVariant*);
    using QCPGraph_GetKeyRange_Callback = QCPRange* (*)(const QCPGraph*, bool*, int);
    using QCPGraph_GetValueRange_Callback = QCPRange* (*)(const QCPGraph*, bool*, int, QCPRange*);
    using QCPGraph_Draw_Callback = void (*)(QCPGraph*, QCPPainter*);
    using QCPGraph_DrawLegendIcon_Callback = void (*)(const QCPGraph*, QCPPainter*, QRectF*);
    using QCPGraph_DrawFill_Callback = void (*)(const QCPGraph*, QCPPainter*, libqt_list /* of QPointF* */);
    using QCPGraph_DrawScatterPlot_Callback = void (*)(const QCPGraph*, QCPPainter*, libqt_list /* of QPointF* */, QCPScatterStyle*);
    using QCPGraph_DrawLinePlot_Callback = void (*)(const QCPGraph*, QCPPainter*, libqt_list /* of QPointF* */);
    using QCPGraph_DrawImpulsePlot_Callback = void (*)(const QCPGraph*, QCPPainter*, libqt_list /* of QPointF* */);
    using QCPGraph_DataCount_Callback = int (*)();
    using QCPGraph_DataMainKey_Callback = double (*)(const QCPGraph*, int);
    using QCPGraph_DataSortKey_Callback = double (*)(const QCPGraph*, int);
    using QCPGraph_DataMainValue_Callback = double (*)(const QCPGraph*, int);
    using QCPGraph_DataValueRange_Callback = QCPRange* (*)(const QCPGraph*, int);
    using QCPGraph_DataPixelPosition_Callback = QPointF* (*)(const QCPGraph*, int);
    using QCPGraph_SortKeyIsMainKey_Callback = bool (*)();
    using QCPGraph_SelectTestRect_Callback = QCPDataSelection* (*)(const QCPGraph*, QRectF*, bool);
    using QCPGraph_FindBegin_Callback = int (*)(const QCPGraph*, double, bool);
    using QCPGraph_FindEnd_Callback = int (*)(const QCPGraph*, double, bool);
    using QCPGraph_Interface1D_Callback = QCPPlottableInterface1D* (*)();
    using QCPGraph_ClipRect_Callback = QRect* (*)();
    using QCPGraph_SelectionCategory_Callback = int (*)();
    using QCPGraph_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPGraph*, QCPPainter*);
    using QCPGraph_SelectEvent_Callback = void (*)(QCPGraph*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPGraph_DeselectEvent_Callback = void (*)(QCPGraph*, bool*);
    using QCPGraph_ParentPlotInitialized_Callback = void (*)(QCPGraph*, QCustomPlot*);
    using QCPGraph_MousePressEvent_Callback = void (*)(QCPGraph*, QMouseEvent*, QVariant*);
    using QCPGraph_MouseMoveEvent_Callback = void (*)(QCPGraph*, QMouseEvent*, QPointF*);
    using QCPGraph_MouseReleaseEvent_Callback = void (*)(QCPGraph*, QMouseEvent*, QPointF*);
    using QCPGraph_MouseDoubleClickEvent_Callback = void (*)(QCPGraph*, QMouseEvent*, QVariant*);
    using QCPGraph_WheelEvent_Callback = void (*)(QCPGraph*, QWheelEvent*);
    using QCPGraph_Event_Callback = bool (*)(QCPGraph*, QEvent*);
    using QCPGraph_EventFilter_Callback = bool (*)(QCPGraph*, QObject*, QEvent*);
    using QCPGraph_TimerEvent_Callback = void (*)(QCPGraph*, QTimerEvent*);
    using QCPGraph_ChildEvent_Callback = void (*)(QCPGraph*, QChildEvent*);
    using QCPGraph_CustomEvent_Callback = void (*)(QCPGraph*, QEvent*);
    using QCPGraph_ConnectNotify_Callback = void (*)(QCPGraph*, QMetaMethod*);
    using QCPGraph_DisconnectNotify_Callback = void (*)(QCPGraph*, QMetaMethod*);
    using QCPGraph_GetLines_Callback = void (*)(const QCPGraph*, libqt_list /* of QPointF* */, QCPDataRange*);
    using QCPGraph_GetScatters_Callback = void (*)(const QCPGraph*, libqt_list /* of QPointF* */, QCPDataRange*);
    using QCPGraph_DataToLines_Callback = QPointF** (*)(const QCPGraph*, libqt_list /* of QCPGraphData* */);
    using QCPGraph_DataToStepLeftLines_Callback = QPointF** (*)(const QCPGraph*, libqt_list /* of QCPGraphData* */);
    using QCPGraph_DataToStepRightLines_Callback = QPointF** (*)(const QCPGraph*, libqt_list /* of QCPGraphData* */);
    using QCPGraph_DataToStepCenterLines_Callback = QPointF** (*)(const QCPGraph*, libqt_list /* of QCPGraphData* */);
    using QCPGraph_DataToImpulseLines_Callback = QPointF** (*)(const QCPGraph*, libqt_list /* of QCPGraphData* */);
    using QCPGraph_GetNonNanSegments_Callback = QCPDataRange** (*)(const QCPGraph*, libqt_list /* of QPointF* */, int);
    using QCPGraph_GetOverlappingSegments_Callback = libqt_list /* of libqt_pair  tuple of QCPDataRange* and QCPDataRange*  */ (*)(const QCPGraph*, libqt_list /* of QCPDataRange* */, libqt_list /* of QPointF* */, libqt_list /* of QCPDataRange* */, libqt_list /* of QPointF* */);
    using QCPGraph_SegmentsIntersect_Callback = bool (*)(const QCPGraph*, double, double, double, double, int*);
    using QCPGraph_GetFillBasePoint_Callback = QPointF* (*)(const QCPGraph*, QPointF*);
    using QCPGraph_FindIndexBelowX_Callback = int (*)(const QCPGraph*, libqt_list /* of QPointF* */, double);
    using QCPGraph_FindIndexAboveX_Callback = int (*)(const QCPGraph*, libqt_list /* of QPointF* */, double);
    using QCPGraph_FindIndexBelowY_Callback = int (*)(const QCPGraph*, libqt_list /* of QPointF* */, double);
    using QCPGraph_FindIndexAboveY_Callback = int (*)(const QCPGraph*, libqt_list /* of QPointF* */, double);
    using QCPGraph_ApplyFillAntialiasingHint_Callback = void (*)(const QCPGraph*, QCPPainter*);
    using QCPGraph_ApplyScattersAntialiasingHint_Callback = void (*)(const QCPGraph*, QCPPainter*);
    using QCPGraph_InitializeParentPlot_Callback = void (*)(QCPGraph*, QCustomPlot*);
    using QCPGraph_SetParentLayerable_Callback = void (*)(QCPGraph*, QCPLayerable*);
    using QCPGraph_MoveToLayer_Callback = bool (*)(QCPGraph*, QCPLayer*, bool);
    using QCPGraph_ApplyAntialiasingHint_Callback = void (*)(const QCPGraph*, QCPPainter*, bool, int);
    using QCPGraph_Sender_Callback = QObject* (*)();
    using QCPGraph_SenderSignalIndex_Callback = int (*)();
    using QCPGraph_Receivers_Callback = int (*)(const QCPGraph*, const char*);
    using QCPGraph_IsSignalConnected_Callback = bool (*)(const QCPGraph*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPGraph_Metacall_Callback qcpgraph_metacall_callback = nullptr;
    QCPGraph_SelectTest_Callback qcpgraph_selecttest_callback = nullptr;
    QCPGraph_GetKeyRange_Callback qcpgraph_getkeyrange_callback = nullptr;
    QCPGraph_GetValueRange_Callback qcpgraph_getvaluerange_callback = nullptr;
    QCPGraph_Draw_Callback qcpgraph_draw_callback = nullptr;
    QCPGraph_DrawLegendIcon_Callback qcpgraph_drawlegendicon_callback = nullptr;
    QCPGraph_DrawFill_Callback qcpgraph_drawfill_callback = nullptr;
    QCPGraph_DrawScatterPlot_Callback qcpgraph_drawscatterplot_callback = nullptr;
    QCPGraph_DrawLinePlot_Callback qcpgraph_drawlineplot_callback = nullptr;
    QCPGraph_DrawImpulsePlot_Callback qcpgraph_drawimpulseplot_callback = nullptr;
    QCPGraph_DataCount_Callback qcpgraph_datacount_callback = nullptr;
    QCPGraph_DataMainKey_Callback qcpgraph_datamainkey_callback = nullptr;
    QCPGraph_DataSortKey_Callback qcpgraph_datasortkey_callback = nullptr;
    QCPGraph_DataMainValue_Callback qcpgraph_datamainvalue_callback = nullptr;
    QCPGraph_DataValueRange_Callback qcpgraph_datavaluerange_callback = nullptr;
    QCPGraph_DataPixelPosition_Callback qcpgraph_datapixelposition_callback = nullptr;
    QCPGraph_SortKeyIsMainKey_Callback qcpgraph_sortkeyismainkey_callback = nullptr;
    QCPGraph_SelectTestRect_Callback qcpgraph_selecttestrect_callback = nullptr;
    QCPGraph_FindBegin_Callback qcpgraph_findbegin_callback = nullptr;
    QCPGraph_FindEnd_Callback qcpgraph_findend_callback = nullptr;
    QCPGraph_Interface1D_Callback qcpgraph_interface1d_callback = nullptr;
    QCPGraph_ClipRect_Callback qcpgraph_cliprect_callback = nullptr;
    QCPGraph_SelectionCategory_Callback qcpgraph_selectioncategory_callback = nullptr;
    QCPGraph_ApplyDefaultAntialiasingHint_Callback qcpgraph_applydefaultantialiasinghint_callback = nullptr;
    QCPGraph_SelectEvent_Callback qcpgraph_selectevent_callback = nullptr;
    QCPGraph_DeselectEvent_Callback qcpgraph_deselectevent_callback = nullptr;
    QCPGraph_ParentPlotInitialized_Callback qcpgraph_parentplotinitialized_callback = nullptr;
    QCPGraph_MousePressEvent_Callback qcpgraph_mousepressevent_callback = nullptr;
    QCPGraph_MouseMoveEvent_Callback qcpgraph_mousemoveevent_callback = nullptr;
    QCPGraph_MouseReleaseEvent_Callback qcpgraph_mousereleaseevent_callback = nullptr;
    QCPGraph_MouseDoubleClickEvent_Callback qcpgraph_mousedoubleclickevent_callback = nullptr;
    QCPGraph_WheelEvent_Callback qcpgraph_wheelevent_callback = nullptr;
    QCPGraph_Event_Callback qcpgraph_event_callback = nullptr;
    QCPGraph_EventFilter_Callback qcpgraph_eventfilter_callback = nullptr;
    QCPGraph_TimerEvent_Callback qcpgraph_timerevent_callback = nullptr;
    QCPGraph_ChildEvent_Callback qcpgraph_childevent_callback = nullptr;
    QCPGraph_CustomEvent_Callback qcpgraph_customevent_callback = nullptr;
    QCPGraph_ConnectNotify_Callback qcpgraph_connectnotify_callback = nullptr;
    QCPGraph_DisconnectNotify_Callback qcpgraph_disconnectnotify_callback = nullptr;
    QCPGraph_GetLines_Callback qcpgraph_getlines_callback = nullptr;
    QCPGraph_GetScatters_Callback qcpgraph_getscatters_callback = nullptr;
    QCPGraph_DataToLines_Callback qcpgraph_datatolines_callback = nullptr;
    QCPGraph_DataToStepLeftLines_Callback qcpgraph_datatostepleftlines_callback = nullptr;
    QCPGraph_DataToStepRightLines_Callback qcpgraph_datatosteprightlines_callback = nullptr;
    QCPGraph_DataToStepCenterLines_Callback qcpgraph_datatostepcenterlines_callback = nullptr;
    QCPGraph_DataToImpulseLines_Callback qcpgraph_datatoimpulselines_callback = nullptr;
    QCPGraph_GetNonNanSegments_Callback qcpgraph_getnonnansegments_callback = nullptr;
    QCPGraph_GetOverlappingSegments_Callback qcpgraph_getoverlappingsegments_callback = nullptr;
    QCPGraph_SegmentsIntersect_Callback qcpgraph_segmentsintersect_callback = nullptr;
    QCPGraph_GetFillBasePoint_Callback qcpgraph_getfillbasepoint_callback = nullptr;
    QCPGraph_FindIndexBelowX_Callback qcpgraph_findindexbelowx_callback = nullptr;
    QCPGraph_FindIndexAboveX_Callback qcpgraph_findindexabovex_callback = nullptr;
    QCPGraph_FindIndexBelowY_Callback qcpgraph_findindexbelowy_callback = nullptr;
    QCPGraph_FindIndexAboveY_Callback qcpgraph_findindexabovey_callback = nullptr;
    QCPGraph_ApplyFillAntialiasingHint_Callback qcpgraph_applyfillantialiasinghint_callback = nullptr;
    QCPGraph_ApplyScattersAntialiasingHint_Callback qcpgraph_applyscattersantialiasinghint_callback = nullptr;
    QCPGraph_InitializeParentPlot_Callback qcpgraph_initializeparentplot_callback = nullptr;
    QCPGraph_SetParentLayerable_Callback qcpgraph_setparentlayerable_callback = nullptr;
    QCPGraph_MoveToLayer_Callback qcpgraph_movetolayer_callback = nullptr;
    QCPGraph_ApplyAntialiasingHint_Callback qcpgraph_applyantialiasinghint_callback = nullptr;
    QCPGraph_Sender_Callback qcpgraph_sender_callback = nullptr;
    QCPGraph_SenderSignalIndex_Callback qcpgraph_sendersignalindex_callback = nullptr;
    QCPGraph_Receivers_Callback qcpgraph_receivers_callback = nullptr;
    QCPGraph_IsSignalConnected_Callback qcpgraph_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpgraph_metacall_isbase = false;
    mutable bool qcpgraph_selecttest_isbase = false;
    mutable bool qcpgraph_getkeyrange_isbase = false;
    mutable bool qcpgraph_getvaluerange_isbase = false;
    mutable bool qcpgraph_draw_isbase = false;
    mutable bool qcpgraph_drawlegendicon_isbase = false;
    mutable bool qcpgraph_drawfill_isbase = false;
    mutable bool qcpgraph_drawscatterplot_isbase = false;
    mutable bool qcpgraph_drawlineplot_isbase = false;
    mutable bool qcpgraph_drawimpulseplot_isbase = false;
    mutable bool qcpgraph_datacount_isbase = false;
    mutable bool qcpgraph_datamainkey_isbase = false;
    mutable bool qcpgraph_datasortkey_isbase = false;
    mutable bool qcpgraph_datamainvalue_isbase = false;
    mutable bool qcpgraph_datavaluerange_isbase = false;
    mutable bool qcpgraph_datapixelposition_isbase = false;
    mutable bool qcpgraph_sortkeyismainkey_isbase = false;
    mutable bool qcpgraph_selecttestrect_isbase = false;
    mutable bool qcpgraph_findbegin_isbase = false;
    mutable bool qcpgraph_findend_isbase = false;
    mutable bool qcpgraph_interface1d_isbase = false;
    mutable bool qcpgraph_cliprect_isbase = false;
    mutable bool qcpgraph_selectioncategory_isbase = false;
    mutable bool qcpgraph_applydefaultantialiasinghint_isbase = false;
    mutable bool qcpgraph_selectevent_isbase = false;
    mutable bool qcpgraph_deselectevent_isbase = false;
    mutable bool qcpgraph_parentplotinitialized_isbase = false;
    mutable bool qcpgraph_mousepressevent_isbase = false;
    mutable bool qcpgraph_mousemoveevent_isbase = false;
    mutable bool qcpgraph_mousereleaseevent_isbase = false;
    mutable bool qcpgraph_mousedoubleclickevent_isbase = false;
    mutable bool qcpgraph_wheelevent_isbase = false;
    mutable bool qcpgraph_event_isbase = false;
    mutable bool qcpgraph_eventfilter_isbase = false;
    mutable bool qcpgraph_timerevent_isbase = false;
    mutable bool qcpgraph_childevent_isbase = false;
    mutable bool qcpgraph_customevent_isbase = false;
    mutable bool qcpgraph_connectnotify_isbase = false;
    mutable bool qcpgraph_disconnectnotify_isbase = false;
    mutable bool qcpgraph_getlines_isbase = false;
    mutable bool qcpgraph_getscatters_isbase = false;
    mutable bool qcpgraph_datatolines_isbase = false;
    mutable bool qcpgraph_datatostepleftlines_isbase = false;
    mutable bool qcpgraph_datatosteprightlines_isbase = false;
    mutable bool qcpgraph_datatostepcenterlines_isbase = false;
    mutable bool qcpgraph_datatoimpulselines_isbase = false;
    mutable bool qcpgraph_getnonnansegments_isbase = false;
    mutable bool qcpgraph_getoverlappingsegments_isbase = false;
    mutable bool qcpgraph_segmentsintersect_isbase = false;
    mutable bool qcpgraph_getfillbasepoint_isbase = false;
    mutable bool qcpgraph_findindexbelowx_isbase = false;
    mutable bool qcpgraph_findindexabovex_isbase = false;
    mutable bool qcpgraph_findindexbelowy_isbase = false;
    mutable bool qcpgraph_findindexabovey_isbase = false;
    mutable bool qcpgraph_applyfillantialiasinghint_isbase = false;
    mutable bool qcpgraph_applyscattersantialiasinghint_isbase = false;
    mutable bool qcpgraph_initializeparentplot_isbase = false;
    mutable bool qcpgraph_setparentlayerable_isbase = false;
    mutable bool qcpgraph_movetolayer_isbase = false;
    mutable bool qcpgraph_applyantialiasinghint_isbase = false;
    mutable bool qcpgraph_sender_isbase = false;
    mutable bool qcpgraph_sendersignalindex_isbase = false;
    mutable bool qcpgraph_receivers_isbase = false;
    mutable bool qcpgraph_issignalconnected_isbase = false;

  public:
    VirtualQCPGraph(QCPAxis* keyAxis, QCPAxis* valueAxis) : QCPGraph(keyAxis, valueAxis) {};

    ~VirtualQCPGraph() {
        qcpgraph_metacall_callback = nullptr;
        qcpgraph_selecttest_callback = nullptr;
        qcpgraph_getkeyrange_callback = nullptr;
        qcpgraph_getvaluerange_callback = nullptr;
        qcpgraph_draw_callback = nullptr;
        qcpgraph_drawlegendicon_callback = nullptr;
        qcpgraph_drawfill_callback = nullptr;
        qcpgraph_drawscatterplot_callback = nullptr;
        qcpgraph_drawlineplot_callback = nullptr;
        qcpgraph_drawimpulseplot_callback = nullptr;
        qcpgraph_datacount_callback = nullptr;
        qcpgraph_datamainkey_callback = nullptr;
        qcpgraph_datasortkey_callback = nullptr;
        qcpgraph_datamainvalue_callback = nullptr;
        qcpgraph_datavaluerange_callback = nullptr;
        qcpgraph_datapixelposition_callback = nullptr;
        qcpgraph_sortkeyismainkey_callback = nullptr;
        qcpgraph_selecttestrect_callback = nullptr;
        qcpgraph_findbegin_callback = nullptr;
        qcpgraph_findend_callback = nullptr;
        qcpgraph_interface1d_callback = nullptr;
        qcpgraph_cliprect_callback = nullptr;
        qcpgraph_selectioncategory_callback = nullptr;
        qcpgraph_applydefaultantialiasinghint_callback = nullptr;
        qcpgraph_selectevent_callback = nullptr;
        qcpgraph_deselectevent_callback = nullptr;
        qcpgraph_parentplotinitialized_callback = nullptr;
        qcpgraph_mousepressevent_callback = nullptr;
        qcpgraph_mousemoveevent_callback = nullptr;
        qcpgraph_mousereleaseevent_callback = nullptr;
        qcpgraph_mousedoubleclickevent_callback = nullptr;
        qcpgraph_wheelevent_callback = nullptr;
        qcpgraph_event_callback = nullptr;
        qcpgraph_eventfilter_callback = nullptr;
        qcpgraph_timerevent_callback = nullptr;
        qcpgraph_childevent_callback = nullptr;
        qcpgraph_customevent_callback = nullptr;
        qcpgraph_connectnotify_callback = nullptr;
        qcpgraph_disconnectnotify_callback = nullptr;
        qcpgraph_getlines_callback = nullptr;
        qcpgraph_getscatters_callback = nullptr;
        qcpgraph_datatolines_callback = nullptr;
        qcpgraph_datatostepleftlines_callback = nullptr;
        qcpgraph_datatosteprightlines_callback = nullptr;
        qcpgraph_datatostepcenterlines_callback = nullptr;
        qcpgraph_datatoimpulselines_callback = nullptr;
        qcpgraph_getnonnansegments_callback = nullptr;
        qcpgraph_getoverlappingsegments_callback = nullptr;
        qcpgraph_segmentsintersect_callback = nullptr;
        qcpgraph_getfillbasepoint_callback = nullptr;
        qcpgraph_findindexbelowx_callback = nullptr;
        qcpgraph_findindexabovex_callback = nullptr;
        qcpgraph_findindexbelowy_callback = nullptr;
        qcpgraph_findindexabovey_callback = nullptr;
        qcpgraph_applyfillantialiasinghint_callback = nullptr;
        qcpgraph_applyscattersantialiasinghint_callback = nullptr;
        qcpgraph_initializeparentplot_callback = nullptr;
        qcpgraph_setparentlayerable_callback = nullptr;
        qcpgraph_movetolayer_callback = nullptr;
        qcpgraph_applyantialiasinghint_callback = nullptr;
        qcpgraph_sender_callback = nullptr;
        qcpgraph_sendersignalindex_callback = nullptr;
        qcpgraph_receivers_callback = nullptr;
        qcpgraph_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPGraph_Metacall_Callback(QCPGraph_Metacall_Callback cb) { qcpgraph_metacall_callback = cb; }
    inline void setQCPGraph_SelectTest_Callback(QCPGraph_SelectTest_Callback cb) { qcpgraph_selecttest_callback = cb; }
    inline void setQCPGraph_GetKeyRange_Callback(QCPGraph_GetKeyRange_Callback cb) { qcpgraph_getkeyrange_callback = cb; }
    inline void setQCPGraph_GetValueRange_Callback(QCPGraph_GetValueRange_Callback cb) { qcpgraph_getvaluerange_callback = cb; }
    inline void setQCPGraph_Draw_Callback(QCPGraph_Draw_Callback cb) { qcpgraph_draw_callback = cb; }
    inline void setQCPGraph_DrawLegendIcon_Callback(QCPGraph_DrawLegendIcon_Callback cb) { qcpgraph_drawlegendicon_callback = cb; }
    inline void setQCPGraph_DrawFill_Callback(QCPGraph_DrawFill_Callback cb) { qcpgraph_drawfill_callback = cb; }
    inline void setQCPGraph_DrawScatterPlot_Callback(QCPGraph_DrawScatterPlot_Callback cb) { qcpgraph_drawscatterplot_callback = cb; }
    inline void setQCPGraph_DrawLinePlot_Callback(QCPGraph_DrawLinePlot_Callback cb) { qcpgraph_drawlineplot_callback = cb; }
    inline void setQCPGraph_DrawImpulsePlot_Callback(QCPGraph_DrawImpulsePlot_Callback cb) { qcpgraph_drawimpulseplot_callback = cb; }
    inline void setQCPGraph_DataCount_Callback(QCPGraph_DataCount_Callback cb) { qcpgraph_datacount_callback = cb; }
    inline void setQCPGraph_DataMainKey_Callback(QCPGraph_DataMainKey_Callback cb) { qcpgraph_datamainkey_callback = cb; }
    inline void setQCPGraph_DataSortKey_Callback(QCPGraph_DataSortKey_Callback cb) { qcpgraph_datasortkey_callback = cb; }
    inline void setQCPGraph_DataMainValue_Callback(QCPGraph_DataMainValue_Callback cb) { qcpgraph_datamainvalue_callback = cb; }
    inline void setQCPGraph_DataValueRange_Callback(QCPGraph_DataValueRange_Callback cb) { qcpgraph_datavaluerange_callback = cb; }
    inline void setQCPGraph_DataPixelPosition_Callback(QCPGraph_DataPixelPosition_Callback cb) { qcpgraph_datapixelposition_callback = cb; }
    inline void setQCPGraph_SortKeyIsMainKey_Callback(QCPGraph_SortKeyIsMainKey_Callback cb) { qcpgraph_sortkeyismainkey_callback = cb; }
    inline void setQCPGraph_SelectTestRect_Callback(QCPGraph_SelectTestRect_Callback cb) { qcpgraph_selecttestrect_callback = cb; }
    inline void setQCPGraph_FindBegin_Callback(QCPGraph_FindBegin_Callback cb) { qcpgraph_findbegin_callback = cb; }
    inline void setQCPGraph_FindEnd_Callback(QCPGraph_FindEnd_Callback cb) { qcpgraph_findend_callback = cb; }
    inline void setQCPGraph_Interface1D_Callback(QCPGraph_Interface1D_Callback cb) { qcpgraph_interface1d_callback = cb; }
    inline void setQCPGraph_ClipRect_Callback(QCPGraph_ClipRect_Callback cb) { qcpgraph_cliprect_callback = cb; }
    inline void setQCPGraph_SelectionCategory_Callback(QCPGraph_SelectionCategory_Callback cb) { qcpgraph_selectioncategory_callback = cb; }
    inline void setQCPGraph_ApplyDefaultAntialiasingHint_Callback(QCPGraph_ApplyDefaultAntialiasingHint_Callback cb) { qcpgraph_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPGraph_SelectEvent_Callback(QCPGraph_SelectEvent_Callback cb) { qcpgraph_selectevent_callback = cb; }
    inline void setQCPGraph_DeselectEvent_Callback(QCPGraph_DeselectEvent_Callback cb) { qcpgraph_deselectevent_callback = cb; }
    inline void setQCPGraph_ParentPlotInitialized_Callback(QCPGraph_ParentPlotInitialized_Callback cb) { qcpgraph_parentplotinitialized_callback = cb; }
    inline void setQCPGraph_MousePressEvent_Callback(QCPGraph_MousePressEvent_Callback cb) { qcpgraph_mousepressevent_callback = cb; }
    inline void setQCPGraph_MouseMoveEvent_Callback(QCPGraph_MouseMoveEvent_Callback cb) { qcpgraph_mousemoveevent_callback = cb; }
    inline void setQCPGraph_MouseReleaseEvent_Callback(QCPGraph_MouseReleaseEvent_Callback cb) { qcpgraph_mousereleaseevent_callback = cb; }
    inline void setQCPGraph_MouseDoubleClickEvent_Callback(QCPGraph_MouseDoubleClickEvent_Callback cb) { qcpgraph_mousedoubleclickevent_callback = cb; }
    inline void setQCPGraph_WheelEvent_Callback(QCPGraph_WheelEvent_Callback cb) { qcpgraph_wheelevent_callback = cb; }
    inline void setQCPGraph_Event_Callback(QCPGraph_Event_Callback cb) { qcpgraph_event_callback = cb; }
    inline void setQCPGraph_EventFilter_Callback(QCPGraph_EventFilter_Callback cb) { qcpgraph_eventfilter_callback = cb; }
    inline void setQCPGraph_TimerEvent_Callback(QCPGraph_TimerEvent_Callback cb) { qcpgraph_timerevent_callback = cb; }
    inline void setQCPGraph_ChildEvent_Callback(QCPGraph_ChildEvent_Callback cb) { qcpgraph_childevent_callback = cb; }
    inline void setQCPGraph_CustomEvent_Callback(QCPGraph_CustomEvent_Callback cb) { qcpgraph_customevent_callback = cb; }
    inline void setQCPGraph_ConnectNotify_Callback(QCPGraph_ConnectNotify_Callback cb) { qcpgraph_connectnotify_callback = cb; }
    inline void setQCPGraph_DisconnectNotify_Callback(QCPGraph_DisconnectNotify_Callback cb) { qcpgraph_disconnectnotify_callback = cb; }
    inline void setQCPGraph_GetLines_Callback(QCPGraph_GetLines_Callback cb) { qcpgraph_getlines_callback = cb; }
    inline void setQCPGraph_GetScatters_Callback(QCPGraph_GetScatters_Callback cb) { qcpgraph_getscatters_callback = cb; }
    inline void setQCPGraph_DataToLines_Callback(QCPGraph_DataToLines_Callback cb) { qcpgraph_datatolines_callback = cb; }
    inline void setQCPGraph_DataToStepLeftLines_Callback(QCPGraph_DataToStepLeftLines_Callback cb) { qcpgraph_datatostepleftlines_callback = cb; }
    inline void setQCPGraph_DataToStepRightLines_Callback(QCPGraph_DataToStepRightLines_Callback cb) { qcpgraph_datatosteprightlines_callback = cb; }
    inline void setQCPGraph_DataToStepCenterLines_Callback(QCPGraph_DataToStepCenterLines_Callback cb) { qcpgraph_datatostepcenterlines_callback = cb; }
    inline void setQCPGraph_DataToImpulseLines_Callback(QCPGraph_DataToImpulseLines_Callback cb) { qcpgraph_datatoimpulselines_callback = cb; }
    inline void setQCPGraph_GetNonNanSegments_Callback(QCPGraph_GetNonNanSegments_Callback cb) { qcpgraph_getnonnansegments_callback = cb; }
    inline void setQCPGraph_GetOverlappingSegments_Callback(QCPGraph_GetOverlappingSegments_Callback cb) { qcpgraph_getoverlappingsegments_callback = cb; }
    inline void setQCPGraph_SegmentsIntersect_Callback(QCPGraph_SegmentsIntersect_Callback cb) { qcpgraph_segmentsintersect_callback = cb; }
    inline void setQCPGraph_GetFillBasePoint_Callback(QCPGraph_GetFillBasePoint_Callback cb) { qcpgraph_getfillbasepoint_callback = cb; }
    inline void setQCPGraph_FindIndexBelowX_Callback(QCPGraph_FindIndexBelowX_Callback cb) { qcpgraph_findindexbelowx_callback = cb; }
    inline void setQCPGraph_FindIndexAboveX_Callback(QCPGraph_FindIndexAboveX_Callback cb) { qcpgraph_findindexabovex_callback = cb; }
    inline void setQCPGraph_FindIndexBelowY_Callback(QCPGraph_FindIndexBelowY_Callback cb) { qcpgraph_findindexbelowy_callback = cb; }
    inline void setQCPGraph_FindIndexAboveY_Callback(QCPGraph_FindIndexAboveY_Callback cb) { qcpgraph_findindexabovey_callback = cb; }
    inline void setQCPGraph_ApplyFillAntialiasingHint_Callback(QCPGraph_ApplyFillAntialiasingHint_Callback cb) { qcpgraph_applyfillantialiasinghint_callback = cb; }
    inline void setQCPGraph_ApplyScattersAntialiasingHint_Callback(QCPGraph_ApplyScattersAntialiasingHint_Callback cb) { qcpgraph_applyscattersantialiasinghint_callback = cb; }
    inline void setQCPGraph_InitializeParentPlot_Callback(QCPGraph_InitializeParentPlot_Callback cb) { qcpgraph_initializeparentplot_callback = cb; }
    inline void setQCPGraph_SetParentLayerable_Callback(QCPGraph_SetParentLayerable_Callback cb) { qcpgraph_setparentlayerable_callback = cb; }
    inline void setQCPGraph_MoveToLayer_Callback(QCPGraph_MoveToLayer_Callback cb) { qcpgraph_movetolayer_callback = cb; }
    inline void setQCPGraph_ApplyAntialiasingHint_Callback(QCPGraph_ApplyAntialiasingHint_Callback cb) { qcpgraph_applyantialiasinghint_callback = cb; }
    inline void setQCPGraph_Sender_Callback(QCPGraph_Sender_Callback cb) { qcpgraph_sender_callback = cb; }
    inline void setQCPGraph_SenderSignalIndex_Callback(QCPGraph_SenderSignalIndex_Callback cb) { qcpgraph_sendersignalindex_callback = cb; }
    inline void setQCPGraph_Receivers_Callback(QCPGraph_Receivers_Callback cb) { qcpgraph_receivers_callback = cb; }
    inline void setQCPGraph_IsSignalConnected_Callback(QCPGraph_IsSignalConnected_Callback cb) { qcpgraph_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPGraph_Metacall_IsBase(bool value) const { qcpgraph_metacall_isbase = value; }
    inline void setQCPGraph_SelectTest_IsBase(bool value) const { qcpgraph_selecttest_isbase = value; }
    inline void setQCPGraph_GetKeyRange_IsBase(bool value) const { qcpgraph_getkeyrange_isbase = value; }
    inline void setQCPGraph_GetValueRange_IsBase(bool value) const { qcpgraph_getvaluerange_isbase = value; }
    inline void setQCPGraph_Draw_IsBase(bool value) const { qcpgraph_draw_isbase = value; }
    inline void setQCPGraph_DrawLegendIcon_IsBase(bool value) const { qcpgraph_drawlegendicon_isbase = value; }
    inline void setQCPGraph_DrawFill_IsBase(bool value) const { qcpgraph_drawfill_isbase = value; }
    inline void setQCPGraph_DrawScatterPlot_IsBase(bool value) const { qcpgraph_drawscatterplot_isbase = value; }
    inline void setQCPGraph_DrawLinePlot_IsBase(bool value) const { qcpgraph_drawlineplot_isbase = value; }
    inline void setQCPGraph_DrawImpulsePlot_IsBase(bool value) const { qcpgraph_drawimpulseplot_isbase = value; }
    inline void setQCPGraph_DataCount_IsBase(bool value) const { qcpgraph_datacount_isbase = value; }
    inline void setQCPGraph_DataMainKey_IsBase(bool value) const { qcpgraph_datamainkey_isbase = value; }
    inline void setQCPGraph_DataSortKey_IsBase(bool value) const { qcpgraph_datasortkey_isbase = value; }
    inline void setQCPGraph_DataMainValue_IsBase(bool value) const { qcpgraph_datamainvalue_isbase = value; }
    inline void setQCPGraph_DataValueRange_IsBase(bool value) const { qcpgraph_datavaluerange_isbase = value; }
    inline void setQCPGraph_DataPixelPosition_IsBase(bool value) const { qcpgraph_datapixelposition_isbase = value; }
    inline void setQCPGraph_SortKeyIsMainKey_IsBase(bool value) const { qcpgraph_sortkeyismainkey_isbase = value; }
    inline void setQCPGraph_SelectTestRect_IsBase(bool value) const { qcpgraph_selecttestrect_isbase = value; }
    inline void setQCPGraph_FindBegin_IsBase(bool value) const { qcpgraph_findbegin_isbase = value; }
    inline void setQCPGraph_FindEnd_IsBase(bool value) const { qcpgraph_findend_isbase = value; }
    inline void setQCPGraph_Interface1D_IsBase(bool value) const { qcpgraph_interface1d_isbase = value; }
    inline void setQCPGraph_ClipRect_IsBase(bool value) const { qcpgraph_cliprect_isbase = value; }
    inline void setQCPGraph_SelectionCategory_IsBase(bool value) const { qcpgraph_selectioncategory_isbase = value; }
    inline void setQCPGraph_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcpgraph_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPGraph_SelectEvent_IsBase(bool value) const { qcpgraph_selectevent_isbase = value; }
    inline void setQCPGraph_DeselectEvent_IsBase(bool value) const { qcpgraph_deselectevent_isbase = value; }
    inline void setQCPGraph_ParentPlotInitialized_IsBase(bool value) const { qcpgraph_parentplotinitialized_isbase = value; }
    inline void setQCPGraph_MousePressEvent_IsBase(bool value) const { qcpgraph_mousepressevent_isbase = value; }
    inline void setQCPGraph_MouseMoveEvent_IsBase(bool value) const { qcpgraph_mousemoveevent_isbase = value; }
    inline void setQCPGraph_MouseReleaseEvent_IsBase(bool value) const { qcpgraph_mousereleaseevent_isbase = value; }
    inline void setQCPGraph_MouseDoubleClickEvent_IsBase(bool value) const { qcpgraph_mousedoubleclickevent_isbase = value; }
    inline void setQCPGraph_WheelEvent_IsBase(bool value) const { qcpgraph_wheelevent_isbase = value; }
    inline void setQCPGraph_Event_IsBase(bool value) const { qcpgraph_event_isbase = value; }
    inline void setQCPGraph_EventFilter_IsBase(bool value) const { qcpgraph_eventfilter_isbase = value; }
    inline void setQCPGraph_TimerEvent_IsBase(bool value) const { qcpgraph_timerevent_isbase = value; }
    inline void setQCPGraph_ChildEvent_IsBase(bool value) const { qcpgraph_childevent_isbase = value; }
    inline void setQCPGraph_CustomEvent_IsBase(bool value) const { qcpgraph_customevent_isbase = value; }
    inline void setQCPGraph_ConnectNotify_IsBase(bool value) const { qcpgraph_connectnotify_isbase = value; }
    inline void setQCPGraph_DisconnectNotify_IsBase(bool value) const { qcpgraph_disconnectnotify_isbase = value; }
    inline void setQCPGraph_GetLines_IsBase(bool value) const { qcpgraph_getlines_isbase = value; }
    inline void setQCPGraph_GetScatters_IsBase(bool value) const { qcpgraph_getscatters_isbase = value; }
    inline void setQCPGraph_DataToLines_IsBase(bool value) const { qcpgraph_datatolines_isbase = value; }
    inline void setQCPGraph_DataToStepLeftLines_IsBase(bool value) const { qcpgraph_datatostepleftlines_isbase = value; }
    inline void setQCPGraph_DataToStepRightLines_IsBase(bool value) const { qcpgraph_datatosteprightlines_isbase = value; }
    inline void setQCPGraph_DataToStepCenterLines_IsBase(bool value) const { qcpgraph_datatostepcenterlines_isbase = value; }
    inline void setQCPGraph_DataToImpulseLines_IsBase(bool value) const { qcpgraph_datatoimpulselines_isbase = value; }
    inline void setQCPGraph_GetNonNanSegments_IsBase(bool value) const { qcpgraph_getnonnansegments_isbase = value; }
    inline void setQCPGraph_GetOverlappingSegments_IsBase(bool value) const { qcpgraph_getoverlappingsegments_isbase = value; }
    inline void setQCPGraph_SegmentsIntersect_IsBase(bool value) const { qcpgraph_segmentsintersect_isbase = value; }
    inline void setQCPGraph_GetFillBasePoint_IsBase(bool value) const { qcpgraph_getfillbasepoint_isbase = value; }
    inline void setQCPGraph_FindIndexBelowX_IsBase(bool value) const { qcpgraph_findindexbelowx_isbase = value; }
    inline void setQCPGraph_FindIndexAboveX_IsBase(bool value) const { qcpgraph_findindexabovex_isbase = value; }
    inline void setQCPGraph_FindIndexBelowY_IsBase(bool value) const { qcpgraph_findindexbelowy_isbase = value; }
    inline void setQCPGraph_FindIndexAboveY_IsBase(bool value) const { qcpgraph_findindexabovey_isbase = value; }
    inline void setQCPGraph_ApplyFillAntialiasingHint_IsBase(bool value) const { qcpgraph_applyfillantialiasinghint_isbase = value; }
    inline void setQCPGraph_ApplyScattersAntialiasingHint_IsBase(bool value) const { qcpgraph_applyscattersantialiasinghint_isbase = value; }
    inline void setQCPGraph_InitializeParentPlot_IsBase(bool value) const { qcpgraph_initializeparentplot_isbase = value; }
    inline void setQCPGraph_SetParentLayerable_IsBase(bool value) const { qcpgraph_setparentlayerable_isbase = value; }
    inline void setQCPGraph_MoveToLayer_IsBase(bool value) const { qcpgraph_movetolayer_isbase = value; }
    inline void setQCPGraph_ApplyAntialiasingHint_IsBase(bool value) const { qcpgraph_applyantialiasinghint_isbase = value; }
    inline void setQCPGraph_Sender_IsBase(bool value) const { qcpgraph_sender_isbase = value; }
    inline void setQCPGraph_SenderSignalIndex_IsBase(bool value) const { qcpgraph_sendersignalindex_isbase = value; }
    inline void setQCPGraph_Receivers_IsBase(bool value) const { qcpgraph_receivers_isbase = value; }
    inline void setQCPGraph_IsSignalConnected_IsBase(bool value) const { qcpgraph_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpgraph_metacall_isbase) {
            qcpgraph_metacall_isbase = false;
            return QCPGraph::qt_metacall(param1, param2, param3);
        } else if (qcpgraph_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpgraph_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPGraph::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcpgraph_selecttest_isbase) {
            qcpgraph_selecttest_isbase = false;
            return QCPGraph::selectTest(pos, onlySelectable, details);
        } else if (qcpgraph_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcpgraph_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPGraph::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPRange getKeyRange(bool& foundRange, QCP::SignDomain inSignDomain) const override {
        if (qcpgraph_getkeyrange_isbase) {
            qcpgraph_getkeyrange_isbase = false;
            return QCPGraph::getKeyRange(foundRange, inSignDomain);
        } else if (qcpgraph_getkeyrange_callback != nullptr) {
            bool* cbval1 = &foundRange;
            int cbval2 = static_cast<int>(inSignDomain);

            QCPRange* callback_ret = qcpgraph_getkeyrange_callback(this, cbval1, cbval2);
            return *callback_ret;
        } else {
            return QCPGraph::getKeyRange(foundRange, inSignDomain);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPRange getValueRange(bool& foundRange, QCP::SignDomain inSignDomain, const QCPRange& inKeyRange) const override {
        if (qcpgraph_getvaluerange_isbase) {
            qcpgraph_getvaluerange_isbase = false;
            return QCPGraph::getValueRange(foundRange, inSignDomain, inKeyRange);
        } else if (qcpgraph_getvaluerange_callback != nullptr) {
            bool* cbval1 = &foundRange;
            int cbval2 = static_cast<int>(inSignDomain);
            const QCPRange& inKeyRange_ret = inKeyRange;
            // Cast returned reference into pointer
            QCPRange* cbval3 = const_cast<QCPRange*>(&inKeyRange_ret);

            QCPRange* callback_ret = qcpgraph_getvaluerange_callback(this, cbval1, cbval2, cbval3);
            return *callback_ret;
        } else {
            return QCPGraph::getValueRange(foundRange, inSignDomain, inKeyRange);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcpgraph_draw_isbase) {
            qcpgraph_draw_isbase = false;
            QCPGraph::draw(painter);
        } else if (qcpgraph_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpgraph_draw_callback(this, cbval1);
        } else {
            QCPGraph::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void drawLegendIcon(QCPPainter* painter, const QRectF& rect) const override {
        if (qcpgraph_drawlegendicon_isbase) {
            qcpgraph_drawlegendicon_isbase = false;
            QCPGraph::drawLegendIcon(painter, rect);
        } else if (qcpgraph_drawlegendicon_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval2 = const_cast<QRectF*>(&rect_ret);

            qcpgraph_drawlegendicon_callback(this, cbval1, cbval2);
        } else {
            QCPGraph::drawLegendIcon(painter, rect);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void drawFill(QCPPainter* painter, QVector<QPointF>* lines) const override {
        if (qcpgraph_drawfill_isbase) {
            qcpgraph_drawfill_isbase = false;
            QCPGraph::drawFill(painter, lines);
        } else if (qcpgraph_drawfill_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            QVector<QPointF>* lines_ret = lines;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** lines_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (lines_ret->size() + 1)));
            for (qsizetype i = 0; i < lines_ret->size(); ++i) {
                lines_arr[i] = new QPointF((*lines_ret)[i]);
            }
            libqt_list lines_out;
            lines_out.len = lines_ret->size();
            lines_out.data = static_cast<void*>(lines_arr);
            libqt_list /* of QPointF* */ cbval2 = lines_out;

            qcpgraph_drawfill_callback(this, cbval1, cbval2);
        } else {
            QCPGraph::drawFill(painter, lines);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void drawScatterPlot(QCPPainter* painter, const QVector<QPointF>& scatters, const QCPScatterStyle& style) const override {
        if (qcpgraph_drawscatterplot_isbase) {
            qcpgraph_drawscatterplot_isbase = false;
            QCPGraph::drawScatterPlot(painter, scatters, style);
        } else if (qcpgraph_drawscatterplot_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            const QVector<QPointF>& scatters_ret = scatters;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** scatters_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (scatters_ret.size() + 1)));
            for (qsizetype i = 0; i < scatters_ret.size(); ++i) {
                scatters_arr[i] = new QPointF(scatters_ret[i]);
            }
            libqt_list scatters_out;
            scatters_out.len = scatters_ret.size();
            scatters_out.data = static_cast<void*>(scatters_arr);
            libqt_list /* of QPointF* */ cbval2 = scatters_out;
            const QCPScatterStyle& style_ret = style;
            // Cast returned reference into pointer
            QCPScatterStyle* cbval3 = const_cast<QCPScatterStyle*>(&style_ret);

            qcpgraph_drawscatterplot_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPGraph::drawScatterPlot(painter, scatters, style);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void drawLinePlot(QCPPainter* painter, const QVector<QPointF>& lines) const override {
        if (qcpgraph_drawlineplot_isbase) {
            qcpgraph_drawlineplot_isbase = false;
            QCPGraph::drawLinePlot(painter, lines);
        } else if (qcpgraph_drawlineplot_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            const QVector<QPointF>& lines_ret = lines;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** lines_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (lines_ret.size() + 1)));
            for (qsizetype i = 0; i < lines_ret.size(); ++i) {
                lines_arr[i] = new QPointF(lines_ret[i]);
            }
            libqt_list lines_out;
            lines_out.len = lines_ret.size();
            lines_out.data = static_cast<void*>(lines_arr);
            libqt_list /* of QPointF* */ cbval2 = lines_out;

            qcpgraph_drawlineplot_callback(this, cbval1, cbval2);
        } else {
            QCPGraph::drawLinePlot(painter, lines);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void drawImpulsePlot(QCPPainter* painter, const QVector<QPointF>& lines) const override {
        if (qcpgraph_drawimpulseplot_isbase) {
            qcpgraph_drawimpulseplot_isbase = false;
            QCPGraph::drawImpulsePlot(painter, lines);
        } else if (qcpgraph_drawimpulseplot_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            const QVector<QPointF>& lines_ret = lines;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** lines_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (lines_ret.size() + 1)));
            for (qsizetype i = 0; i < lines_ret.size(); ++i) {
                lines_arr[i] = new QPointF(lines_ret[i]);
            }
            libqt_list lines_out;
            lines_out.len = lines_ret.size();
            lines_out.data = static_cast<void*>(lines_arr);
            libqt_list /* of QPointF* */ cbval2 = lines_out;

            qcpgraph_drawimpulseplot_callback(this, cbval1, cbval2);
        } else {
            QCPGraph::drawImpulsePlot(painter, lines);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int dataCount() const override {
        if (qcpgraph_datacount_callback != nullptr) {
            int callback_ret = qcpgraph_datacount_callback();
            return static_cast<int>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double dataMainKey(int index) const override {
        if (qcpgraph_datamainkey_callback != nullptr) {
            int cbval1 = index;

            double callback_ret = qcpgraph_datamainkey_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double dataSortKey(int index) const override {
        if (qcpgraph_datasortkey_callback != nullptr) {
            int cbval1 = index;

            double callback_ret = qcpgraph_datasortkey_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double dataMainValue(int index) const override {
        if (qcpgraph_datamainvalue_callback != nullptr) {
            int cbval1 = index;

            double callback_ret = qcpgraph_datamainvalue_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPRange dataValueRange(int index) const override {
        if (qcpgraph_datavaluerange_callback != nullptr) {
            int cbval1 = index;

            QCPRange* callback_ret = qcpgraph_datavaluerange_callback(this, cbval1);
            return *callback_ret;
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QPointF dataPixelPosition(int index) const override {
        if (qcpgraph_datapixelposition_callback != nullptr) {
            int cbval1 = index;

            QPointF* callback_ret = qcpgraph_datapixelposition_callback(this, cbval1);
            return *callback_ret;
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool sortKeyIsMainKey() const override {
        if (qcpgraph_sortkeyismainkey_callback != nullptr) {
            bool callback_ret = qcpgraph_sortkeyismainkey_callback();
            return callback_ret;
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPDataSelection selectTestRect(const QRectF& rect, bool onlySelectable) const override {
        if (qcpgraph_selecttestrect_callback != nullptr) {
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval1 = const_cast<QRectF*>(&rect_ret);
            bool cbval2 = onlySelectable;

            QCPDataSelection* callback_ret = qcpgraph_selecttestrect_callback(this, cbval1, cbval2);
            return *callback_ret;
        } else {
            return QCPDataSelection();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int findBegin(double sortKey, bool expandedRange) const override {
        if (qcpgraph_findbegin_callback != nullptr) {
            double cbval1 = sortKey;
            bool cbval2 = expandedRange;

            int callback_ret = qcpgraph_findbegin_callback(this, cbval1, cbval2);
            return static_cast<int>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int findEnd(double sortKey, bool expandedRange) const override {
        if (qcpgraph_findend_callback != nullptr) {
            double cbval1 = sortKey;
            bool cbval2 = expandedRange;

            int callback_ret = qcpgraph_findend_callback(this, cbval1, cbval2);
            return static_cast<int>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPPlottableInterface1D* interface1D() override {
        if (qcpgraph_interface1d_isbase) {
            qcpgraph_interface1d_isbase = false;
            return QCPGraph::interface1D();
        } else if (qcpgraph_interface1d_callback != nullptr) {
            QCPPlottableInterface1D* callback_ret = qcpgraph_interface1d_callback();
            return callback_ret;
        } else {
            return QCPGraph::interface1D();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcpgraph_cliprect_isbase) {
            qcpgraph_cliprect_isbase = false;
            return QCPGraph::clipRect();
        } else if (qcpgraph_cliprect_callback != nullptr) {
            QRect* callback_ret = qcpgraph_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPGraph::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcpgraph_selectioncategory_isbase) {
            qcpgraph_selectioncategory_isbase = false;
            return QCPGraph::selectionCategory();
        } else if (qcpgraph_selectioncategory_callback != nullptr) {
            int callback_ret = qcpgraph_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPGraph::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcpgraph_applydefaultantialiasinghint_isbase) {
            qcpgraph_applydefaultantialiasinghint_isbase = false;
            QCPGraph::applyDefaultAntialiasingHint(painter);
        } else if (qcpgraph_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpgraph_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPGraph::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcpgraph_selectevent_isbase) {
            qcpgraph_selectevent_isbase = false;
            QCPGraph::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcpgraph_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcpgraph_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPGraph::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcpgraph_deselectevent_isbase) {
            qcpgraph_deselectevent_isbase = false;
            QCPGraph::deselectEvent(selectionStateChanged);
        } else if (qcpgraph_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcpgraph_deselectevent_callback(this, cbval1);
        } else {
            QCPGraph::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcpgraph_parentplotinitialized_isbase) {
            qcpgraph_parentplotinitialized_isbase = false;
            QCPGraph::parentPlotInitialized(parentPlot);
        } else if (qcpgraph_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpgraph_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPGraph::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpgraph_mousepressevent_isbase) {
            qcpgraph_mousepressevent_isbase = false;
            QCPGraph::mousePressEvent(event, details);
        } else if (qcpgraph_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpgraph_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPGraph::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpgraph_mousemoveevent_isbase) {
            qcpgraph_mousemoveevent_isbase = false;
            QCPGraph::mouseMoveEvent(event, startPos);
        } else if (qcpgraph_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpgraph_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPGraph::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpgraph_mousereleaseevent_isbase) {
            qcpgraph_mousereleaseevent_isbase = false;
            QCPGraph::mouseReleaseEvent(event, startPos);
        } else if (qcpgraph_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpgraph_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPGraph::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpgraph_mousedoubleclickevent_isbase) {
            qcpgraph_mousedoubleclickevent_isbase = false;
            QCPGraph::mouseDoubleClickEvent(event, details);
        } else if (qcpgraph_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpgraph_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPGraph::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcpgraph_wheelevent_isbase) {
            qcpgraph_wheelevent_isbase = false;
            QCPGraph::wheelEvent(event);
        } else if (qcpgraph_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcpgraph_wheelevent_callback(this, cbval1);
        } else {
            QCPGraph::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpgraph_event_isbase) {
            qcpgraph_event_isbase = false;
            return QCPGraph::event(event);
        } else if (qcpgraph_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpgraph_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPGraph::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpgraph_eventfilter_isbase) {
            qcpgraph_eventfilter_isbase = false;
            return QCPGraph::eventFilter(watched, event);
        } else if (qcpgraph_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpgraph_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPGraph::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpgraph_timerevent_isbase) {
            qcpgraph_timerevent_isbase = false;
            QCPGraph::timerEvent(event);
        } else if (qcpgraph_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpgraph_timerevent_callback(this, cbval1);
        } else {
            QCPGraph::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpgraph_childevent_isbase) {
            qcpgraph_childevent_isbase = false;
            QCPGraph::childEvent(event);
        } else if (qcpgraph_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpgraph_childevent_callback(this, cbval1);
        } else {
            QCPGraph::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpgraph_customevent_isbase) {
            qcpgraph_customevent_isbase = false;
            QCPGraph::customEvent(event);
        } else if (qcpgraph_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpgraph_customevent_callback(this, cbval1);
        } else {
            QCPGraph::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpgraph_connectnotify_isbase) {
            qcpgraph_connectnotify_isbase = false;
            QCPGraph::connectNotify(signal);
        } else if (qcpgraph_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpgraph_connectnotify_callback(this, cbval1);
        } else {
            QCPGraph::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpgraph_disconnectnotify_isbase) {
            qcpgraph_disconnectnotify_isbase = false;
            QCPGraph::disconnectNotify(signal);
        } else if (qcpgraph_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpgraph_disconnectnotify_callback(this, cbval1);
        } else {
            QCPGraph::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    void getLines(QVector<QPointF>* lines, const QCPDataRange& dataRange) const {
        if (qcpgraph_getlines_isbase) {
            qcpgraph_getlines_isbase = false;
            QCPGraph::getLines(lines, dataRange);
        } else if (qcpgraph_getlines_callback != nullptr) {
            QVector<QPointF>* lines_ret = lines;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** lines_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (lines_ret->size() + 1)));
            for (qsizetype i = 0; i < lines_ret->size(); ++i) {
                lines_arr[i] = new QPointF((*lines_ret)[i]);
            }
            libqt_list lines_out;
            lines_out.len = lines_ret->size();
            lines_out.data = static_cast<void*>(lines_arr);
            libqt_list /* of QPointF* */ cbval1 = lines_out;
            const QCPDataRange& dataRange_ret = dataRange;
            // Cast returned reference into pointer
            QCPDataRange* cbval2 = const_cast<QCPDataRange*>(&dataRange_ret);

            qcpgraph_getlines_callback(this, cbval1, cbval2);
        } else {
            QCPGraph::getLines(lines, dataRange);
        }
    }

    // Virtual method for C ABI access and custom callback
    void getScatters(QVector<QPointF>* scatters, const QCPDataRange& dataRange) const {
        if (qcpgraph_getscatters_isbase) {
            qcpgraph_getscatters_isbase = false;
            QCPGraph::getScatters(scatters, dataRange);
        } else if (qcpgraph_getscatters_callback != nullptr) {
            QVector<QPointF>* scatters_ret = scatters;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** scatters_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (scatters_ret->size() + 1)));
            for (qsizetype i = 0; i < scatters_ret->size(); ++i) {
                scatters_arr[i] = new QPointF((*scatters_ret)[i]);
            }
            libqt_list scatters_out;
            scatters_out.len = scatters_ret->size();
            scatters_out.data = static_cast<void*>(scatters_arr);
            libqt_list /* of QPointF* */ cbval1 = scatters_out;
            const QCPDataRange& dataRange_ret = dataRange;
            // Cast returned reference into pointer
            QCPDataRange* cbval2 = const_cast<QCPDataRange*>(&dataRange_ret);

            qcpgraph_getscatters_callback(this, cbval1, cbval2);
        } else {
            QCPGraph::getScatters(scatters, dataRange);
        }
    }

    // Virtual method for C ABI access and custom callback
    QVector<QPointF> dataToLines(const QVector<QCPGraphData>& data) const {
        if (qcpgraph_datatolines_isbase) {
            qcpgraph_datatolines_isbase = false;
            return QCPGraph::dataToLines(data);
        } else if (qcpgraph_datatolines_callback != nullptr) {
            const QVector<QCPGraphData>& data_ret = data;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QCPGraphData** data_arr = static_cast<QCPGraphData**>(malloc(sizeof(QCPGraphData*) * (data_ret.size() + 1)));
            for (qsizetype i = 0; i < data_ret.size(); ++i) {
                data_arr[i] = new QCPGraphData(data_ret[i]);
            }
            libqt_list data_out;
            data_out.len = data_ret.size();
            data_out.data = static_cast<void*>(data_arr);
            libqt_list /* of QCPGraphData* */ cbval1 = data_out;

            QPointF** callback_ret = qcpgraph_datatolines_callback(this, cbval1);
            QVector<QPointF> callback_ret_QVector;
            // Iterate until null pointer sentinel
            for (QPointF** ptridx = callback_ret; *ptridx != nullptr; ptridx++) {
                callback_ret_QVector.push_back(**ptridx);
            }
            free(callback_ret);
            return callback_ret_QVector;
        } else {
            return QCPGraph::dataToLines(data);
        }
    }

    // Virtual method for C ABI access and custom callback
    QVector<QPointF> dataToStepLeftLines(const QVector<QCPGraphData>& data) const {
        if (qcpgraph_datatostepleftlines_isbase) {
            qcpgraph_datatostepleftlines_isbase = false;
            return QCPGraph::dataToStepLeftLines(data);
        } else if (qcpgraph_datatostepleftlines_callback != nullptr) {
            const QVector<QCPGraphData>& data_ret = data;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QCPGraphData** data_arr = static_cast<QCPGraphData**>(malloc(sizeof(QCPGraphData*) * (data_ret.size() + 1)));
            for (qsizetype i = 0; i < data_ret.size(); ++i) {
                data_arr[i] = new QCPGraphData(data_ret[i]);
            }
            libqt_list data_out;
            data_out.len = data_ret.size();
            data_out.data = static_cast<void*>(data_arr);
            libqt_list /* of QCPGraphData* */ cbval1 = data_out;

            QPointF** callback_ret = qcpgraph_datatostepleftlines_callback(this, cbval1);
            QVector<QPointF> callback_ret_QVector;
            // Iterate until null pointer sentinel
            for (QPointF** ptridx = callback_ret; *ptridx != nullptr; ptridx++) {
                callback_ret_QVector.push_back(**ptridx);
            }
            free(callback_ret);
            return callback_ret_QVector;
        } else {
            return QCPGraph::dataToStepLeftLines(data);
        }
    }

    // Virtual method for C ABI access and custom callback
    QVector<QPointF> dataToStepRightLines(const QVector<QCPGraphData>& data) const {
        if (qcpgraph_datatosteprightlines_isbase) {
            qcpgraph_datatosteprightlines_isbase = false;
            return QCPGraph::dataToStepRightLines(data);
        } else if (qcpgraph_datatosteprightlines_callback != nullptr) {
            const QVector<QCPGraphData>& data_ret = data;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QCPGraphData** data_arr = static_cast<QCPGraphData**>(malloc(sizeof(QCPGraphData*) * (data_ret.size() + 1)));
            for (qsizetype i = 0; i < data_ret.size(); ++i) {
                data_arr[i] = new QCPGraphData(data_ret[i]);
            }
            libqt_list data_out;
            data_out.len = data_ret.size();
            data_out.data = static_cast<void*>(data_arr);
            libqt_list /* of QCPGraphData* */ cbval1 = data_out;

            QPointF** callback_ret = qcpgraph_datatosteprightlines_callback(this, cbval1);
            QVector<QPointF> callback_ret_QVector;
            // Iterate until null pointer sentinel
            for (QPointF** ptridx = callback_ret; *ptridx != nullptr; ptridx++) {
                callback_ret_QVector.push_back(**ptridx);
            }
            free(callback_ret);
            return callback_ret_QVector;
        } else {
            return QCPGraph::dataToStepRightLines(data);
        }
    }

    // Virtual method for C ABI access and custom callback
    QVector<QPointF> dataToStepCenterLines(const QVector<QCPGraphData>& data) const {
        if (qcpgraph_datatostepcenterlines_isbase) {
            qcpgraph_datatostepcenterlines_isbase = false;
            return QCPGraph::dataToStepCenterLines(data);
        } else if (qcpgraph_datatostepcenterlines_callback != nullptr) {
            const QVector<QCPGraphData>& data_ret = data;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QCPGraphData** data_arr = static_cast<QCPGraphData**>(malloc(sizeof(QCPGraphData*) * (data_ret.size() + 1)));
            for (qsizetype i = 0; i < data_ret.size(); ++i) {
                data_arr[i] = new QCPGraphData(data_ret[i]);
            }
            libqt_list data_out;
            data_out.len = data_ret.size();
            data_out.data = static_cast<void*>(data_arr);
            libqt_list /* of QCPGraphData* */ cbval1 = data_out;

            QPointF** callback_ret = qcpgraph_datatostepcenterlines_callback(this, cbval1);
            QVector<QPointF> callback_ret_QVector;
            // Iterate until null pointer sentinel
            for (QPointF** ptridx = callback_ret; *ptridx != nullptr; ptridx++) {
                callback_ret_QVector.push_back(**ptridx);
            }
            free(callback_ret);
            return callback_ret_QVector;
        } else {
            return QCPGraph::dataToStepCenterLines(data);
        }
    }

    // Virtual method for C ABI access and custom callback
    QVector<QPointF> dataToImpulseLines(const QVector<QCPGraphData>& data) const {
        if (qcpgraph_datatoimpulselines_isbase) {
            qcpgraph_datatoimpulselines_isbase = false;
            return QCPGraph::dataToImpulseLines(data);
        } else if (qcpgraph_datatoimpulselines_callback != nullptr) {
            const QVector<QCPGraphData>& data_ret = data;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QCPGraphData** data_arr = static_cast<QCPGraphData**>(malloc(sizeof(QCPGraphData*) * (data_ret.size() + 1)));
            for (qsizetype i = 0; i < data_ret.size(); ++i) {
                data_arr[i] = new QCPGraphData(data_ret[i]);
            }
            libqt_list data_out;
            data_out.len = data_ret.size();
            data_out.data = static_cast<void*>(data_arr);
            libqt_list /* of QCPGraphData* */ cbval1 = data_out;

            QPointF** callback_ret = qcpgraph_datatoimpulselines_callback(this, cbval1);
            QVector<QPointF> callback_ret_QVector;
            // Iterate until null pointer sentinel
            for (QPointF** ptridx = callback_ret; *ptridx != nullptr; ptridx++) {
                callback_ret_QVector.push_back(**ptridx);
            }
            free(callback_ret);
            return callback_ret_QVector;
        } else {
            return QCPGraph::dataToImpulseLines(data);
        }
    }

    // Virtual method for C ABI access and custom callback
    QVector<QCPDataRange> getNonNanSegments(const QVector<QPointF>* lineData, Qt::Orientation keyOrientation) const {
        if (qcpgraph_getnonnansegments_isbase) {
            qcpgraph_getnonnansegments_isbase = false;
            return QCPGraph::getNonNanSegments(lineData, keyOrientation);
        } else if (qcpgraph_getnonnansegments_callback != nullptr) {
            const QVector<QPointF>* lineData_ret = lineData;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** lineData_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (lineData_ret->size() + 1)));
            for (qsizetype i = 0; i < lineData_ret->size(); ++i) {
                lineData_arr[i] = new QPointF((*lineData_ret)[i]);
            }
            libqt_list lineData_out;
            lineData_out.len = lineData_ret->size();
            lineData_out.data = static_cast<void*>(lineData_arr);
            libqt_list /* of QPointF* */ cbval1 = lineData_out;
            int cbval2 = static_cast<int>(keyOrientation);

            QCPDataRange** callback_ret = qcpgraph_getnonnansegments_callback(this, cbval1, cbval2);
            QVector<QCPDataRange> callback_ret_QVector;
            // Iterate until null pointer sentinel
            for (QCPDataRange** ptridx = callback_ret; *ptridx != nullptr; ptridx++) {
                callback_ret_QVector.push_back(**ptridx);
            }
            free(callback_ret);
            return callback_ret_QVector;
        } else {
            return QCPGraph::getNonNanSegments(lineData, keyOrientation);
        }
    }

    // Virtual method for C ABI access and custom callback
    QVector<QPair<QCPDataRange, QCPDataRange>> getOverlappingSegments(QVector<QCPDataRange> thisSegments, const QVector<QPointF>* thisData, QVector<QCPDataRange> otherSegments, const QVector<QPointF>* otherData) const {
        if (qcpgraph_getoverlappingsegments_isbase) {
            qcpgraph_getoverlappingsegments_isbase = false;
            return QCPGraph::getOverlappingSegments(thisSegments, thisData, otherSegments, otherData);
        } else if (qcpgraph_getoverlappingsegments_callback != nullptr) {
            QVector<QCPDataRange> thisSegments_ret = thisSegments;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QCPDataRange** thisSegments_arr = static_cast<QCPDataRange**>(malloc(sizeof(QCPDataRange*) * (thisSegments_ret.size() + 1)));
            for (qsizetype i = 0; i < thisSegments_ret.size(); ++i) {
                thisSegments_arr[i] = new QCPDataRange(thisSegments_ret[i]);
            }
            libqt_list thisSegments_out;
            thisSegments_out.len = thisSegments_ret.size();
            thisSegments_out.data = static_cast<void*>(thisSegments_arr);
            libqt_list /* of QCPDataRange* */ cbval1 = thisSegments_out;
            const QVector<QPointF>* thisData_ret = thisData;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** thisData_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (thisData_ret->size() + 1)));
            for (qsizetype i = 0; i < thisData_ret->size(); ++i) {
                thisData_arr[i] = new QPointF((*thisData_ret)[i]);
            }
            libqt_list thisData_out;
            thisData_out.len = thisData_ret->size();
            thisData_out.data = static_cast<void*>(thisData_arr);
            libqt_list /* of QPointF* */ cbval2 = thisData_out;
            QVector<QCPDataRange> otherSegments_ret = otherSegments;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QCPDataRange** otherSegments_arr = static_cast<QCPDataRange**>(malloc(sizeof(QCPDataRange*) * (otherSegments_ret.size() + 1)));
            for (qsizetype i = 0; i < otherSegments_ret.size(); ++i) {
                otherSegments_arr[i] = new QCPDataRange(otherSegments_ret[i]);
            }
            libqt_list otherSegments_out;
            otherSegments_out.len = otherSegments_ret.size();
            otherSegments_out.data = static_cast<void*>(otherSegments_arr);
            libqt_list /* of QCPDataRange* */ cbval3 = otherSegments_out;
            const QVector<QPointF>* otherData_ret = otherData;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** otherData_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (otherData_ret->size() + 1)));
            for (qsizetype i = 0; i < otherData_ret->size(); ++i) {
                otherData_arr[i] = new QPointF((*otherData_ret)[i]);
            }
            libqt_list otherData_out;
            otherData_out.len = otherData_ret->size();
            otherData_out.data = static_cast<void*>(otherData_arr);
            libqt_list /* of QPointF* */ cbval4 = otherData_out;

            libqt_list /* of libqt_pair  tuple of QCPDataRange* and QCPDataRange*  */ callback_ret = qcpgraph_getoverlappingsegments_callback(this, cbval1, cbval2, cbval3, cbval4);
            QVector<QPair<QCPDataRange, QCPDataRange>> callback_ret_QVector;
            callback_ret_QVector.reserve(callback_ret.len);
            libqt_pair /* tuple of QCPDataRange* and QCPDataRange* */* callback_ret_arr = static_cast<libqt_pair /* tuple of QCPDataRange* and QCPDataRange* */*>(callback_ret.data);
            for (size_t i = 0; i < callback_ret.len; ++i) {
                QPair<QCPDataRange, QCPDataRange> callback_ret_arr_i_QPair;
                QCPDataRange** callback_ret_arr_i_first = static_cast<QCPDataRange**>(callback_ret_arr[i].first);
                QCPDataRange** callback_ret_arr_i_second = static_cast<QCPDataRange**>(callback_ret_arr[i].second);
                callback_ret_arr_i_QPair.first = *(callback_ret_arr_i_first[0]);
                callback_ret_arr_i_QPair.second = *(callback_ret_arr_i_second[0]);
                callback_ret_QVector.push_back(callback_ret_arr_i_QPair);
            }
            return callback_ret_QVector;
        } else {
            return QCPGraph::getOverlappingSegments(thisSegments, thisData, otherSegments, otherData);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool segmentsIntersect(double aLower, double aUpper, double bLower, double bUpper, int& bPrecedence) const {
        if (qcpgraph_segmentsintersect_isbase) {
            qcpgraph_segmentsintersect_isbase = false;
            return QCPGraph::segmentsIntersect(aLower, aUpper, bLower, bUpper, bPrecedence);
        } else if (qcpgraph_segmentsintersect_callback != nullptr) {
            double cbval1 = aLower;
            double cbval2 = aUpper;
            double cbval3 = bLower;
            double cbval4 = bUpper;
            int* cbval5 = &bPrecedence;

            bool callback_ret = qcpgraph_segmentsintersect_callback(this, cbval1, cbval2, cbval3, cbval4, cbval5);
            return callback_ret;
        } else {
            return QCPGraph::segmentsIntersect(aLower, aUpper, bLower, bUpper, bPrecedence);
        }
    }

    // Virtual method for C ABI access and custom callback
    QPointF getFillBasePoint(QPointF matchingDataPoint) const {
        if (qcpgraph_getfillbasepoint_isbase) {
            qcpgraph_getfillbasepoint_isbase = false;
            return QCPGraph::getFillBasePoint(matchingDataPoint);
        } else if (qcpgraph_getfillbasepoint_callback != nullptr) {
            QPointF* cbval1 = new QPointF(matchingDataPoint);

            QPointF* callback_ret = qcpgraph_getfillbasepoint_callback(this, cbval1);
            return *callback_ret;
        } else {
            return QCPGraph::getFillBasePoint(matchingDataPoint);
        }
    }

    // Virtual method for C ABI access and custom callback
    int findIndexBelowX(const QVector<QPointF>* data, double x) const {
        if (qcpgraph_findindexbelowx_isbase) {
            qcpgraph_findindexbelowx_isbase = false;
            return QCPGraph::findIndexBelowX(data, x);
        } else if (qcpgraph_findindexbelowx_callback != nullptr) {
            const QVector<QPointF>* data_ret = data;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** data_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (data_ret->size() + 1)));
            for (qsizetype i = 0; i < data_ret->size(); ++i) {
                data_arr[i] = new QPointF((*data_ret)[i]);
            }
            libqt_list data_out;
            data_out.len = data_ret->size();
            data_out.data = static_cast<void*>(data_arr);
            libqt_list /* of QPointF* */ cbval1 = data_out;
            double cbval2 = x;

            int callback_ret = qcpgraph_findindexbelowx_callback(this, cbval1, cbval2);
            return static_cast<int>(callback_ret);
        } else {
            return QCPGraph::findIndexBelowX(data, x);
        }
    }

    // Virtual method for C ABI access and custom callback
    int findIndexAboveX(const QVector<QPointF>* data, double x) const {
        if (qcpgraph_findindexabovex_isbase) {
            qcpgraph_findindexabovex_isbase = false;
            return QCPGraph::findIndexAboveX(data, x);
        } else if (qcpgraph_findindexabovex_callback != nullptr) {
            const QVector<QPointF>* data_ret = data;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** data_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (data_ret->size() + 1)));
            for (qsizetype i = 0; i < data_ret->size(); ++i) {
                data_arr[i] = new QPointF((*data_ret)[i]);
            }
            libqt_list data_out;
            data_out.len = data_ret->size();
            data_out.data = static_cast<void*>(data_arr);
            libqt_list /* of QPointF* */ cbval1 = data_out;
            double cbval2 = x;

            int callback_ret = qcpgraph_findindexabovex_callback(this, cbval1, cbval2);
            return static_cast<int>(callback_ret);
        } else {
            return QCPGraph::findIndexAboveX(data, x);
        }
    }

    // Virtual method for C ABI access and custom callback
    int findIndexBelowY(const QVector<QPointF>* data, double y) const {
        if (qcpgraph_findindexbelowy_isbase) {
            qcpgraph_findindexbelowy_isbase = false;
            return QCPGraph::findIndexBelowY(data, y);
        } else if (qcpgraph_findindexbelowy_callback != nullptr) {
            const QVector<QPointF>* data_ret = data;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** data_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (data_ret->size() + 1)));
            for (qsizetype i = 0; i < data_ret->size(); ++i) {
                data_arr[i] = new QPointF((*data_ret)[i]);
            }
            libqt_list data_out;
            data_out.len = data_ret->size();
            data_out.data = static_cast<void*>(data_arr);
            libqt_list /* of QPointF* */ cbval1 = data_out;
            double cbval2 = y;

            int callback_ret = qcpgraph_findindexbelowy_callback(this, cbval1, cbval2);
            return static_cast<int>(callback_ret);
        } else {
            return QCPGraph::findIndexBelowY(data, y);
        }
    }

    // Virtual method for C ABI access and custom callback
    int findIndexAboveY(const QVector<QPointF>* data, double y) const {
        if (qcpgraph_findindexabovey_isbase) {
            qcpgraph_findindexabovey_isbase = false;
            return QCPGraph::findIndexAboveY(data, y);
        } else if (qcpgraph_findindexabovey_callback != nullptr) {
            const QVector<QPointF>* data_ret = data;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** data_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (data_ret->size() + 1)));
            for (qsizetype i = 0; i < data_ret->size(); ++i) {
                data_arr[i] = new QPointF((*data_ret)[i]);
            }
            libqt_list data_out;
            data_out.len = data_ret->size();
            data_out.data = static_cast<void*>(data_arr);
            libqt_list /* of QPointF* */ cbval1 = data_out;
            double cbval2 = y;

            int callback_ret = qcpgraph_findindexabovey_callback(this, cbval1, cbval2);
            return static_cast<int>(callback_ret);
        } else {
            return QCPGraph::findIndexAboveY(data, y);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyFillAntialiasingHint(QCPPainter* painter) const {
        if (qcpgraph_applyfillantialiasinghint_isbase) {
            qcpgraph_applyfillantialiasinghint_isbase = false;
            QCPGraph::applyFillAntialiasingHint(painter);
        } else if (qcpgraph_applyfillantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpgraph_applyfillantialiasinghint_callback(this, cbval1);
        } else {
            QCPGraph::applyFillAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyScattersAntialiasingHint(QCPPainter* painter) const {
        if (qcpgraph_applyscattersantialiasinghint_isbase) {
            qcpgraph_applyscattersantialiasinghint_isbase = false;
            QCPGraph::applyScattersAntialiasingHint(painter);
        } else if (qcpgraph_applyscattersantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpgraph_applyscattersantialiasinghint_callback(this, cbval1);
        } else {
            QCPGraph::applyScattersAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcpgraph_initializeparentplot_isbase) {
            qcpgraph_initializeparentplot_isbase = false;
            QCPGraph::initializeParentPlot(parentPlot);
        } else if (qcpgraph_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpgraph_initializeparentplot_callback(this, cbval1);
        } else {
            QCPGraph::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcpgraph_setparentlayerable_isbase) {
            qcpgraph_setparentlayerable_isbase = false;
            QCPGraph::setParentLayerable(parentLayerable);
        } else if (qcpgraph_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcpgraph_setparentlayerable_callback(this, cbval1);
        } else {
            QCPGraph::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcpgraph_movetolayer_isbase) {
            qcpgraph_movetolayer_isbase = false;
            return QCPGraph::moveToLayer(layer, prepend);
        } else if (qcpgraph_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcpgraph_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPGraph::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcpgraph_applyantialiasinghint_isbase) {
            qcpgraph_applyantialiasinghint_isbase = false;
            QCPGraph::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcpgraph_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcpgraph_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPGraph::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpgraph_sender_isbase) {
            qcpgraph_sender_isbase = false;
            return QCPGraph::sender();
        } else if (qcpgraph_sender_callback != nullptr) {
            QObject* callback_ret = qcpgraph_sender_callback();
            return callback_ret;
        } else {
            return QCPGraph::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpgraph_sendersignalindex_isbase) {
            qcpgraph_sendersignalindex_isbase = false;
            return QCPGraph::senderSignalIndex();
        } else if (qcpgraph_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpgraph_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPGraph::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpgraph_receivers_isbase) {
            qcpgraph_receivers_isbase = false;
            return QCPGraph::receivers(signal);
        } else if (qcpgraph_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpgraph_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPGraph::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpgraph_issignalconnected_isbase) {
            qcpgraph_issignalconnected_isbase = false;
            return QCPGraph::isSignalConnected(signal);
        } else if (qcpgraph_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpgraph_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPGraph::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPGraph_Draw(QCPGraph* self, QCPPainter* painter);
    friend void QCPGraph_QBaseDraw(QCPGraph* self, QCPPainter* painter);
    friend void QCPGraph_DrawLegendIcon(const QCPGraph* self, QCPPainter* painter, const QRectF* rect);
    friend void QCPGraph_QBaseDrawLegendIcon(const QCPGraph* self, QCPPainter* painter, const QRectF* rect);
    friend void QCPGraph_DrawFill(const QCPGraph* self, QCPPainter* painter, libqt_list /* of QPointF* */ lines);
    friend void QCPGraph_QBaseDrawFill(const QCPGraph* self, QCPPainter* painter, libqt_list /* of QPointF* */ lines);
    friend void QCPGraph_DrawScatterPlot(const QCPGraph* self, QCPPainter* painter, const libqt_list /* of QPointF* */ scatters, const QCPScatterStyle* style);
    friend void QCPGraph_QBaseDrawScatterPlot(const QCPGraph* self, QCPPainter* painter, const libqt_list /* of QPointF* */ scatters, const QCPScatterStyle* style);
    friend void QCPGraph_DrawLinePlot(const QCPGraph* self, QCPPainter* painter, const libqt_list /* of QPointF* */ lines);
    friend void QCPGraph_QBaseDrawLinePlot(const QCPGraph* self, QCPPainter* painter, const libqt_list /* of QPointF* */ lines);
    friend void QCPGraph_DrawImpulsePlot(const QCPGraph* self, QCPPainter* painter, const libqt_list /* of QPointF* */ lines);
    friend void QCPGraph_QBaseDrawImpulsePlot(const QCPGraph* self, QCPPainter* painter, const libqt_list /* of QPointF* */ lines);
    friend QRect* QCPGraph_ClipRect(const QCPGraph* self);
    friend QRect* QCPGraph_QBaseClipRect(const QCPGraph* self);
    friend int QCPGraph_SelectionCategory(const QCPGraph* self);
    friend int QCPGraph_QBaseSelectionCategory(const QCPGraph* self);
    friend void QCPGraph_ApplyDefaultAntialiasingHint(const QCPGraph* self, QCPPainter* painter);
    friend void QCPGraph_QBaseApplyDefaultAntialiasingHint(const QCPGraph* self, QCPPainter* painter);
    friend void QCPGraph_SelectEvent(QCPGraph* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPGraph_QBaseSelectEvent(QCPGraph* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPGraph_DeselectEvent(QCPGraph* self, bool* selectionStateChanged);
    friend void QCPGraph_QBaseDeselectEvent(QCPGraph* self, bool* selectionStateChanged);
    friend void QCPGraph_ParentPlotInitialized(QCPGraph* self, QCustomPlot* parentPlot);
    friend void QCPGraph_QBaseParentPlotInitialized(QCPGraph* self, QCustomPlot* parentPlot);
    friend void QCPGraph_MousePressEvent(QCPGraph* self, QMouseEvent* event, const QVariant* details);
    friend void QCPGraph_QBaseMousePressEvent(QCPGraph* self, QMouseEvent* event, const QVariant* details);
    friend void QCPGraph_MouseMoveEvent(QCPGraph* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPGraph_QBaseMouseMoveEvent(QCPGraph* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPGraph_MouseReleaseEvent(QCPGraph* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPGraph_QBaseMouseReleaseEvent(QCPGraph* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPGraph_MouseDoubleClickEvent(QCPGraph* self, QMouseEvent* event, const QVariant* details);
    friend void QCPGraph_QBaseMouseDoubleClickEvent(QCPGraph* self, QMouseEvent* event, const QVariant* details);
    friend void QCPGraph_WheelEvent(QCPGraph* self, QWheelEvent* event);
    friend void QCPGraph_QBaseWheelEvent(QCPGraph* self, QWheelEvent* event);
    friend void QCPGraph_TimerEvent(QCPGraph* self, QTimerEvent* event);
    friend void QCPGraph_QBaseTimerEvent(QCPGraph* self, QTimerEvent* event);
    friend void QCPGraph_ChildEvent(QCPGraph* self, QChildEvent* event);
    friend void QCPGraph_QBaseChildEvent(QCPGraph* self, QChildEvent* event);
    friend void QCPGraph_CustomEvent(QCPGraph* self, QEvent* event);
    friend void QCPGraph_QBaseCustomEvent(QCPGraph* self, QEvent* event);
    friend void QCPGraph_ConnectNotify(QCPGraph* self, const QMetaMethod* signal);
    friend void QCPGraph_QBaseConnectNotify(QCPGraph* self, const QMetaMethod* signal);
    friend void QCPGraph_DisconnectNotify(QCPGraph* self, const QMetaMethod* signal);
    friend void QCPGraph_QBaseDisconnectNotify(QCPGraph* self, const QMetaMethod* signal);
    friend void QCPGraph_GetLines(const QCPGraph* self, libqt_list /* of QPointF* */ lines, const QCPDataRange* dataRange);
    friend void QCPGraph_QBaseGetLines(const QCPGraph* self, libqt_list /* of QPointF* */ lines, const QCPDataRange* dataRange);
    friend void QCPGraph_GetScatters(const QCPGraph* self, libqt_list /* of QPointF* */ scatters, const QCPDataRange* dataRange);
    friend void QCPGraph_QBaseGetScatters(const QCPGraph* self, libqt_list /* of QPointF* */ scatters, const QCPDataRange* dataRange);
    friend libqt_list /* of QPointF* */ QCPGraph_DataToLines(const QCPGraph* self, const libqt_list /* of QCPGraphData* */ data);
    friend libqt_list /* of QPointF* */ QCPGraph_QBaseDataToLines(const QCPGraph* self, const libqt_list /* of QCPGraphData* */ data);
    friend libqt_list /* of QPointF* */ QCPGraph_DataToStepLeftLines(const QCPGraph* self, const libqt_list /* of QCPGraphData* */ data);
    friend libqt_list /* of QPointF* */ QCPGraph_QBaseDataToStepLeftLines(const QCPGraph* self, const libqt_list /* of QCPGraphData* */ data);
    friend libqt_list /* of QPointF* */ QCPGraph_DataToStepRightLines(const QCPGraph* self, const libqt_list /* of QCPGraphData* */ data);
    friend libqt_list /* of QPointF* */ QCPGraph_QBaseDataToStepRightLines(const QCPGraph* self, const libqt_list /* of QCPGraphData* */ data);
    friend libqt_list /* of QPointF* */ QCPGraph_DataToStepCenterLines(const QCPGraph* self, const libqt_list /* of QCPGraphData* */ data);
    friend libqt_list /* of QPointF* */ QCPGraph_QBaseDataToStepCenterLines(const QCPGraph* self, const libqt_list /* of QCPGraphData* */ data);
    friend libqt_list /* of QPointF* */ QCPGraph_DataToImpulseLines(const QCPGraph* self, const libqt_list /* of QCPGraphData* */ data);
    friend libqt_list /* of QPointF* */ QCPGraph_QBaseDataToImpulseLines(const QCPGraph* self, const libqt_list /* of QCPGraphData* */ data);
    friend libqt_list /* of QCPDataRange* */ QCPGraph_GetNonNanSegments(const QCPGraph* self, const libqt_list /* of QPointF* */ lineData, int keyOrientation);
    friend libqt_list /* of QCPDataRange* */ QCPGraph_QBaseGetNonNanSegments(const QCPGraph* self, const libqt_list /* of QPointF* */ lineData, int keyOrientation);
    friend libqt_list /* of libqt_pair  tuple of QCPDataRange* and QCPDataRange*  */ QCPGraph_GetOverlappingSegments(const QCPGraph* self, libqt_list /* of QCPDataRange* */ thisSegments, const libqt_list /* of QPointF* */ thisData, libqt_list /* of QCPDataRange* */ otherSegments, const libqt_list /* of QPointF* */ otherData);
    friend libqt_list /* of libqt_pair  tuple of QCPDataRange* and QCPDataRange*  */ QCPGraph_QBaseGetOverlappingSegments(const QCPGraph* self, libqt_list /* of QCPDataRange* */ thisSegments, const libqt_list /* of QPointF* */ thisData, libqt_list /* of QCPDataRange* */ otherSegments, const libqt_list /* of QPointF* */ otherData);
    friend bool QCPGraph_SegmentsIntersect(const QCPGraph* self, double aLower, double aUpper, double bLower, double bUpper, int* bPrecedence);
    friend bool QCPGraph_QBaseSegmentsIntersect(const QCPGraph* self, double aLower, double aUpper, double bLower, double bUpper, int* bPrecedence);
    friend QPointF* QCPGraph_GetFillBasePoint(const QCPGraph* self, QPointF* matchingDataPoint);
    friend QPointF* QCPGraph_QBaseGetFillBasePoint(const QCPGraph* self, QPointF* matchingDataPoint);
    friend int QCPGraph_FindIndexBelowX(const QCPGraph* self, const libqt_list /* of QPointF* */ data, double x);
    friend int QCPGraph_QBaseFindIndexBelowX(const QCPGraph* self, const libqt_list /* of QPointF* */ data, double x);
    friend int QCPGraph_FindIndexAboveX(const QCPGraph* self, const libqt_list /* of QPointF* */ data, double x);
    friend int QCPGraph_QBaseFindIndexAboveX(const QCPGraph* self, const libqt_list /* of QPointF* */ data, double x);
    friend int QCPGraph_FindIndexBelowY(const QCPGraph* self, const libqt_list /* of QPointF* */ data, double y);
    friend int QCPGraph_QBaseFindIndexBelowY(const QCPGraph* self, const libqt_list /* of QPointF* */ data, double y);
    friend int QCPGraph_FindIndexAboveY(const QCPGraph* self, const libqt_list /* of QPointF* */ data, double y);
    friend int QCPGraph_QBaseFindIndexAboveY(const QCPGraph* self, const libqt_list /* of QPointF* */ data, double y);
    friend void QCPGraph_ApplyFillAntialiasingHint(const QCPGraph* self, QCPPainter* painter);
    friend void QCPGraph_QBaseApplyFillAntialiasingHint(const QCPGraph* self, QCPPainter* painter);
    friend void QCPGraph_ApplyScattersAntialiasingHint(const QCPGraph* self, QCPPainter* painter);
    friend void QCPGraph_QBaseApplyScattersAntialiasingHint(const QCPGraph* self, QCPPainter* painter);
    friend void QCPGraph_InitializeParentPlot(QCPGraph* self, QCustomPlot* parentPlot);
    friend void QCPGraph_QBaseInitializeParentPlot(QCPGraph* self, QCustomPlot* parentPlot);
    friend void QCPGraph_SetParentLayerable(QCPGraph* self, QCPLayerable* parentLayerable);
    friend void QCPGraph_QBaseSetParentLayerable(QCPGraph* self, QCPLayerable* parentLayerable);
    friend bool QCPGraph_MoveToLayer(QCPGraph* self, QCPLayer* layer, bool prepend);
    friend bool QCPGraph_QBaseMoveToLayer(QCPGraph* self, QCPLayer* layer, bool prepend);
    friend void QCPGraph_ApplyAntialiasingHint(const QCPGraph* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPGraph_QBaseApplyAntialiasingHint(const QCPGraph* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPGraph_Sender(const QCPGraph* self);
    friend QObject* QCPGraph_QBaseSender(const QCPGraph* self);
    friend int QCPGraph_SenderSignalIndex(const QCPGraph* self);
    friend int QCPGraph_QBaseSenderSignalIndex(const QCPGraph* self);
    friend int QCPGraph_Receivers(const QCPGraph* self, const char* signal);
    friend int QCPGraph_QBaseReceivers(const QCPGraph* self, const char* signal);
    friend bool QCPGraph_IsSignalConnected(const QCPGraph* self, const QMetaMethod* signal);
    friend bool QCPGraph_QBaseIsSignalConnected(const QCPGraph* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPCurve so that we can call protected methods
class VirtualQCPCurve final : public QCPCurve {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPCurve = true;

    // Virtual class public types (including callbacks)
    using QCPCurve_Metacall_Callback = int (*)(QCPCurve*, int, int, void**);
    using QCPCurve_SelectTest_Callback = double (*)(const QCPCurve*, QPointF*, bool, QVariant*);
    using QCPCurve_GetKeyRange_Callback = QCPRange* (*)(const QCPCurve*, bool*, int);
    using QCPCurve_GetValueRange_Callback = QCPRange* (*)(const QCPCurve*, bool*, int, QCPRange*);
    using QCPCurve_Draw_Callback = void (*)(QCPCurve*, QCPPainter*);
    using QCPCurve_DrawLegendIcon_Callback = void (*)(const QCPCurve*, QCPPainter*, QRectF*);
    using QCPCurve_DrawCurveLine_Callback = void (*)(const QCPCurve*, QCPPainter*, libqt_list /* of QPointF* */);
    using QCPCurve_DrawScatterPlot_Callback = void (*)(const QCPCurve*, QCPPainter*, libqt_list /* of QPointF* */, QCPScatterStyle*);
    using QCPCurve_DataCount_Callback = int (*)();
    using QCPCurve_DataMainKey_Callback = double (*)(const QCPCurve*, int);
    using QCPCurve_DataSortKey_Callback = double (*)(const QCPCurve*, int);
    using QCPCurve_DataMainValue_Callback = double (*)(const QCPCurve*, int);
    using QCPCurve_DataValueRange_Callback = QCPRange* (*)(const QCPCurve*, int);
    using QCPCurve_DataPixelPosition_Callback = QPointF* (*)(const QCPCurve*, int);
    using QCPCurve_SortKeyIsMainKey_Callback = bool (*)();
    using QCPCurve_SelectTestRect_Callback = QCPDataSelection* (*)(const QCPCurve*, QRectF*, bool);
    using QCPCurve_FindBegin_Callback = int (*)(const QCPCurve*, double, bool);
    using QCPCurve_FindEnd_Callback = int (*)(const QCPCurve*, double, bool);
    using QCPCurve_Interface1D_Callback = QCPPlottableInterface1D* (*)();
    using QCPCurve_ClipRect_Callback = QRect* (*)();
    using QCPCurve_SelectionCategory_Callback = int (*)();
    using QCPCurve_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPCurve*, QCPPainter*);
    using QCPCurve_SelectEvent_Callback = void (*)(QCPCurve*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPCurve_DeselectEvent_Callback = void (*)(QCPCurve*, bool*);
    using QCPCurve_ParentPlotInitialized_Callback = void (*)(QCPCurve*, QCustomPlot*);
    using QCPCurve_MousePressEvent_Callback = void (*)(QCPCurve*, QMouseEvent*, QVariant*);
    using QCPCurve_MouseMoveEvent_Callback = void (*)(QCPCurve*, QMouseEvent*, QPointF*);
    using QCPCurve_MouseReleaseEvent_Callback = void (*)(QCPCurve*, QMouseEvent*, QPointF*);
    using QCPCurve_MouseDoubleClickEvent_Callback = void (*)(QCPCurve*, QMouseEvent*, QVariant*);
    using QCPCurve_WheelEvent_Callback = void (*)(QCPCurve*, QWheelEvent*);
    using QCPCurve_Event_Callback = bool (*)(QCPCurve*, QEvent*);
    using QCPCurve_EventFilter_Callback = bool (*)(QCPCurve*, QObject*, QEvent*);
    using QCPCurve_TimerEvent_Callback = void (*)(QCPCurve*, QTimerEvent*);
    using QCPCurve_ChildEvent_Callback = void (*)(QCPCurve*, QChildEvent*);
    using QCPCurve_CustomEvent_Callback = void (*)(QCPCurve*, QEvent*);
    using QCPCurve_ConnectNotify_Callback = void (*)(QCPCurve*, QMetaMethod*);
    using QCPCurve_DisconnectNotify_Callback = void (*)(QCPCurve*, QMetaMethod*);
    using QCPCurve_GetCurveLines_Callback = void (*)(const QCPCurve*, libqt_list /* of QPointF* */, QCPDataRange*, double);
    using QCPCurve_GetScatters_Callback = void (*)(const QCPCurve*, libqt_list /* of QPointF* */, QCPDataRange*, double);
    using QCPCurve_GetRegion_Callback = int (*)(const QCPCurve*, double, double, double, double, double, double);
    using QCPCurve_GetOptimizedPoint_Callback = QPointF* (*)(const QCPCurve*, int, double, double, double, double, double, double, double, double);
    using QCPCurve_GetOptimizedCornerPoints_Callback = QPointF** (*)(const QCPCurve*, int, int, double, double, double, double, double, double, double, double);
    using QCPCurve_MayTraverse_Callback = bool (*)(const QCPCurve*, int, int);
    using QCPCurve_GetTraverse_Callback = bool (*)(const QCPCurve*, double, double, double, double, double, double, double, double, QPointF*, QPointF*);
    using QCPCurve_GetTraverseCornerPoints_Callback = void (*)(const QCPCurve*, int, int, double, double, double, double, libqt_list /* of QPointF* */, libqt_list /* of QPointF* */);
    using QCPCurve_ApplyFillAntialiasingHint_Callback = void (*)(const QCPCurve*, QCPPainter*);
    using QCPCurve_ApplyScattersAntialiasingHint_Callback = void (*)(const QCPCurve*, QCPPainter*);
    using QCPCurve_InitializeParentPlot_Callback = void (*)(QCPCurve*, QCustomPlot*);
    using QCPCurve_SetParentLayerable_Callback = void (*)(QCPCurve*, QCPLayerable*);
    using QCPCurve_MoveToLayer_Callback = bool (*)(QCPCurve*, QCPLayer*, bool);
    using QCPCurve_ApplyAntialiasingHint_Callback = void (*)(const QCPCurve*, QCPPainter*, bool, int);
    using QCPCurve_Sender_Callback = QObject* (*)();
    using QCPCurve_SenderSignalIndex_Callback = int (*)();
    using QCPCurve_Receivers_Callback = int (*)(const QCPCurve*, const char*);
    using QCPCurve_IsSignalConnected_Callback = bool (*)(const QCPCurve*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPCurve_Metacall_Callback qcpcurve_metacall_callback = nullptr;
    QCPCurve_SelectTest_Callback qcpcurve_selecttest_callback = nullptr;
    QCPCurve_GetKeyRange_Callback qcpcurve_getkeyrange_callback = nullptr;
    QCPCurve_GetValueRange_Callback qcpcurve_getvaluerange_callback = nullptr;
    QCPCurve_Draw_Callback qcpcurve_draw_callback = nullptr;
    QCPCurve_DrawLegendIcon_Callback qcpcurve_drawlegendicon_callback = nullptr;
    QCPCurve_DrawCurveLine_Callback qcpcurve_drawcurveline_callback = nullptr;
    QCPCurve_DrawScatterPlot_Callback qcpcurve_drawscatterplot_callback = nullptr;
    QCPCurve_DataCount_Callback qcpcurve_datacount_callback = nullptr;
    QCPCurve_DataMainKey_Callback qcpcurve_datamainkey_callback = nullptr;
    QCPCurve_DataSortKey_Callback qcpcurve_datasortkey_callback = nullptr;
    QCPCurve_DataMainValue_Callback qcpcurve_datamainvalue_callback = nullptr;
    QCPCurve_DataValueRange_Callback qcpcurve_datavaluerange_callback = nullptr;
    QCPCurve_DataPixelPosition_Callback qcpcurve_datapixelposition_callback = nullptr;
    QCPCurve_SortKeyIsMainKey_Callback qcpcurve_sortkeyismainkey_callback = nullptr;
    QCPCurve_SelectTestRect_Callback qcpcurve_selecttestrect_callback = nullptr;
    QCPCurve_FindBegin_Callback qcpcurve_findbegin_callback = nullptr;
    QCPCurve_FindEnd_Callback qcpcurve_findend_callback = nullptr;
    QCPCurve_Interface1D_Callback qcpcurve_interface1d_callback = nullptr;
    QCPCurve_ClipRect_Callback qcpcurve_cliprect_callback = nullptr;
    QCPCurve_SelectionCategory_Callback qcpcurve_selectioncategory_callback = nullptr;
    QCPCurve_ApplyDefaultAntialiasingHint_Callback qcpcurve_applydefaultantialiasinghint_callback = nullptr;
    QCPCurve_SelectEvent_Callback qcpcurve_selectevent_callback = nullptr;
    QCPCurve_DeselectEvent_Callback qcpcurve_deselectevent_callback = nullptr;
    QCPCurve_ParentPlotInitialized_Callback qcpcurve_parentplotinitialized_callback = nullptr;
    QCPCurve_MousePressEvent_Callback qcpcurve_mousepressevent_callback = nullptr;
    QCPCurve_MouseMoveEvent_Callback qcpcurve_mousemoveevent_callback = nullptr;
    QCPCurve_MouseReleaseEvent_Callback qcpcurve_mousereleaseevent_callback = nullptr;
    QCPCurve_MouseDoubleClickEvent_Callback qcpcurve_mousedoubleclickevent_callback = nullptr;
    QCPCurve_WheelEvent_Callback qcpcurve_wheelevent_callback = nullptr;
    QCPCurve_Event_Callback qcpcurve_event_callback = nullptr;
    QCPCurve_EventFilter_Callback qcpcurve_eventfilter_callback = nullptr;
    QCPCurve_TimerEvent_Callback qcpcurve_timerevent_callback = nullptr;
    QCPCurve_ChildEvent_Callback qcpcurve_childevent_callback = nullptr;
    QCPCurve_CustomEvent_Callback qcpcurve_customevent_callback = nullptr;
    QCPCurve_ConnectNotify_Callback qcpcurve_connectnotify_callback = nullptr;
    QCPCurve_DisconnectNotify_Callback qcpcurve_disconnectnotify_callback = nullptr;
    QCPCurve_GetCurveLines_Callback qcpcurve_getcurvelines_callback = nullptr;
    QCPCurve_GetScatters_Callback qcpcurve_getscatters_callback = nullptr;
    QCPCurve_GetRegion_Callback qcpcurve_getregion_callback = nullptr;
    QCPCurve_GetOptimizedPoint_Callback qcpcurve_getoptimizedpoint_callback = nullptr;
    QCPCurve_GetOptimizedCornerPoints_Callback qcpcurve_getoptimizedcornerpoints_callback = nullptr;
    QCPCurve_MayTraverse_Callback qcpcurve_maytraverse_callback = nullptr;
    QCPCurve_GetTraverse_Callback qcpcurve_gettraverse_callback = nullptr;
    QCPCurve_GetTraverseCornerPoints_Callback qcpcurve_gettraversecornerpoints_callback = nullptr;
    QCPCurve_ApplyFillAntialiasingHint_Callback qcpcurve_applyfillantialiasinghint_callback = nullptr;
    QCPCurve_ApplyScattersAntialiasingHint_Callback qcpcurve_applyscattersantialiasinghint_callback = nullptr;
    QCPCurve_InitializeParentPlot_Callback qcpcurve_initializeparentplot_callback = nullptr;
    QCPCurve_SetParentLayerable_Callback qcpcurve_setparentlayerable_callback = nullptr;
    QCPCurve_MoveToLayer_Callback qcpcurve_movetolayer_callback = nullptr;
    QCPCurve_ApplyAntialiasingHint_Callback qcpcurve_applyantialiasinghint_callback = nullptr;
    QCPCurve_Sender_Callback qcpcurve_sender_callback = nullptr;
    QCPCurve_SenderSignalIndex_Callback qcpcurve_sendersignalindex_callback = nullptr;
    QCPCurve_Receivers_Callback qcpcurve_receivers_callback = nullptr;
    QCPCurve_IsSignalConnected_Callback qcpcurve_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpcurve_metacall_isbase = false;
    mutable bool qcpcurve_selecttest_isbase = false;
    mutable bool qcpcurve_getkeyrange_isbase = false;
    mutable bool qcpcurve_getvaluerange_isbase = false;
    mutable bool qcpcurve_draw_isbase = false;
    mutable bool qcpcurve_drawlegendicon_isbase = false;
    mutable bool qcpcurve_drawcurveline_isbase = false;
    mutable bool qcpcurve_drawscatterplot_isbase = false;
    mutable bool qcpcurve_datacount_isbase = false;
    mutable bool qcpcurve_datamainkey_isbase = false;
    mutable bool qcpcurve_datasortkey_isbase = false;
    mutable bool qcpcurve_datamainvalue_isbase = false;
    mutable bool qcpcurve_datavaluerange_isbase = false;
    mutable bool qcpcurve_datapixelposition_isbase = false;
    mutable bool qcpcurve_sortkeyismainkey_isbase = false;
    mutable bool qcpcurve_selecttestrect_isbase = false;
    mutable bool qcpcurve_findbegin_isbase = false;
    mutable bool qcpcurve_findend_isbase = false;
    mutable bool qcpcurve_interface1d_isbase = false;
    mutable bool qcpcurve_cliprect_isbase = false;
    mutable bool qcpcurve_selectioncategory_isbase = false;
    mutable bool qcpcurve_applydefaultantialiasinghint_isbase = false;
    mutable bool qcpcurve_selectevent_isbase = false;
    mutable bool qcpcurve_deselectevent_isbase = false;
    mutable bool qcpcurve_parentplotinitialized_isbase = false;
    mutable bool qcpcurve_mousepressevent_isbase = false;
    mutable bool qcpcurve_mousemoveevent_isbase = false;
    mutable bool qcpcurve_mousereleaseevent_isbase = false;
    mutable bool qcpcurve_mousedoubleclickevent_isbase = false;
    mutable bool qcpcurve_wheelevent_isbase = false;
    mutable bool qcpcurve_event_isbase = false;
    mutable bool qcpcurve_eventfilter_isbase = false;
    mutable bool qcpcurve_timerevent_isbase = false;
    mutable bool qcpcurve_childevent_isbase = false;
    mutable bool qcpcurve_customevent_isbase = false;
    mutable bool qcpcurve_connectnotify_isbase = false;
    mutable bool qcpcurve_disconnectnotify_isbase = false;
    mutable bool qcpcurve_getcurvelines_isbase = false;
    mutable bool qcpcurve_getscatters_isbase = false;
    mutable bool qcpcurve_getregion_isbase = false;
    mutable bool qcpcurve_getoptimizedpoint_isbase = false;
    mutable bool qcpcurve_getoptimizedcornerpoints_isbase = false;
    mutable bool qcpcurve_maytraverse_isbase = false;
    mutable bool qcpcurve_gettraverse_isbase = false;
    mutable bool qcpcurve_gettraversecornerpoints_isbase = false;
    mutable bool qcpcurve_applyfillantialiasinghint_isbase = false;
    mutable bool qcpcurve_applyscattersantialiasinghint_isbase = false;
    mutable bool qcpcurve_initializeparentplot_isbase = false;
    mutable bool qcpcurve_setparentlayerable_isbase = false;
    mutable bool qcpcurve_movetolayer_isbase = false;
    mutable bool qcpcurve_applyantialiasinghint_isbase = false;
    mutable bool qcpcurve_sender_isbase = false;
    mutable bool qcpcurve_sendersignalindex_isbase = false;
    mutable bool qcpcurve_receivers_isbase = false;
    mutable bool qcpcurve_issignalconnected_isbase = false;

  public:
    VirtualQCPCurve(QCPAxis* keyAxis, QCPAxis* valueAxis) : QCPCurve(keyAxis, valueAxis) {};

    ~VirtualQCPCurve() {
        qcpcurve_metacall_callback = nullptr;
        qcpcurve_selecttest_callback = nullptr;
        qcpcurve_getkeyrange_callback = nullptr;
        qcpcurve_getvaluerange_callback = nullptr;
        qcpcurve_draw_callback = nullptr;
        qcpcurve_drawlegendicon_callback = nullptr;
        qcpcurve_drawcurveline_callback = nullptr;
        qcpcurve_drawscatterplot_callback = nullptr;
        qcpcurve_datacount_callback = nullptr;
        qcpcurve_datamainkey_callback = nullptr;
        qcpcurve_datasortkey_callback = nullptr;
        qcpcurve_datamainvalue_callback = nullptr;
        qcpcurve_datavaluerange_callback = nullptr;
        qcpcurve_datapixelposition_callback = nullptr;
        qcpcurve_sortkeyismainkey_callback = nullptr;
        qcpcurve_selecttestrect_callback = nullptr;
        qcpcurve_findbegin_callback = nullptr;
        qcpcurve_findend_callback = nullptr;
        qcpcurve_interface1d_callback = nullptr;
        qcpcurve_cliprect_callback = nullptr;
        qcpcurve_selectioncategory_callback = nullptr;
        qcpcurve_applydefaultantialiasinghint_callback = nullptr;
        qcpcurve_selectevent_callback = nullptr;
        qcpcurve_deselectevent_callback = nullptr;
        qcpcurve_parentplotinitialized_callback = nullptr;
        qcpcurve_mousepressevent_callback = nullptr;
        qcpcurve_mousemoveevent_callback = nullptr;
        qcpcurve_mousereleaseevent_callback = nullptr;
        qcpcurve_mousedoubleclickevent_callback = nullptr;
        qcpcurve_wheelevent_callback = nullptr;
        qcpcurve_event_callback = nullptr;
        qcpcurve_eventfilter_callback = nullptr;
        qcpcurve_timerevent_callback = nullptr;
        qcpcurve_childevent_callback = nullptr;
        qcpcurve_customevent_callback = nullptr;
        qcpcurve_connectnotify_callback = nullptr;
        qcpcurve_disconnectnotify_callback = nullptr;
        qcpcurve_getcurvelines_callback = nullptr;
        qcpcurve_getscatters_callback = nullptr;
        qcpcurve_getregion_callback = nullptr;
        qcpcurve_getoptimizedpoint_callback = nullptr;
        qcpcurve_getoptimizedcornerpoints_callback = nullptr;
        qcpcurve_maytraverse_callback = nullptr;
        qcpcurve_gettraverse_callback = nullptr;
        qcpcurve_gettraversecornerpoints_callback = nullptr;
        qcpcurve_applyfillantialiasinghint_callback = nullptr;
        qcpcurve_applyscattersantialiasinghint_callback = nullptr;
        qcpcurve_initializeparentplot_callback = nullptr;
        qcpcurve_setparentlayerable_callback = nullptr;
        qcpcurve_movetolayer_callback = nullptr;
        qcpcurve_applyantialiasinghint_callback = nullptr;
        qcpcurve_sender_callback = nullptr;
        qcpcurve_sendersignalindex_callback = nullptr;
        qcpcurve_receivers_callback = nullptr;
        qcpcurve_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPCurve_Metacall_Callback(QCPCurve_Metacall_Callback cb) { qcpcurve_metacall_callback = cb; }
    inline void setQCPCurve_SelectTest_Callback(QCPCurve_SelectTest_Callback cb) { qcpcurve_selecttest_callback = cb; }
    inline void setQCPCurve_GetKeyRange_Callback(QCPCurve_GetKeyRange_Callback cb) { qcpcurve_getkeyrange_callback = cb; }
    inline void setQCPCurve_GetValueRange_Callback(QCPCurve_GetValueRange_Callback cb) { qcpcurve_getvaluerange_callback = cb; }
    inline void setQCPCurve_Draw_Callback(QCPCurve_Draw_Callback cb) { qcpcurve_draw_callback = cb; }
    inline void setQCPCurve_DrawLegendIcon_Callback(QCPCurve_DrawLegendIcon_Callback cb) { qcpcurve_drawlegendicon_callback = cb; }
    inline void setQCPCurve_DrawCurveLine_Callback(QCPCurve_DrawCurveLine_Callback cb) { qcpcurve_drawcurveline_callback = cb; }
    inline void setQCPCurve_DrawScatterPlot_Callback(QCPCurve_DrawScatterPlot_Callback cb) { qcpcurve_drawscatterplot_callback = cb; }
    inline void setQCPCurve_DataCount_Callback(QCPCurve_DataCount_Callback cb) { qcpcurve_datacount_callback = cb; }
    inline void setQCPCurve_DataMainKey_Callback(QCPCurve_DataMainKey_Callback cb) { qcpcurve_datamainkey_callback = cb; }
    inline void setQCPCurve_DataSortKey_Callback(QCPCurve_DataSortKey_Callback cb) { qcpcurve_datasortkey_callback = cb; }
    inline void setQCPCurve_DataMainValue_Callback(QCPCurve_DataMainValue_Callback cb) { qcpcurve_datamainvalue_callback = cb; }
    inline void setQCPCurve_DataValueRange_Callback(QCPCurve_DataValueRange_Callback cb) { qcpcurve_datavaluerange_callback = cb; }
    inline void setQCPCurve_DataPixelPosition_Callback(QCPCurve_DataPixelPosition_Callback cb) { qcpcurve_datapixelposition_callback = cb; }
    inline void setQCPCurve_SortKeyIsMainKey_Callback(QCPCurve_SortKeyIsMainKey_Callback cb) { qcpcurve_sortkeyismainkey_callback = cb; }
    inline void setQCPCurve_SelectTestRect_Callback(QCPCurve_SelectTestRect_Callback cb) { qcpcurve_selecttestrect_callback = cb; }
    inline void setQCPCurve_FindBegin_Callback(QCPCurve_FindBegin_Callback cb) { qcpcurve_findbegin_callback = cb; }
    inline void setQCPCurve_FindEnd_Callback(QCPCurve_FindEnd_Callback cb) { qcpcurve_findend_callback = cb; }
    inline void setQCPCurve_Interface1D_Callback(QCPCurve_Interface1D_Callback cb) { qcpcurve_interface1d_callback = cb; }
    inline void setQCPCurve_ClipRect_Callback(QCPCurve_ClipRect_Callback cb) { qcpcurve_cliprect_callback = cb; }
    inline void setQCPCurve_SelectionCategory_Callback(QCPCurve_SelectionCategory_Callback cb) { qcpcurve_selectioncategory_callback = cb; }
    inline void setQCPCurve_ApplyDefaultAntialiasingHint_Callback(QCPCurve_ApplyDefaultAntialiasingHint_Callback cb) { qcpcurve_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPCurve_SelectEvent_Callback(QCPCurve_SelectEvent_Callback cb) { qcpcurve_selectevent_callback = cb; }
    inline void setQCPCurve_DeselectEvent_Callback(QCPCurve_DeselectEvent_Callback cb) { qcpcurve_deselectevent_callback = cb; }
    inline void setQCPCurve_ParentPlotInitialized_Callback(QCPCurve_ParentPlotInitialized_Callback cb) { qcpcurve_parentplotinitialized_callback = cb; }
    inline void setQCPCurve_MousePressEvent_Callback(QCPCurve_MousePressEvent_Callback cb) { qcpcurve_mousepressevent_callback = cb; }
    inline void setQCPCurve_MouseMoveEvent_Callback(QCPCurve_MouseMoveEvent_Callback cb) { qcpcurve_mousemoveevent_callback = cb; }
    inline void setQCPCurve_MouseReleaseEvent_Callback(QCPCurve_MouseReleaseEvent_Callback cb) { qcpcurve_mousereleaseevent_callback = cb; }
    inline void setQCPCurve_MouseDoubleClickEvent_Callback(QCPCurve_MouseDoubleClickEvent_Callback cb) { qcpcurve_mousedoubleclickevent_callback = cb; }
    inline void setQCPCurve_WheelEvent_Callback(QCPCurve_WheelEvent_Callback cb) { qcpcurve_wheelevent_callback = cb; }
    inline void setQCPCurve_Event_Callback(QCPCurve_Event_Callback cb) { qcpcurve_event_callback = cb; }
    inline void setQCPCurve_EventFilter_Callback(QCPCurve_EventFilter_Callback cb) { qcpcurve_eventfilter_callback = cb; }
    inline void setQCPCurve_TimerEvent_Callback(QCPCurve_TimerEvent_Callback cb) { qcpcurve_timerevent_callback = cb; }
    inline void setQCPCurve_ChildEvent_Callback(QCPCurve_ChildEvent_Callback cb) { qcpcurve_childevent_callback = cb; }
    inline void setQCPCurve_CustomEvent_Callback(QCPCurve_CustomEvent_Callback cb) { qcpcurve_customevent_callback = cb; }
    inline void setQCPCurve_ConnectNotify_Callback(QCPCurve_ConnectNotify_Callback cb) { qcpcurve_connectnotify_callback = cb; }
    inline void setQCPCurve_DisconnectNotify_Callback(QCPCurve_DisconnectNotify_Callback cb) { qcpcurve_disconnectnotify_callback = cb; }
    inline void setQCPCurve_GetCurveLines_Callback(QCPCurve_GetCurveLines_Callback cb) { qcpcurve_getcurvelines_callback = cb; }
    inline void setQCPCurve_GetScatters_Callback(QCPCurve_GetScatters_Callback cb) { qcpcurve_getscatters_callback = cb; }
    inline void setQCPCurve_GetRegion_Callback(QCPCurve_GetRegion_Callback cb) { qcpcurve_getregion_callback = cb; }
    inline void setQCPCurve_GetOptimizedPoint_Callback(QCPCurve_GetOptimizedPoint_Callback cb) { qcpcurve_getoptimizedpoint_callback = cb; }
    inline void setQCPCurve_GetOptimizedCornerPoints_Callback(QCPCurve_GetOptimizedCornerPoints_Callback cb) { qcpcurve_getoptimizedcornerpoints_callback = cb; }
    inline void setQCPCurve_MayTraverse_Callback(QCPCurve_MayTraverse_Callback cb) { qcpcurve_maytraverse_callback = cb; }
    inline void setQCPCurve_GetTraverse_Callback(QCPCurve_GetTraverse_Callback cb) { qcpcurve_gettraverse_callback = cb; }
    inline void setQCPCurve_GetTraverseCornerPoints_Callback(QCPCurve_GetTraverseCornerPoints_Callback cb) { qcpcurve_gettraversecornerpoints_callback = cb; }
    inline void setQCPCurve_ApplyFillAntialiasingHint_Callback(QCPCurve_ApplyFillAntialiasingHint_Callback cb) { qcpcurve_applyfillantialiasinghint_callback = cb; }
    inline void setQCPCurve_ApplyScattersAntialiasingHint_Callback(QCPCurve_ApplyScattersAntialiasingHint_Callback cb) { qcpcurve_applyscattersantialiasinghint_callback = cb; }
    inline void setQCPCurve_InitializeParentPlot_Callback(QCPCurve_InitializeParentPlot_Callback cb) { qcpcurve_initializeparentplot_callback = cb; }
    inline void setQCPCurve_SetParentLayerable_Callback(QCPCurve_SetParentLayerable_Callback cb) { qcpcurve_setparentlayerable_callback = cb; }
    inline void setQCPCurve_MoveToLayer_Callback(QCPCurve_MoveToLayer_Callback cb) { qcpcurve_movetolayer_callback = cb; }
    inline void setQCPCurve_ApplyAntialiasingHint_Callback(QCPCurve_ApplyAntialiasingHint_Callback cb) { qcpcurve_applyantialiasinghint_callback = cb; }
    inline void setQCPCurve_Sender_Callback(QCPCurve_Sender_Callback cb) { qcpcurve_sender_callback = cb; }
    inline void setQCPCurve_SenderSignalIndex_Callback(QCPCurve_SenderSignalIndex_Callback cb) { qcpcurve_sendersignalindex_callback = cb; }
    inline void setQCPCurve_Receivers_Callback(QCPCurve_Receivers_Callback cb) { qcpcurve_receivers_callback = cb; }
    inline void setQCPCurve_IsSignalConnected_Callback(QCPCurve_IsSignalConnected_Callback cb) { qcpcurve_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPCurve_Metacall_IsBase(bool value) const { qcpcurve_metacall_isbase = value; }
    inline void setQCPCurve_SelectTest_IsBase(bool value) const { qcpcurve_selecttest_isbase = value; }
    inline void setQCPCurve_GetKeyRange_IsBase(bool value) const { qcpcurve_getkeyrange_isbase = value; }
    inline void setQCPCurve_GetValueRange_IsBase(bool value) const { qcpcurve_getvaluerange_isbase = value; }
    inline void setQCPCurve_Draw_IsBase(bool value) const { qcpcurve_draw_isbase = value; }
    inline void setQCPCurve_DrawLegendIcon_IsBase(bool value) const { qcpcurve_drawlegendicon_isbase = value; }
    inline void setQCPCurve_DrawCurveLine_IsBase(bool value) const { qcpcurve_drawcurveline_isbase = value; }
    inline void setQCPCurve_DrawScatterPlot_IsBase(bool value) const { qcpcurve_drawscatterplot_isbase = value; }
    inline void setQCPCurve_DataCount_IsBase(bool value) const { qcpcurve_datacount_isbase = value; }
    inline void setQCPCurve_DataMainKey_IsBase(bool value) const { qcpcurve_datamainkey_isbase = value; }
    inline void setQCPCurve_DataSortKey_IsBase(bool value) const { qcpcurve_datasortkey_isbase = value; }
    inline void setQCPCurve_DataMainValue_IsBase(bool value) const { qcpcurve_datamainvalue_isbase = value; }
    inline void setQCPCurve_DataValueRange_IsBase(bool value) const { qcpcurve_datavaluerange_isbase = value; }
    inline void setQCPCurve_DataPixelPosition_IsBase(bool value) const { qcpcurve_datapixelposition_isbase = value; }
    inline void setQCPCurve_SortKeyIsMainKey_IsBase(bool value) const { qcpcurve_sortkeyismainkey_isbase = value; }
    inline void setQCPCurve_SelectTestRect_IsBase(bool value) const { qcpcurve_selecttestrect_isbase = value; }
    inline void setQCPCurve_FindBegin_IsBase(bool value) const { qcpcurve_findbegin_isbase = value; }
    inline void setQCPCurve_FindEnd_IsBase(bool value) const { qcpcurve_findend_isbase = value; }
    inline void setQCPCurve_Interface1D_IsBase(bool value) const { qcpcurve_interface1d_isbase = value; }
    inline void setQCPCurve_ClipRect_IsBase(bool value) const { qcpcurve_cliprect_isbase = value; }
    inline void setQCPCurve_SelectionCategory_IsBase(bool value) const { qcpcurve_selectioncategory_isbase = value; }
    inline void setQCPCurve_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcpcurve_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPCurve_SelectEvent_IsBase(bool value) const { qcpcurve_selectevent_isbase = value; }
    inline void setQCPCurve_DeselectEvent_IsBase(bool value) const { qcpcurve_deselectevent_isbase = value; }
    inline void setQCPCurve_ParentPlotInitialized_IsBase(bool value) const { qcpcurve_parentplotinitialized_isbase = value; }
    inline void setQCPCurve_MousePressEvent_IsBase(bool value) const { qcpcurve_mousepressevent_isbase = value; }
    inline void setQCPCurve_MouseMoveEvent_IsBase(bool value) const { qcpcurve_mousemoveevent_isbase = value; }
    inline void setQCPCurve_MouseReleaseEvent_IsBase(bool value) const { qcpcurve_mousereleaseevent_isbase = value; }
    inline void setQCPCurve_MouseDoubleClickEvent_IsBase(bool value) const { qcpcurve_mousedoubleclickevent_isbase = value; }
    inline void setQCPCurve_WheelEvent_IsBase(bool value) const { qcpcurve_wheelevent_isbase = value; }
    inline void setQCPCurve_Event_IsBase(bool value) const { qcpcurve_event_isbase = value; }
    inline void setQCPCurve_EventFilter_IsBase(bool value) const { qcpcurve_eventfilter_isbase = value; }
    inline void setQCPCurve_TimerEvent_IsBase(bool value) const { qcpcurve_timerevent_isbase = value; }
    inline void setQCPCurve_ChildEvent_IsBase(bool value) const { qcpcurve_childevent_isbase = value; }
    inline void setQCPCurve_CustomEvent_IsBase(bool value) const { qcpcurve_customevent_isbase = value; }
    inline void setQCPCurve_ConnectNotify_IsBase(bool value) const { qcpcurve_connectnotify_isbase = value; }
    inline void setQCPCurve_DisconnectNotify_IsBase(bool value) const { qcpcurve_disconnectnotify_isbase = value; }
    inline void setQCPCurve_GetCurveLines_IsBase(bool value) const { qcpcurve_getcurvelines_isbase = value; }
    inline void setQCPCurve_GetScatters_IsBase(bool value) const { qcpcurve_getscatters_isbase = value; }
    inline void setQCPCurve_GetRegion_IsBase(bool value) const { qcpcurve_getregion_isbase = value; }
    inline void setQCPCurve_GetOptimizedPoint_IsBase(bool value) const { qcpcurve_getoptimizedpoint_isbase = value; }
    inline void setQCPCurve_GetOptimizedCornerPoints_IsBase(bool value) const { qcpcurve_getoptimizedcornerpoints_isbase = value; }
    inline void setQCPCurve_MayTraverse_IsBase(bool value) const { qcpcurve_maytraverse_isbase = value; }
    inline void setQCPCurve_GetTraverse_IsBase(bool value) const { qcpcurve_gettraverse_isbase = value; }
    inline void setQCPCurve_GetTraverseCornerPoints_IsBase(bool value) const { qcpcurve_gettraversecornerpoints_isbase = value; }
    inline void setQCPCurve_ApplyFillAntialiasingHint_IsBase(bool value) const { qcpcurve_applyfillantialiasinghint_isbase = value; }
    inline void setQCPCurve_ApplyScattersAntialiasingHint_IsBase(bool value) const { qcpcurve_applyscattersantialiasinghint_isbase = value; }
    inline void setQCPCurve_InitializeParentPlot_IsBase(bool value) const { qcpcurve_initializeparentplot_isbase = value; }
    inline void setQCPCurve_SetParentLayerable_IsBase(bool value) const { qcpcurve_setparentlayerable_isbase = value; }
    inline void setQCPCurve_MoveToLayer_IsBase(bool value) const { qcpcurve_movetolayer_isbase = value; }
    inline void setQCPCurve_ApplyAntialiasingHint_IsBase(bool value) const { qcpcurve_applyantialiasinghint_isbase = value; }
    inline void setQCPCurve_Sender_IsBase(bool value) const { qcpcurve_sender_isbase = value; }
    inline void setQCPCurve_SenderSignalIndex_IsBase(bool value) const { qcpcurve_sendersignalindex_isbase = value; }
    inline void setQCPCurve_Receivers_IsBase(bool value) const { qcpcurve_receivers_isbase = value; }
    inline void setQCPCurve_IsSignalConnected_IsBase(bool value) const { qcpcurve_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpcurve_metacall_isbase) {
            qcpcurve_metacall_isbase = false;
            return QCPCurve::qt_metacall(param1, param2, param3);
        } else if (qcpcurve_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpcurve_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPCurve::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcpcurve_selecttest_isbase) {
            qcpcurve_selecttest_isbase = false;
            return QCPCurve::selectTest(pos, onlySelectable, details);
        } else if (qcpcurve_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcpcurve_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPCurve::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPRange getKeyRange(bool& foundRange, QCP::SignDomain inSignDomain) const override {
        if (qcpcurve_getkeyrange_isbase) {
            qcpcurve_getkeyrange_isbase = false;
            return QCPCurve::getKeyRange(foundRange, inSignDomain);
        } else if (qcpcurve_getkeyrange_callback != nullptr) {
            bool* cbval1 = &foundRange;
            int cbval2 = static_cast<int>(inSignDomain);

            QCPRange* callback_ret = qcpcurve_getkeyrange_callback(this, cbval1, cbval2);
            return *callback_ret;
        } else {
            return QCPCurve::getKeyRange(foundRange, inSignDomain);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPRange getValueRange(bool& foundRange, QCP::SignDomain inSignDomain, const QCPRange& inKeyRange) const override {
        if (qcpcurve_getvaluerange_isbase) {
            qcpcurve_getvaluerange_isbase = false;
            return QCPCurve::getValueRange(foundRange, inSignDomain, inKeyRange);
        } else if (qcpcurve_getvaluerange_callback != nullptr) {
            bool* cbval1 = &foundRange;
            int cbval2 = static_cast<int>(inSignDomain);
            const QCPRange& inKeyRange_ret = inKeyRange;
            // Cast returned reference into pointer
            QCPRange* cbval3 = const_cast<QCPRange*>(&inKeyRange_ret);

            QCPRange* callback_ret = qcpcurve_getvaluerange_callback(this, cbval1, cbval2, cbval3);
            return *callback_ret;
        } else {
            return QCPCurve::getValueRange(foundRange, inSignDomain, inKeyRange);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcpcurve_draw_isbase) {
            qcpcurve_draw_isbase = false;
            QCPCurve::draw(painter);
        } else if (qcpcurve_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpcurve_draw_callback(this, cbval1);
        } else {
            QCPCurve::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void drawLegendIcon(QCPPainter* painter, const QRectF& rect) const override {
        if (qcpcurve_drawlegendicon_isbase) {
            qcpcurve_drawlegendicon_isbase = false;
            QCPCurve::drawLegendIcon(painter, rect);
        } else if (qcpcurve_drawlegendicon_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval2 = const_cast<QRectF*>(&rect_ret);

            qcpcurve_drawlegendicon_callback(this, cbval1, cbval2);
        } else {
            QCPCurve::drawLegendIcon(painter, rect);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void drawCurveLine(QCPPainter* painter, const QVector<QPointF>& lines) const override {
        if (qcpcurve_drawcurveline_isbase) {
            qcpcurve_drawcurveline_isbase = false;
            QCPCurve::drawCurveLine(painter, lines);
        } else if (qcpcurve_drawcurveline_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            const QVector<QPointF>& lines_ret = lines;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** lines_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (lines_ret.size() + 1)));
            for (qsizetype i = 0; i < lines_ret.size(); ++i) {
                lines_arr[i] = new QPointF(lines_ret[i]);
            }
            libqt_list lines_out;
            lines_out.len = lines_ret.size();
            lines_out.data = static_cast<void*>(lines_arr);
            libqt_list /* of QPointF* */ cbval2 = lines_out;

            qcpcurve_drawcurveline_callback(this, cbval1, cbval2);
        } else {
            QCPCurve::drawCurveLine(painter, lines);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void drawScatterPlot(QCPPainter* painter, const QVector<QPointF>& points, const QCPScatterStyle& style) const override {
        if (qcpcurve_drawscatterplot_isbase) {
            qcpcurve_drawscatterplot_isbase = false;
            QCPCurve::drawScatterPlot(painter, points, style);
        } else if (qcpcurve_drawscatterplot_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            const QVector<QPointF>& points_ret = points;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** points_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (points_ret.size() + 1)));
            for (qsizetype i = 0; i < points_ret.size(); ++i) {
                points_arr[i] = new QPointF(points_ret[i]);
            }
            libqt_list points_out;
            points_out.len = points_ret.size();
            points_out.data = static_cast<void*>(points_arr);
            libqt_list /* of QPointF* */ cbval2 = points_out;
            const QCPScatterStyle& style_ret = style;
            // Cast returned reference into pointer
            QCPScatterStyle* cbval3 = const_cast<QCPScatterStyle*>(&style_ret);

            qcpcurve_drawscatterplot_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPCurve::drawScatterPlot(painter, points, style);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int dataCount() const override {
        if (qcpcurve_datacount_callback != nullptr) {
            int callback_ret = qcpcurve_datacount_callback();
            return static_cast<int>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double dataMainKey(int index) const override {
        if (qcpcurve_datamainkey_callback != nullptr) {
            int cbval1 = index;

            double callback_ret = qcpcurve_datamainkey_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double dataSortKey(int index) const override {
        if (qcpcurve_datasortkey_callback != nullptr) {
            int cbval1 = index;

            double callback_ret = qcpcurve_datasortkey_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double dataMainValue(int index) const override {
        if (qcpcurve_datamainvalue_callback != nullptr) {
            int cbval1 = index;

            double callback_ret = qcpcurve_datamainvalue_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPRange dataValueRange(int index) const override {
        if (qcpcurve_datavaluerange_callback != nullptr) {
            int cbval1 = index;

            QCPRange* callback_ret = qcpcurve_datavaluerange_callback(this, cbval1);
            return *callback_ret;
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QPointF dataPixelPosition(int index) const override {
        if (qcpcurve_datapixelposition_callback != nullptr) {
            int cbval1 = index;

            QPointF* callback_ret = qcpcurve_datapixelposition_callback(this, cbval1);
            return *callback_ret;
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool sortKeyIsMainKey() const override {
        if (qcpcurve_sortkeyismainkey_callback != nullptr) {
            bool callback_ret = qcpcurve_sortkeyismainkey_callback();
            return callback_ret;
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPDataSelection selectTestRect(const QRectF& rect, bool onlySelectable) const override {
        if (qcpcurve_selecttestrect_callback != nullptr) {
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval1 = const_cast<QRectF*>(&rect_ret);
            bool cbval2 = onlySelectable;

            QCPDataSelection* callback_ret = qcpcurve_selecttestrect_callback(this, cbval1, cbval2);
            return *callback_ret;
        } else {
            return QCPDataSelection();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int findBegin(double sortKey, bool expandedRange) const override {
        if (qcpcurve_findbegin_callback != nullptr) {
            double cbval1 = sortKey;
            bool cbval2 = expandedRange;

            int callback_ret = qcpcurve_findbegin_callback(this, cbval1, cbval2);
            return static_cast<int>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int findEnd(double sortKey, bool expandedRange) const override {
        if (qcpcurve_findend_callback != nullptr) {
            double cbval1 = sortKey;
            bool cbval2 = expandedRange;

            int callback_ret = qcpcurve_findend_callback(this, cbval1, cbval2);
            return static_cast<int>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPPlottableInterface1D* interface1D() override {
        if (qcpcurve_interface1d_isbase) {
            qcpcurve_interface1d_isbase = false;
            return QCPCurve::interface1D();
        } else if (qcpcurve_interface1d_callback != nullptr) {
            QCPPlottableInterface1D* callback_ret = qcpcurve_interface1d_callback();
            return callback_ret;
        } else {
            return QCPCurve::interface1D();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcpcurve_cliprect_isbase) {
            qcpcurve_cliprect_isbase = false;
            return QCPCurve::clipRect();
        } else if (qcpcurve_cliprect_callback != nullptr) {
            QRect* callback_ret = qcpcurve_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPCurve::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcpcurve_selectioncategory_isbase) {
            qcpcurve_selectioncategory_isbase = false;
            return QCPCurve::selectionCategory();
        } else if (qcpcurve_selectioncategory_callback != nullptr) {
            int callback_ret = qcpcurve_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPCurve::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcpcurve_applydefaultantialiasinghint_isbase) {
            qcpcurve_applydefaultantialiasinghint_isbase = false;
            QCPCurve::applyDefaultAntialiasingHint(painter);
        } else if (qcpcurve_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpcurve_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPCurve::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcpcurve_selectevent_isbase) {
            qcpcurve_selectevent_isbase = false;
            QCPCurve::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcpcurve_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcpcurve_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPCurve::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcpcurve_deselectevent_isbase) {
            qcpcurve_deselectevent_isbase = false;
            QCPCurve::deselectEvent(selectionStateChanged);
        } else if (qcpcurve_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcpcurve_deselectevent_callback(this, cbval1);
        } else {
            QCPCurve::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcpcurve_parentplotinitialized_isbase) {
            qcpcurve_parentplotinitialized_isbase = false;
            QCPCurve::parentPlotInitialized(parentPlot);
        } else if (qcpcurve_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpcurve_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPCurve::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpcurve_mousepressevent_isbase) {
            qcpcurve_mousepressevent_isbase = false;
            QCPCurve::mousePressEvent(event, details);
        } else if (qcpcurve_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpcurve_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPCurve::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpcurve_mousemoveevent_isbase) {
            qcpcurve_mousemoveevent_isbase = false;
            QCPCurve::mouseMoveEvent(event, startPos);
        } else if (qcpcurve_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpcurve_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPCurve::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpcurve_mousereleaseevent_isbase) {
            qcpcurve_mousereleaseevent_isbase = false;
            QCPCurve::mouseReleaseEvent(event, startPos);
        } else if (qcpcurve_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpcurve_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPCurve::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpcurve_mousedoubleclickevent_isbase) {
            qcpcurve_mousedoubleclickevent_isbase = false;
            QCPCurve::mouseDoubleClickEvent(event, details);
        } else if (qcpcurve_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpcurve_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPCurve::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcpcurve_wheelevent_isbase) {
            qcpcurve_wheelevent_isbase = false;
            QCPCurve::wheelEvent(event);
        } else if (qcpcurve_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcpcurve_wheelevent_callback(this, cbval1);
        } else {
            QCPCurve::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpcurve_event_isbase) {
            qcpcurve_event_isbase = false;
            return QCPCurve::event(event);
        } else if (qcpcurve_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpcurve_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPCurve::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpcurve_eventfilter_isbase) {
            qcpcurve_eventfilter_isbase = false;
            return QCPCurve::eventFilter(watched, event);
        } else if (qcpcurve_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpcurve_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPCurve::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpcurve_timerevent_isbase) {
            qcpcurve_timerevent_isbase = false;
            QCPCurve::timerEvent(event);
        } else if (qcpcurve_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpcurve_timerevent_callback(this, cbval1);
        } else {
            QCPCurve::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpcurve_childevent_isbase) {
            qcpcurve_childevent_isbase = false;
            QCPCurve::childEvent(event);
        } else if (qcpcurve_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpcurve_childevent_callback(this, cbval1);
        } else {
            QCPCurve::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpcurve_customevent_isbase) {
            qcpcurve_customevent_isbase = false;
            QCPCurve::customEvent(event);
        } else if (qcpcurve_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpcurve_customevent_callback(this, cbval1);
        } else {
            QCPCurve::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpcurve_connectnotify_isbase) {
            qcpcurve_connectnotify_isbase = false;
            QCPCurve::connectNotify(signal);
        } else if (qcpcurve_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpcurve_connectnotify_callback(this, cbval1);
        } else {
            QCPCurve::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpcurve_disconnectnotify_isbase) {
            qcpcurve_disconnectnotify_isbase = false;
            QCPCurve::disconnectNotify(signal);
        } else if (qcpcurve_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpcurve_disconnectnotify_callback(this, cbval1);
        } else {
            QCPCurve::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    void getCurveLines(QVector<QPointF>* lines, const QCPDataRange& dataRange, double penWidth) const {
        if (qcpcurve_getcurvelines_isbase) {
            qcpcurve_getcurvelines_isbase = false;
            QCPCurve::getCurveLines(lines, dataRange, penWidth);
        } else if (qcpcurve_getcurvelines_callback != nullptr) {
            QVector<QPointF>* lines_ret = lines;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** lines_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (lines_ret->size() + 1)));
            for (qsizetype i = 0; i < lines_ret->size(); ++i) {
                lines_arr[i] = new QPointF((*lines_ret)[i]);
            }
            libqt_list lines_out;
            lines_out.len = lines_ret->size();
            lines_out.data = static_cast<void*>(lines_arr);
            libqt_list /* of QPointF* */ cbval1 = lines_out;
            const QCPDataRange& dataRange_ret = dataRange;
            // Cast returned reference into pointer
            QCPDataRange* cbval2 = const_cast<QCPDataRange*>(&dataRange_ret);
            double cbval3 = penWidth;

            qcpcurve_getcurvelines_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPCurve::getCurveLines(lines, dataRange, penWidth);
        }
    }

    // Virtual method for C ABI access and custom callback
    void getScatters(QVector<QPointF>* scatters, const QCPDataRange& dataRange, double scatterWidth) const {
        if (qcpcurve_getscatters_isbase) {
            qcpcurve_getscatters_isbase = false;
            QCPCurve::getScatters(scatters, dataRange, scatterWidth);
        } else if (qcpcurve_getscatters_callback != nullptr) {
            QVector<QPointF>* scatters_ret = scatters;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** scatters_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (scatters_ret->size() + 1)));
            for (qsizetype i = 0; i < scatters_ret->size(); ++i) {
                scatters_arr[i] = new QPointF((*scatters_ret)[i]);
            }
            libqt_list scatters_out;
            scatters_out.len = scatters_ret->size();
            scatters_out.data = static_cast<void*>(scatters_arr);
            libqt_list /* of QPointF* */ cbval1 = scatters_out;
            const QCPDataRange& dataRange_ret = dataRange;
            // Cast returned reference into pointer
            QCPDataRange* cbval2 = const_cast<QCPDataRange*>(&dataRange_ret);
            double cbval3 = scatterWidth;

            qcpcurve_getscatters_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPCurve::getScatters(scatters, dataRange, scatterWidth);
        }
    }

    // Virtual method for C ABI access and custom callback
    int getRegion(double key, double value, double keyMin, double valueMax, double keyMax, double valueMin) const {
        if (qcpcurve_getregion_isbase) {
            qcpcurve_getregion_isbase = false;
            return QCPCurve::getRegion(key, value, keyMin, valueMax, keyMax, valueMin);
        } else if (qcpcurve_getregion_callback != nullptr) {
            double cbval1 = key;
            double cbval2 = value;
            double cbval3 = keyMin;
            double cbval4 = valueMax;
            double cbval5 = keyMax;
            double cbval6 = valueMin;

            int callback_ret = qcpcurve_getregion_callback(this, cbval1, cbval2, cbval3, cbval4, cbval5, cbval6);
            return static_cast<int>(callback_ret);
        } else {
            return QCPCurve::getRegion(key, value, keyMin, valueMax, keyMax, valueMin);
        }
    }

    // Virtual method for C ABI access and custom callback
    QPointF getOptimizedPoint(int otherRegion, double otherKey, double otherValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin) const {
        if (qcpcurve_getoptimizedpoint_isbase) {
            qcpcurve_getoptimizedpoint_isbase = false;
            return QCPCurve::getOptimizedPoint(otherRegion, otherKey, otherValue, key, value, keyMin, valueMax, keyMax, valueMin);
        } else if (qcpcurve_getoptimizedpoint_callback != nullptr) {
            int cbval1 = otherRegion;
            double cbval2 = otherKey;
            double cbval3 = otherValue;
            double cbval4 = key;
            double cbval5 = value;
            double cbval6 = keyMin;
            double cbval7 = valueMax;
            double cbval8 = keyMax;
            double cbval9 = valueMin;

            QPointF* callback_ret = qcpcurve_getoptimizedpoint_callback(this, cbval1, cbval2, cbval3, cbval4, cbval5, cbval6, cbval7, cbval8, cbval9);
            return *callback_ret;
        } else {
            return QCPCurve::getOptimizedPoint(otherRegion, otherKey, otherValue, key, value, keyMin, valueMax, keyMax, valueMin);
        }
    }

    // Virtual method for C ABI access and custom callback
    QVector<QPointF> getOptimizedCornerPoints(int prevRegion, int currentRegion, double prevKey, double prevValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin) const {
        if (qcpcurve_getoptimizedcornerpoints_isbase) {
            qcpcurve_getoptimizedcornerpoints_isbase = false;
            return QCPCurve::getOptimizedCornerPoints(prevRegion, currentRegion, prevKey, prevValue, key, value, keyMin, valueMax, keyMax, valueMin);
        } else if (qcpcurve_getoptimizedcornerpoints_callback != nullptr) {
            int cbval1 = prevRegion;
            int cbval2 = currentRegion;
            double cbval3 = prevKey;
            double cbval4 = prevValue;
            double cbval5 = key;
            double cbval6 = value;
            double cbval7 = keyMin;
            double cbval8 = valueMax;
            double cbval9 = keyMax;
            double cbval10 = valueMin;

            QPointF** callback_ret = qcpcurve_getoptimizedcornerpoints_callback(this, cbval1, cbval2, cbval3, cbval4, cbval5, cbval6, cbval7, cbval8, cbval9, cbval10);
            QVector<QPointF> callback_ret_QVector;
            // Iterate until null pointer sentinel
            for (QPointF** ptridx = callback_ret; *ptridx != nullptr; ptridx++) {
                callback_ret_QVector.push_back(**ptridx);
            }
            free(callback_ret);
            return callback_ret_QVector;
        } else {
            return QCPCurve::getOptimizedCornerPoints(prevRegion, currentRegion, prevKey, prevValue, key, value, keyMin, valueMax, keyMax, valueMin);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool mayTraverse(int prevRegion, int currentRegion) const {
        if (qcpcurve_maytraverse_isbase) {
            qcpcurve_maytraverse_isbase = false;
            return QCPCurve::mayTraverse(prevRegion, currentRegion);
        } else if (qcpcurve_maytraverse_callback != nullptr) {
            int cbval1 = prevRegion;
            int cbval2 = currentRegion;

            bool callback_ret = qcpcurve_maytraverse_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPCurve::mayTraverse(prevRegion, currentRegion);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool getTraverse(double prevKey, double prevValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin, QPointF& crossA, QPointF& crossB) const {
        if (qcpcurve_gettraverse_isbase) {
            qcpcurve_gettraverse_isbase = false;
            return QCPCurve::getTraverse(prevKey, prevValue, key, value, keyMin, valueMax, keyMax, valueMin, crossA, crossB);
        } else if (qcpcurve_gettraverse_callback != nullptr) {
            double cbval1 = prevKey;
            double cbval2 = prevValue;
            double cbval3 = key;
            double cbval4 = value;
            double cbval5 = keyMin;
            double cbval6 = valueMax;
            double cbval7 = keyMax;
            double cbval8 = valueMin;
            QPointF& crossA_ret = crossA;
            // Cast returned reference into pointer
            QPointF* cbval9 = &crossA_ret;
            QPointF& crossB_ret = crossB;
            // Cast returned reference into pointer
            QPointF* cbval10 = &crossB_ret;

            bool callback_ret = qcpcurve_gettraverse_callback(this, cbval1, cbval2, cbval3, cbval4, cbval5, cbval6, cbval7, cbval8, cbval9, cbval10);
            return callback_ret;
        } else {
            return QCPCurve::getTraverse(prevKey, prevValue, key, value, keyMin, valueMax, keyMax, valueMin, crossA, crossB);
        }
    }

    // Virtual method for C ABI access and custom callback
    void getTraverseCornerPoints(int prevRegion, int currentRegion, double keyMin, double valueMax, double keyMax, double valueMin, QVector<QPointF>& beforeTraverse, QVector<QPointF>& afterTraverse) const {
        if (qcpcurve_gettraversecornerpoints_isbase) {
            qcpcurve_gettraversecornerpoints_isbase = false;
            QCPCurve::getTraverseCornerPoints(prevRegion, currentRegion, keyMin, valueMax, keyMax, valueMin, beforeTraverse, afterTraverse);
        } else if (qcpcurve_gettraversecornerpoints_callback != nullptr) {
            int cbval1 = prevRegion;
            int cbval2 = currentRegion;
            double cbval3 = keyMin;
            double cbval4 = valueMax;
            double cbval5 = keyMax;
            double cbval6 = valueMin;
            QVector<QPointF>& beforeTraverse_ret = beforeTraverse;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** beforeTraverse_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (beforeTraverse_ret.size() + 1)));
            for (qsizetype i = 0; i < beforeTraverse_ret.size(); ++i) {
                beforeTraverse_arr[i] = new QPointF(beforeTraverse_ret[i]);
            }
            libqt_list beforeTraverse_out;
            beforeTraverse_out.len = beforeTraverse_ret.size();
            beforeTraverse_out.data = static_cast<void*>(beforeTraverse_arr);
            libqt_list /* of QPointF* */ cbval7 = beforeTraverse_out;
            QVector<QPointF>& afterTraverse_ret = afterTraverse;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** afterTraverse_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (afterTraverse_ret.size() + 1)));
            for (qsizetype i = 0; i < afterTraverse_ret.size(); ++i) {
                afterTraverse_arr[i] = new QPointF(afterTraverse_ret[i]);
            }
            libqt_list afterTraverse_out;
            afterTraverse_out.len = afterTraverse_ret.size();
            afterTraverse_out.data = static_cast<void*>(afterTraverse_arr);
            libqt_list /* of QPointF* */ cbval8 = afterTraverse_out;

            qcpcurve_gettraversecornerpoints_callback(this, cbval1, cbval2, cbval3, cbval4, cbval5, cbval6, cbval7, cbval8);
        } else {
            QCPCurve::getTraverseCornerPoints(prevRegion, currentRegion, keyMin, valueMax, keyMax, valueMin, beforeTraverse, afterTraverse);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyFillAntialiasingHint(QCPPainter* painter) const {
        if (qcpcurve_applyfillantialiasinghint_isbase) {
            qcpcurve_applyfillantialiasinghint_isbase = false;
            QCPCurve::applyFillAntialiasingHint(painter);
        } else if (qcpcurve_applyfillantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpcurve_applyfillantialiasinghint_callback(this, cbval1);
        } else {
            QCPCurve::applyFillAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyScattersAntialiasingHint(QCPPainter* painter) const {
        if (qcpcurve_applyscattersantialiasinghint_isbase) {
            qcpcurve_applyscattersantialiasinghint_isbase = false;
            QCPCurve::applyScattersAntialiasingHint(painter);
        } else if (qcpcurve_applyscattersantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpcurve_applyscattersantialiasinghint_callback(this, cbval1);
        } else {
            QCPCurve::applyScattersAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcpcurve_initializeparentplot_isbase) {
            qcpcurve_initializeparentplot_isbase = false;
            QCPCurve::initializeParentPlot(parentPlot);
        } else if (qcpcurve_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpcurve_initializeparentplot_callback(this, cbval1);
        } else {
            QCPCurve::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcpcurve_setparentlayerable_isbase) {
            qcpcurve_setparentlayerable_isbase = false;
            QCPCurve::setParentLayerable(parentLayerable);
        } else if (qcpcurve_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcpcurve_setparentlayerable_callback(this, cbval1);
        } else {
            QCPCurve::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcpcurve_movetolayer_isbase) {
            qcpcurve_movetolayer_isbase = false;
            return QCPCurve::moveToLayer(layer, prepend);
        } else if (qcpcurve_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcpcurve_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPCurve::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcpcurve_applyantialiasinghint_isbase) {
            qcpcurve_applyantialiasinghint_isbase = false;
            QCPCurve::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcpcurve_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcpcurve_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPCurve::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpcurve_sender_isbase) {
            qcpcurve_sender_isbase = false;
            return QCPCurve::sender();
        } else if (qcpcurve_sender_callback != nullptr) {
            QObject* callback_ret = qcpcurve_sender_callback();
            return callback_ret;
        } else {
            return QCPCurve::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpcurve_sendersignalindex_isbase) {
            qcpcurve_sendersignalindex_isbase = false;
            return QCPCurve::senderSignalIndex();
        } else if (qcpcurve_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpcurve_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPCurve::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpcurve_receivers_isbase) {
            qcpcurve_receivers_isbase = false;
            return QCPCurve::receivers(signal);
        } else if (qcpcurve_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpcurve_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPCurve::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpcurve_issignalconnected_isbase) {
            qcpcurve_issignalconnected_isbase = false;
            return QCPCurve::isSignalConnected(signal);
        } else if (qcpcurve_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpcurve_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPCurve::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPCurve_Draw(QCPCurve* self, QCPPainter* painter);
    friend void QCPCurve_QBaseDraw(QCPCurve* self, QCPPainter* painter);
    friend void QCPCurve_DrawLegendIcon(const QCPCurve* self, QCPPainter* painter, const QRectF* rect);
    friend void QCPCurve_QBaseDrawLegendIcon(const QCPCurve* self, QCPPainter* painter, const QRectF* rect);
    friend void QCPCurve_DrawCurveLine(const QCPCurve* self, QCPPainter* painter, const libqt_list /* of QPointF* */ lines);
    friend void QCPCurve_QBaseDrawCurveLine(const QCPCurve* self, QCPPainter* painter, const libqt_list /* of QPointF* */ lines);
    friend void QCPCurve_DrawScatterPlot(const QCPCurve* self, QCPPainter* painter, const libqt_list /* of QPointF* */ points, const QCPScatterStyle* style);
    friend void QCPCurve_QBaseDrawScatterPlot(const QCPCurve* self, QCPPainter* painter, const libqt_list /* of QPointF* */ points, const QCPScatterStyle* style);
    friend QRect* QCPCurve_ClipRect(const QCPCurve* self);
    friend QRect* QCPCurve_QBaseClipRect(const QCPCurve* self);
    friend int QCPCurve_SelectionCategory(const QCPCurve* self);
    friend int QCPCurve_QBaseSelectionCategory(const QCPCurve* self);
    friend void QCPCurve_ApplyDefaultAntialiasingHint(const QCPCurve* self, QCPPainter* painter);
    friend void QCPCurve_QBaseApplyDefaultAntialiasingHint(const QCPCurve* self, QCPPainter* painter);
    friend void QCPCurve_SelectEvent(QCPCurve* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPCurve_QBaseSelectEvent(QCPCurve* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPCurve_DeselectEvent(QCPCurve* self, bool* selectionStateChanged);
    friend void QCPCurve_QBaseDeselectEvent(QCPCurve* self, bool* selectionStateChanged);
    friend void QCPCurve_ParentPlotInitialized(QCPCurve* self, QCustomPlot* parentPlot);
    friend void QCPCurve_QBaseParentPlotInitialized(QCPCurve* self, QCustomPlot* parentPlot);
    friend void QCPCurve_MousePressEvent(QCPCurve* self, QMouseEvent* event, const QVariant* details);
    friend void QCPCurve_QBaseMousePressEvent(QCPCurve* self, QMouseEvent* event, const QVariant* details);
    friend void QCPCurve_MouseMoveEvent(QCPCurve* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPCurve_QBaseMouseMoveEvent(QCPCurve* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPCurve_MouseReleaseEvent(QCPCurve* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPCurve_QBaseMouseReleaseEvent(QCPCurve* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPCurve_MouseDoubleClickEvent(QCPCurve* self, QMouseEvent* event, const QVariant* details);
    friend void QCPCurve_QBaseMouseDoubleClickEvent(QCPCurve* self, QMouseEvent* event, const QVariant* details);
    friend void QCPCurve_WheelEvent(QCPCurve* self, QWheelEvent* event);
    friend void QCPCurve_QBaseWheelEvent(QCPCurve* self, QWheelEvent* event);
    friend void QCPCurve_TimerEvent(QCPCurve* self, QTimerEvent* event);
    friend void QCPCurve_QBaseTimerEvent(QCPCurve* self, QTimerEvent* event);
    friend void QCPCurve_ChildEvent(QCPCurve* self, QChildEvent* event);
    friend void QCPCurve_QBaseChildEvent(QCPCurve* self, QChildEvent* event);
    friend void QCPCurve_CustomEvent(QCPCurve* self, QEvent* event);
    friend void QCPCurve_QBaseCustomEvent(QCPCurve* self, QEvent* event);
    friend void QCPCurve_ConnectNotify(QCPCurve* self, const QMetaMethod* signal);
    friend void QCPCurve_QBaseConnectNotify(QCPCurve* self, const QMetaMethod* signal);
    friend void QCPCurve_DisconnectNotify(QCPCurve* self, const QMetaMethod* signal);
    friend void QCPCurve_QBaseDisconnectNotify(QCPCurve* self, const QMetaMethod* signal);
    friend void QCPCurve_GetCurveLines(const QCPCurve* self, libqt_list /* of QPointF* */ lines, const QCPDataRange* dataRange, double penWidth);
    friend void QCPCurve_QBaseGetCurveLines(const QCPCurve* self, libqt_list /* of QPointF* */ lines, const QCPDataRange* dataRange, double penWidth);
    friend void QCPCurve_GetScatters(const QCPCurve* self, libqt_list /* of QPointF* */ scatters, const QCPDataRange* dataRange, double scatterWidth);
    friend void QCPCurve_QBaseGetScatters(const QCPCurve* self, libqt_list /* of QPointF* */ scatters, const QCPDataRange* dataRange, double scatterWidth);
    friend int QCPCurve_GetRegion(const QCPCurve* self, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin);
    friend int QCPCurve_QBaseGetRegion(const QCPCurve* self, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin);
    friend QPointF* QCPCurve_GetOptimizedPoint(const QCPCurve* self, int otherRegion, double otherKey, double otherValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin);
    friend QPointF* QCPCurve_QBaseGetOptimizedPoint(const QCPCurve* self, int otherRegion, double otherKey, double otherValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin);
    friend libqt_list /* of QPointF* */ QCPCurve_GetOptimizedCornerPoints(const QCPCurve* self, int prevRegion, int currentRegion, double prevKey, double prevValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin);
    friend libqt_list /* of QPointF* */ QCPCurve_QBaseGetOptimizedCornerPoints(const QCPCurve* self, int prevRegion, int currentRegion, double prevKey, double prevValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin);
    friend bool QCPCurve_MayTraverse(const QCPCurve* self, int prevRegion, int currentRegion);
    friend bool QCPCurve_QBaseMayTraverse(const QCPCurve* self, int prevRegion, int currentRegion);
    friend bool QCPCurve_GetTraverse(const QCPCurve* self, double prevKey, double prevValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin, QPointF* crossA, QPointF* crossB);
    friend bool QCPCurve_QBaseGetTraverse(const QCPCurve* self, double prevKey, double prevValue, double key, double value, double keyMin, double valueMax, double keyMax, double valueMin, QPointF* crossA, QPointF* crossB);
    friend void QCPCurve_GetTraverseCornerPoints(const QCPCurve* self, int prevRegion, int currentRegion, double keyMin, double valueMax, double keyMax, double valueMin, libqt_list /* of QPointF* */ beforeTraverse, libqt_list /* of QPointF* */ afterTraverse);
    friend void QCPCurve_QBaseGetTraverseCornerPoints(const QCPCurve* self, int prevRegion, int currentRegion, double keyMin, double valueMax, double keyMax, double valueMin, libqt_list /* of QPointF* */ beforeTraverse, libqt_list /* of QPointF* */ afterTraverse);
    friend void QCPCurve_ApplyFillAntialiasingHint(const QCPCurve* self, QCPPainter* painter);
    friend void QCPCurve_QBaseApplyFillAntialiasingHint(const QCPCurve* self, QCPPainter* painter);
    friend void QCPCurve_ApplyScattersAntialiasingHint(const QCPCurve* self, QCPPainter* painter);
    friend void QCPCurve_QBaseApplyScattersAntialiasingHint(const QCPCurve* self, QCPPainter* painter);
    friend void QCPCurve_InitializeParentPlot(QCPCurve* self, QCustomPlot* parentPlot);
    friend void QCPCurve_QBaseInitializeParentPlot(QCPCurve* self, QCustomPlot* parentPlot);
    friend void QCPCurve_SetParentLayerable(QCPCurve* self, QCPLayerable* parentLayerable);
    friend void QCPCurve_QBaseSetParentLayerable(QCPCurve* self, QCPLayerable* parentLayerable);
    friend bool QCPCurve_MoveToLayer(QCPCurve* self, QCPLayer* layer, bool prepend);
    friend bool QCPCurve_QBaseMoveToLayer(QCPCurve* self, QCPLayer* layer, bool prepend);
    friend void QCPCurve_ApplyAntialiasingHint(const QCPCurve* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPCurve_QBaseApplyAntialiasingHint(const QCPCurve* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPCurve_Sender(const QCPCurve* self);
    friend QObject* QCPCurve_QBaseSender(const QCPCurve* self);
    friend int QCPCurve_SenderSignalIndex(const QCPCurve* self);
    friend int QCPCurve_QBaseSenderSignalIndex(const QCPCurve* self);
    friend int QCPCurve_Receivers(const QCPCurve* self, const char* signal);
    friend int QCPCurve_QBaseReceivers(const QCPCurve* self, const char* signal);
    friend bool QCPCurve_IsSignalConnected(const QCPCurve* self, const QMetaMethod* signal);
    friend bool QCPCurve_QBaseIsSignalConnected(const QCPCurve* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPBarsGroup so that we can call protected methods
class VirtualQCPBarsGroup final : public QCPBarsGroup {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPBarsGroup = true;

    // Virtual class public types (including callbacks)
    using QCPBarsGroup_Metacall_Callback = int (*)(QCPBarsGroup*, int, int, void**);
    using QCPBarsGroup_Event_Callback = bool (*)(QCPBarsGroup*, QEvent*);
    using QCPBarsGroup_EventFilter_Callback = bool (*)(QCPBarsGroup*, QObject*, QEvent*);
    using QCPBarsGroup_TimerEvent_Callback = void (*)(QCPBarsGroup*, QTimerEvent*);
    using QCPBarsGroup_ChildEvent_Callback = void (*)(QCPBarsGroup*, QChildEvent*);
    using QCPBarsGroup_CustomEvent_Callback = void (*)(QCPBarsGroup*, QEvent*);
    using QCPBarsGroup_ConnectNotify_Callback = void (*)(QCPBarsGroup*, QMetaMethod*);
    using QCPBarsGroup_DisconnectNotify_Callback = void (*)(QCPBarsGroup*, QMetaMethod*);
    using QCPBarsGroup_RegisterBars_Callback = void (*)(QCPBarsGroup*, QCPBars*);
    using QCPBarsGroup_UnregisterBars_Callback = void (*)(QCPBarsGroup*, QCPBars*);
    using QCPBarsGroup_KeyPixelOffset_Callback = double (*)(QCPBarsGroup*, QCPBars*, double);
    using QCPBarsGroup_GetPixelSpacing_Callback = double (*)(QCPBarsGroup*, QCPBars*, double);
    using QCPBarsGroup_Sender_Callback = QObject* (*)();
    using QCPBarsGroup_SenderSignalIndex_Callback = int (*)();
    using QCPBarsGroup_Receivers_Callback = int (*)(const QCPBarsGroup*, const char*);
    using QCPBarsGroup_IsSignalConnected_Callback = bool (*)(const QCPBarsGroup*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPBarsGroup_Metacall_Callback qcpbarsgroup_metacall_callback = nullptr;
    QCPBarsGroup_Event_Callback qcpbarsgroup_event_callback = nullptr;
    QCPBarsGroup_EventFilter_Callback qcpbarsgroup_eventfilter_callback = nullptr;
    QCPBarsGroup_TimerEvent_Callback qcpbarsgroup_timerevent_callback = nullptr;
    QCPBarsGroup_ChildEvent_Callback qcpbarsgroup_childevent_callback = nullptr;
    QCPBarsGroup_CustomEvent_Callback qcpbarsgroup_customevent_callback = nullptr;
    QCPBarsGroup_ConnectNotify_Callback qcpbarsgroup_connectnotify_callback = nullptr;
    QCPBarsGroup_DisconnectNotify_Callback qcpbarsgroup_disconnectnotify_callback = nullptr;
    QCPBarsGroup_RegisterBars_Callback qcpbarsgroup_registerbars_callback = nullptr;
    QCPBarsGroup_UnregisterBars_Callback qcpbarsgroup_unregisterbars_callback = nullptr;
    QCPBarsGroup_KeyPixelOffset_Callback qcpbarsgroup_keypixeloffset_callback = nullptr;
    QCPBarsGroup_GetPixelSpacing_Callback qcpbarsgroup_getpixelspacing_callback = nullptr;
    QCPBarsGroup_Sender_Callback qcpbarsgroup_sender_callback = nullptr;
    QCPBarsGroup_SenderSignalIndex_Callback qcpbarsgroup_sendersignalindex_callback = nullptr;
    QCPBarsGroup_Receivers_Callback qcpbarsgroup_receivers_callback = nullptr;
    QCPBarsGroup_IsSignalConnected_Callback qcpbarsgroup_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpbarsgroup_metacall_isbase = false;
    mutable bool qcpbarsgroup_event_isbase = false;
    mutable bool qcpbarsgroup_eventfilter_isbase = false;
    mutable bool qcpbarsgroup_timerevent_isbase = false;
    mutable bool qcpbarsgroup_childevent_isbase = false;
    mutable bool qcpbarsgroup_customevent_isbase = false;
    mutable bool qcpbarsgroup_connectnotify_isbase = false;
    mutable bool qcpbarsgroup_disconnectnotify_isbase = false;
    mutable bool qcpbarsgroup_registerbars_isbase = false;
    mutable bool qcpbarsgroup_unregisterbars_isbase = false;
    mutable bool qcpbarsgroup_keypixeloffset_isbase = false;
    mutable bool qcpbarsgroup_getpixelspacing_isbase = false;
    mutable bool qcpbarsgroup_sender_isbase = false;
    mutable bool qcpbarsgroup_sendersignalindex_isbase = false;
    mutable bool qcpbarsgroup_receivers_isbase = false;
    mutable bool qcpbarsgroup_issignalconnected_isbase = false;

  public:
    VirtualQCPBarsGroup(QCustomPlot* parentPlot) : QCPBarsGroup(parentPlot) {};

    ~VirtualQCPBarsGroup() {
        qcpbarsgroup_metacall_callback = nullptr;
        qcpbarsgroup_event_callback = nullptr;
        qcpbarsgroup_eventfilter_callback = nullptr;
        qcpbarsgroup_timerevent_callback = nullptr;
        qcpbarsgroup_childevent_callback = nullptr;
        qcpbarsgroup_customevent_callback = nullptr;
        qcpbarsgroup_connectnotify_callback = nullptr;
        qcpbarsgroup_disconnectnotify_callback = nullptr;
        qcpbarsgroup_registerbars_callback = nullptr;
        qcpbarsgroup_unregisterbars_callback = nullptr;
        qcpbarsgroup_keypixeloffset_callback = nullptr;
        qcpbarsgroup_getpixelspacing_callback = nullptr;
        qcpbarsgroup_sender_callback = nullptr;
        qcpbarsgroup_sendersignalindex_callback = nullptr;
        qcpbarsgroup_receivers_callback = nullptr;
        qcpbarsgroup_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPBarsGroup_Metacall_Callback(QCPBarsGroup_Metacall_Callback cb) { qcpbarsgroup_metacall_callback = cb; }
    inline void setQCPBarsGroup_Event_Callback(QCPBarsGroup_Event_Callback cb) { qcpbarsgroup_event_callback = cb; }
    inline void setQCPBarsGroup_EventFilter_Callback(QCPBarsGroup_EventFilter_Callback cb) { qcpbarsgroup_eventfilter_callback = cb; }
    inline void setQCPBarsGroup_TimerEvent_Callback(QCPBarsGroup_TimerEvent_Callback cb) { qcpbarsgroup_timerevent_callback = cb; }
    inline void setQCPBarsGroup_ChildEvent_Callback(QCPBarsGroup_ChildEvent_Callback cb) { qcpbarsgroup_childevent_callback = cb; }
    inline void setQCPBarsGroup_CustomEvent_Callback(QCPBarsGroup_CustomEvent_Callback cb) { qcpbarsgroup_customevent_callback = cb; }
    inline void setQCPBarsGroup_ConnectNotify_Callback(QCPBarsGroup_ConnectNotify_Callback cb) { qcpbarsgroup_connectnotify_callback = cb; }
    inline void setQCPBarsGroup_DisconnectNotify_Callback(QCPBarsGroup_DisconnectNotify_Callback cb) { qcpbarsgroup_disconnectnotify_callback = cb; }
    inline void setQCPBarsGroup_RegisterBars_Callback(QCPBarsGroup_RegisterBars_Callback cb) { qcpbarsgroup_registerbars_callback = cb; }
    inline void setQCPBarsGroup_UnregisterBars_Callback(QCPBarsGroup_UnregisterBars_Callback cb) { qcpbarsgroup_unregisterbars_callback = cb; }
    inline void setQCPBarsGroup_KeyPixelOffset_Callback(QCPBarsGroup_KeyPixelOffset_Callback cb) { qcpbarsgroup_keypixeloffset_callback = cb; }
    inline void setQCPBarsGroup_GetPixelSpacing_Callback(QCPBarsGroup_GetPixelSpacing_Callback cb) { qcpbarsgroup_getpixelspacing_callback = cb; }
    inline void setQCPBarsGroup_Sender_Callback(QCPBarsGroup_Sender_Callback cb) { qcpbarsgroup_sender_callback = cb; }
    inline void setQCPBarsGroup_SenderSignalIndex_Callback(QCPBarsGroup_SenderSignalIndex_Callback cb) { qcpbarsgroup_sendersignalindex_callback = cb; }
    inline void setQCPBarsGroup_Receivers_Callback(QCPBarsGroup_Receivers_Callback cb) { qcpbarsgroup_receivers_callback = cb; }
    inline void setQCPBarsGroup_IsSignalConnected_Callback(QCPBarsGroup_IsSignalConnected_Callback cb) { qcpbarsgroup_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPBarsGroup_Metacall_IsBase(bool value) const { qcpbarsgroup_metacall_isbase = value; }
    inline void setQCPBarsGroup_Event_IsBase(bool value) const { qcpbarsgroup_event_isbase = value; }
    inline void setQCPBarsGroup_EventFilter_IsBase(bool value) const { qcpbarsgroup_eventfilter_isbase = value; }
    inline void setQCPBarsGroup_TimerEvent_IsBase(bool value) const { qcpbarsgroup_timerevent_isbase = value; }
    inline void setQCPBarsGroup_ChildEvent_IsBase(bool value) const { qcpbarsgroup_childevent_isbase = value; }
    inline void setQCPBarsGroup_CustomEvent_IsBase(bool value) const { qcpbarsgroup_customevent_isbase = value; }
    inline void setQCPBarsGroup_ConnectNotify_IsBase(bool value) const { qcpbarsgroup_connectnotify_isbase = value; }
    inline void setQCPBarsGroup_DisconnectNotify_IsBase(bool value) const { qcpbarsgroup_disconnectnotify_isbase = value; }
    inline void setQCPBarsGroup_RegisterBars_IsBase(bool value) const { qcpbarsgroup_registerbars_isbase = value; }
    inline void setQCPBarsGroup_UnregisterBars_IsBase(bool value) const { qcpbarsgroup_unregisterbars_isbase = value; }
    inline void setQCPBarsGroup_KeyPixelOffset_IsBase(bool value) const { qcpbarsgroup_keypixeloffset_isbase = value; }
    inline void setQCPBarsGroup_GetPixelSpacing_IsBase(bool value) const { qcpbarsgroup_getpixelspacing_isbase = value; }
    inline void setQCPBarsGroup_Sender_IsBase(bool value) const { qcpbarsgroup_sender_isbase = value; }
    inline void setQCPBarsGroup_SenderSignalIndex_IsBase(bool value) const { qcpbarsgroup_sendersignalindex_isbase = value; }
    inline void setQCPBarsGroup_Receivers_IsBase(bool value) const { qcpbarsgroup_receivers_isbase = value; }
    inline void setQCPBarsGroup_IsSignalConnected_IsBase(bool value) const { qcpbarsgroup_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpbarsgroup_metacall_isbase) {
            qcpbarsgroup_metacall_isbase = false;
            return QCPBarsGroup::qt_metacall(param1, param2, param3);
        } else if (qcpbarsgroup_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpbarsgroup_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPBarsGroup::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpbarsgroup_event_isbase) {
            qcpbarsgroup_event_isbase = false;
            return QCPBarsGroup::event(event);
        } else if (qcpbarsgroup_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpbarsgroup_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPBarsGroup::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpbarsgroup_eventfilter_isbase) {
            qcpbarsgroup_eventfilter_isbase = false;
            return QCPBarsGroup::eventFilter(watched, event);
        } else if (qcpbarsgroup_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpbarsgroup_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPBarsGroup::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpbarsgroup_timerevent_isbase) {
            qcpbarsgroup_timerevent_isbase = false;
            QCPBarsGroup::timerEvent(event);
        } else if (qcpbarsgroup_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpbarsgroup_timerevent_callback(this, cbval1);
        } else {
            QCPBarsGroup::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpbarsgroup_childevent_isbase) {
            qcpbarsgroup_childevent_isbase = false;
            QCPBarsGroup::childEvent(event);
        } else if (qcpbarsgroup_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpbarsgroup_childevent_callback(this, cbval1);
        } else {
            QCPBarsGroup::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpbarsgroup_customevent_isbase) {
            qcpbarsgroup_customevent_isbase = false;
            QCPBarsGroup::customEvent(event);
        } else if (qcpbarsgroup_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpbarsgroup_customevent_callback(this, cbval1);
        } else {
            QCPBarsGroup::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpbarsgroup_connectnotify_isbase) {
            qcpbarsgroup_connectnotify_isbase = false;
            QCPBarsGroup::connectNotify(signal);
        } else if (qcpbarsgroup_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpbarsgroup_connectnotify_callback(this, cbval1);
        } else {
            QCPBarsGroup::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpbarsgroup_disconnectnotify_isbase) {
            qcpbarsgroup_disconnectnotify_isbase = false;
            QCPBarsGroup::disconnectNotify(signal);
        } else if (qcpbarsgroup_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpbarsgroup_disconnectnotify_callback(this, cbval1);
        } else {
            QCPBarsGroup::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    void registerBars(QCPBars* bars) {
        if (qcpbarsgroup_registerbars_isbase) {
            qcpbarsgroup_registerbars_isbase = false;
            QCPBarsGroup::registerBars(bars);
        } else if (qcpbarsgroup_registerbars_callback != nullptr) {
            QCPBars* cbval1 = bars;

            qcpbarsgroup_registerbars_callback(this, cbval1);
        } else {
            QCPBarsGroup::registerBars(bars);
        }
    }

    // Virtual method for C ABI access and custom callback
    void unregisterBars(QCPBars* bars) {
        if (qcpbarsgroup_unregisterbars_isbase) {
            qcpbarsgroup_unregisterbars_isbase = false;
            QCPBarsGroup::unregisterBars(bars);
        } else if (qcpbarsgroup_unregisterbars_callback != nullptr) {
            QCPBars* cbval1 = bars;

            qcpbarsgroup_unregisterbars_callback(this, cbval1);
        } else {
            QCPBarsGroup::unregisterBars(bars);
        }
    }

    // Virtual method for C ABI access and custom callback
    double keyPixelOffset(const QCPBars* bars, double keyCoord) {
        if (qcpbarsgroup_keypixeloffset_isbase) {
            qcpbarsgroup_keypixeloffset_isbase = false;
            return QCPBarsGroup::keyPixelOffset(bars, keyCoord);
        } else if (qcpbarsgroup_keypixeloffset_callback != nullptr) {
            QCPBars* cbval1 = (QCPBars*)bars;
            double cbval2 = keyCoord;

            double callback_ret = qcpbarsgroup_keypixeloffset_callback(this, cbval1, cbval2);
            return static_cast<double>(callback_ret);
        } else {
            return QCPBarsGroup::keyPixelOffset(bars, keyCoord);
        }
    }

    // Virtual method for C ABI access and custom callback
    double getPixelSpacing(const QCPBars* bars, double keyCoord) {
        if (qcpbarsgroup_getpixelspacing_isbase) {
            qcpbarsgroup_getpixelspacing_isbase = false;
            return QCPBarsGroup::getPixelSpacing(bars, keyCoord);
        } else if (qcpbarsgroup_getpixelspacing_callback != nullptr) {
            QCPBars* cbval1 = (QCPBars*)bars;
            double cbval2 = keyCoord;

            double callback_ret = qcpbarsgroup_getpixelspacing_callback(this, cbval1, cbval2);
            return static_cast<double>(callback_ret);
        } else {
            return QCPBarsGroup::getPixelSpacing(bars, keyCoord);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpbarsgroup_sender_isbase) {
            qcpbarsgroup_sender_isbase = false;
            return QCPBarsGroup::sender();
        } else if (qcpbarsgroup_sender_callback != nullptr) {
            QObject* callback_ret = qcpbarsgroup_sender_callback();
            return callback_ret;
        } else {
            return QCPBarsGroup::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpbarsgroup_sendersignalindex_isbase) {
            qcpbarsgroup_sendersignalindex_isbase = false;
            return QCPBarsGroup::senderSignalIndex();
        } else if (qcpbarsgroup_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpbarsgroup_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPBarsGroup::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpbarsgroup_receivers_isbase) {
            qcpbarsgroup_receivers_isbase = false;
            return QCPBarsGroup::receivers(signal);
        } else if (qcpbarsgroup_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpbarsgroup_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPBarsGroup::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpbarsgroup_issignalconnected_isbase) {
            qcpbarsgroup_issignalconnected_isbase = false;
            return QCPBarsGroup::isSignalConnected(signal);
        } else if (qcpbarsgroup_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpbarsgroup_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPBarsGroup::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPBarsGroup_TimerEvent(QCPBarsGroup* self, QTimerEvent* event);
    friend void QCPBarsGroup_QBaseTimerEvent(QCPBarsGroup* self, QTimerEvent* event);
    friend void QCPBarsGroup_ChildEvent(QCPBarsGroup* self, QChildEvent* event);
    friend void QCPBarsGroup_QBaseChildEvent(QCPBarsGroup* self, QChildEvent* event);
    friend void QCPBarsGroup_CustomEvent(QCPBarsGroup* self, QEvent* event);
    friend void QCPBarsGroup_QBaseCustomEvent(QCPBarsGroup* self, QEvent* event);
    friend void QCPBarsGroup_ConnectNotify(QCPBarsGroup* self, const QMetaMethod* signal);
    friend void QCPBarsGroup_QBaseConnectNotify(QCPBarsGroup* self, const QMetaMethod* signal);
    friend void QCPBarsGroup_DisconnectNotify(QCPBarsGroup* self, const QMetaMethod* signal);
    friend void QCPBarsGroup_QBaseDisconnectNotify(QCPBarsGroup* self, const QMetaMethod* signal);
    friend void QCPBarsGroup_RegisterBars(QCPBarsGroup* self, QCPBars* bars);
    friend void QCPBarsGroup_QBaseRegisterBars(QCPBarsGroup* self, QCPBars* bars);
    friend void QCPBarsGroup_UnregisterBars(QCPBarsGroup* self, QCPBars* bars);
    friend void QCPBarsGroup_QBaseUnregisterBars(QCPBarsGroup* self, QCPBars* bars);
    friend double QCPBarsGroup_KeyPixelOffset(QCPBarsGroup* self, const QCPBars* bars, double keyCoord);
    friend double QCPBarsGroup_QBaseKeyPixelOffset(QCPBarsGroup* self, const QCPBars* bars, double keyCoord);
    friend double QCPBarsGroup_GetPixelSpacing(QCPBarsGroup* self, const QCPBars* bars, double keyCoord);
    friend double QCPBarsGroup_QBaseGetPixelSpacing(QCPBarsGroup* self, const QCPBars* bars, double keyCoord);
    friend QObject* QCPBarsGroup_Sender(const QCPBarsGroup* self);
    friend QObject* QCPBarsGroup_QBaseSender(const QCPBarsGroup* self);
    friend int QCPBarsGroup_SenderSignalIndex(const QCPBarsGroup* self);
    friend int QCPBarsGroup_QBaseSenderSignalIndex(const QCPBarsGroup* self);
    friend int QCPBarsGroup_Receivers(const QCPBarsGroup* self, const char* signal);
    friend int QCPBarsGroup_QBaseReceivers(const QCPBarsGroup* self, const char* signal);
    friend bool QCPBarsGroup_IsSignalConnected(const QCPBarsGroup* self, const QMetaMethod* signal);
    friend bool QCPBarsGroup_QBaseIsSignalConnected(const QCPBarsGroup* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPBars so that we can call protected methods
class VirtualQCPBars final : public QCPBars {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPBars = true;

    // Virtual class public types (including callbacks)
    using QCPBars_Metacall_Callback = int (*)(QCPBars*, int, int, void**);
    using QCPBars_SelectTestRect_Callback = QCPDataSelection* (*)(const QCPBars*, QRectF*, bool);
    using QCPBars_SelectTest_Callback = double (*)(const QCPBars*, QPointF*, bool, QVariant*);
    using QCPBars_GetKeyRange_Callback = QCPRange* (*)(const QCPBars*, bool*, int);
    using QCPBars_GetValueRange_Callback = QCPRange* (*)(const QCPBars*, bool*, int, QCPRange*);
    using QCPBars_DataPixelPosition_Callback = QPointF* (*)(const QCPBars*, int);
    using QCPBars_Draw_Callback = void (*)(QCPBars*, QCPPainter*);
    using QCPBars_DrawLegendIcon_Callback = void (*)(const QCPBars*, QCPPainter*, QRectF*);
    using QCPBars_DataCount_Callback = int (*)();
    using QCPBars_DataMainKey_Callback = double (*)(const QCPBars*, int);
    using QCPBars_DataSortKey_Callback = double (*)(const QCPBars*, int);
    using QCPBars_DataMainValue_Callback = double (*)(const QCPBars*, int);
    using QCPBars_DataValueRange_Callback = QCPRange* (*)(const QCPBars*, int);
    using QCPBars_SortKeyIsMainKey_Callback = bool (*)();
    using QCPBars_FindBegin_Callback = int (*)(const QCPBars*, double, bool);
    using QCPBars_FindEnd_Callback = int (*)(const QCPBars*, double, bool);
    using QCPBars_Interface1D_Callback = QCPPlottableInterface1D* (*)();
    using QCPBars_ClipRect_Callback = QRect* (*)();
    using QCPBars_SelectionCategory_Callback = int (*)();
    using QCPBars_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPBars*, QCPPainter*);
    using QCPBars_SelectEvent_Callback = void (*)(QCPBars*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPBars_DeselectEvent_Callback = void (*)(QCPBars*, bool*);
    using QCPBars_ParentPlotInitialized_Callback = void (*)(QCPBars*, QCustomPlot*);
    using QCPBars_MousePressEvent_Callback = void (*)(QCPBars*, QMouseEvent*, QVariant*);
    using QCPBars_MouseMoveEvent_Callback = void (*)(QCPBars*, QMouseEvent*, QPointF*);
    using QCPBars_MouseReleaseEvent_Callback = void (*)(QCPBars*, QMouseEvent*, QPointF*);
    using QCPBars_MouseDoubleClickEvent_Callback = void (*)(QCPBars*, QMouseEvent*, QVariant*);
    using QCPBars_WheelEvent_Callback = void (*)(QCPBars*, QWheelEvent*);
    using QCPBars_Event_Callback = bool (*)(QCPBars*, QEvent*);
    using QCPBars_EventFilter_Callback = bool (*)(QCPBars*, QObject*, QEvent*);
    using QCPBars_TimerEvent_Callback = void (*)(QCPBars*, QTimerEvent*);
    using QCPBars_ChildEvent_Callback = void (*)(QCPBars*, QChildEvent*);
    using QCPBars_CustomEvent_Callback = void (*)(QCPBars*, QEvent*);
    using QCPBars_ConnectNotify_Callback = void (*)(QCPBars*, QMetaMethod*);
    using QCPBars_DisconnectNotify_Callback = void (*)(QCPBars*, QMetaMethod*);
    using QCPBars_GetBarRect_Callback = QRectF* (*)(const QCPBars*, double, double);
    using QCPBars_GetPixelWidth_Callback = void (*)(const QCPBars*, double, double*, double*);
    using QCPBars_GetStackedBaseValue_Callback = double (*)(const QCPBars*, double, bool);
    using QCPBars_ConnectBars_Callback = void (*)(QCPBars*, QCPBars*, QCPBars*);
    using QCPBars_ApplyFillAntialiasingHint_Callback = void (*)(const QCPBars*, QCPPainter*);
    using QCPBars_ApplyScattersAntialiasingHint_Callback = void (*)(const QCPBars*, QCPPainter*);
    using QCPBars_InitializeParentPlot_Callback = void (*)(QCPBars*, QCustomPlot*);
    using QCPBars_SetParentLayerable_Callback = void (*)(QCPBars*, QCPLayerable*);
    using QCPBars_MoveToLayer_Callback = bool (*)(QCPBars*, QCPLayer*, bool);
    using QCPBars_ApplyAntialiasingHint_Callback = void (*)(const QCPBars*, QCPPainter*, bool, int);
    using QCPBars_Sender_Callback = QObject* (*)();
    using QCPBars_SenderSignalIndex_Callback = int (*)();
    using QCPBars_Receivers_Callback = int (*)(const QCPBars*, const char*);
    using QCPBars_IsSignalConnected_Callback = bool (*)(const QCPBars*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPBars_Metacall_Callback qcpbars_metacall_callback = nullptr;
    QCPBars_SelectTestRect_Callback qcpbars_selecttestrect_callback = nullptr;
    QCPBars_SelectTest_Callback qcpbars_selecttest_callback = nullptr;
    QCPBars_GetKeyRange_Callback qcpbars_getkeyrange_callback = nullptr;
    QCPBars_GetValueRange_Callback qcpbars_getvaluerange_callback = nullptr;
    QCPBars_DataPixelPosition_Callback qcpbars_datapixelposition_callback = nullptr;
    QCPBars_Draw_Callback qcpbars_draw_callback = nullptr;
    QCPBars_DrawLegendIcon_Callback qcpbars_drawlegendicon_callback = nullptr;
    QCPBars_DataCount_Callback qcpbars_datacount_callback = nullptr;
    QCPBars_DataMainKey_Callback qcpbars_datamainkey_callback = nullptr;
    QCPBars_DataSortKey_Callback qcpbars_datasortkey_callback = nullptr;
    QCPBars_DataMainValue_Callback qcpbars_datamainvalue_callback = nullptr;
    QCPBars_DataValueRange_Callback qcpbars_datavaluerange_callback = nullptr;
    QCPBars_SortKeyIsMainKey_Callback qcpbars_sortkeyismainkey_callback = nullptr;
    QCPBars_FindBegin_Callback qcpbars_findbegin_callback = nullptr;
    QCPBars_FindEnd_Callback qcpbars_findend_callback = nullptr;
    QCPBars_Interface1D_Callback qcpbars_interface1d_callback = nullptr;
    QCPBars_ClipRect_Callback qcpbars_cliprect_callback = nullptr;
    QCPBars_SelectionCategory_Callback qcpbars_selectioncategory_callback = nullptr;
    QCPBars_ApplyDefaultAntialiasingHint_Callback qcpbars_applydefaultantialiasinghint_callback = nullptr;
    QCPBars_SelectEvent_Callback qcpbars_selectevent_callback = nullptr;
    QCPBars_DeselectEvent_Callback qcpbars_deselectevent_callback = nullptr;
    QCPBars_ParentPlotInitialized_Callback qcpbars_parentplotinitialized_callback = nullptr;
    QCPBars_MousePressEvent_Callback qcpbars_mousepressevent_callback = nullptr;
    QCPBars_MouseMoveEvent_Callback qcpbars_mousemoveevent_callback = nullptr;
    QCPBars_MouseReleaseEvent_Callback qcpbars_mousereleaseevent_callback = nullptr;
    QCPBars_MouseDoubleClickEvent_Callback qcpbars_mousedoubleclickevent_callback = nullptr;
    QCPBars_WheelEvent_Callback qcpbars_wheelevent_callback = nullptr;
    QCPBars_Event_Callback qcpbars_event_callback = nullptr;
    QCPBars_EventFilter_Callback qcpbars_eventfilter_callback = nullptr;
    QCPBars_TimerEvent_Callback qcpbars_timerevent_callback = nullptr;
    QCPBars_ChildEvent_Callback qcpbars_childevent_callback = nullptr;
    QCPBars_CustomEvent_Callback qcpbars_customevent_callback = nullptr;
    QCPBars_ConnectNotify_Callback qcpbars_connectnotify_callback = nullptr;
    QCPBars_DisconnectNotify_Callback qcpbars_disconnectnotify_callback = nullptr;
    QCPBars_GetBarRect_Callback qcpbars_getbarrect_callback = nullptr;
    QCPBars_GetPixelWidth_Callback qcpbars_getpixelwidth_callback = nullptr;
    QCPBars_GetStackedBaseValue_Callback qcpbars_getstackedbasevalue_callback = nullptr;
    QCPBars_ConnectBars_Callback qcpbars_connectbars_callback = nullptr;
    QCPBars_ApplyFillAntialiasingHint_Callback qcpbars_applyfillantialiasinghint_callback = nullptr;
    QCPBars_ApplyScattersAntialiasingHint_Callback qcpbars_applyscattersantialiasinghint_callback = nullptr;
    QCPBars_InitializeParentPlot_Callback qcpbars_initializeparentplot_callback = nullptr;
    QCPBars_SetParentLayerable_Callback qcpbars_setparentlayerable_callback = nullptr;
    QCPBars_MoveToLayer_Callback qcpbars_movetolayer_callback = nullptr;
    QCPBars_ApplyAntialiasingHint_Callback qcpbars_applyantialiasinghint_callback = nullptr;
    QCPBars_Sender_Callback qcpbars_sender_callback = nullptr;
    QCPBars_SenderSignalIndex_Callback qcpbars_sendersignalindex_callback = nullptr;
    QCPBars_Receivers_Callback qcpbars_receivers_callback = nullptr;
    QCPBars_IsSignalConnected_Callback qcpbars_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpbars_metacall_isbase = false;
    mutable bool qcpbars_selecttestrect_isbase = false;
    mutable bool qcpbars_selecttest_isbase = false;
    mutable bool qcpbars_getkeyrange_isbase = false;
    mutable bool qcpbars_getvaluerange_isbase = false;
    mutable bool qcpbars_datapixelposition_isbase = false;
    mutable bool qcpbars_draw_isbase = false;
    mutable bool qcpbars_drawlegendicon_isbase = false;
    mutable bool qcpbars_datacount_isbase = false;
    mutable bool qcpbars_datamainkey_isbase = false;
    mutable bool qcpbars_datasortkey_isbase = false;
    mutable bool qcpbars_datamainvalue_isbase = false;
    mutable bool qcpbars_datavaluerange_isbase = false;
    mutable bool qcpbars_sortkeyismainkey_isbase = false;
    mutable bool qcpbars_findbegin_isbase = false;
    mutable bool qcpbars_findend_isbase = false;
    mutable bool qcpbars_interface1d_isbase = false;
    mutable bool qcpbars_cliprect_isbase = false;
    mutable bool qcpbars_selectioncategory_isbase = false;
    mutable bool qcpbars_applydefaultantialiasinghint_isbase = false;
    mutable bool qcpbars_selectevent_isbase = false;
    mutable bool qcpbars_deselectevent_isbase = false;
    mutable bool qcpbars_parentplotinitialized_isbase = false;
    mutable bool qcpbars_mousepressevent_isbase = false;
    mutable bool qcpbars_mousemoveevent_isbase = false;
    mutable bool qcpbars_mousereleaseevent_isbase = false;
    mutable bool qcpbars_mousedoubleclickevent_isbase = false;
    mutable bool qcpbars_wheelevent_isbase = false;
    mutable bool qcpbars_event_isbase = false;
    mutable bool qcpbars_eventfilter_isbase = false;
    mutable bool qcpbars_timerevent_isbase = false;
    mutable bool qcpbars_childevent_isbase = false;
    mutable bool qcpbars_customevent_isbase = false;
    mutable bool qcpbars_connectnotify_isbase = false;
    mutable bool qcpbars_disconnectnotify_isbase = false;
    mutable bool qcpbars_getbarrect_isbase = false;
    mutable bool qcpbars_getpixelwidth_isbase = false;
    mutable bool qcpbars_getstackedbasevalue_isbase = false;
    mutable bool qcpbars_connectbars_isbase = false;
    mutable bool qcpbars_applyfillantialiasinghint_isbase = false;
    mutable bool qcpbars_applyscattersantialiasinghint_isbase = false;
    mutable bool qcpbars_initializeparentplot_isbase = false;
    mutable bool qcpbars_setparentlayerable_isbase = false;
    mutable bool qcpbars_movetolayer_isbase = false;
    mutable bool qcpbars_applyantialiasinghint_isbase = false;
    mutable bool qcpbars_sender_isbase = false;
    mutable bool qcpbars_sendersignalindex_isbase = false;
    mutable bool qcpbars_receivers_isbase = false;
    mutable bool qcpbars_issignalconnected_isbase = false;

  public:
    VirtualQCPBars(QCPAxis* keyAxis, QCPAxis* valueAxis) : QCPBars(keyAxis, valueAxis) {};

    ~VirtualQCPBars() {
        qcpbars_metacall_callback = nullptr;
        qcpbars_selecttestrect_callback = nullptr;
        qcpbars_selecttest_callback = nullptr;
        qcpbars_getkeyrange_callback = nullptr;
        qcpbars_getvaluerange_callback = nullptr;
        qcpbars_datapixelposition_callback = nullptr;
        qcpbars_draw_callback = nullptr;
        qcpbars_drawlegendicon_callback = nullptr;
        qcpbars_datacount_callback = nullptr;
        qcpbars_datamainkey_callback = nullptr;
        qcpbars_datasortkey_callback = nullptr;
        qcpbars_datamainvalue_callback = nullptr;
        qcpbars_datavaluerange_callback = nullptr;
        qcpbars_sortkeyismainkey_callback = nullptr;
        qcpbars_findbegin_callback = nullptr;
        qcpbars_findend_callback = nullptr;
        qcpbars_interface1d_callback = nullptr;
        qcpbars_cliprect_callback = nullptr;
        qcpbars_selectioncategory_callback = nullptr;
        qcpbars_applydefaultantialiasinghint_callback = nullptr;
        qcpbars_selectevent_callback = nullptr;
        qcpbars_deselectevent_callback = nullptr;
        qcpbars_parentplotinitialized_callback = nullptr;
        qcpbars_mousepressevent_callback = nullptr;
        qcpbars_mousemoveevent_callback = nullptr;
        qcpbars_mousereleaseevent_callback = nullptr;
        qcpbars_mousedoubleclickevent_callback = nullptr;
        qcpbars_wheelevent_callback = nullptr;
        qcpbars_event_callback = nullptr;
        qcpbars_eventfilter_callback = nullptr;
        qcpbars_timerevent_callback = nullptr;
        qcpbars_childevent_callback = nullptr;
        qcpbars_customevent_callback = nullptr;
        qcpbars_connectnotify_callback = nullptr;
        qcpbars_disconnectnotify_callback = nullptr;
        qcpbars_getbarrect_callback = nullptr;
        qcpbars_getpixelwidth_callback = nullptr;
        qcpbars_getstackedbasevalue_callback = nullptr;
        qcpbars_connectbars_callback = nullptr;
        qcpbars_applyfillantialiasinghint_callback = nullptr;
        qcpbars_applyscattersantialiasinghint_callback = nullptr;
        qcpbars_initializeparentplot_callback = nullptr;
        qcpbars_setparentlayerable_callback = nullptr;
        qcpbars_movetolayer_callback = nullptr;
        qcpbars_applyantialiasinghint_callback = nullptr;
        qcpbars_sender_callback = nullptr;
        qcpbars_sendersignalindex_callback = nullptr;
        qcpbars_receivers_callback = nullptr;
        qcpbars_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPBars_Metacall_Callback(QCPBars_Metacall_Callback cb) { qcpbars_metacall_callback = cb; }
    inline void setQCPBars_SelectTestRect_Callback(QCPBars_SelectTestRect_Callback cb) { qcpbars_selecttestrect_callback = cb; }
    inline void setQCPBars_SelectTest_Callback(QCPBars_SelectTest_Callback cb) { qcpbars_selecttest_callback = cb; }
    inline void setQCPBars_GetKeyRange_Callback(QCPBars_GetKeyRange_Callback cb) { qcpbars_getkeyrange_callback = cb; }
    inline void setQCPBars_GetValueRange_Callback(QCPBars_GetValueRange_Callback cb) { qcpbars_getvaluerange_callback = cb; }
    inline void setQCPBars_DataPixelPosition_Callback(QCPBars_DataPixelPosition_Callback cb) { qcpbars_datapixelposition_callback = cb; }
    inline void setQCPBars_Draw_Callback(QCPBars_Draw_Callback cb) { qcpbars_draw_callback = cb; }
    inline void setQCPBars_DrawLegendIcon_Callback(QCPBars_DrawLegendIcon_Callback cb) { qcpbars_drawlegendicon_callback = cb; }
    inline void setQCPBars_DataCount_Callback(QCPBars_DataCount_Callback cb) { qcpbars_datacount_callback = cb; }
    inline void setQCPBars_DataMainKey_Callback(QCPBars_DataMainKey_Callback cb) { qcpbars_datamainkey_callback = cb; }
    inline void setQCPBars_DataSortKey_Callback(QCPBars_DataSortKey_Callback cb) { qcpbars_datasortkey_callback = cb; }
    inline void setQCPBars_DataMainValue_Callback(QCPBars_DataMainValue_Callback cb) { qcpbars_datamainvalue_callback = cb; }
    inline void setQCPBars_DataValueRange_Callback(QCPBars_DataValueRange_Callback cb) { qcpbars_datavaluerange_callback = cb; }
    inline void setQCPBars_SortKeyIsMainKey_Callback(QCPBars_SortKeyIsMainKey_Callback cb) { qcpbars_sortkeyismainkey_callback = cb; }
    inline void setQCPBars_FindBegin_Callback(QCPBars_FindBegin_Callback cb) { qcpbars_findbegin_callback = cb; }
    inline void setQCPBars_FindEnd_Callback(QCPBars_FindEnd_Callback cb) { qcpbars_findend_callback = cb; }
    inline void setQCPBars_Interface1D_Callback(QCPBars_Interface1D_Callback cb) { qcpbars_interface1d_callback = cb; }
    inline void setQCPBars_ClipRect_Callback(QCPBars_ClipRect_Callback cb) { qcpbars_cliprect_callback = cb; }
    inline void setQCPBars_SelectionCategory_Callback(QCPBars_SelectionCategory_Callback cb) { qcpbars_selectioncategory_callback = cb; }
    inline void setQCPBars_ApplyDefaultAntialiasingHint_Callback(QCPBars_ApplyDefaultAntialiasingHint_Callback cb) { qcpbars_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPBars_SelectEvent_Callback(QCPBars_SelectEvent_Callback cb) { qcpbars_selectevent_callback = cb; }
    inline void setQCPBars_DeselectEvent_Callback(QCPBars_DeselectEvent_Callback cb) { qcpbars_deselectevent_callback = cb; }
    inline void setQCPBars_ParentPlotInitialized_Callback(QCPBars_ParentPlotInitialized_Callback cb) { qcpbars_parentplotinitialized_callback = cb; }
    inline void setQCPBars_MousePressEvent_Callback(QCPBars_MousePressEvent_Callback cb) { qcpbars_mousepressevent_callback = cb; }
    inline void setQCPBars_MouseMoveEvent_Callback(QCPBars_MouseMoveEvent_Callback cb) { qcpbars_mousemoveevent_callback = cb; }
    inline void setQCPBars_MouseReleaseEvent_Callback(QCPBars_MouseReleaseEvent_Callback cb) { qcpbars_mousereleaseevent_callback = cb; }
    inline void setQCPBars_MouseDoubleClickEvent_Callback(QCPBars_MouseDoubleClickEvent_Callback cb) { qcpbars_mousedoubleclickevent_callback = cb; }
    inline void setQCPBars_WheelEvent_Callback(QCPBars_WheelEvent_Callback cb) { qcpbars_wheelevent_callback = cb; }
    inline void setQCPBars_Event_Callback(QCPBars_Event_Callback cb) { qcpbars_event_callback = cb; }
    inline void setQCPBars_EventFilter_Callback(QCPBars_EventFilter_Callback cb) { qcpbars_eventfilter_callback = cb; }
    inline void setQCPBars_TimerEvent_Callback(QCPBars_TimerEvent_Callback cb) { qcpbars_timerevent_callback = cb; }
    inline void setQCPBars_ChildEvent_Callback(QCPBars_ChildEvent_Callback cb) { qcpbars_childevent_callback = cb; }
    inline void setQCPBars_CustomEvent_Callback(QCPBars_CustomEvent_Callback cb) { qcpbars_customevent_callback = cb; }
    inline void setQCPBars_ConnectNotify_Callback(QCPBars_ConnectNotify_Callback cb) { qcpbars_connectnotify_callback = cb; }
    inline void setQCPBars_DisconnectNotify_Callback(QCPBars_DisconnectNotify_Callback cb) { qcpbars_disconnectnotify_callback = cb; }
    inline void setQCPBars_GetBarRect_Callback(QCPBars_GetBarRect_Callback cb) { qcpbars_getbarrect_callback = cb; }
    inline void setQCPBars_GetPixelWidth_Callback(QCPBars_GetPixelWidth_Callback cb) { qcpbars_getpixelwidth_callback = cb; }
    inline void setQCPBars_GetStackedBaseValue_Callback(QCPBars_GetStackedBaseValue_Callback cb) { qcpbars_getstackedbasevalue_callback = cb; }
    inline void setQCPBars_ConnectBars_Callback(QCPBars_ConnectBars_Callback cb) { qcpbars_connectbars_callback = cb; }
    inline void setQCPBars_ApplyFillAntialiasingHint_Callback(QCPBars_ApplyFillAntialiasingHint_Callback cb) { qcpbars_applyfillantialiasinghint_callback = cb; }
    inline void setQCPBars_ApplyScattersAntialiasingHint_Callback(QCPBars_ApplyScattersAntialiasingHint_Callback cb) { qcpbars_applyscattersantialiasinghint_callback = cb; }
    inline void setQCPBars_InitializeParentPlot_Callback(QCPBars_InitializeParentPlot_Callback cb) { qcpbars_initializeparentplot_callback = cb; }
    inline void setQCPBars_SetParentLayerable_Callback(QCPBars_SetParentLayerable_Callback cb) { qcpbars_setparentlayerable_callback = cb; }
    inline void setQCPBars_MoveToLayer_Callback(QCPBars_MoveToLayer_Callback cb) { qcpbars_movetolayer_callback = cb; }
    inline void setQCPBars_ApplyAntialiasingHint_Callback(QCPBars_ApplyAntialiasingHint_Callback cb) { qcpbars_applyantialiasinghint_callback = cb; }
    inline void setQCPBars_Sender_Callback(QCPBars_Sender_Callback cb) { qcpbars_sender_callback = cb; }
    inline void setQCPBars_SenderSignalIndex_Callback(QCPBars_SenderSignalIndex_Callback cb) { qcpbars_sendersignalindex_callback = cb; }
    inline void setQCPBars_Receivers_Callback(QCPBars_Receivers_Callback cb) { qcpbars_receivers_callback = cb; }
    inline void setQCPBars_IsSignalConnected_Callback(QCPBars_IsSignalConnected_Callback cb) { qcpbars_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPBars_Metacall_IsBase(bool value) const { qcpbars_metacall_isbase = value; }
    inline void setQCPBars_SelectTestRect_IsBase(bool value) const { qcpbars_selecttestrect_isbase = value; }
    inline void setQCPBars_SelectTest_IsBase(bool value) const { qcpbars_selecttest_isbase = value; }
    inline void setQCPBars_GetKeyRange_IsBase(bool value) const { qcpbars_getkeyrange_isbase = value; }
    inline void setQCPBars_GetValueRange_IsBase(bool value) const { qcpbars_getvaluerange_isbase = value; }
    inline void setQCPBars_DataPixelPosition_IsBase(bool value) const { qcpbars_datapixelposition_isbase = value; }
    inline void setQCPBars_Draw_IsBase(bool value) const { qcpbars_draw_isbase = value; }
    inline void setQCPBars_DrawLegendIcon_IsBase(bool value) const { qcpbars_drawlegendicon_isbase = value; }
    inline void setQCPBars_DataCount_IsBase(bool value) const { qcpbars_datacount_isbase = value; }
    inline void setQCPBars_DataMainKey_IsBase(bool value) const { qcpbars_datamainkey_isbase = value; }
    inline void setQCPBars_DataSortKey_IsBase(bool value) const { qcpbars_datasortkey_isbase = value; }
    inline void setQCPBars_DataMainValue_IsBase(bool value) const { qcpbars_datamainvalue_isbase = value; }
    inline void setQCPBars_DataValueRange_IsBase(bool value) const { qcpbars_datavaluerange_isbase = value; }
    inline void setQCPBars_SortKeyIsMainKey_IsBase(bool value) const { qcpbars_sortkeyismainkey_isbase = value; }
    inline void setQCPBars_FindBegin_IsBase(bool value) const { qcpbars_findbegin_isbase = value; }
    inline void setQCPBars_FindEnd_IsBase(bool value) const { qcpbars_findend_isbase = value; }
    inline void setQCPBars_Interface1D_IsBase(bool value) const { qcpbars_interface1d_isbase = value; }
    inline void setQCPBars_ClipRect_IsBase(bool value) const { qcpbars_cliprect_isbase = value; }
    inline void setQCPBars_SelectionCategory_IsBase(bool value) const { qcpbars_selectioncategory_isbase = value; }
    inline void setQCPBars_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcpbars_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPBars_SelectEvent_IsBase(bool value) const { qcpbars_selectevent_isbase = value; }
    inline void setQCPBars_DeselectEvent_IsBase(bool value) const { qcpbars_deselectevent_isbase = value; }
    inline void setQCPBars_ParentPlotInitialized_IsBase(bool value) const { qcpbars_parentplotinitialized_isbase = value; }
    inline void setQCPBars_MousePressEvent_IsBase(bool value) const { qcpbars_mousepressevent_isbase = value; }
    inline void setQCPBars_MouseMoveEvent_IsBase(bool value) const { qcpbars_mousemoveevent_isbase = value; }
    inline void setQCPBars_MouseReleaseEvent_IsBase(bool value) const { qcpbars_mousereleaseevent_isbase = value; }
    inline void setQCPBars_MouseDoubleClickEvent_IsBase(bool value) const { qcpbars_mousedoubleclickevent_isbase = value; }
    inline void setQCPBars_WheelEvent_IsBase(bool value) const { qcpbars_wheelevent_isbase = value; }
    inline void setQCPBars_Event_IsBase(bool value) const { qcpbars_event_isbase = value; }
    inline void setQCPBars_EventFilter_IsBase(bool value) const { qcpbars_eventfilter_isbase = value; }
    inline void setQCPBars_TimerEvent_IsBase(bool value) const { qcpbars_timerevent_isbase = value; }
    inline void setQCPBars_ChildEvent_IsBase(bool value) const { qcpbars_childevent_isbase = value; }
    inline void setQCPBars_CustomEvent_IsBase(bool value) const { qcpbars_customevent_isbase = value; }
    inline void setQCPBars_ConnectNotify_IsBase(bool value) const { qcpbars_connectnotify_isbase = value; }
    inline void setQCPBars_DisconnectNotify_IsBase(bool value) const { qcpbars_disconnectnotify_isbase = value; }
    inline void setQCPBars_GetBarRect_IsBase(bool value) const { qcpbars_getbarrect_isbase = value; }
    inline void setQCPBars_GetPixelWidth_IsBase(bool value) const { qcpbars_getpixelwidth_isbase = value; }
    inline void setQCPBars_GetStackedBaseValue_IsBase(bool value) const { qcpbars_getstackedbasevalue_isbase = value; }
    inline void setQCPBars_ConnectBars_IsBase(bool value) const { qcpbars_connectbars_isbase = value; }
    inline void setQCPBars_ApplyFillAntialiasingHint_IsBase(bool value) const { qcpbars_applyfillantialiasinghint_isbase = value; }
    inline void setQCPBars_ApplyScattersAntialiasingHint_IsBase(bool value) const { qcpbars_applyscattersantialiasinghint_isbase = value; }
    inline void setQCPBars_InitializeParentPlot_IsBase(bool value) const { qcpbars_initializeparentplot_isbase = value; }
    inline void setQCPBars_SetParentLayerable_IsBase(bool value) const { qcpbars_setparentlayerable_isbase = value; }
    inline void setQCPBars_MoveToLayer_IsBase(bool value) const { qcpbars_movetolayer_isbase = value; }
    inline void setQCPBars_ApplyAntialiasingHint_IsBase(bool value) const { qcpbars_applyantialiasinghint_isbase = value; }
    inline void setQCPBars_Sender_IsBase(bool value) const { qcpbars_sender_isbase = value; }
    inline void setQCPBars_SenderSignalIndex_IsBase(bool value) const { qcpbars_sendersignalindex_isbase = value; }
    inline void setQCPBars_Receivers_IsBase(bool value) const { qcpbars_receivers_isbase = value; }
    inline void setQCPBars_IsSignalConnected_IsBase(bool value) const { qcpbars_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpbars_metacall_isbase) {
            qcpbars_metacall_isbase = false;
            return QCPBars::qt_metacall(param1, param2, param3);
        } else if (qcpbars_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpbars_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPBars::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPDataSelection selectTestRect(const QRectF& rect, bool onlySelectable) const override {
        if (qcpbars_selecttestrect_isbase) {
            qcpbars_selecttestrect_isbase = false;
            return QCPBars::selectTestRect(rect, onlySelectable);
        } else if (qcpbars_selecttestrect_callback != nullptr) {
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval1 = const_cast<QRectF*>(&rect_ret);
            bool cbval2 = onlySelectable;

            QCPDataSelection* callback_ret = qcpbars_selecttestrect_callback(this, cbval1, cbval2);
            return *callback_ret;
        } else {
            return QCPBars::selectTestRect(rect, onlySelectable);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcpbars_selecttest_isbase) {
            qcpbars_selecttest_isbase = false;
            return QCPBars::selectTest(pos, onlySelectable, details);
        } else if (qcpbars_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcpbars_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPBars::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPRange getKeyRange(bool& foundRange, QCP::SignDomain inSignDomain) const override {
        if (qcpbars_getkeyrange_isbase) {
            qcpbars_getkeyrange_isbase = false;
            return QCPBars::getKeyRange(foundRange, inSignDomain);
        } else if (qcpbars_getkeyrange_callback != nullptr) {
            bool* cbval1 = &foundRange;
            int cbval2 = static_cast<int>(inSignDomain);

            QCPRange* callback_ret = qcpbars_getkeyrange_callback(this, cbval1, cbval2);
            return *callback_ret;
        } else {
            return QCPBars::getKeyRange(foundRange, inSignDomain);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPRange getValueRange(bool& foundRange, QCP::SignDomain inSignDomain, const QCPRange& inKeyRange) const override {
        if (qcpbars_getvaluerange_isbase) {
            qcpbars_getvaluerange_isbase = false;
            return QCPBars::getValueRange(foundRange, inSignDomain, inKeyRange);
        } else if (qcpbars_getvaluerange_callback != nullptr) {
            bool* cbval1 = &foundRange;
            int cbval2 = static_cast<int>(inSignDomain);
            const QCPRange& inKeyRange_ret = inKeyRange;
            // Cast returned reference into pointer
            QCPRange* cbval3 = const_cast<QCPRange*>(&inKeyRange_ret);

            QCPRange* callback_ret = qcpbars_getvaluerange_callback(this, cbval1, cbval2, cbval3);
            return *callback_ret;
        } else {
            return QCPBars::getValueRange(foundRange, inSignDomain, inKeyRange);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QPointF dataPixelPosition(int index) const override {
        if (qcpbars_datapixelposition_isbase) {
            qcpbars_datapixelposition_isbase = false;
            return QCPBars::dataPixelPosition(index);
        } else if (qcpbars_datapixelposition_callback != nullptr) {
            int cbval1 = index;

            QPointF* callback_ret = qcpbars_datapixelposition_callback(this, cbval1);
            return *callback_ret;
        } else {
            return QCPBars::dataPixelPosition(index);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcpbars_draw_isbase) {
            qcpbars_draw_isbase = false;
            QCPBars::draw(painter);
        } else if (qcpbars_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpbars_draw_callback(this, cbval1);
        } else {
            QCPBars::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void drawLegendIcon(QCPPainter* painter, const QRectF& rect) const override {
        if (qcpbars_drawlegendicon_isbase) {
            qcpbars_drawlegendicon_isbase = false;
            QCPBars::drawLegendIcon(painter, rect);
        } else if (qcpbars_drawlegendicon_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval2 = const_cast<QRectF*>(&rect_ret);

            qcpbars_drawlegendicon_callback(this, cbval1, cbval2);
        } else {
            QCPBars::drawLegendIcon(painter, rect);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int dataCount() const override {
        if (qcpbars_datacount_callback != nullptr) {
            int callback_ret = qcpbars_datacount_callback();
            return static_cast<int>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double dataMainKey(int index) const override {
        if (qcpbars_datamainkey_callback != nullptr) {
            int cbval1 = index;

            double callback_ret = qcpbars_datamainkey_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double dataSortKey(int index) const override {
        if (qcpbars_datasortkey_callback != nullptr) {
            int cbval1 = index;

            double callback_ret = qcpbars_datasortkey_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double dataMainValue(int index) const override {
        if (qcpbars_datamainvalue_callback != nullptr) {
            int cbval1 = index;

            double callback_ret = qcpbars_datamainvalue_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPRange dataValueRange(int index) const override {
        if (qcpbars_datavaluerange_callback != nullptr) {
            int cbval1 = index;

            QCPRange* callback_ret = qcpbars_datavaluerange_callback(this, cbval1);
            return *callback_ret;
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool sortKeyIsMainKey() const override {
        if (qcpbars_sortkeyismainkey_callback != nullptr) {
            bool callback_ret = qcpbars_sortkeyismainkey_callback();
            return callback_ret;
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int findBegin(double sortKey, bool expandedRange) const override {
        if (qcpbars_findbegin_callback != nullptr) {
            double cbval1 = sortKey;
            bool cbval2 = expandedRange;

            int callback_ret = qcpbars_findbegin_callback(this, cbval1, cbval2);
            return static_cast<int>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int findEnd(double sortKey, bool expandedRange) const override {
        if (qcpbars_findend_callback != nullptr) {
            double cbval1 = sortKey;
            bool cbval2 = expandedRange;

            int callback_ret = qcpbars_findend_callback(this, cbval1, cbval2);
            return static_cast<int>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPPlottableInterface1D* interface1D() override {
        if (qcpbars_interface1d_isbase) {
            qcpbars_interface1d_isbase = false;
            return QCPBars::interface1D();
        } else if (qcpbars_interface1d_callback != nullptr) {
            QCPPlottableInterface1D* callback_ret = qcpbars_interface1d_callback();
            return callback_ret;
        } else {
            return QCPBars::interface1D();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcpbars_cliprect_isbase) {
            qcpbars_cliprect_isbase = false;
            return QCPBars::clipRect();
        } else if (qcpbars_cliprect_callback != nullptr) {
            QRect* callback_ret = qcpbars_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPBars::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcpbars_selectioncategory_isbase) {
            qcpbars_selectioncategory_isbase = false;
            return QCPBars::selectionCategory();
        } else if (qcpbars_selectioncategory_callback != nullptr) {
            int callback_ret = qcpbars_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPBars::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcpbars_applydefaultantialiasinghint_isbase) {
            qcpbars_applydefaultantialiasinghint_isbase = false;
            QCPBars::applyDefaultAntialiasingHint(painter);
        } else if (qcpbars_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpbars_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPBars::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcpbars_selectevent_isbase) {
            qcpbars_selectevent_isbase = false;
            QCPBars::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcpbars_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcpbars_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPBars::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcpbars_deselectevent_isbase) {
            qcpbars_deselectevent_isbase = false;
            QCPBars::deselectEvent(selectionStateChanged);
        } else if (qcpbars_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcpbars_deselectevent_callback(this, cbval1);
        } else {
            QCPBars::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcpbars_parentplotinitialized_isbase) {
            qcpbars_parentplotinitialized_isbase = false;
            QCPBars::parentPlotInitialized(parentPlot);
        } else if (qcpbars_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpbars_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPBars::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpbars_mousepressevent_isbase) {
            qcpbars_mousepressevent_isbase = false;
            QCPBars::mousePressEvent(event, details);
        } else if (qcpbars_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpbars_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPBars::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpbars_mousemoveevent_isbase) {
            qcpbars_mousemoveevent_isbase = false;
            QCPBars::mouseMoveEvent(event, startPos);
        } else if (qcpbars_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpbars_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPBars::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpbars_mousereleaseevent_isbase) {
            qcpbars_mousereleaseevent_isbase = false;
            QCPBars::mouseReleaseEvent(event, startPos);
        } else if (qcpbars_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpbars_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPBars::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpbars_mousedoubleclickevent_isbase) {
            qcpbars_mousedoubleclickevent_isbase = false;
            QCPBars::mouseDoubleClickEvent(event, details);
        } else if (qcpbars_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpbars_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPBars::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcpbars_wheelevent_isbase) {
            qcpbars_wheelevent_isbase = false;
            QCPBars::wheelEvent(event);
        } else if (qcpbars_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcpbars_wheelevent_callback(this, cbval1);
        } else {
            QCPBars::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpbars_event_isbase) {
            qcpbars_event_isbase = false;
            return QCPBars::event(event);
        } else if (qcpbars_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpbars_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPBars::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpbars_eventfilter_isbase) {
            qcpbars_eventfilter_isbase = false;
            return QCPBars::eventFilter(watched, event);
        } else if (qcpbars_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpbars_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPBars::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpbars_timerevent_isbase) {
            qcpbars_timerevent_isbase = false;
            QCPBars::timerEvent(event);
        } else if (qcpbars_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpbars_timerevent_callback(this, cbval1);
        } else {
            QCPBars::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpbars_childevent_isbase) {
            qcpbars_childevent_isbase = false;
            QCPBars::childEvent(event);
        } else if (qcpbars_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpbars_childevent_callback(this, cbval1);
        } else {
            QCPBars::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpbars_customevent_isbase) {
            qcpbars_customevent_isbase = false;
            QCPBars::customEvent(event);
        } else if (qcpbars_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpbars_customevent_callback(this, cbval1);
        } else {
            QCPBars::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpbars_connectnotify_isbase) {
            qcpbars_connectnotify_isbase = false;
            QCPBars::connectNotify(signal);
        } else if (qcpbars_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpbars_connectnotify_callback(this, cbval1);
        } else {
            QCPBars::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpbars_disconnectnotify_isbase) {
            qcpbars_disconnectnotify_isbase = false;
            QCPBars::disconnectNotify(signal);
        } else if (qcpbars_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpbars_disconnectnotify_callback(this, cbval1);
        } else {
            QCPBars::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    QRectF getBarRect(double key, double value) const {
        if (qcpbars_getbarrect_isbase) {
            qcpbars_getbarrect_isbase = false;
            return QCPBars::getBarRect(key, value);
        } else if (qcpbars_getbarrect_callback != nullptr) {
            double cbval1 = key;
            double cbval2 = value;

            QRectF* callback_ret = qcpbars_getbarrect_callback(this, cbval1, cbval2);
            return *callback_ret;
        } else {
            return QCPBars::getBarRect(key, value);
        }
    }

    // Virtual method for C ABI access and custom callback
    void getPixelWidth(double key, double& lower, double& upper) const {
        if (qcpbars_getpixelwidth_isbase) {
            qcpbars_getpixelwidth_isbase = false;
            QCPBars::getPixelWidth(key, lower, upper);
        } else if (qcpbars_getpixelwidth_callback != nullptr) {
            double cbval1 = key;
            double* cbval2 = &lower;
            double* cbval3 = &upper;

            qcpbars_getpixelwidth_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPBars::getPixelWidth(key, lower, upper);
        }
    }

    // Virtual method for C ABI access and custom callback
    double getStackedBaseValue(double key, bool positive) const {
        if (qcpbars_getstackedbasevalue_isbase) {
            qcpbars_getstackedbasevalue_isbase = false;
            return QCPBars::getStackedBaseValue(key, positive);
        } else if (qcpbars_getstackedbasevalue_callback != nullptr) {
            double cbval1 = key;
            bool cbval2 = positive;

            double callback_ret = qcpbars_getstackedbasevalue_callback(this, cbval1, cbval2);
            return static_cast<double>(callback_ret);
        } else {
            return QCPBars::getStackedBaseValue(key, positive);
        }
    }

    // Virtual method for C ABI access and custom callback
    void connectBars(QCPBars* lower, QCPBars* upper) {
        if (qcpbars_connectbars_isbase) {
            qcpbars_connectbars_isbase = false;
            QCPBars::connectBars(lower, upper);
        } else if (qcpbars_connectbars_callback != nullptr) {
            QCPBars* cbval1 = lower;
            QCPBars* cbval2 = upper;

            qcpbars_connectbars_callback(this, cbval1, cbval2);
        } else {
            QCPBars::connectBars(lower, upper);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyFillAntialiasingHint(QCPPainter* painter) const {
        if (qcpbars_applyfillantialiasinghint_isbase) {
            qcpbars_applyfillantialiasinghint_isbase = false;
            QCPBars::applyFillAntialiasingHint(painter);
        } else if (qcpbars_applyfillantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpbars_applyfillantialiasinghint_callback(this, cbval1);
        } else {
            QCPBars::applyFillAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyScattersAntialiasingHint(QCPPainter* painter) const {
        if (qcpbars_applyscattersantialiasinghint_isbase) {
            qcpbars_applyscattersantialiasinghint_isbase = false;
            QCPBars::applyScattersAntialiasingHint(painter);
        } else if (qcpbars_applyscattersantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpbars_applyscattersantialiasinghint_callback(this, cbval1);
        } else {
            QCPBars::applyScattersAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcpbars_initializeparentplot_isbase) {
            qcpbars_initializeparentplot_isbase = false;
            QCPBars::initializeParentPlot(parentPlot);
        } else if (qcpbars_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpbars_initializeparentplot_callback(this, cbval1);
        } else {
            QCPBars::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcpbars_setparentlayerable_isbase) {
            qcpbars_setparentlayerable_isbase = false;
            QCPBars::setParentLayerable(parentLayerable);
        } else if (qcpbars_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcpbars_setparentlayerable_callback(this, cbval1);
        } else {
            QCPBars::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcpbars_movetolayer_isbase) {
            qcpbars_movetolayer_isbase = false;
            return QCPBars::moveToLayer(layer, prepend);
        } else if (qcpbars_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcpbars_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPBars::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcpbars_applyantialiasinghint_isbase) {
            qcpbars_applyantialiasinghint_isbase = false;
            QCPBars::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcpbars_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcpbars_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPBars::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpbars_sender_isbase) {
            qcpbars_sender_isbase = false;
            return QCPBars::sender();
        } else if (qcpbars_sender_callback != nullptr) {
            QObject* callback_ret = qcpbars_sender_callback();
            return callback_ret;
        } else {
            return QCPBars::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpbars_sendersignalindex_isbase) {
            qcpbars_sendersignalindex_isbase = false;
            return QCPBars::senderSignalIndex();
        } else if (qcpbars_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpbars_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPBars::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpbars_receivers_isbase) {
            qcpbars_receivers_isbase = false;
            return QCPBars::receivers(signal);
        } else if (qcpbars_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpbars_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPBars::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpbars_issignalconnected_isbase) {
            qcpbars_issignalconnected_isbase = false;
            return QCPBars::isSignalConnected(signal);
        } else if (qcpbars_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpbars_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPBars::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPBars_Draw(QCPBars* self, QCPPainter* painter);
    friend void QCPBars_QBaseDraw(QCPBars* self, QCPPainter* painter);
    friend void QCPBars_DrawLegendIcon(const QCPBars* self, QCPPainter* painter, const QRectF* rect);
    friend void QCPBars_QBaseDrawLegendIcon(const QCPBars* self, QCPPainter* painter, const QRectF* rect);
    friend QRect* QCPBars_ClipRect(const QCPBars* self);
    friend QRect* QCPBars_QBaseClipRect(const QCPBars* self);
    friend int QCPBars_SelectionCategory(const QCPBars* self);
    friend int QCPBars_QBaseSelectionCategory(const QCPBars* self);
    friend void QCPBars_ApplyDefaultAntialiasingHint(const QCPBars* self, QCPPainter* painter);
    friend void QCPBars_QBaseApplyDefaultAntialiasingHint(const QCPBars* self, QCPPainter* painter);
    friend void QCPBars_SelectEvent(QCPBars* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPBars_QBaseSelectEvent(QCPBars* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPBars_DeselectEvent(QCPBars* self, bool* selectionStateChanged);
    friend void QCPBars_QBaseDeselectEvent(QCPBars* self, bool* selectionStateChanged);
    friend void QCPBars_ParentPlotInitialized(QCPBars* self, QCustomPlot* parentPlot);
    friend void QCPBars_QBaseParentPlotInitialized(QCPBars* self, QCustomPlot* parentPlot);
    friend void QCPBars_MousePressEvent(QCPBars* self, QMouseEvent* event, const QVariant* details);
    friend void QCPBars_QBaseMousePressEvent(QCPBars* self, QMouseEvent* event, const QVariant* details);
    friend void QCPBars_MouseMoveEvent(QCPBars* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPBars_QBaseMouseMoveEvent(QCPBars* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPBars_MouseReleaseEvent(QCPBars* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPBars_QBaseMouseReleaseEvent(QCPBars* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPBars_MouseDoubleClickEvent(QCPBars* self, QMouseEvent* event, const QVariant* details);
    friend void QCPBars_QBaseMouseDoubleClickEvent(QCPBars* self, QMouseEvent* event, const QVariant* details);
    friend void QCPBars_WheelEvent(QCPBars* self, QWheelEvent* event);
    friend void QCPBars_QBaseWheelEvent(QCPBars* self, QWheelEvent* event);
    friend void QCPBars_TimerEvent(QCPBars* self, QTimerEvent* event);
    friend void QCPBars_QBaseTimerEvent(QCPBars* self, QTimerEvent* event);
    friend void QCPBars_ChildEvent(QCPBars* self, QChildEvent* event);
    friend void QCPBars_QBaseChildEvent(QCPBars* self, QChildEvent* event);
    friend void QCPBars_CustomEvent(QCPBars* self, QEvent* event);
    friend void QCPBars_QBaseCustomEvent(QCPBars* self, QEvent* event);
    friend void QCPBars_ConnectNotify(QCPBars* self, const QMetaMethod* signal);
    friend void QCPBars_QBaseConnectNotify(QCPBars* self, const QMetaMethod* signal);
    friend void QCPBars_DisconnectNotify(QCPBars* self, const QMetaMethod* signal);
    friend void QCPBars_QBaseDisconnectNotify(QCPBars* self, const QMetaMethod* signal);
    friend QRectF* QCPBars_GetBarRect(const QCPBars* self, double key, double value);
    friend QRectF* QCPBars_QBaseGetBarRect(const QCPBars* self, double key, double value);
    friend void QCPBars_GetPixelWidth(const QCPBars* self, double key, double* lower, double* upper);
    friend void QCPBars_QBaseGetPixelWidth(const QCPBars* self, double key, double* lower, double* upper);
    friend double QCPBars_GetStackedBaseValue(const QCPBars* self, double key, bool positive);
    friend double QCPBars_QBaseGetStackedBaseValue(const QCPBars* self, double key, bool positive);
    friend void QCPBars_ConnectBars(QCPBars* self, QCPBars* lower, QCPBars* upper);
    friend void QCPBars_QBaseConnectBars(QCPBars* self, QCPBars* lower, QCPBars* upper);
    friend void QCPBars_ApplyFillAntialiasingHint(const QCPBars* self, QCPPainter* painter);
    friend void QCPBars_QBaseApplyFillAntialiasingHint(const QCPBars* self, QCPPainter* painter);
    friend void QCPBars_ApplyScattersAntialiasingHint(const QCPBars* self, QCPPainter* painter);
    friend void QCPBars_QBaseApplyScattersAntialiasingHint(const QCPBars* self, QCPPainter* painter);
    friend void QCPBars_InitializeParentPlot(QCPBars* self, QCustomPlot* parentPlot);
    friend void QCPBars_QBaseInitializeParentPlot(QCPBars* self, QCustomPlot* parentPlot);
    friend void QCPBars_SetParentLayerable(QCPBars* self, QCPLayerable* parentLayerable);
    friend void QCPBars_QBaseSetParentLayerable(QCPBars* self, QCPLayerable* parentLayerable);
    friend bool QCPBars_MoveToLayer(QCPBars* self, QCPLayer* layer, bool prepend);
    friend bool QCPBars_QBaseMoveToLayer(QCPBars* self, QCPLayer* layer, bool prepend);
    friend void QCPBars_ApplyAntialiasingHint(const QCPBars* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPBars_QBaseApplyAntialiasingHint(const QCPBars* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPBars_Sender(const QCPBars* self);
    friend QObject* QCPBars_QBaseSender(const QCPBars* self);
    friend int QCPBars_SenderSignalIndex(const QCPBars* self);
    friend int QCPBars_QBaseSenderSignalIndex(const QCPBars* self);
    friend int QCPBars_Receivers(const QCPBars* self, const char* signal);
    friend int QCPBars_QBaseReceivers(const QCPBars* self, const char* signal);
    friend bool QCPBars_IsSignalConnected(const QCPBars* self, const QMetaMethod* signal);
    friend bool QCPBars_QBaseIsSignalConnected(const QCPBars* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPStatisticalBox so that we can call protected methods
class VirtualQCPStatisticalBox final : public QCPStatisticalBox {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPStatisticalBox = true;

    // Virtual class public types (including callbacks)
    using QCPStatisticalBox_Metacall_Callback = int (*)(QCPStatisticalBox*, int, int, void**);
    using QCPStatisticalBox_SelectTestRect_Callback = QCPDataSelection* (*)(const QCPStatisticalBox*, QRectF*, bool);
    using QCPStatisticalBox_SelectTest_Callback = double (*)(const QCPStatisticalBox*, QPointF*, bool, QVariant*);
    using QCPStatisticalBox_GetKeyRange_Callback = QCPRange* (*)(const QCPStatisticalBox*, bool*, int);
    using QCPStatisticalBox_GetValueRange_Callback = QCPRange* (*)(const QCPStatisticalBox*, bool*, int, QCPRange*);
    using QCPStatisticalBox_Draw_Callback = void (*)(QCPStatisticalBox*, QCPPainter*);
    using QCPStatisticalBox_DrawLegendIcon_Callback = void (*)(const QCPStatisticalBox*, QCPPainter*, QRectF*);
    using QCPStatisticalBox_DataCount_Callback = int (*)();
    using QCPStatisticalBox_DataMainKey_Callback = double (*)(const QCPStatisticalBox*, int);
    using QCPStatisticalBox_DataSortKey_Callback = double (*)(const QCPStatisticalBox*, int);
    using QCPStatisticalBox_DataMainValue_Callback = double (*)(const QCPStatisticalBox*, int);
    using QCPStatisticalBox_DataValueRange_Callback = QCPRange* (*)(const QCPStatisticalBox*, int);
    using QCPStatisticalBox_DataPixelPosition_Callback = QPointF* (*)(const QCPStatisticalBox*, int);
    using QCPStatisticalBox_SortKeyIsMainKey_Callback = bool (*)();
    using QCPStatisticalBox_FindBegin_Callback = int (*)(const QCPStatisticalBox*, double, bool);
    using QCPStatisticalBox_FindEnd_Callback = int (*)(const QCPStatisticalBox*, double, bool);
    using QCPStatisticalBox_Interface1D_Callback = QCPPlottableInterface1D* (*)();
    using QCPStatisticalBox_ClipRect_Callback = QRect* (*)();
    using QCPStatisticalBox_SelectionCategory_Callback = int (*)();
    using QCPStatisticalBox_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPStatisticalBox*, QCPPainter*);
    using QCPStatisticalBox_SelectEvent_Callback = void (*)(QCPStatisticalBox*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPStatisticalBox_DeselectEvent_Callback = void (*)(QCPStatisticalBox*, bool*);
    using QCPStatisticalBox_ParentPlotInitialized_Callback = void (*)(QCPStatisticalBox*, QCustomPlot*);
    using QCPStatisticalBox_MousePressEvent_Callback = void (*)(QCPStatisticalBox*, QMouseEvent*, QVariant*);
    using QCPStatisticalBox_MouseMoveEvent_Callback = void (*)(QCPStatisticalBox*, QMouseEvent*, QPointF*);
    using QCPStatisticalBox_MouseReleaseEvent_Callback = void (*)(QCPStatisticalBox*, QMouseEvent*, QPointF*);
    using QCPStatisticalBox_MouseDoubleClickEvent_Callback = void (*)(QCPStatisticalBox*, QMouseEvent*, QVariant*);
    using QCPStatisticalBox_WheelEvent_Callback = void (*)(QCPStatisticalBox*, QWheelEvent*);
    using QCPStatisticalBox_Event_Callback = bool (*)(QCPStatisticalBox*, QEvent*);
    using QCPStatisticalBox_EventFilter_Callback = bool (*)(QCPStatisticalBox*, QObject*, QEvent*);
    using QCPStatisticalBox_TimerEvent_Callback = void (*)(QCPStatisticalBox*, QTimerEvent*);
    using QCPStatisticalBox_ChildEvent_Callback = void (*)(QCPStatisticalBox*, QChildEvent*);
    using QCPStatisticalBox_CustomEvent_Callback = void (*)(QCPStatisticalBox*, QEvent*);
    using QCPStatisticalBox_ConnectNotify_Callback = void (*)(QCPStatisticalBox*, QMetaMethod*);
    using QCPStatisticalBox_DisconnectNotify_Callback = void (*)(QCPStatisticalBox*, QMetaMethod*);
    using QCPStatisticalBox_ApplyFillAntialiasingHint_Callback = void (*)(const QCPStatisticalBox*, QCPPainter*);
    using QCPStatisticalBox_ApplyScattersAntialiasingHint_Callback = void (*)(const QCPStatisticalBox*, QCPPainter*);
    using QCPStatisticalBox_InitializeParentPlot_Callback = void (*)(QCPStatisticalBox*, QCustomPlot*);
    using QCPStatisticalBox_SetParentLayerable_Callback = void (*)(QCPStatisticalBox*, QCPLayerable*);
    using QCPStatisticalBox_MoveToLayer_Callback = bool (*)(QCPStatisticalBox*, QCPLayer*, bool);
    using QCPStatisticalBox_ApplyAntialiasingHint_Callback = void (*)(const QCPStatisticalBox*, QCPPainter*, bool, int);
    using QCPStatisticalBox_Sender_Callback = QObject* (*)();
    using QCPStatisticalBox_SenderSignalIndex_Callback = int (*)();
    using QCPStatisticalBox_Receivers_Callback = int (*)(const QCPStatisticalBox*, const char*);
    using QCPStatisticalBox_IsSignalConnected_Callback = bool (*)(const QCPStatisticalBox*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPStatisticalBox_Metacall_Callback qcpstatisticalbox_metacall_callback = nullptr;
    QCPStatisticalBox_SelectTestRect_Callback qcpstatisticalbox_selecttestrect_callback = nullptr;
    QCPStatisticalBox_SelectTest_Callback qcpstatisticalbox_selecttest_callback = nullptr;
    QCPStatisticalBox_GetKeyRange_Callback qcpstatisticalbox_getkeyrange_callback = nullptr;
    QCPStatisticalBox_GetValueRange_Callback qcpstatisticalbox_getvaluerange_callback = nullptr;
    QCPStatisticalBox_Draw_Callback qcpstatisticalbox_draw_callback = nullptr;
    QCPStatisticalBox_DrawLegendIcon_Callback qcpstatisticalbox_drawlegendicon_callback = nullptr;
    QCPStatisticalBox_DataCount_Callback qcpstatisticalbox_datacount_callback = nullptr;
    QCPStatisticalBox_DataMainKey_Callback qcpstatisticalbox_datamainkey_callback = nullptr;
    QCPStatisticalBox_DataSortKey_Callback qcpstatisticalbox_datasortkey_callback = nullptr;
    QCPStatisticalBox_DataMainValue_Callback qcpstatisticalbox_datamainvalue_callback = nullptr;
    QCPStatisticalBox_DataValueRange_Callback qcpstatisticalbox_datavaluerange_callback = nullptr;
    QCPStatisticalBox_DataPixelPosition_Callback qcpstatisticalbox_datapixelposition_callback = nullptr;
    QCPStatisticalBox_SortKeyIsMainKey_Callback qcpstatisticalbox_sortkeyismainkey_callback = nullptr;
    QCPStatisticalBox_FindBegin_Callback qcpstatisticalbox_findbegin_callback = nullptr;
    QCPStatisticalBox_FindEnd_Callback qcpstatisticalbox_findend_callback = nullptr;
    QCPStatisticalBox_Interface1D_Callback qcpstatisticalbox_interface1d_callback = nullptr;
    QCPStatisticalBox_ClipRect_Callback qcpstatisticalbox_cliprect_callback = nullptr;
    QCPStatisticalBox_SelectionCategory_Callback qcpstatisticalbox_selectioncategory_callback = nullptr;
    QCPStatisticalBox_ApplyDefaultAntialiasingHint_Callback qcpstatisticalbox_applydefaultantialiasinghint_callback = nullptr;
    QCPStatisticalBox_SelectEvent_Callback qcpstatisticalbox_selectevent_callback = nullptr;
    QCPStatisticalBox_DeselectEvent_Callback qcpstatisticalbox_deselectevent_callback = nullptr;
    QCPStatisticalBox_ParentPlotInitialized_Callback qcpstatisticalbox_parentplotinitialized_callback = nullptr;
    QCPStatisticalBox_MousePressEvent_Callback qcpstatisticalbox_mousepressevent_callback = nullptr;
    QCPStatisticalBox_MouseMoveEvent_Callback qcpstatisticalbox_mousemoveevent_callback = nullptr;
    QCPStatisticalBox_MouseReleaseEvent_Callback qcpstatisticalbox_mousereleaseevent_callback = nullptr;
    QCPStatisticalBox_MouseDoubleClickEvent_Callback qcpstatisticalbox_mousedoubleclickevent_callback = nullptr;
    QCPStatisticalBox_WheelEvent_Callback qcpstatisticalbox_wheelevent_callback = nullptr;
    QCPStatisticalBox_Event_Callback qcpstatisticalbox_event_callback = nullptr;
    QCPStatisticalBox_EventFilter_Callback qcpstatisticalbox_eventfilter_callback = nullptr;
    QCPStatisticalBox_TimerEvent_Callback qcpstatisticalbox_timerevent_callback = nullptr;
    QCPStatisticalBox_ChildEvent_Callback qcpstatisticalbox_childevent_callback = nullptr;
    QCPStatisticalBox_CustomEvent_Callback qcpstatisticalbox_customevent_callback = nullptr;
    QCPStatisticalBox_ConnectNotify_Callback qcpstatisticalbox_connectnotify_callback = nullptr;
    QCPStatisticalBox_DisconnectNotify_Callback qcpstatisticalbox_disconnectnotify_callback = nullptr;
    QCPStatisticalBox_ApplyFillAntialiasingHint_Callback qcpstatisticalbox_applyfillantialiasinghint_callback = nullptr;
    QCPStatisticalBox_ApplyScattersAntialiasingHint_Callback qcpstatisticalbox_applyscattersantialiasinghint_callback = nullptr;
    QCPStatisticalBox_InitializeParentPlot_Callback qcpstatisticalbox_initializeparentplot_callback = nullptr;
    QCPStatisticalBox_SetParentLayerable_Callback qcpstatisticalbox_setparentlayerable_callback = nullptr;
    QCPStatisticalBox_MoveToLayer_Callback qcpstatisticalbox_movetolayer_callback = nullptr;
    QCPStatisticalBox_ApplyAntialiasingHint_Callback qcpstatisticalbox_applyantialiasinghint_callback = nullptr;
    QCPStatisticalBox_Sender_Callback qcpstatisticalbox_sender_callback = nullptr;
    QCPStatisticalBox_SenderSignalIndex_Callback qcpstatisticalbox_sendersignalindex_callback = nullptr;
    QCPStatisticalBox_Receivers_Callback qcpstatisticalbox_receivers_callback = nullptr;
    QCPStatisticalBox_IsSignalConnected_Callback qcpstatisticalbox_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpstatisticalbox_metacall_isbase = false;
    mutable bool qcpstatisticalbox_selecttestrect_isbase = false;
    mutable bool qcpstatisticalbox_selecttest_isbase = false;
    mutable bool qcpstatisticalbox_getkeyrange_isbase = false;
    mutable bool qcpstatisticalbox_getvaluerange_isbase = false;
    mutable bool qcpstatisticalbox_draw_isbase = false;
    mutable bool qcpstatisticalbox_drawlegendicon_isbase = false;
    mutable bool qcpstatisticalbox_datacount_isbase = false;
    mutable bool qcpstatisticalbox_datamainkey_isbase = false;
    mutable bool qcpstatisticalbox_datasortkey_isbase = false;
    mutable bool qcpstatisticalbox_datamainvalue_isbase = false;
    mutable bool qcpstatisticalbox_datavaluerange_isbase = false;
    mutable bool qcpstatisticalbox_datapixelposition_isbase = false;
    mutable bool qcpstatisticalbox_sortkeyismainkey_isbase = false;
    mutable bool qcpstatisticalbox_findbegin_isbase = false;
    mutable bool qcpstatisticalbox_findend_isbase = false;
    mutable bool qcpstatisticalbox_interface1d_isbase = false;
    mutable bool qcpstatisticalbox_cliprect_isbase = false;
    mutable bool qcpstatisticalbox_selectioncategory_isbase = false;
    mutable bool qcpstatisticalbox_applydefaultantialiasinghint_isbase = false;
    mutable bool qcpstatisticalbox_selectevent_isbase = false;
    mutable bool qcpstatisticalbox_deselectevent_isbase = false;
    mutable bool qcpstatisticalbox_parentplotinitialized_isbase = false;
    mutable bool qcpstatisticalbox_mousepressevent_isbase = false;
    mutable bool qcpstatisticalbox_mousemoveevent_isbase = false;
    mutable bool qcpstatisticalbox_mousereleaseevent_isbase = false;
    mutable bool qcpstatisticalbox_mousedoubleclickevent_isbase = false;
    mutable bool qcpstatisticalbox_wheelevent_isbase = false;
    mutable bool qcpstatisticalbox_event_isbase = false;
    mutable bool qcpstatisticalbox_eventfilter_isbase = false;
    mutable bool qcpstatisticalbox_timerevent_isbase = false;
    mutable bool qcpstatisticalbox_childevent_isbase = false;
    mutable bool qcpstatisticalbox_customevent_isbase = false;
    mutable bool qcpstatisticalbox_connectnotify_isbase = false;
    mutable bool qcpstatisticalbox_disconnectnotify_isbase = false;
    mutable bool qcpstatisticalbox_applyfillantialiasinghint_isbase = false;
    mutable bool qcpstatisticalbox_applyscattersantialiasinghint_isbase = false;
    mutable bool qcpstatisticalbox_initializeparentplot_isbase = false;
    mutable bool qcpstatisticalbox_setparentlayerable_isbase = false;
    mutable bool qcpstatisticalbox_movetolayer_isbase = false;
    mutable bool qcpstatisticalbox_applyantialiasinghint_isbase = false;
    mutable bool qcpstatisticalbox_sender_isbase = false;
    mutable bool qcpstatisticalbox_sendersignalindex_isbase = false;
    mutable bool qcpstatisticalbox_receivers_isbase = false;
    mutable bool qcpstatisticalbox_issignalconnected_isbase = false;

  public:
    VirtualQCPStatisticalBox(QCPAxis* keyAxis, QCPAxis* valueAxis) : QCPStatisticalBox(keyAxis, valueAxis) {};

    ~VirtualQCPStatisticalBox() {
        qcpstatisticalbox_metacall_callback = nullptr;
        qcpstatisticalbox_selecttestrect_callback = nullptr;
        qcpstatisticalbox_selecttest_callback = nullptr;
        qcpstatisticalbox_getkeyrange_callback = nullptr;
        qcpstatisticalbox_getvaluerange_callback = nullptr;
        qcpstatisticalbox_draw_callback = nullptr;
        qcpstatisticalbox_drawlegendicon_callback = nullptr;
        qcpstatisticalbox_datacount_callback = nullptr;
        qcpstatisticalbox_datamainkey_callback = nullptr;
        qcpstatisticalbox_datasortkey_callback = nullptr;
        qcpstatisticalbox_datamainvalue_callback = nullptr;
        qcpstatisticalbox_datavaluerange_callback = nullptr;
        qcpstatisticalbox_datapixelposition_callback = nullptr;
        qcpstatisticalbox_sortkeyismainkey_callback = nullptr;
        qcpstatisticalbox_findbegin_callback = nullptr;
        qcpstatisticalbox_findend_callback = nullptr;
        qcpstatisticalbox_interface1d_callback = nullptr;
        qcpstatisticalbox_cliprect_callback = nullptr;
        qcpstatisticalbox_selectioncategory_callback = nullptr;
        qcpstatisticalbox_applydefaultantialiasinghint_callback = nullptr;
        qcpstatisticalbox_selectevent_callback = nullptr;
        qcpstatisticalbox_deselectevent_callback = nullptr;
        qcpstatisticalbox_parentplotinitialized_callback = nullptr;
        qcpstatisticalbox_mousepressevent_callback = nullptr;
        qcpstatisticalbox_mousemoveevent_callback = nullptr;
        qcpstatisticalbox_mousereleaseevent_callback = nullptr;
        qcpstatisticalbox_mousedoubleclickevent_callback = nullptr;
        qcpstatisticalbox_wheelevent_callback = nullptr;
        qcpstatisticalbox_event_callback = nullptr;
        qcpstatisticalbox_eventfilter_callback = nullptr;
        qcpstatisticalbox_timerevent_callback = nullptr;
        qcpstatisticalbox_childevent_callback = nullptr;
        qcpstatisticalbox_customevent_callback = nullptr;
        qcpstatisticalbox_connectnotify_callback = nullptr;
        qcpstatisticalbox_disconnectnotify_callback = nullptr;
        qcpstatisticalbox_applyfillantialiasinghint_callback = nullptr;
        qcpstatisticalbox_applyscattersantialiasinghint_callback = nullptr;
        qcpstatisticalbox_initializeparentplot_callback = nullptr;
        qcpstatisticalbox_setparentlayerable_callback = nullptr;
        qcpstatisticalbox_movetolayer_callback = nullptr;
        qcpstatisticalbox_applyantialiasinghint_callback = nullptr;
        qcpstatisticalbox_sender_callback = nullptr;
        qcpstatisticalbox_sendersignalindex_callback = nullptr;
        qcpstatisticalbox_receivers_callback = nullptr;
        qcpstatisticalbox_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPStatisticalBox_Metacall_Callback(QCPStatisticalBox_Metacall_Callback cb) { qcpstatisticalbox_metacall_callback = cb; }
    inline void setQCPStatisticalBox_SelectTestRect_Callback(QCPStatisticalBox_SelectTestRect_Callback cb) { qcpstatisticalbox_selecttestrect_callback = cb; }
    inline void setQCPStatisticalBox_SelectTest_Callback(QCPStatisticalBox_SelectTest_Callback cb) { qcpstatisticalbox_selecttest_callback = cb; }
    inline void setQCPStatisticalBox_GetKeyRange_Callback(QCPStatisticalBox_GetKeyRange_Callback cb) { qcpstatisticalbox_getkeyrange_callback = cb; }
    inline void setQCPStatisticalBox_GetValueRange_Callback(QCPStatisticalBox_GetValueRange_Callback cb) { qcpstatisticalbox_getvaluerange_callback = cb; }
    inline void setQCPStatisticalBox_Draw_Callback(QCPStatisticalBox_Draw_Callback cb) { qcpstatisticalbox_draw_callback = cb; }
    inline void setQCPStatisticalBox_DrawLegendIcon_Callback(QCPStatisticalBox_DrawLegendIcon_Callback cb) { qcpstatisticalbox_drawlegendicon_callback = cb; }
    inline void setQCPStatisticalBox_DataCount_Callback(QCPStatisticalBox_DataCount_Callback cb) { qcpstatisticalbox_datacount_callback = cb; }
    inline void setQCPStatisticalBox_DataMainKey_Callback(QCPStatisticalBox_DataMainKey_Callback cb) { qcpstatisticalbox_datamainkey_callback = cb; }
    inline void setQCPStatisticalBox_DataSortKey_Callback(QCPStatisticalBox_DataSortKey_Callback cb) { qcpstatisticalbox_datasortkey_callback = cb; }
    inline void setQCPStatisticalBox_DataMainValue_Callback(QCPStatisticalBox_DataMainValue_Callback cb) { qcpstatisticalbox_datamainvalue_callback = cb; }
    inline void setQCPStatisticalBox_DataValueRange_Callback(QCPStatisticalBox_DataValueRange_Callback cb) { qcpstatisticalbox_datavaluerange_callback = cb; }
    inline void setQCPStatisticalBox_DataPixelPosition_Callback(QCPStatisticalBox_DataPixelPosition_Callback cb) { qcpstatisticalbox_datapixelposition_callback = cb; }
    inline void setQCPStatisticalBox_SortKeyIsMainKey_Callback(QCPStatisticalBox_SortKeyIsMainKey_Callback cb) { qcpstatisticalbox_sortkeyismainkey_callback = cb; }
    inline void setQCPStatisticalBox_FindBegin_Callback(QCPStatisticalBox_FindBegin_Callback cb) { qcpstatisticalbox_findbegin_callback = cb; }
    inline void setQCPStatisticalBox_FindEnd_Callback(QCPStatisticalBox_FindEnd_Callback cb) { qcpstatisticalbox_findend_callback = cb; }
    inline void setQCPStatisticalBox_Interface1D_Callback(QCPStatisticalBox_Interface1D_Callback cb) { qcpstatisticalbox_interface1d_callback = cb; }
    inline void setQCPStatisticalBox_ClipRect_Callback(QCPStatisticalBox_ClipRect_Callback cb) { qcpstatisticalbox_cliprect_callback = cb; }
    inline void setQCPStatisticalBox_SelectionCategory_Callback(QCPStatisticalBox_SelectionCategory_Callback cb) { qcpstatisticalbox_selectioncategory_callback = cb; }
    inline void setQCPStatisticalBox_ApplyDefaultAntialiasingHint_Callback(QCPStatisticalBox_ApplyDefaultAntialiasingHint_Callback cb) { qcpstatisticalbox_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPStatisticalBox_SelectEvent_Callback(QCPStatisticalBox_SelectEvent_Callback cb) { qcpstatisticalbox_selectevent_callback = cb; }
    inline void setQCPStatisticalBox_DeselectEvent_Callback(QCPStatisticalBox_DeselectEvent_Callback cb) { qcpstatisticalbox_deselectevent_callback = cb; }
    inline void setQCPStatisticalBox_ParentPlotInitialized_Callback(QCPStatisticalBox_ParentPlotInitialized_Callback cb) { qcpstatisticalbox_parentplotinitialized_callback = cb; }
    inline void setQCPStatisticalBox_MousePressEvent_Callback(QCPStatisticalBox_MousePressEvent_Callback cb) { qcpstatisticalbox_mousepressevent_callback = cb; }
    inline void setQCPStatisticalBox_MouseMoveEvent_Callback(QCPStatisticalBox_MouseMoveEvent_Callback cb) { qcpstatisticalbox_mousemoveevent_callback = cb; }
    inline void setQCPStatisticalBox_MouseReleaseEvent_Callback(QCPStatisticalBox_MouseReleaseEvent_Callback cb) { qcpstatisticalbox_mousereleaseevent_callback = cb; }
    inline void setQCPStatisticalBox_MouseDoubleClickEvent_Callback(QCPStatisticalBox_MouseDoubleClickEvent_Callback cb) { qcpstatisticalbox_mousedoubleclickevent_callback = cb; }
    inline void setQCPStatisticalBox_WheelEvent_Callback(QCPStatisticalBox_WheelEvent_Callback cb) { qcpstatisticalbox_wheelevent_callback = cb; }
    inline void setQCPStatisticalBox_Event_Callback(QCPStatisticalBox_Event_Callback cb) { qcpstatisticalbox_event_callback = cb; }
    inline void setQCPStatisticalBox_EventFilter_Callback(QCPStatisticalBox_EventFilter_Callback cb) { qcpstatisticalbox_eventfilter_callback = cb; }
    inline void setQCPStatisticalBox_TimerEvent_Callback(QCPStatisticalBox_TimerEvent_Callback cb) { qcpstatisticalbox_timerevent_callback = cb; }
    inline void setQCPStatisticalBox_ChildEvent_Callback(QCPStatisticalBox_ChildEvent_Callback cb) { qcpstatisticalbox_childevent_callback = cb; }
    inline void setQCPStatisticalBox_CustomEvent_Callback(QCPStatisticalBox_CustomEvent_Callback cb) { qcpstatisticalbox_customevent_callback = cb; }
    inline void setQCPStatisticalBox_ConnectNotify_Callback(QCPStatisticalBox_ConnectNotify_Callback cb) { qcpstatisticalbox_connectnotify_callback = cb; }
    inline void setQCPStatisticalBox_DisconnectNotify_Callback(QCPStatisticalBox_DisconnectNotify_Callback cb) { qcpstatisticalbox_disconnectnotify_callback = cb; }
    inline void setQCPStatisticalBox_ApplyFillAntialiasingHint_Callback(QCPStatisticalBox_ApplyFillAntialiasingHint_Callback cb) { qcpstatisticalbox_applyfillantialiasinghint_callback = cb; }
    inline void setQCPStatisticalBox_ApplyScattersAntialiasingHint_Callback(QCPStatisticalBox_ApplyScattersAntialiasingHint_Callback cb) { qcpstatisticalbox_applyscattersantialiasinghint_callback = cb; }
    inline void setQCPStatisticalBox_InitializeParentPlot_Callback(QCPStatisticalBox_InitializeParentPlot_Callback cb) { qcpstatisticalbox_initializeparentplot_callback = cb; }
    inline void setQCPStatisticalBox_SetParentLayerable_Callback(QCPStatisticalBox_SetParentLayerable_Callback cb) { qcpstatisticalbox_setparentlayerable_callback = cb; }
    inline void setQCPStatisticalBox_MoveToLayer_Callback(QCPStatisticalBox_MoveToLayer_Callback cb) { qcpstatisticalbox_movetolayer_callback = cb; }
    inline void setQCPStatisticalBox_ApplyAntialiasingHint_Callback(QCPStatisticalBox_ApplyAntialiasingHint_Callback cb) { qcpstatisticalbox_applyantialiasinghint_callback = cb; }
    inline void setQCPStatisticalBox_Sender_Callback(QCPStatisticalBox_Sender_Callback cb) { qcpstatisticalbox_sender_callback = cb; }
    inline void setQCPStatisticalBox_SenderSignalIndex_Callback(QCPStatisticalBox_SenderSignalIndex_Callback cb) { qcpstatisticalbox_sendersignalindex_callback = cb; }
    inline void setQCPStatisticalBox_Receivers_Callback(QCPStatisticalBox_Receivers_Callback cb) { qcpstatisticalbox_receivers_callback = cb; }
    inline void setQCPStatisticalBox_IsSignalConnected_Callback(QCPStatisticalBox_IsSignalConnected_Callback cb) { qcpstatisticalbox_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPStatisticalBox_Metacall_IsBase(bool value) const { qcpstatisticalbox_metacall_isbase = value; }
    inline void setQCPStatisticalBox_SelectTestRect_IsBase(bool value) const { qcpstatisticalbox_selecttestrect_isbase = value; }
    inline void setQCPStatisticalBox_SelectTest_IsBase(bool value) const { qcpstatisticalbox_selecttest_isbase = value; }
    inline void setQCPStatisticalBox_GetKeyRange_IsBase(bool value) const { qcpstatisticalbox_getkeyrange_isbase = value; }
    inline void setQCPStatisticalBox_GetValueRange_IsBase(bool value) const { qcpstatisticalbox_getvaluerange_isbase = value; }
    inline void setQCPStatisticalBox_Draw_IsBase(bool value) const { qcpstatisticalbox_draw_isbase = value; }
    inline void setQCPStatisticalBox_DrawLegendIcon_IsBase(bool value) const { qcpstatisticalbox_drawlegendicon_isbase = value; }
    inline void setQCPStatisticalBox_DataCount_IsBase(bool value) const { qcpstatisticalbox_datacount_isbase = value; }
    inline void setQCPStatisticalBox_DataMainKey_IsBase(bool value) const { qcpstatisticalbox_datamainkey_isbase = value; }
    inline void setQCPStatisticalBox_DataSortKey_IsBase(bool value) const { qcpstatisticalbox_datasortkey_isbase = value; }
    inline void setQCPStatisticalBox_DataMainValue_IsBase(bool value) const { qcpstatisticalbox_datamainvalue_isbase = value; }
    inline void setQCPStatisticalBox_DataValueRange_IsBase(bool value) const { qcpstatisticalbox_datavaluerange_isbase = value; }
    inline void setQCPStatisticalBox_DataPixelPosition_IsBase(bool value) const { qcpstatisticalbox_datapixelposition_isbase = value; }
    inline void setQCPStatisticalBox_SortKeyIsMainKey_IsBase(bool value) const { qcpstatisticalbox_sortkeyismainkey_isbase = value; }
    inline void setQCPStatisticalBox_FindBegin_IsBase(bool value) const { qcpstatisticalbox_findbegin_isbase = value; }
    inline void setQCPStatisticalBox_FindEnd_IsBase(bool value) const { qcpstatisticalbox_findend_isbase = value; }
    inline void setQCPStatisticalBox_Interface1D_IsBase(bool value) const { qcpstatisticalbox_interface1d_isbase = value; }
    inline void setQCPStatisticalBox_ClipRect_IsBase(bool value) const { qcpstatisticalbox_cliprect_isbase = value; }
    inline void setQCPStatisticalBox_SelectionCategory_IsBase(bool value) const { qcpstatisticalbox_selectioncategory_isbase = value; }
    inline void setQCPStatisticalBox_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcpstatisticalbox_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPStatisticalBox_SelectEvent_IsBase(bool value) const { qcpstatisticalbox_selectevent_isbase = value; }
    inline void setQCPStatisticalBox_DeselectEvent_IsBase(bool value) const { qcpstatisticalbox_deselectevent_isbase = value; }
    inline void setQCPStatisticalBox_ParentPlotInitialized_IsBase(bool value) const { qcpstatisticalbox_parentplotinitialized_isbase = value; }
    inline void setQCPStatisticalBox_MousePressEvent_IsBase(bool value) const { qcpstatisticalbox_mousepressevent_isbase = value; }
    inline void setQCPStatisticalBox_MouseMoveEvent_IsBase(bool value) const { qcpstatisticalbox_mousemoveevent_isbase = value; }
    inline void setQCPStatisticalBox_MouseReleaseEvent_IsBase(bool value) const { qcpstatisticalbox_mousereleaseevent_isbase = value; }
    inline void setQCPStatisticalBox_MouseDoubleClickEvent_IsBase(bool value) const { qcpstatisticalbox_mousedoubleclickevent_isbase = value; }
    inline void setQCPStatisticalBox_WheelEvent_IsBase(bool value) const { qcpstatisticalbox_wheelevent_isbase = value; }
    inline void setQCPStatisticalBox_Event_IsBase(bool value) const { qcpstatisticalbox_event_isbase = value; }
    inline void setQCPStatisticalBox_EventFilter_IsBase(bool value) const { qcpstatisticalbox_eventfilter_isbase = value; }
    inline void setQCPStatisticalBox_TimerEvent_IsBase(bool value) const { qcpstatisticalbox_timerevent_isbase = value; }
    inline void setQCPStatisticalBox_ChildEvent_IsBase(bool value) const { qcpstatisticalbox_childevent_isbase = value; }
    inline void setQCPStatisticalBox_CustomEvent_IsBase(bool value) const { qcpstatisticalbox_customevent_isbase = value; }
    inline void setQCPStatisticalBox_ConnectNotify_IsBase(bool value) const { qcpstatisticalbox_connectnotify_isbase = value; }
    inline void setQCPStatisticalBox_DisconnectNotify_IsBase(bool value) const { qcpstatisticalbox_disconnectnotify_isbase = value; }
    inline void setQCPStatisticalBox_ApplyFillAntialiasingHint_IsBase(bool value) const { qcpstatisticalbox_applyfillantialiasinghint_isbase = value; }
    inline void setQCPStatisticalBox_ApplyScattersAntialiasingHint_IsBase(bool value) const { qcpstatisticalbox_applyscattersantialiasinghint_isbase = value; }
    inline void setQCPStatisticalBox_InitializeParentPlot_IsBase(bool value) const { qcpstatisticalbox_initializeparentplot_isbase = value; }
    inline void setQCPStatisticalBox_SetParentLayerable_IsBase(bool value) const { qcpstatisticalbox_setparentlayerable_isbase = value; }
    inline void setQCPStatisticalBox_MoveToLayer_IsBase(bool value) const { qcpstatisticalbox_movetolayer_isbase = value; }
    inline void setQCPStatisticalBox_ApplyAntialiasingHint_IsBase(bool value) const { qcpstatisticalbox_applyantialiasinghint_isbase = value; }
    inline void setQCPStatisticalBox_Sender_IsBase(bool value) const { qcpstatisticalbox_sender_isbase = value; }
    inline void setQCPStatisticalBox_SenderSignalIndex_IsBase(bool value) const { qcpstatisticalbox_sendersignalindex_isbase = value; }
    inline void setQCPStatisticalBox_Receivers_IsBase(bool value) const { qcpstatisticalbox_receivers_isbase = value; }
    inline void setQCPStatisticalBox_IsSignalConnected_IsBase(bool value) const { qcpstatisticalbox_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpstatisticalbox_metacall_isbase) {
            qcpstatisticalbox_metacall_isbase = false;
            return QCPStatisticalBox::qt_metacall(param1, param2, param3);
        } else if (qcpstatisticalbox_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpstatisticalbox_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPStatisticalBox::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPDataSelection selectTestRect(const QRectF& rect, bool onlySelectable) const override {
        if (qcpstatisticalbox_selecttestrect_isbase) {
            qcpstatisticalbox_selecttestrect_isbase = false;
            return QCPStatisticalBox::selectTestRect(rect, onlySelectable);
        } else if (qcpstatisticalbox_selecttestrect_callback != nullptr) {
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval1 = const_cast<QRectF*>(&rect_ret);
            bool cbval2 = onlySelectable;

            QCPDataSelection* callback_ret = qcpstatisticalbox_selecttestrect_callback(this, cbval1, cbval2);
            return *callback_ret;
        } else {
            return QCPStatisticalBox::selectTestRect(rect, onlySelectable);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcpstatisticalbox_selecttest_isbase) {
            qcpstatisticalbox_selecttest_isbase = false;
            return QCPStatisticalBox::selectTest(pos, onlySelectable, details);
        } else if (qcpstatisticalbox_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcpstatisticalbox_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPStatisticalBox::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPRange getKeyRange(bool& foundRange, QCP::SignDomain inSignDomain) const override {
        if (qcpstatisticalbox_getkeyrange_isbase) {
            qcpstatisticalbox_getkeyrange_isbase = false;
            return QCPStatisticalBox::getKeyRange(foundRange, inSignDomain);
        } else if (qcpstatisticalbox_getkeyrange_callback != nullptr) {
            bool* cbval1 = &foundRange;
            int cbval2 = static_cast<int>(inSignDomain);

            QCPRange* callback_ret = qcpstatisticalbox_getkeyrange_callback(this, cbval1, cbval2);
            return *callback_ret;
        } else {
            return QCPStatisticalBox::getKeyRange(foundRange, inSignDomain);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPRange getValueRange(bool& foundRange, QCP::SignDomain inSignDomain, const QCPRange& inKeyRange) const override {
        if (qcpstatisticalbox_getvaluerange_isbase) {
            qcpstatisticalbox_getvaluerange_isbase = false;
            return QCPStatisticalBox::getValueRange(foundRange, inSignDomain, inKeyRange);
        } else if (qcpstatisticalbox_getvaluerange_callback != nullptr) {
            bool* cbval1 = &foundRange;
            int cbval2 = static_cast<int>(inSignDomain);
            const QCPRange& inKeyRange_ret = inKeyRange;
            // Cast returned reference into pointer
            QCPRange* cbval3 = const_cast<QCPRange*>(&inKeyRange_ret);

            QCPRange* callback_ret = qcpstatisticalbox_getvaluerange_callback(this, cbval1, cbval2, cbval3);
            return *callback_ret;
        } else {
            return QCPStatisticalBox::getValueRange(foundRange, inSignDomain, inKeyRange);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcpstatisticalbox_draw_isbase) {
            qcpstatisticalbox_draw_isbase = false;
            QCPStatisticalBox::draw(painter);
        } else if (qcpstatisticalbox_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpstatisticalbox_draw_callback(this, cbval1);
        } else {
            QCPStatisticalBox::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void drawLegendIcon(QCPPainter* painter, const QRectF& rect) const override {
        if (qcpstatisticalbox_drawlegendicon_isbase) {
            qcpstatisticalbox_drawlegendicon_isbase = false;
            QCPStatisticalBox::drawLegendIcon(painter, rect);
        } else if (qcpstatisticalbox_drawlegendicon_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval2 = const_cast<QRectF*>(&rect_ret);

            qcpstatisticalbox_drawlegendicon_callback(this, cbval1, cbval2);
        } else {
            QCPStatisticalBox::drawLegendIcon(painter, rect);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int dataCount() const override {
        if (qcpstatisticalbox_datacount_callback != nullptr) {
            int callback_ret = qcpstatisticalbox_datacount_callback();
            return static_cast<int>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double dataMainKey(int index) const override {
        if (qcpstatisticalbox_datamainkey_callback != nullptr) {
            int cbval1 = index;

            double callback_ret = qcpstatisticalbox_datamainkey_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double dataSortKey(int index) const override {
        if (qcpstatisticalbox_datasortkey_callback != nullptr) {
            int cbval1 = index;

            double callback_ret = qcpstatisticalbox_datasortkey_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double dataMainValue(int index) const override {
        if (qcpstatisticalbox_datamainvalue_callback != nullptr) {
            int cbval1 = index;

            double callback_ret = qcpstatisticalbox_datamainvalue_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPRange dataValueRange(int index) const override {
        if (qcpstatisticalbox_datavaluerange_callback != nullptr) {
            int cbval1 = index;

            QCPRange* callback_ret = qcpstatisticalbox_datavaluerange_callback(this, cbval1);
            return *callback_ret;
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QPointF dataPixelPosition(int index) const override {
        if (qcpstatisticalbox_datapixelposition_callback != nullptr) {
            int cbval1 = index;

            QPointF* callback_ret = qcpstatisticalbox_datapixelposition_callback(this, cbval1);
            return *callback_ret;
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool sortKeyIsMainKey() const override {
        if (qcpstatisticalbox_sortkeyismainkey_callback != nullptr) {
            bool callback_ret = qcpstatisticalbox_sortkeyismainkey_callback();
            return callback_ret;
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int findBegin(double sortKey, bool expandedRange) const override {
        if (qcpstatisticalbox_findbegin_callback != nullptr) {
            double cbval1 = sortKey;
            bool cbval2 = expandedRange;

            int callback_ret = qcpstatisticalbox_findbegin_callback(this, cbval1, cbval2);
            return static_cast<int>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int findEnd(double sortKey, bool expandedRange) const override {
        if (qcpstatisticalbox_findend_callback != nullptr) {
            double cbval1 = sortKey;
            bool cbval2 = expandedRange;

            int callback_ret = qcpstatisticalbox_findend_callback(this, cbval1, cbval2);
            return static_cast<int>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPPlottableInterface1D* interface1D() override {
        if (qcpstatisticalbox_interface1d_isbase) {
            qcpstatisticalbox_interface1d_isbase = false;
            return QCPStatisticalBox::interface1D();
        } else if (qcpstatisticalbox_interface1d_callback != nullptr) {
            QCPPlottableInterface1D* callback_ret = qcpstatisticalbox_interface1d_callback();
            return callback_ret;
        } else {
            return QCPStatisticalBox::interface1D();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcpstatisticalbox_cliprect_isbase) {
            qcpstatisticalbox_cliprect_isbase = false;
            return QCPStatisticalBox::clipRect();
        } else if (qcpstatisticalbox_cliprect_callback != nullptr) {
            QRect* callback_ret = qcpstatisticalbox_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPStatisticalBox::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcpstatisticalbox_selectioncategory_isbase) {
            qcpstatisticalbox_selectioncategory_isbase = false;
            return QCPStatisticalBox::selectionCategory();
        } else if (qcpstatisticalbox_selectioncategory_callback != nullptr) {
            int callback_ret = qcpstatisticalbox_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPStatisticalBox::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcpstatisticalbox_applydefaultantialiasinghint_isbase) {
            qcpstatisticalbox_applydefaultantialiasinghint_isbase = false;
            QCPStatisticalBox::applyDefaultAntialiasingHint(painter);
        } else if (qcpstatisticalbox_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpstatisticalbox_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPStatisticalBox::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcpstatisticalbox_selectevent_isbase) {
            qcpstatisticalbox_selectevent_isbase = false;
            QCPStatisticalBox::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcpstatisticalbox_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcpstatisticalbox_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPStatisticalBox::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcpstatisticalbox_deselectevent_isbase) {
            qcpstatisticalbox_deselectevent_isbase = false;
            QCPStatisticalBox::deselectEvent(selectionStateChanged);
        } else if (qcpstatisticalbox_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcpstatisticalbox_deselectevent_callback(this, cbval1);
        } else {
            QCPStatisticalBox::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcpstatisticalbox_parentplotinitialized_isbase) {
            qcpstatisticalbox_parentplotinitialized_isbase = false;
            QCPStatisticalBox::parentPlotInitialized(parentPlot);
        } else if (qcpstatisticalbox_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpstatisticalbox_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPStatisticalBox::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpstatisticalbox_mousepressevent_isbase) {
            qcpstatisticalbox_mousepressevent_isbase = false;
            QCPStatisticalBox::mousePressEvent(event, details);
        } else if (qcpstatisticalbox_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpstatisticalbox_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPStatisticalBox::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpstatisticalbox_mousemoveevent_isbase) {
            qcpstatisticalbox_mousemoveevent_isbase = false;
            QCPStatisticalBox::mouseMoveEvent(event, startPos);
        } else if (qcpstatisticalbox_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpstatisticalbox_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPStatisticalBox::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpstatisticalbox_mousereleaseevent_isbase) {
            qcpstatisticalbox_mousereleaseevent_isbase = false;
            QCPStatisticalBox::mouseReleaseEvent(event, startPos);
        } else if (qcpstatisticalbox_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpstatisticalbox_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPStatisticalBox::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpstatisticalbox_mousedoubleclickevent_isbase) {
            qcpstatisticalbox_mousedoubleclickevent_isbase = false;
            QCPStatisticalBox::mouseDoubleClickEvent(event, details);
        } else if (qcpstatisticalbox_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpstatisticalbox_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPStatisticalBox::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcpstatisticalbox_wheelevent_isbase) {
            qcpstatisticalbox_wheelevent_isbase = false;
            QCPStatisticalBox::wheelEvent(event);
        } else if (qcpstatisticalbox_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcpstatisticalbox_wheelevent_callback(this, cbval1);
        } else {
            QCPStatisticalBox::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpstatisticalbox_event_isbase) {
            qcpstatisticalbox_event_isbase = false;
            return QCPStatisticalBox::event(event);
        } else if (qcpstatisticalbox_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpstatisticalbox_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPStatisticalBox::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpstatisticalbox_eventfilter_isbase) {
            qcpstatisticalbox_eventfilter_isbase = false;
            return QCPStatisticalBox::eventFilter(watched, event);
        } else if (qcpstatisticalbox_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpstatisticalbox_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPStatisticalBox::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpstatisticalbox_timerevent_isbase) {
            qcpstatisticalbox_timerevent_isbase = false;
            QCPStatisticalBox::timerEvent(event);
        } else if (qcpstatisticalbox_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpstatisticalbox_timerevent_callback(this, cbval1);
        } else {
            QCPStatisticalBox::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpstatisticalbox_childevent_isbase) {
            qcpstatisticalbox_childevent_isbase = false;
            QCPStatisticalBox::childEvent(event);
        } else if (qcpstatisticalbox_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpstatisticalbox_childevent_callback(this, cbval1);
        } else {
            QCPStatisticalBox::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpstatisticalbox_customevent_isbase) {
            qcpstatisticalbox_customevent_isbase = false;
            QCPStatisticalBox::customEvent(event);
        } else if (qcpstatisticalbox_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpstatisticalbox_customevent_callback(this, cbval1);
        } else {
            QCPStatisticalBox::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpstatisticalbox_connectnotify_isbase) {
            qcpstatisticalbox_connectnotify_isbase = false;
            QCPStatisticalBox::connectNotify(signal);
        } else if (qcpstatisticalbox_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpstatisticalbox_connectnotify_callback(this, cbval1);
        } else {
            QCPStatisticalBox::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpstatisticalbox_disconnectnotify_isbase) {
            qcpstatisticalbox_disconnectnotify_isbase = false;
            QCPStatisticalBox::disconnectNotify(signal);
        } else if (qcpstatisticalbox_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpstatisticalbox_disconnectnotify_callback(this, cbval1);
        } else {
            QCPStatisticalBox::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyFillAntialiasingHint(QCPPainter* painter) const {
        if (qcpstatisticalbox_applyfillantialiasinghint_isbase) {
            qcpstatisticalbox_applyfillantialiasinghint_isbase = false;
            QCPStatisticalBox::applyFillAntialiasingHint(painter);
        } else if (qcpstatisticalbox_applyfillantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpstatisticalbox_applyfillantialiasinghint_callback(this, cbval1);
        } else {
            QCPStatisticalBox::applyFillAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyScattersAntialiasingHint(QCPPainter* painter) const {
        if (qcpstatisticalbox_applyscattersantialiasinghint_isbase) {
            qcpstatisticalbox_applyscattersantialiasinghint_isbase = false;
            QCPStatisticalBox::applyScattersAntialiasingHint(painter);
        } else if (qcpstatisticalbox_applyscattersantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpstatisticalbox_applyscattersantialiasinghint_callback(this, cbval1);
        } else {
            QCPStatisticalBox::applyScattersAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcpstatisticalbox_initializeparentplot_isbase) {
            qcpstatisticalbox_initializeparentplot_isbase = false;
            QCPStatisticalBox::initializeParentPlot(parentPlot);
        } else if (qcpstatisticalbox_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpstatisticalbox_initializeparentplot_callback(this, cbval1);
        } else {
            QCPStatisticalBox::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcpstatisticalbox_setparentlayerable_isbase) {
            qcpstatisticalbox_setparentlayerable_isbase = false;
            QCPStatisticalBox::setParentLayerable(parentLayerable);
        } else if (qcpstatisticalbox_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcpstatisticalbox_setparentlayerable_callback(this, cbval1);
        } else {
            QCPStatisticalBox::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcpstatisticalbox_movetolayer_isbase) {
            qcpstatisticalbox_movetolayer_isbase = false;
            return QCPStatisticalBox::moveToLayer(layer, prepend);
        } else if (qcpstatisticalbox_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcpstatisticalbox_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPStatisticalBox::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcpstatisticalbox_applyantialiasinghint_isbase) {
            qcpstatisticalbox_applyantialiasinghint_isbase = false;
            QCPStatisticalBox::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcpstatisticalbox_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcpstatisticalbox_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPStatisticalBox::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpstatisticalbox_sender_isbase) {
            qcpstatisticalbox_sender_isbase = false;
            return QCPStatisticalBox::sender();
        } else if (qcpstatisticalbox_sender_callback != nullptr) {
            QObject* callback_ret = qcpstatisticalbox_sender_callback();
            return callback_ret;
        } else {
            return QCPStatisticalBox::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpstatisticalbox_sendersignalindex_isbase) {
            qcpstatisticalbox_sendersignalindex_isbase = false;
            return QCPStatisticalBox::senderSignalIndex();
        } else if (qcpstatisticalbox_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpstatisticalbox_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPStatisticalBox::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpstatisticalbox_receivers_isbase) {
            qcpstatisticalbox_receivers_isbase = false;
            return QCPStatisticalBox::receivers(signal);
        } else if (qcpstatisticalbox_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpstatisticalbox_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPStatisticalBox::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpstatisticalbox_issignalconnected_isbase) {
            qcpstatisticalbox_issignalconnected_isbase = false;
            return QCPStatisticalBox::isSignalConnected(signal);
        } else if (qcpstatisticalbox_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpstatisticalbox_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPStatisticalBox::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPStatisticalBox_Draw(QCPStatisticalBox* self, QCPPainter* painter);
    friend void QCPStatisticalBox_QBaseDraw(QCPStatisticalBox* self, QCPPainter* painter);
    friend void QCPStatisticalBox_DrawLegendIcon(const QCPStatisticalBox* self, QCPPainter* painter, const QRectF* rect);
    friend void QCPStatisticalBox_QBaseDrawLegendIcon(const QCPStatisticalBox* self, QCPPainter* painter, const QRectF* rect);
    friend QRect* QCPStatisticalBox_ClipRect(const QCPStatisticalBox* self);
    friend QRect* QCPStatisticalBox_QBaseClipRect(const QCPStatisticalBox* self);
    friend int QCPStatisticalBox_SelectionCategory(const QCPStatisticalBox* self);
    friend int QCPStatisticalBox_QBaseSelectionCategory(const QCPStatisticalBox* self);
    friend void QCPStatisticalBox_ApplyDefaultAntialiasingHint(const QCPStatisticalBox* self, QCPPainter* painter);
    friend void QCPStatisticalBox_QBaseApplyDefaultAntialiasingHint(const QCPStatisticalBox* self, QCPPainter* painter);
    friend void QCPStatisticalBox_SelectEvent(QCPStatisticalBox* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPStatisticalBox_QBaseSelectEvent(QCPStatisticalBox* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPStatisticalBox_DeselectEvent(QCPStatisticalBox* self, bool* selectionStateChanged);
    friend void QCPStatisticalBox_QBaseDeselectEvent(QCPStatisticalBox* self, bool* selectionStateChanged);
    friend void QCPStatisticalBox_ParentPlotInitialized(QCPStatisticalBox* self, QCustomPlot* parentPlot);
    friend void QCPStatisticalBox_QBaseParentPlotInitialized(QCPStatisticalBox* self, QCustomPlot* parentPlot);
    friend void QCPStatisticalBox_MousePressEvent(QCPStatisticalBox* self, QMouseEvent* event, const QVariant* details);
    friend void QCPStatisticalBox_QBaseMousePressEvent(QCPStatisticalBox* self, QMouseEvent* event, const QVariant* details);
    friend void QCPStatisticalBox_MouseMoveEvent(QCPStatisticalBox* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPStatisticalBox_QBaseMouseMoveEvent(QCPStatisticalBox* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPStatisticalBox_MouseReleaseEvent(QCPStatisticalBox* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPStatisticalBox_QBaseMouseReleaseEvent(QCPStatisticalBox* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPStatisticalBox_MouseDoubleClickEvent(QCPStatisticalBox* self, QMouseEvent* event, const QVariant* details);
    friend void QCPStatisticalBox_QBaseMouseDoubleClickEvent(QCPStatisticalBox* self, QMouseEvent* event, const QVariant* details);
    friend void QCPStatisticalBox_WheelEvent(QCPStatisticalBox* self, QWheelEvent* event);
    friend void QCPStatisticalBox_QBaseWheelEvent(QCPStatisticalBox* self, QWheelEvent* event);
    friend void QCPStatisticalBox_TimerEvent(QCPStatisticalBox* self, QTimerEvent* event);
    friend void QCPStatisticalBox_QBaseTimerEvent(QCPStatisticalBox* self, QTimerEvent* event);
    friend void QCPStatisticalBox_ChildEvent(QCPStatisticalBox* self, QChildEvent* event);
    friend void QCPStatisticalBox_QBaseChildEvent(QCPStatisticalBox* self, QChildEvent* event);
    friend void QCPStatisticalBox_CustomEvent(QCPStatisticalBox* self, QEvent* event);
    friend void QCPStatisticalBox_QBaseCustomEvent(QCPStatisticalBox* self, QEvent* event);
    friend void QCPStatisticalBox_ConnectNotify(QCPStatisticalBox* self, const QMetaMethod* signal);
    friend void QCPStatisticalBox_QBaseConnectNotify(QCPStatisticalBox* self, const QMetaMethod* signal);
    friend void QCPStatisticalBox_DisconnectNotify(QCPStatisticalBox* self, const QMetaMethod* signal);
    friend void QCPStatisticalBox_QBaseDisconnectNotify(QCPStatisticalBox* self, const QMetaMethod* signal);
    friend void QCPStatisticalBox_ApplyFillAntialiasingHint(const QCPStatisticalBox* self, QCPPainter* painter);
    friend void QCPStatisticalBox_QBaseApplyFillAntialiasingHint(const QCPStatisticalBox* self, QCPPainter* painter);
    friend void QCPStatisticalBox_ApplyScattersAntialiasingHint(const QCPStatisticalBox* self, QCPPainter* painter);
    friend void QCPStatisticalBox_QBaseApplyScattersAntialiasingHint(const QCPStatisticalBox* self, QCPPainter* painter);
    friend void QCPStatisticalBox_InitializeParentPlot(QCPStatisticalBox* self, QCustomPlot* parentPlot);
    friend void QCPStatisticalBox_QBaseInitializeParentPlot(QCPStatisticalBox* self, QCustomPlot* parentPlot);
    friend void QCPStatisticalBox_SetParentLayerable(QCPStatisticalBox* self, QCPLayerable* parentLayerable);
    friend void QCPStatisticalBox_QBaseSetParentLayerable(QCPStatisticalBox* self, QCPLayerable* parentLayerable);
    friend bool QCPStatisticalBox_MoveToLayer(QCPStatisticalBox* self, QCPLayer* layer, bool prepend);
    friend bool QCPStatisticalBox_QBaseMoveToLayer(QCPStatisticalBox* self, QCPLayer* layer, bool prepend);
    friend void QCPStatisticalBox_ApplyAntialiasingHint(const QCPStatisticalBox* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPStatisticalBox_QBaseApplyAntialiasingHint(const QCPStatisticalBox* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPStatisticalBox_Sender(const QCPStatisticalBox* self);
    friend QObject* QCPStatisticalBox_QBaseSender(const QCPStatisticalBox* self);
    friend int QCPStatisticalBox_SenderSignalIndex(const QCPStatisticalBox* self);
    friend int QCPStatisticalBox_QBaseSenderSignalIndex(const QCPStatisticalBox* self);
    friend int QCPStatisticalBox_Receivers(const QCPStatisticalBox* self, const char* signal);
    friend int QCPStatisticalBox_QBaseReceivers(const QCPStatisticalBox* self, const char* signal);
    friend bool QCPStatisticalBox_IsSignalConnected(const QCPStatisticalBox* self, const QMetaMethod* signal);
    friend bool QCPStatisticalBox_QBaseIsSignalConnected(const QCPStatisticalBox* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPColorMap so that we can call protected methods
class VirtualQCPColorMap final : public QCPColorMap {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPColorMap = true;

    // Virtual class public types (including callbacks)
    using QCPColorMap_Metacall_Callback = int (*)(QCPColorMap*, int, int, void**);
    using QCPColorMap_SelectTest_Callback = double (*)(const QCPColorMap*, QPointF*, bool, QVariant*);
    using QCPColorMap_GetKeyRange_Callback = QCPRange* (*)(const QCPColorMap*, bool*, int);
    using QCPColorMap_GetValueRange_Callback = QCPRange* (*)(const QCPColorMap*, bool*, int, QCPRange*);
    using QCPColorMap_UpdateMapImage_Callback = void (*)();
    using QCPColorMap_Draw_Callback = void (*)(QCPColorMap*, QCPPainter*);
    using QCPColorMap_DrawLegendIcon_Callback = void (*)(const QCPColorMap*, QCPPainter*, QRectF*);
    using QCPColorMap_Interface1D_Callback = QCPPlottableInterface1D* (*)();
    using QCPColorMap_ClipRect_Callback = QRect* (*)();
    using QCPColorMap_SelectionCategory_Callback = int (*)();
    using QCPColorMap_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPColorMap*, QCPPainter*);
    using QCPColorMap_SelectEvent_Callback = void (*)(QCPColorMap*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPColorMap_DeselectEvent_Callback = void (*)(QCPColorMap*, bool*);
    using QCPColorMap_ParentPlotInitialized_Callback = void (*)(QCPColorMap*, QCustomPlot*);
    using QCPColorMap_MousePressEvent_Callback = void (*)(QCPColorMap*, QMouseEvent*, QVariant*);
    using QCPColorMap_MouseMoveEvent_Callback = void (*)(QCPColorMap*, QMouseEvent*, QPointF*);
    using QCPColorMap_MouseReleaseEvent_Callback = void (*)(QCPColorMap*, QMouseEvent*, QPointF*);
    using QCPColorMap_MouseDoubleClickEvent_Callback = void (*)(QCPColorMap*, QMouseEvent*, QVariant*);
    using QCPColorMap_WheelEvent_Callback = void (*)(QCPColorMap*, QWheelEvent*);
    using QCPColorMap_Event_Callback = bool (*)(QCPColorMap*, QEvent*);
    using QCPColorMap_EventFilter_Callback = bool (*)(QCPColorMap*, QObject*, QEvent*);
    using QCPColorMap_TimerEvent_Callback = void (*)(QCPColorMap*, QTimerEvent*);
    using QCPColorMap_ChildEvent_Callback = void (*)(QCPColorMap*, QChildEvent*);
    using QCPColorMap_CustomEvent_Callback = void (*)(QCPColorMap*, QEvent*);
    using QCPColorMap_ConnectNotify_Callback = void (*)(QCPColorMap*, QMetaMethod*);
    using QCPColorMap_DisconnectNotify_Callback = void (*)(QCPColorMap*, QMetaMethod*);
    using QCPColorMap_ApplyFillAntialiasingHint_Callback = void (*)(const QCPColorMap*, QCPPainter*);
    using QCPColorMap_ApplyScattersAntialiasingHint_Callback = void (*)(const QCPColorMap*, QCPPainter*);
    using QCPColorMap_InitializeParentPlot_Callback = void (*)(QCPColorMap*, QCustomPlot*);
    using QCPColorMap_SetParentLayerable_Callback = void (*)(QCPColorMap*, QCPLayerable*);
    using QCPColorMap_MoveToLayer_Callback = bool (*)(QCPColorMap*, QCPLayer*, bool);
    using QCPColorMap_ApplyAntialiasingHint_Callback = void (*)(const QCPColorMap*, QCPPainter*, bool, int);
    using QCPColorMap_Sender_Callback = QObject* (*)();
    using QCPColorMap_SenderSignalIndex_Callback = int (*)();
    using QCPColorMap_Receivers_Callback = int (*)(const QCPColorMap*, const char*);
    using QCPColorMap_IsSignalConnected_Callback = bool (*)(const QCPColorMap*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPColorMap_Metacall_Callback qcpcolormap_metacall_callback = nullptr;
    QCPColorMap_SelectTest_Callback qcpcolormap_selecttest_callback = nullptr;
    QCPColorMap_GetKeyRange_Callback qcpcolormap_getkeyrange_callback = nullptr;
    QCPColorMap_GetValueRange_Callback qcpcolormap_getvaluerange_callback = nullptr;
    QCPColorMap_UpdateMapImage_Callback qcpcolormap_updatemapimage_callback = nullptr;
    QCPColorMap_Draw_Callback qcpcolormap_draw_callback = nullptr;
    QCPColorMap_DrawLegendIcon_Callback qcpcolormap_drawlegendicon_callback = nullptr;
    QCPColorMap_Interface1D_Callback qcpcolormap_interface1d_callback = nullptr;
    QCPColorMap_ClipRect_Callback qcpcolormap_cliprect_callback = nullptr;
    QCPColorMap_SelectionCategory_Callback qcpcolormap_selectioncategory_callback = nullptr;
    QCPColorMap_ApplyDefaultAntialiasingHint_Callback qcpcolormap_applydefaultantialiasinghint_callback = nullptr;
    QCPColorMap_SelectEvent_Callback qcpcolormap_selectevent_callback = nullptr;
    QCPColorMap_DeselectEvent_Callback qcpcolormap_deselectevent_callback = nullptr;
    QCPColorMap_ParentPlotInitialized_Callback qcpcolormap_parentplotinitialized_callback = nullptr;
    QCPColorMap_MousePressEvent_Callback qcpcolormap_mousepressevent_callback = nullptr;
    QCPColorMap_MouseMoveEvent_Callback qcpcolormap_mousemoveevent_callback = nullptr;
    QCPColorMap_MouseReleaseEvent_Callback qcpcolormap_mousereleaseevent_callback = nullptr;
    QCPColorMap_MouseDoubleClickEvent_Callback qcpcolormap_mousedoubleclickevent_callback = nullptr;
    QCPColorMap_WheelEvent_Callback qcpcolormap_wheelevent_callback = nullptr;
    QCPColorMap_Event_Callback qcpcolormap_event_callback = nullptr;
    QCPColorMap_EventFilter_Callback qcpcolormap_eventfilter_callback = nullptr;
    QCPColorMap_TimerEvent_Callback qcpcolormap_timerevent_callback = nullptr;
    QCPColorMap_ChildEvent_Callback qcpcolormap_childevent_callback = nullptr;
    QCPColorMap_CustomEvent_Callback qcpcolormap_customevent_callback = nullptr;
    QCPColorMap_ConnectNotify_Callback qcpcolormap_connectnotify_callback = nullptr;
    QCPColorMap_DisconnectNotify_Callback qcpcolormap_disconnectnotify_callback = nullptr;
    QCPColorMap_ApplyFillAntialiasingHint_Callback qcpcolormap_applyfillantialiasinghint_callback = nullptr;
    QCPColorMap_ApplyScattersAntialiasingHint_Callback qcpcolormap_applyscattersantialiasinghint_callback = nullptr;
    QCPColorMap_InitializeParentPlot_Callback qcpcolormap_initializeparentplot_callback = nullptr;
    QCPColorMap_SetParentLayerable_Callback qcpcolormap_setparentlayerable_callback = nullptr;
    QCPColorMap_MoveToLayer_Callback qcpcolormap_movetolayer_callback = nullptr;
    QCPColorMap_ApplyAntialiasingHint_Callback qcpcolormap_applyantialiasinghint_callback = nullptr;
    QCPColorMap_Sender_Callback qcpcolormap_sender_callback = nullptr;
    QCPColorMap_SenderSignalIndex_Callback qcpcolormap_sendersignalindex_callback = nullptr;
    QCPColorMap_Receivers_Callback qcpcolormap_receivers_callback = nullptr;
    QCPColorMap_IsSignalConnected_Callback qcpcolormap_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpcolormap_metacall_isbase = false;
    mutable bool qcpcolormap_selecttest_isbase = false;
    mutable bool qcpcolormap_getkeyrange_isbase = false;
    mutable bool qcpcolormap_getvaluerange_isbase = false;
    mutable bool qcpcolormap_updatemapimage_isbase = false;
    mutable bool qcpcolormap_draw_isbase = false;
    mutable bool qcpcolormap_drawlegendicon_isbase = false;
    mutable bool qcpcolormap_interface1d_isbase = false;
    mutable bool qcpcolormap_cliprect_isbase = false;
    mutable bool qcpcolormap_selectioncategory_isbase = false;
    mutable bool qcpcolormap_applydefaultantialiasinghint_isbase = false;
    mutable bool qcpcolormap_selectevent_isbase = false;
    mutable bool qcpcolormap_deselectevent_isbase = false;
    mutable bool qcpcolormap_parentplotinitialized_isbase = false;
    mutable bool qcpcolormap_mousepressevent_isbase = false;
    mutable bool qcpcolormap_mousemoveevent_isbase = false;
    mutable bool qcpcolormap_mousereleaseevent_isbase = false;
    mutable bool qcpcolormap_mousedoubleclickevent_isbase = false;
    mutable bool qcpcolormap_wheelevent_isbase = false;
    mutable bool qcpcolormap_event_isbase = false;
    mutable bool qcpcolormap_eventfilter_isbase = false;
    mutable bool qcpcolormap_timerevent_isbase = false;
    mutable bool qcpcolormap_childevent_isbase = false;
    mutable bool qcpcolormap_customevent_isbase = false;
    mutable bool qcpcolormap_connectnotify_isbase = false;
    mutable bool qcpcolormap_disconnectnotify_isbase = false;
    mutable bool qcpcolormap_applyfillantialiasinghint_isbase = false;
    mutable bool qcpcolormap_applyscattersantialiasinghint_isbase = false;
    mutable bool qcpcolormap_initializeparentplot_isbase = false;
    mutable bool qcpcolormap_setparentlayerable_isbase = false;
    mutable bool qcpcolormap_movetolayer_isbase = false;
    mutable bool qcpcolormap_applyantialiasinghint_isbase = false;
    mutable bool qcpcolormap_sender_isbase = false;
    mutable bool qcpcolormap_sendersignalindex_isbase = false;
    mutable bool qcpcolormap_receivers_isbase = false;
    mutable bool qcpcolormap_issignalconnected_isbase = false;

  public:
    VirtualQCPColorMap(QCPAxis* keyAxis, QCPAxis* valueAxis) : QCPColorMap(keyAxis, valueAxis) {};

    ~VirtualQCPColorMap() {
        qcpcolormap_metacall_callback = nullptr;
        qcpcolormap_selecttest_callback = nullptr;
        qcpcolormap_getkeyrange_callback = nullptr;
        qcpcolormap_getvaluerange_callback = nullptr;
        qcpcolormap_updatemapimage_callback = nullptr;
        qcpcolormap_draw_callback = nullptr;
        qcpcolormap_drawlegendicon_callback = nullptr;
        qcpcolormap_interface1d_callback = nullptr;
        qcpcolormap_cliprect_callback = nullptr;
        qcpcolormap_selectioncategory_callback = nullptr;
        qcpcolormap_applydefaultantialiasinghint_callback = nullptr;
        qcpcolormap_selectevent_callback = nullptr;
        qcpcolormap_deselectevent_callback = nullptr;
        qcpcolormap_parentplotinitialized_callback = nullptr;
        qcpcolormap_mousepressevent_callback = nullptr;
        qcpcolormap_mousemoveevent_callback = nullptr;
        qcpcolormap_mousereleaseevent_callback = nullptr;
        qcpcolormap_mousedoubleclickevent_callback = nullptr;
        qcpcolormap_wheelevent_callback = nullptr;
        qcpcolormap_event_callback = nullptr;
        qcpcolormap_eventfilter_callback = nullptr;
        qcpcolormap_timerevent_callback = nullptr;
        qcpcolormap_childevent_callback = nullptr;
        qcpcolormap_customevent_callback = nullptr;
        qcpcolormap_connectnotify_callback = nullptr;
        qcpcolormap_disconnectnotify_callback = nullptr;
        qcpcolormap_applyfillantialiasinghint_callback = nullptr;
        qcpcolormap_applyscattersantialiasinghint_callback = nullptr;
        qcpcolormap_initializeparentplot_callback = nullptr;
        qcpcolormap_setparentlayerable_callback = nullptr;
        qcpcolormap_movetolayer_callback = nullptr;
        qcpcolormap_applyantialiasinghint_callback = nullptr;
        qcpcolormap_sender_callback = nullptr;
        qcpcolormap_sendersignalindex_callback = nullptr;
        qcpcolormap_receivers_callback = nullptr;
        qcpcolormap_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPColorMap_Metacall_Callback(QCPColorMap_Metacall_Callback cb) { qcpcolormap_metacall_callback = cb; }
    inline void setQCPColorMap_SelectTest_Callback(QCPColorMap_SelectTest_Callback cb) { qcpcolormap_selecttest_callback = cb; }
    inline void setQCPColorMap_GetKeyRange_Callback(QCPColorMap_GetKeyRange_Callback cb) { qcpcolormap_getkeyrange_callback = cb; }
    inline void setQCPColorMap_GetValueRange_Callback(QCPColorMap_GetValueRange_Callback cb) { qcpcolormap_getvaluerange_callback = cb; }
    inline void setQCPColorMap_UpdateMapImage_Callback(QCPColorMap_UpdateMapImage_Callback cb) { qcpcolormap_updatemapimage_callback = cb; }
    inline void setQCPColorMap_Draw_Callback(QCPColorMap_Draw_Callback cb) { qcpcolormap_draw_callback = cb; }
    inline void setQCPColorMap_DrawLegendIcon_Callback(QCPColorMap_DrawLegendIcon_Callback cb) { qcpcolormap_drawlegendicon_callback = cb; }
    inline void setQCPColorMap_Interface1D_Callback(QCPColorMap_Interface1D_Callback cb) { qcpcolormap_interface1d_callback = cb; }
    inline void setQCPColorMap_ClipRect_Callback(QCPColorMap_ClipRect_Callback cb) { qcpcolormap_cliprect_callback = cb; }
    inline void setQCPColorMap_SelectionCategory_Callback(QCPColorMap_SelectionCategory_Callback cb) { qcpcolormap_selectioncategory_callback = cb; }
    inline void setQCPColorMap_ApplyDefaultAntialiasingHint_Callback(QCPColorMap_ApplyDefaultAntialiasingHint_Callback cb) { qcpcolormap_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPColorMap_SelectEvent_Callback(QCPColorMap_SelectEvent_Callback cb) { qcpcolormap_selectevent_callback = cb; }
    inline void setQCPColorMap_DeselectEvent_Callback(QCPColorMap_DeselectEvent_Callback cb) { qcpcolormap_deselectevent_callback = cb; }
    inline void setQCPColorMap_ParentPlotInitialized_Callback(QCPColorMap_ParentPlotInitialized_Callback cb) { qcpcolormap_parentplotinitialized_callback = cb; }
    inline void setQCPColorMap_MousePressEvent_Callback(QCPColorMap_MousePressEvent_Callback cb) { qcpcolormap_mousepressevent_callback = cb; }
    inline void setQCPColorMap_MouseMoveEvent_Callback(QCPColorMap_MouseMoveEvent_Callback cb) { qcpcolormap_mousemoveevent_callback = cb; }
    inline void setQCPColorMap_MouseReleaseEvent_Callback(QCPColorMap_MouseReleaseEvent_Callback cb) { qcpcolormap_mousereleaseevent_callback = cb; }
    inline void setQCPColorMap_MouseDoubleClickEvent_Callback(QCPColorMap_MouseDoubleClickEvent_Callback cb) { qcpcolormap_mousedoubleclickevent_callback = cb; }
    inline void setQCPColorMap_WheelEvent_Callback(QCPColorMap_WheelEvent_Callback cb) { qcpcolormap_wheelevent_callback = cb; }
    inline void setQCPColorMap_Event_Callback(QCPColorMap_Event_Callback cb) { qcpcolormap_event_callback = cb; }
    inline void setQCPColorMap_EventFilter_Callback(QCPColorMap_EventFilter_Callback cb) { qcpcolormap_eventfilter_callback = cb; }
    inline void setQCPColorMap_TimerEvent_Callback(QCPColorMap_TimerEvent_Callback cb) { qcpcolormap_timerevent_callback = cb; }
    inline void setQCPColorMap_ChildEvent_Callback(QCPColorMap_ChildEvent_Callback cb) { qcpcolormap_childevent_callback = cb; }
    inline void setQCPColorMap_CustomEvent_Callback(QCPColorMap_CustomEvent_Callback cb) { qcpcolormap_customevent_callback = cb; }
    inline void setQCPColorMap_ConnectNotify_Callback(QCPColorMap_ConnectNotify_Callback cb) { qcpcolormap_connectnotify_callback = cb; }
    inline void setQCPColorMap_DisconnectNotify_Callback(QCPColorMap_DisconnectNotify_Callback cb) { qcpcolormap_disconnectnotify_callback = cb; }
    inline void setQCPColorMap_ApplyFillAntialiasingHint_Callback(QCPColorMap_ApplyFillAntialiasingHint_Callback cb) { qcpcolormap_applyfillantialiasinghint_callback = cb; }
    inline void setQCPColorMap_ApplyScattersAntialiasingHint_Callback(QCPColorMap_ApplyScattersAntialiasingHint_Callback cb) { qcpcolormap_applyscattersantialiasinghint_callback = cb; }
    inline void setQCPColorMap_InitializeParentPlot_Callback(QCPColorMap_InitializeParentPlot_Callback cb) { qcpcolormap_initializeparentplot_callback = cb; }
    inline void setQCPColorMap_SetParentLayerable_Callback(QCPColorMap_SetParentLayerable_Callback cb) { qcpcolormap_setparentlayerable_callback = cb; }
    inline void setQCPColorMap_MoveToLayer_Callback(QCPColorMap_MoveToLayer_Callback cb) { qcpcolormap_movetolayer_callback = cb; }
    inline void setQCPColorMap_ApplyAntialiasingHint_Callback(QCPColorMap_ApplyAntialiasingHint_Callback cb) { qcpcolormap_applyantialiasinghint_callback = cb; }
    inline void setQCPColorMap_Sender_Callback(QCPColorMap_Sender_Callback cb) { qcpcolormap_sender_callback = cb; }
    inline void setQCPColorMap_SenderSignalIndex_Callback(QCPColorMap_SenderSignalIndex_Callback cb) { qcpcolormap_sendersignalindex_callback = cb; }
    inline void setQCPColorMap_Receivers_Callback(QCPColorMap_Receivers_Callback cb) { qcpcolormap_receivers_callback = cb; }
    inline void setQCPColorMap_IsSignalConnected_Callback(QCPColorMap_IsSignalConnected_Callback cb) { qcpcolormap_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPColorMap_Metacall_IsBase(bool value) const { qcpcolormap_metacall_isbase = value; }
    inline void setQCPColorMap_SelectTest_IsBase(bool value) const { qcpcolormap_selecttest_isbase = value; }
    inline void setQCPColorMap_GetKeyRange_IsBase(bool value) const { qcpcolormap_getkeyrange_isbase = value; }
    inline void setQCPColorMap_GetValueRange_IsBase(bool value) const { qcpcolormap_getvaluerange_isbase = value; }
    inline void setQCPColorMap_UpdateMapImage_IsBase(bool value) const { qcpcolormap_updatemapimage_isbase = value; }
    inline void setQCPColorMap_Draw_IsBase(bool value) const { qcpcolormap_draw_isbase = value; }
    inline void setQCPColorMap_DrawLegendIcon_IsBase(bool value) const { qcpcolormap_drawlegendicon_isbase = value; }
    inline void setQCPColorMap_Interface1D_IsBase(bool value) const { qcpcolormap_interface1d_isbase = value; }
    inline void setQCPColorMap_ClipRect_IsBase(bool value) const { qcpcolormap_cliprect_isbase = value; }
    inline void setQCPColorMap_SelectionCategory_IsBase(bool value) const { qcpcolormap_selectioncategory_isbase = value; }
    inline void setQCPColorMap_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcpcolormap_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPColorMap_SelectEvent_IsBase(bool value) const { qcpcolormap_selectevent_isbase = value; }
    inline void setQCPColorMap_DeselectEvent_IsBase(bool value) const { qcpcolormap_deselectevent_isbase = value; }
    inline void setQCPColorMap_ParentPlotInitialized_IsBase(bool value) const { qcpcolormap_parentplotinitialized_isbase = value; }
    inline void setQCPColorMap_MousePressEvent_IsBase(bool value) const { qcpcolormap_mousepressevent_isbase = value; }
    inline void setQCPColorMap_MouseMoveEvent_IsBase(bool value) const { qcpcolormap_mousemoveevent_isbase = value; }
    inline void setQCPColorMap_MouseReleaseEvent_IsBase(bool value) const { qcpcolormap_mousereleaseevent_isbase = value; }
    inline void setQCPColorMap_MouseDoubleClickEvent_IsBase(bool value) const { qcpcolormap_mousedoubleclickevent_isbase = value; }
    inline void setQCPColorMap_WheelEvent_IsBase(bool value) const { qcpcolormap_wheelevent_isbase = value; }
    inline void setQCPColorMap_Event_IsBase(bool value) const { qcpcolormap_event_isbase = value; }
    inline void setQCPColorMap_EventFilter_IsBase(bool value) const { qcpcolormap_eventfilter_isbase = value; }
    inline void setQCPColorMap_TimerEvent_IsBase(bool value) const { qcpcolormap_timerevent_isbase = value; }
    inline void setQCPColorMap_ChildEvent_IsBase(bool value) const { qcpcolormap_childevent_isbase = value; }
    inline void setQCPColorMap_CustomEvent_IsBase(bool value) const { qcpcolormap_customevent_isbase = value; }
    inline void setQCPColorMap_ConnectNotify_IsBase(bool value) const { qcpcolormap_connectnotify_isbase = value; }
    inline void setQCPColorMap_DisconnectNotify_IsBase(bool value) const { qcpcolormap_disconnectnotify_isbase = value; }
    inline void setQCPColorMap_ApplyFillAntialiasingHint_IsBase(bool value) const { qcpcolormap_applyfillantialiasinghint_isbase = value; }
    inline void setQCPColorMap_ApplyScattersAntialiasingHint_IsBase(bool value) const { qcpcolormap_applyscattersantialiasinghint_isbase = value; }
    inline void setQCPColorMap_InitializeParentPlot_IsBase(bool value) const { qcpcolormap_initializeparentplot_isbase = value; }
    inline void setQCPColorMap_SetParentLayerable_IsBase(bool value) const { qcpcolormap_setparentlayerable_isbase = value; }
    inline void setQCPColorMap_MoveToLayer_IsBase(bool value) const { qcpcolormap_movetolayer_isbase = value; }
    inline void setQCPColorMap_ApplyAntialiasingHint_IsBase(bool value) const { qcpcolormap_applyantialiasinghint_isbase = value; }
    inline void setQCPColorMap_Sender_IsBase(bool value) const { qcpcolormap_sender_isbase = value; }
    inline void setQCPColorMap_SenderSignalIndex_IsBase(bool value) const { qcpcolormap_sendersignalindex_isbase = value; }
    inline void setQCPColorMap_Receivers_IsBase(bool value) const { qcpcolormap_receivers_isbase = value; }
    inline void setQCPColorMap_IsSignalConnected_IsBase(bool value) const { qcpcolormap_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpcolormap_metacall_isbase) {
            qcpcolormap_metacall_isbase = false;
            return QCPColorMap::qt_metacall(param1, param2, param3);
        } else if (qcpcolormap_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpcolormap_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPColorMap::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcpcolormap_selecttest_isbase) {
            qcpcolormap_selecttest_isbase = false;
            return QCPColorMap::selectTest(pos, onlySelectable, details);
        } else if (qcpcolormap_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcpcolormap_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPColorMap::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPRange getKeyRange(bool& foundRange, QCP::SignDomain inSignDomain) const override {
        if (qcpcolormap_getkeyrange_isbase) {
            qcpcolormap_getkeyrange_isbase = false;
            return QCPColorMap::getKeyRange(foundRange, inSignDomain);
        } else if (qcpcolormap_getkeyrange_callback != nullptr) {
            bool* cbval1 = &foundRange;
            int cbval2 = static_cast<int>(inSignDomain);

            QCPRange* callback_ret = qcpcolormap_getkeyrange_callback(this, cbval1, cbval2);
            return *callback_ret;
        } else {
            return QCPColorMap::getKeyRange(foundRange, inSignDomain);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPRange getValueRange(bool& foundRange, QCP::SignDomain inSignDomain, const QCPRange& inKeyRange) const override {
        if (qcpcolormap_getvaluerange_isbase) {
            qcpcolormap_getvaluerange_isbase = false;
            return QCPColorMap::getValueRange(foundRange, inSignDomain, inKeyRange);
        } else if (qcpcolormap_getvaluerange_callback != nullptr) {
            bool* cbval1 = &foundRange;
            int cbval2 = static_cast<int>(inSignDomain);
            const QCPRange& inKeyRange_ret = inKeyRange;
            // Cast returned reference into pointer
            QCPRange* cbval3 = const_cast<QCPRange*>(&inKeyRange_ret);

            QCPRange* callback_ret = qcpcolormap_getvaluerange_callback(this, cbval1, cbval2, cbval3);
            return *callback_ret;
        } else {
            return QCPColorMap::getValueRange(foundRange, inSignDomain, inKeyRange);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void updateMapImage() override {
        if (qcpcolormap_updatemapimage_isbase) {
            qcpcolormap_updatemapimage_isbase = false;
            QCPColorMap::updateMapImage();
        } else if (qcpcolormap_updatemapimage_callback != nullptr) {
            qcpcolormap_updatemapimage_callback();
        } else {
            QCPColorMap::updateMapImage();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcpcolormap_draw_isbase) {
            qcpcolormap_draw_isbase = false;
            QCPColorMap::draw(painter);
        } else if (qcpcolormap_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpcolormap_draw_callback(this, cbval1);
        } else {
            QCPColorMap::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void drawLegendIcon(QCPPainter* painter, const QRectF& rect) const override {
        if (qcpcolormap_drawlegendicon_isbase) {
            qcpcolormap_drawlegendicon_isbase = false;
            QCPColorMap::drawLegendIcon(painter, rect);
        } else if (qcpcolormap_drawlegendicon_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval2 = const_cast<QRectF*>(&rect_ret);

            qcpcolormap_drawlegendicon_callback(this, cbval1, cbval2);
        } else {
            QCPColorMap::drawLegendIcon(painter, rect);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPPlottableInterface1D* interface1D() override {
        if (qcpcolormap_interface1d_isbase) {
            qcpcolormap_interface1d_isbase = false;
            return QCPColorMap::interface1D();
        } else if (qcpcolormap_interface1d_callback != nullptr) {
            QCPPlottableInterface1D* callback_ret = qcpcolormap_interface1d_callback();
            return callback_ret;
        } else {
            return QCPColorMap::interface1D();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcpcolormap_cliprect_isbase) {
            qcpcolormap_cliprect_isbase = false;
            return QCPColorMap::clipRect();
        } else if (qcpcolormap_cliprect_callback != nullptr) {
            QRect* callback_ret = qcpcolormap_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPColorMap::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcpcolormap_selectioncategory_isbase) {
            qcpcolormap_selectioncategory_isbase = false;
            return QCPColorMap::selectionCategory();
        } else if (qcpcolormap_selectioncategory_callback != nullptr) {
            int callback_ret = qcpcolormap_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPColorMap::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcpcolormap_applydefaultantialiasinghint_isbase) {
            qcpcolormap_applydefaultantialiasinghint_isbase = false;
            QCPColorMap::applyDefaultAntialiasingHint(painter);
        } else if (qcpcolormap_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpcolormap_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPColorMap::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcpcolormap_selectevent_isbase) {
            qcpcolormap_selectevent_isbase = false;
            QCPColorMap::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcpcolormap_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcpcolormap_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPColorMap::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcpcolormap_deselectevent_isbase) {
            qcpcolormap_deselectevent_isbase = false;
            QCPColorMap::deselectEvent(selectionStateChanged);
        } else if (qcpcolormap_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcpcolormap_deselectevent_callback(this, cbval1);
        } else {
            QCPColorMap::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcpcolormap_parentplotinitialized_isbase) {
            qcpcolormap_parentplotinitialized_isbase = false;
            QCPColorMap::parentPlotInitialized(parentPlot);
        } else if (qcpcolormap_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpcolormap_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPColorMap::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpcolormap_mousepressevent_isbase) {
            qcpcolormap_mousepressevent_isbase = false;
            QCPColorMap::mousePressEvent(event, details);
        } else if (qcpcolormap_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpcolormap_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPColorMap::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpcolormap_mousemoveevent_isbase) {
            qcpcolormap_mousemoveevent_isbase = false;
            QCPColorMap::mouseMoveEvent(event, startPos);
        } else if (qcpcolormap_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpcolormap_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPColorMap::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpcolormap_mousereleaseevent_isbase) {
            qcpcolormap_mousereleaseevent_isbase = false;
            QCPColorMap::mouseReleaseEvent(event, startPos);
        } else if (qcpcolormap_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpcolormap_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPColorMap::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpcolormap_mousedoubleclickevent_isbase) {
            qcpcolormap_mousedoubleclickevent_isbase = false;
            QCPColorMap::mouseDoubleClickEvent(event, details);
        } else if (qcpcolormap_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpcolormap_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPColorMap::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcpcolormap_wheelevent_isbase) {
            qcpcolormap_wheelevent_isbase = false;
            QCPColorMap::wheelEvent(event);
        } else if (qcpcolormap_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcpcolormap_wheelevent_callback(this, cbval1);
        } else {
            QCPColorMap::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpcolormap_event_isbase) {
            qcpcolormap_event_isbase = false;
            return QCPColorMap::event(event);
        } else if (qcpcolormap_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpcolormap_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPColorMap::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpcolormap_eventfilter_isbase) {
            qcpcolormap_eventfilter_isbase = false;
            return QCPColorMap::eventFilter(watched, event);
        } else if (qcpcolormap_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpcolormap_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPColorMap::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpcolormap_timerevent_isbase) {
            qcpcolormap_timerevent_isbase = false;
            QCPColorMap::timerEvent(event);
        } else if (qcpcolormap_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpcolormap_timerevent_callback(this, cbval1);
        } else {
            QCPColorMap::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpcolormap_childevent_isbase) {
            qcpcolormap_childevent_isbase = false;
            QCPColorMap::childEvent(event);
        } else if (qcpcolormap_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpcolormap_childevent_callback(this, cbval1);
        } else {
            QCPColorMap::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpcolormap_customevent_isbase) {
            qcpcolormap_customevent_isbase = false;
            QCPColorMap::customEvent(event);
        } else if (qcpcolormap_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpcolormap_customevent_callback(this, cbval1);
        } else {
            QCPColorMap::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpcolormap_connectnotify_isbase) {
            qcpcolormap_connectnotify_isbase = false;
            QCPColorMap::connectNotify(signal);
        } else if (qcpcolormap_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpcolormap_connectnotify_callback(this, cbval1);
        } else {
            QCPColorMap::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpcolormap_disconnectnotify_isbase) {
            qcpcolormap_disconnectnotify_isbase = false;
            QCPColorMap::disconnectNotify(signal);
        } else if (qcpcolormap_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpcolormap_disconnectnotify_callback(this, cbval1);
        } else {
            QCPColorMap::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyFillAntialiasingHint(QCPPainter* painter) const {
        if (qcpcolormap_applyfillantialiasinghint_isbase) {
            qcpcolormap_applyfillantialiasinghint_isbase = false;
            QCPColorMap::applyFillAntialiasingHint(painter);
        } else if (qcpcolormap_applyfillantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpcolormap_applyfillantialiasinghint_callback(this, cbval1);
        } else {
            QCPColorMap::applyFillAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyScattersAntialiasingHint(QCPPainter* painter) const {
        if (qcpcolormap_applyscattersantialiasinghint_isbase) {
            qcpcolormap_applyscattersantialiasinghint_isbase = false;
            QCPColorMap::applyScattersAntialiasingHint(painter);
        } else if (qcpcolormap_applyscattersantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpcolormap_applyscattersantialiasinghint_callback(this, cbval1);
        } else {
            QCPColorMap::applyScattersAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcpcolormap_initializeparentplot_isbase) {
            qcpcolormap_initializeparentplot_isbase = false;
            QCPColorMap::initializeParentPlot(parentPlot);
        } else if (qcpcolormap_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpcolormap_initializeparentplot_callback(this, cbval1);
        } else {
            QCPColorMap::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcpcolormap_setparentlayerable_isbase) {
            qcpcolormap_setparentlayerable_isbase = false;
            QCPColorMap::setParentLayerable(parentLayerable);
        } else if (qcpcolormap_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcpcolormap_setparentlayerable_callback(this, cbval1);
        } else {
            QCPColorMap::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcpcolormap_movetolayer_isbase) {
            qcpcolormap_movetolayer_isbase = false;
            return QCPColorMap::moveToLayer(layer, prepend);
        } else if (qcpcolormap_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcpcolormap_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPColorMap::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcpcolormap_applyantialiasinghint_isbase) {
            qcpcolormap_applyantialiasinghint_isbase = false;
            QCPColorMap::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcpcolormap_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcpcolormap_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPColorMap::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpcolormap_sender_isbase) {
            qcpcolormap_sender_isbase = false;
            return QCPColorMap::sender();
        } else if (qcpcolormap_sender_callback != nullptr) {
            QObject* callback_ret = qcpcolormap_sender_callback();
            return callback_ret;
        } else {
            return QCPColorMap::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpcolormap_sendersignalindex_isbase) {
            qcpcolormap_sendersignalindex_isbase = false;
            return QCPColorMap::senderSignalIndex();
        } else if (qcpcolormap_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpcolormap_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPColorMap::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpcolormap_receivers_isbase) {
            qcpcolormap_receivers_isbase = false;
            return QCPColorMap::receivers(signal);
        } else if (qcpcolormap_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpcolormap_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPColorMap::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpcolormap_issignalconnected_isbase) {
            qcpcolormap_issignalconnected_isbase = false;
            return QCPColorMap::isSignalConnected(signal);
        } else if (qcpcolormap_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpcolormap_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPColorMap::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPColorMap_UpdateMapImage(QCPColorMap* self);
    friend void QCPColorMap_QBaseUpdateMapImage(QCPColorMap* self);
    friend void QCPColorMap_Draw(QCPColorMap* self, QCPPainter* painter);
    friend void QCPColorMap_QBaseDraw(QCPColorMap* self, QCPPainter* painter);
    friend void QCPColorMap_DrawLegendIcon(const QCPColorMap* self, QCPPainter* painter, const QRectF* rect);
    friend void QCPColorMap_QBaseDrawLegendIcon(const QCPColorMap* self, QCPPainter* painter, const QRectF* rect);
    friend QRect* QCPColorMap_ClipRect(const QCPColorMap* self);
    friend QRect* QCPColorMap_QBaseClipRect(const QCPColorMap* self);
    friend int QCPColorMap_SelectionCategory(const QCPColorMap* self);
    friend int QCPColorMap_QBaseSelectionCategory(const QCPColorMap* self);
    friend void QCPColorMap_ApplyDefaultAntialiasingHint(const QCPColorMap* self, QCPPainter* painter);
    friend void QCPColorMap_QBaseApplyDefaultAntialiasingHint(const QCPColorMap* self, QCPPainter* painter);
    friend void QCPColorMap_SelectEvent(QCPColorMap* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPColorMap_QBaseSelectEvent(QCPColorMap* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPColorMap_DeselectEvent(QCPColorMap* self, bool* selectionStateChanged);
    friend void QCPColorMap_QBaseDeselectEvent(QCPColorMap* self, bool* selectionStateChanged);
    friend void QCPColorMap_ParentPlotInitialized(QCPColorMap* self, QCustomPlot* parentPlot);
    friend void QCPColorMap_QBaseParentPlotInitialized(QCPColorMap* self, QCustomPlot* parentPlot);
    friend void QCPColorMap_MousePressEvent(QCPColorMap* self, QMouseEvent* event, const QVariant* details);
    friend void QCPColorMap_QBaseMousePressEvent(QCPColorMap* self, QMouseEvent* event, const QVariant* details);
    friend void QCPColorMap_MouseMoveEvent(QCPColorMap* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPColorMap_QBaseMouseMoveEvent(QCPColorMap* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPColorMap_MouseReleaseEvent(QCPColorMap* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPColorMap_QBaseMouseReleaseEvent(QCPColorMap* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPColorMap_MouseDoubleClickEvent(QCPColorMap* self, QMouseEvent* event, const QVariant* details);
    friend void QCPColorMap_QBaseMouseDoubleClickEvent(QCPColorMap* self, QMouseEvent* event, const QVariant* details);
    friend void QCPColorMap_WheelEvent(QCPColorMap* self, QWheelEvent* event);
    friend void QCPColorMap_QBaseWheelEvent(QCPColorMap* self, QWheelEvent* event);
    friend void QCPColorMap_TimerEvent(QCPColorMap* self, QTimerEvent* event);
    friend void QCPColorMap_QBaseTimerEvent(QCPColorMap* self, QTimerEvent* event);
    friend void QCPColorMap_ChildEvent(QCPColorMap* self, QChildEvent* event);
    friend void QCPColorMap_QBaseChildEvent(QCPColorMap* self, QChildEvent* event);
    friend void QCPColorMap_CustomEvent(QCPColorMap* self, QEvent* event);
    friend void QCPColorMap_QBaseCustomEvent(QCPColorMap* self, QEvent* event);
    friend void QCPColorMap_ConnectNotify(QCPColorMap* self, const QMetaMethod* signal);
    friend void QCPColorMap_QBaseConnectNotify(QCPColorMap* self, const QMetaMethod* signal);
    friend void QCPColorMap_DisconnectNotify(QCPColorMap* self, const QMetaMethod* signal);
    friend void QCPColorMap_QBaseDisconnectNotify(QCPColorMap* self, const QMetaMethod* signal);
    friend void QCPColorMap_ApplyFillAntialiasingHint(const QCPColorMap* self, QCPPainter* painter);
    friend void QCPColorMap_QBaseApplyFillAntialiasingHint(const QCPColorMap* self, QCPPainter* painter);
    friend void QCPColorMap_ApplyScattersAntialiasingHint(const QCPColorMap* self, QCPPainter* painter);
    friend void QCPColorMap_QBaseApplyScattersAntialiasingHint(const QCPColorMap* self, QCPPainter* painter);
    friend void QCPColorMap_InitializeParentPlot(QCPColorMap* self, QCustomPlot* parentPlot);
    friend void QCPColorMap_QBaseInitializeParentPlot(QCPColorMap* self, QCustomPlot* parentPlot);
    friend void QCPColorMap_SetParentLayerable(QCPColorMap* self, QCPLayerable* parentLayerable);
    friend void QCPColorMap_QBaseSetParentLayerable(QCPColorMap* self, QCPLayerable* parentLayerable);
    friend bool QCPColorMap_MoveToLayer(QCPColorMap* self, QCPLayer* layer, bool prepend);
    friend bool QCPColorMap_QBaseMoveToLayer(QCPColorMap* self, QCPLayer* layer, bool prepend);
    friend void QCPColorMap_ApplyAntialiasingHint(const QCPColorMap* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPColorMap_QBaseApplyAntialiasingHint(const QCPColorMap* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPColorMap_Sender(const QCPColorMap* self);
    friend QObject* QCPColorMap_QBaseSender(const QCPColorMap* self);
    friend int QCPColorMap_SenderSignalIndex(const QCPColorMap* self);
    friend int QCPColorMap_QBaseSenderSignalIndex(const QCPColorMap* self);
    friend int QCPColorMap_Receivers(const QCPColorMap* self, const char* signal);
    friend int QCPColorMap_QBaseReceivers(const QCPColorMap* self, const char* signal);
    friend bool QCPColorMap_IsSignalConnected(const QCPColorMap* self, const QMetaMethod* signal);
    friend bool QCPColorMap_QBaseIsSignalConnected(const QCPColorMap* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPFinancial so that we can call protected methods
class VirtualQCPFinancial final : public QCPFinancial {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPFinancial = true;

    // Virtual class public types (including callbacks)
    using QCPFinancial_Metacall_Callback = int (*)(QCPFinancial*, int, int, void**);
    using QCPFinancial_SelectTestRect_Callback = QCPDataSelection* (*)(const QCPFinancial*, QRectF*, bool);
    using QCPFinancial_SelectTest_Callback = double (*)(const QCPFinancial*, QPointF*, bool, QVariant*);
    using QCPFinancial_GetKeyRange_Callback = QCPRange* (*)(const QCPFinancial*, bool*, int);
    using QCPFinancial_GetValueRange_Callback = QCPRange* (*)(const QCPFinancial*, bool*, int, QCPRange*);
    using QCPFinancial_Draw_Callback = void (*)(QCPFinancial*, QCPPainter*);
    using QCPFinancial_DrawLegendIcon_Callback = void (*)(const QCPFinancial*, QCPPainter*, QRectF*);
    using QCPFinancial_DataCount_Callback = int (*)();
    using QCPFinancial_DataMainKey_Callback = double (*)(const QCPFinancial*, int);
    using QCPFinancial_DataSortKey_Callback = double (*)(const QCPFinancial*, int);
    using QCPFinancial_DataMainValue_Callback = double (*)(const QCPFinancial*, int);
    using QCPFinancial_DataValueRange_Callback = QCPRange* (*)(const QCPFinancial*, int);
    using QCPFinancial_DataPixelPosition_Callback = QPointF* (*)(const QCPFinancial*, int);
    using QCPFinancial_SortKeyIsMainKey_Callback = bool (*)();
    using QCPFinancial_FindBegin_Callback = int (*)(const QCPFinancial*, double, bool);
    using QCPFinancial_FindEnd_Callback = int (*)(const QCPFinancial*, double, bool);
    using QCPFinancial_Interface1D_Callback = QCPPlottableInterface1D* (*)();
    using QCPFinancial_ClipRect_Callback = QRect* (*)();
    using QCPFinancial_SelectionCategory_Callback = int (*)();
    using QCPFinancial_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPFinancial*, QCPPainter*);
    using QCPFinancial_SelectEvent_Callback = void (*)(QCPFinancial*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPFinancial_DeselectEvent_Callback = void (*)(QCPFinancial*, bool*);
    using QCPFinancial_ParentPlotInitialized_Callback = void (*)(QCPFinancial*, QCustomPlot*);
    using QCPFinancial_MousePressEvent_Callback = void (*)(QCPFinancial*, QMouseEvent*, QVariant*);
    using QCPFinancial_MouseMoveEvent_Callback = void (*)(QCPFinancial*, QMouseEvent*, QPointF*);
    using QCPFinancial_MouseReleaseEvent_Callback = void (*)(QCPFinancial*, QMouseEvent*, QPointF*);
    using QCPFinancial_MouseDoubleClickEvent_Callback = void (*)(QCPFinancial*, QMouseEvent*, QVariant*);
    using QCPFinancial_WheelEvent_Callback = void (*)(QCPFinancial*, QWheelEvent*);
    using QCPFinancial_Event_Callback = bool (*)(QCPFinancial*, QEvent*);
    using QCPFinancial_EventFilter_Callback = bool (*)(QCPFinancial*, QObject*, QEvent*);
    using QCPFinancial_TimerEvent_Callback = void (*)(QCPFinancial*, QTimerEvent*);
    using QCPFinancial_ChildEvent_Callback = void (*)(QCPFinancial*, QChildEvent*);
    using QCPFinancial_CustomEvent_Callback = void (*)(QCPFinancial*, QEvent*);
    using QCPFinancial_ConnectNotify_Callback = void (*)(QCPFinancial*, QMetaMethod*);
    using QCPFinancial_DisconnectNotify_Callback = void (*)(QCPFinancial*, QMetaMethod*);
    using QCPFinancial_GetPixelWidth_Callback = double (*)(const QCPFinancial*, double, double);
    using QCPFinancial_ApplyFillAntialiasingHint_Callback = void (*)(const QCPFinancial*, QCPPainter*);
    using QCPFinancial_ApplyScattersAntialiasingHint_Callback = void (*)(const QCPFinancial*, QCPPainter*);
    using QCPFinancial_InitializeParentPlot_Callback = void (*)(QCPFinancial*, QCustomPlot*);
    using QCPFinancial_SetParentLayerable_Callback = void (*)(QCPFinancial*, QCPLayerable*);
    using QCPFinancial_MoveToLayer_Callback = bool (*)(QCPFinancial*, QCPLayer*, bool);
    using QCPFinancial_ApplyAntialiasingHint_Callback = void (*)(const QCPFinancial*, QCPPainter*, bool, int);
    using QCPFinancial_Sender_Callback = QObject* (*)();
    using QCPFinancial_SenderSignalIndex_Callback = int (*)();
    using QCPFinancial_Receivers_Callback = int (*)(const QCPFinancial*, const char*);
    using QCPFinancial_IsSignalConnected_Callback = bool (*)(const QCPFinancial*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPFinancial_Metacall_Callback qcpfinancial_metacall_callback = nullptr;
    QCPFinancial_SelectTestRect_Callback qcpfinancial_selecttestrect_callback = nullptr;
    QCPFinancial_SelectTest_Callback qcpfinancial_selecttest_callback = nullptr;
    QCPFinancial_GetKeyRange_Callback qcpfinancial_getkeyrange_callback = nullptr;
    QCPFinancial_GetValueRange_Callback qcpfinancial_getvaluerange_callback = nullptr;
    QCPFinancial_Draw_Callback qcpfinancial_draw_callback = nullptr;
    QCPFinancial_DrawLegendIcon_Callback qcpfinancial_drawlegendicon_callback = nullptr;
    QCPFinancial_DataCount_Callback qcpfinancial_datacount_callback = nullptr;
    QCPFinancial_DataMainKey_Callback qcpfinancial_datamainkey_callback = nullptr;
    QCPFinancial_DataSortKey_Callback qcpfinancial_datasortkey_callback = nullptr;
    QCPFinancial_DataMainValue_Callback qcpfinancial_datamainvalue_callback = nullptr;
    QCPFinancial_DataValueRange_Callback qcpfinancial_datavaluerange_callback = nullptr;
    QCPFinancial_DataPixelPosition_Callback qcpfinancial_datapixelposition_callback = nullptr;
    QCPFinancial_SortKeyIsMainKey_Callback qcpfinancial_sortkeyismainkey_callback = nullptr;
    QCPFinancial_FindBegin_Callback qcpfinancial_findbegin_callback = nullptr;
    QCPFinancial_FindEnd_Callback qcpfinancial_findend_callback = nullptr;
    QCPFinancial_Interface1D_Callback qcpfinancial_interface1d_callback = nullptr;
    QCPFinancial_ClipRect_Callback qcpfinancial_cliprect_callback = nullptr;
    QCPFinancial_SelectionCategory_Callback qcpfinancial_selectioncategory_callback = nullptr;
    QCPFinancial_ApplyDefaultAntialiasingHint_Callback qcpfinancial_applydefaultantialiasinghint_callback = nullptr;
    QCPFinancial_SelectEvent_Callback qcpfinancial_selectevent_callback = nullptr;
    QCPFinancial_DeselectEvent_Callback qcpfinancial_deselectevent_callback = nullptr;
    QCPFinancial_ParentPlotInitialized_Callback qcpfinancial_parentplotinitialized_callback = nullptr;
    QCPFinancial_MousePressEvent_Callback qcpfinancial_mousepressevent_callback = nullptr;
    QCPFinancial_MouseMoveEvent_Callback qcpfinancial_mousemoveevent_callback = nullptr;
    QCPFinancial_MouseReleaseEvent_Callback qcpfinancial_mousereleaseevent_callback = nullptr;
    QCPFinancial_MouseDoubleClickEvent_Callback qcpfinancial_mousedoubleclickevent_callback = nullptr;
    QCPFinancial_WheelEvent_Callback qcpfinancial_wheelevent_callback = nullptr;
    QCPFinancial_Event_Callback qcpfinancial_event_callback = nullptr;
    QCPFinancial_EventFilter_Callback qcpfinancial_eventfilter_callback = nullptr;
    QCPFinancial_TimerEvent_Callback qcpfinancial_timerevent_callback = nullptr;
    QCPFinancial_ChildEvent_Callback qcpfinancial_childevent_callback = nullptr;
    QCPFinancial_CustomEvent_Callback qcpfinancial_customevent_callback = nullptr;
    QCPFinancial_ConnectNotify_Callback qcpfinancial_connectnotify_callback = nullptr;
    QCPFinancial_DisconnectNotify_Callback qcpfinancial_disconnectnotify_callback = nullptr;
    QCPFinancial_GetPixelWidth_Callback qcpfinancial_getpixelwidth_callback = nullptr;
    QCPFinancial_ApplyFillAntialiasingHint_Callback qcpfinancial_applyfillantialiasinghint_callback = nullptr;
    QCPFinancial_ApplyScattersAntialiasingHint_Callback qcpfinancial_applyscattersantialiasinghint_callback = nullptr;
    QCPFinancial_InitializeParentPlot_Callback qcpfinancial_initializeparentplot_callback = nullptr;
    QCPFinancial_SetParentLayerable_Callback qcpfinancial_setparentlayerable_callback = nullptr;
    QCPFinancial_MoveToLayer_Callback qcpfinancial_movetolayer_callback = nullptr;
    QCPFinancial_ApplyAntialiasingHint_Callback qcpfinancial_applyantialiasinghint_callback = nullptr;
    QCPFinancial_Sender_Callback qcpfinancial_sender_callback = nullptr;
    QCPFinancial_SenderSignalIndex_Callback qcpfinancial_sendersignalindex_callback = nullptr;
    QCPFinancial_Receivers_Callback qcpfinancial_receivers_callback = nullptr;
    QCPFinancial_IsSignalConnected_Callback qcpfinancial_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpfinancial_metacall_isbase = false;
    mutable bool qcpfinancial_selecttestrect_isbase = false;
    mutable bool qcpfinancial_selecttest_isbase = false;
    mutable bool qcpfinancial_getkeyrange_isbase = false;
    mutable bool qcpfinancial_getvaluerange_isbase = false;
    mutable bool qcpfinancial_draw_isbase = false;
    mutable bool qcpfinancial_drawlegendicon_isbase = false;
    mutable bool qcpfinancial_datacount_isbase = false;
    mutable bool qcpfinancial_datamainkey_isbase = false;
    mutable bool qcpfinancial_datasortkey_isbase = false;
    mutable bool qcpfinancial_datamainvalue_isbase = false;
    mutable bool qcpfinancial_datavaluerange_isbase = false;
    mutable bool qcpfinancial_datapixelposition_isbase = false;
    mutable bool qcpfinancial_sortkeyismainkey_isbase = false;
    mutable bool qcpfinancial_findbegin_isbase = false;
    mutable bool qcpfinancial_findend_isbase = false;
    mutable bool qcpfinancial_interface1d_isbase = false;
    mutable bool qcpfinancial_cliprect_isbase = false;
    mutable bool qcpfinancial_selectioncategory_isbase = false;
    mutable bool qcpfinancial_applydefaultantialiasinghint_isbase = false;
    mutable bool qcpfinancial_selectevent_isbase = false;
    mutable bool qcpfinancial_deselectevent_isbase = false;
    mutable bool qcpfinancial_parentplotinitialized_isbase = false;
    mutable bool qcpfinancial_mousepressevent_isbase = false;
    mutable bool qcpfinancial_mousemoveevent_isbase = false;
    mutable bool qcpfinancial_mousereleaseevent_isbase = false;
    mutable bool qcpfinancial_mousedoubleclickevent_isbase = false;
    mutable bool qcpfinancial_wheelevent_isbase = false;
    mutable bool qcpfinancial_event_isbase = false;
    mutable bool qcpfinancial_eventfilter_isbase = false;
    mutable bool qcpfinancial_timerevent_isbase = false;
    mutable bool qcpfinancial_childevent_isbase = false;
    mutable bool qcpfinancial_customevent_isbase = false;
    mutable bool qcpfinancial_connectnotify_isbase = false;
    mutable bool qcpfinancial_disconnectnotify_isbase = false;
    mutable bool qcpfinancial_getpixelwidth_isbase = false;
    mutable bool qcpfinancial_applyfillantialiasinghint_isbase = false;
    mutable bool qcpfinancial_applyscattersantialiasinghint_isbase = false;
    mutable bool qcpfinancial_initializeparentplot_isbase = false;
    mutable bool qcpfinancial_setparentlayerable_isbase = false;
    mutable bool qcpfinancial_movetolayer_isbase = false;
    mutable bool qcpfinancial_applyantialiasinghint_isbase = false;
    mutable bool qcpfinancial_sender_isbase = false;
    mutable bool qcpfinancial_sendersignalindex_isbase = false;
    mutable bool qcpfinancial_receivers_isbase = false;
    mutable bool qcpfinancial_issignalconnected_isbase = false;

  public:
    VirtualQCPFinancial(QCPAxis* keyAxis, QCPAxis* valueAxis) : QCPFinancial(keyAxis, valueAxis) {};

    ~VirtualQCPFinancial() {
        qcpfinancial_metacall_callback = nullptr;
        qcpfinancial_selecttestrect_callback = nullptr;
        qcpfinancial_selecttest_callback = nullptr;
        qcpfinancial_getkeyrange_callback = nullptr;
        qcpfinancial_getvaluerange_callback = nullptr;
        qcpfinancial_draw_callback = nullptr;
        qcpfinancial_drawlegendicon_callback = nullptr;
        qcpfinancial_datacount_callback = nullptr;
        qcpfinancial_datamainkey_callback = nullptr;
        qcpfinancial_datasortkey_callback = nullptr;
        qcpfinancial_datamainvalue_callback = nullptr;
        qcpfinancial_datavaluerange_callback = nullptr;
        qcpfinancial_datapixelposition_callback = nullptr;
        qcpfinancial_sortkeyismainkey_callback = nullptr;
        qcpfinancial_findbegin_callback = nullptr;
        qcpfinancial_findend_callback = nullptr;
        qcpfinancial_interface1d_callback = nullptr;
        qcpfinancial_cliprect_callback = nullptr;
        qcpfinancial_selectioncategory_callback = nullptr;
        qcpfinancial_applydefaultantialiasinghint_callback = nullptr;
        qcpfinancial_selectevent_callback = nullptr;
        qcpfinancial_deselectevent_callback = nullptr;
        qcpfinancial_parentplotinitialized_callback = nullptr;
        qcpfinancial_mousepressevent_callback = nullptr;
        qcpfinancial_mousemoveevent_callback = nullptr;
        qcpfinancial_mousereleaseevent_callback = nullptr;
        qcpfinancial_mousedoubleclickevent_callback = nullptr;
        qcpfinancial_wheelevent_callback = nullptr;
        qcpfinancial_event_callback = nullptr;
        qcpfinancial_eventfilter_callback = nullptr;
        qcpfinancial_timerevent_callback = nullptr;
        qcpfinancial_childevent_callback = nullptr;
        qcpfinancial_customevent_callback = nullptr;
        qcpfinancial_connectnotify_callback = nullptr;
        qcpfinancial_disconnectnotify_callback = nullptr;
        qcpfinancial_getpixelwidth_callback = nullptr;
        qcpfinancial_applyfillantialiasinghint_callback = nullptr;
        qcpfinancial_applyscattersantialiasinghint_callback = nullptr;
        qcpfinancial_initializeparentplot_callback = nullptr;
        qcpfinancial_setparentlayerable_callback = nullptr;
        qcpfinancial_movetolayer_callback = nullptr;
        qcpfinancial_applyantialiasinghint_callback = nullptr;
        qcpfinancial_sender_callback = nullptr;
        qcpfinancial_sendersignalindex_callback = nullptr;
        qcpfinancial_receivers_callback = nullptr;
        qcpfinancial_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPFinancial_Metacall_Callback(QCPFinancial_Metacall_Callback cb) { qcpfinancial_metacall_callback = cb; }
    inline void setQCPFinancial_SelectTestRect_Callback(QCPFinancial_SelectTestRect_Callback cb) { qcpfinancial_selecttestrect_callback = cb; }
    inline void setQCPFinancial_SelectTest_Callback(QCPFinancial_SelectTest_Callback cb) { qcpfinancial_selecttest_callback = cb; }
    inline void setQCPFinancial_GetKeyRange_Callback(QCPFinancial_GetKeyRange_Callback cb) { qcpfinancial_getkeyrange_callback = cb; }
    inline void setQCPFinancial_GetValueRange_Callback(QCPFinancial_GetValueRange_Callback cb) { qcpfinancial_getvaluerange_callback = cb; }
    inline void setQCPFinancial_Draw_Callback(QCPFinancial_Draw_Callback cb) { qcpfinancial_draw_callback = cb; }
    inline void setQCPFinancial_DrawLegendIcon_Callback(QCPFinancial_DrawLegendIcon_Callback cb) { qcpfinancial_drawlegendicon_callback = cb; }
    inline void setQCPFinancial_DataCount_Callback(QCPFinancial_DataCount_Callback cb) { qcpfinancial_datacount_callback = cb; }
    inline void setQCPFinancial_DataMainKey_Callback(QCPFinancial_DataMainKey_Callback cb) { qcpfinancial_datamainkey_callback = cb; }
    inline void setQCPFinancial_DataSortKey_Callback(QCPFinancial_DataSortKey_Callback cb) { qcpfinancial_datasortkey_callback = cb; }
    inline void setQCPFinancial_DataMainValue_Callback(QCPFinancial_DataMainValue_Callback cb) { qcpfinancial_datamainvalue_callback = cb; }
    inline void setQCPFinancial_DataValueRange_Callback(QCPFinancial_DataValueRange_Callback cb) { qcpfinancial_datavaluerange_callback = cb; }
    inline void setQCPFinancial_DataPixelPosition_Callback(QCPFinancial_DataPixelPosition_Callback cb) { qcpfinancial_datapixelposition_callback = cb; }
    inline void setQCPFinancial_SortKeyIsMainKey_Callback(QCPFinancial_SortKeyIsMainKey_Callback cb) { qcpfinancial_sortkeyismainkey_callback = cb; }
    inline void setQCPFinancial_FindBegin_Callback(QCPFinancial_FindBegin_Callback cb) { qcpfinancial_findbegin_callback = cb; }
    inline void setQCPFinancial_FindEnd_Callback(QCPFinancial_FindEnd_Callback cb) { qcpfinancial_findend_callback = cb; }
    inline void setQCPFinancial_Interface1D_Callback(QCPFinancial_Interface1D_Callback cb) { qcpfinancial_interface1d_callback = cb; }
    inline void setQCPFinancial_ClipRect_Callback(QCPFinancial_ClipRect_Callback cb) { qcpfinancial_cliprect_callback = cb; }
    inline void setQCPFinancial_SelectionCategory_Callback(QCPFinancial_SelectionCategory_Callback cb) { qcpfinancial_selectioncategory_callback = cb; }
    inline void setQCPFinancial_ApplyDefaultAntialiasingHint_Callback(QCPFinancial_ApplyDefaultAntialiasingHint_Callback cb) { qcpfinancial_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPFinancial_SelectEvent_Callback(QCPFinancial_SelectEvent_Callback cb) { qcpfinancial_selectevent_callback = cb; }
    inline void setQCPFinancial_DeselectEvent_Callback(QCPFinancial_DeselectEvent_Callback cb) { qcpfinancial_deselectevent_callback = cb; }
    inline void setQCPFinancial_ParentPlotInitialized_Callback(QCPFinancial_ParentPlotInitialized_Callback cb) { qcpfinancial_parentplotinitialized_callback = cb; }
    inline void setQCPFinancial_MousePressEvent_Callback(QCPFinancial_MousePressEvent_Callback cb) { qcpfinancial_mousepressevent_callback = cb; }
    inline void setQCPFinancial_MouseMoveEvent_Callback(QCPFinancial_MouseMoveEvent_Callback cb) { qcpfinancial_mousemoveevent_callback = cb; }
    inline void setQCPFinancial_MouseReleaseEvent_Callback(QCPFinancial_MouseReleaseEvent_Callback cb) { qcpfinancial_mousereleaseevent_callback = cb; }
    inline void setQCPFinancial_MouseDoubleClickEvent_Callback(QCPFinancial_MouseDoubleClickEvent_Callback cb) { qcpfinancial_mousedoubleclickevent_callback = cb; }
    inline void setQCPFinancial_WheelEvent_Callback(QCPFinancial_WheelEvent_Callback cb) { qcpfinancial_wheelevent_callback = cb; }
    inline void setQCPFinancial_Event_Callback(QCPFinancial_Event_Callback cb) { qcpfinancial_event_callback = cb; }
    inline void setQCPFinancial_EventFilter_Callback(QCPFinancial_EventFilter_Callback cb) { qcpfinancial_eventfilter_callback = cb; }
    inline void setQCPFinancial_TimerEvent_Callback(QCPFinancial_TimerEvent_Callback cb) { qcpfinancial_timerevent_callback = cb; }
    inline void setQCPFinancial_ChildEvent_Callback(QCPFinancial_ChildEvent_Callback cb) { qcpfinancial_childevent_callback = cb; }
    inline void setQCPFinancial_CustomEvent_Callback(QCPFinancial_CustomEvent_Callback cb) { qcpfinancial_customevent_callback = cb; }
    inline void setQCPFinancial_ConnectNotify_Callback(QCPFinancial_ConnectNotify_Callback cb) { qcpfinancial_connectnotify_callback = cb; }
    inline void setQCPFinancial_DisconnectNotify_Callback(QCPFinancial_DisconnectNotify_Callback cb) { qcpfinancial_disconnectnotify_callback = cb; }
    inline void setQCPFinancial_GetPixelWidth_Callback(QCPFinancial_GetPixelWidth_Callback cb) { qcpfinancial_getpixelwidth_callback = cb; }
    inline void setQCPFinancial_ApplyFillAntialiasingHint_Callback(QCPFinancial_ApplyFillAntialiasingHint_Callback cb) { qcpfinancial_applyfillantialiasinghint_callback = cb; }
    inline void setQCPFinancial_ApplyScattersAntialiasingHint_Callback(QCPFinancial_ApplyScattersAntialiasingHint_Callback cb) { qcpfinancial_applyscattersantialiasinghint_callback = cb; }
    inline void setQCPFinancial_InitializeParentPlot_Callback(QCPFinancial_InitializeParentPlot_Callback cb) { qcpfinancial_initializeparentplot_callback = cb; }
    inline void setQCPFinancial_SetParentLayerable_Callback(QCPFinancial_SetParentLayerable_Callback cb) { qcpfinancial_setparentlayerable_callback = cb; }
    inline void setQCPFinancial_MoveToLayer_Callback(QCPFinancial_MoveToLayer_Callback cb) { qcpfinancial_movetolayer_callback = cb; }
    inline void setQCPFinancial_ApplyAntialiasingHint_Callback(QCPFinancial_ApplyAntialiasingHint_Callback cb) { qcpfinancial_applyantialiasinghint_callback = cb; }
    inline void setQCPFinancial_Sender_Callback(QCPFinancial_Sender_Callback cb) { qcpfinancial_sender_callback = cb; }
    inline void setQCPFinancial_SenderSignalIndex_Callback(QCPFinancial_SenderSignalIndex_Callback cb) { qcpfinancial_sendersignalindex_callback = cb; }
    inline void setQCPFinancial_Receivers_Callback(QCPFinancial_Receivers_Callback cb) { qcpfinancial_receivers_callback = cb; }
    inline void setQCPFinancial_IsSignalConnected_Callback(QCPFinancial_IsSignalConnected_Callback cb) { qcpfinancial_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPFinancial_Metacall_IsBase(bool value) const { qcpfinancial_metacall_isbase = value; }
    inline void setQCPFinancial_SelectTestRect_IsBase(bool value) const { qcpfinancial_selecttestrect_isbase = value; }
    inline void setQCPFinancial_SelectTest_IsBase(bool value) const { qcpfinancial_selecttest_isbase = value; }
    inline void setQCPFinancial_GetKeyRange_IsBase(bool value) const { qcpfinancial_getkeyrange_isbase = value; }
    inline void setQCPFinancial_GetValueRange_IsBase(bool value) const { qcpfinancial_getvaluerange_isbase = value; }
    inline void setQCPFinancial_Draw_IsBase(bool value) const { qcpfinancial_draw_isbase = value; }
    inline void setQCPFinancial_DrawLegendIcon_IsBase(bool value) const { qcpfinancial_drawlegendicon_isbase = value; }
    inline void setQCPFinancial_DataCount_IsBase(bool value) const { qcpfinancial_datacount_isbase = value; }
    inline void setQCPFinancial_DataMainKey_IsBase(bool value) const { qcpfinancial_datamainkey_isbase = value; }
    inline void setQCPFinancial_DataSortKey_IsBase(bool value) const { qcpfinancial_datasortkey_isbase = value; }
    inline void setQCPFinancial_DataMainValue_IsBase(bool value) const { qcpfinancial_datamainvalue_isbase = value; }
    inline void setQCPFinancial_DataValueRange_IsBase(bool value) const { qcpfinancial_datavaluerange_isbase = value; }
    inline void setQCPFinancial_DataPixelPosition_IsBase(bool value) const { qcpfinancial_datapixelposition_isbase = value; }
    inline void setQCPFinancial_SortKeyIsMainKey_IsBase(bool value) const { qcpfinancial_sortkeyismainkey_isbase = value; }
    inline void setQCPFinancial_FindBegin_IsBase(bool value) const { qcpfinancial_findbegin_isbase = value; }
    inline void setQCPFinancial_FindEnd_IsBase(bool value) const { qcpfinancial_findend_isbase = value; }
    inline void setQCPFinancial_Interface1D_IsBase(bool value) const { qcpfinancial_interface1d_isbase = value; }
    inline void setQCPFinancial_ClipRect_IsBase(bool value) const { qcpfinancial_cliprect_isbase = value; }
    inline void setQCPFinancial_SelectionCategory_IsBase(bool value) const { qcpfinancial_selectioncategory_isbase = value; }
    inline void setQCPFinancial_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcpfinancial_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPFinancial_SelectEvent_IsBase(bool value) const { qcpfinancial_selectevent_isbase = value; }
    inline void setQCPFinancial_DeselectEvent_IsBase(bool value) const { qcpfinancial_deselectevent_isbase = value; }
    inline void setQCPFinancial_ParentPlotInitialized_IsBase(bool value) const { qcpfinancial_parentplotinitialized_isbase = value; }
    inline void setQCPFinancial_MousePressEvent_IsBase(bool value) const { qcpfinancial_mousepressevent_isbase = value; }
    inline void setQCPFinancial_MouseMoveEvent_IsBase(bool value) const { qcpfinancial_mousemoveevent_isbase = value; }
    inline void setQCPFinancial_MouseReleaseEvent_IsBase(bool value) const { qcpfinancial_mousereleaseevent_isbase = value; }
    inline void setQCPFinancial_MouseDoubleClickEvent_IsBase(bool value) const { qcpfinancial_mousedoubleclickevent_isbase = value; }
    inline void setQCPFinancial_WheelEvent_IsBase(bool value) const { qcpfinancial_wheelevent_isbase = value; }
    inline void setQCPFinancial_Event_IsBase(bool value) const { qcpfinancial_event_isbase = value; }
    inline void setQCPFinancial_EventFilter_IsBase(bool value) const { qcpfinancial_eventfilter_isbase = value; }
    inline void setQCPFinancial_TimerEvent_IsBase(bool value) const { qcpfinancial_timerevent_isbase = value; }
    inline void setQCPFinancial_ChildEvent_IsBase(bool value) const { qcpfinancial_childevent_isbase = value; }
    inline void setQCPFinancial_CustomEvent_IsBase(bool value) const { qcpfinancial_customevent_isbase = value; }
    inline void setQCPFinancial_ConnectNotify_IsBase(bool value) const { qcpfinancial_connectnotify_isbase = value; }
    inline void setQCPFinancial_DisconnectNotify_IsBase(bool value) const { qcpfinancial_disconnectnotify_isbase = value; }
    inline void setQCPFinancial_GetPixelWidth_IsBase(bool value) const { qcpfinancial_getpixelwidth_isbase = value; }
    inline void setQCPFinancial_ApplyFillAntialiasingHint_IsBase(bool value) const { qcpfinancial_applyfillantialiasinghint_isbase = value; }
    inline void setQCPFinancial_ApplyScattersAntialiasingHint_IsBase(bool value) const { qcpfinancial_applyscattersantialiasinghint_isbase = value; }
    inline void setQCPFinancial_InitializeParentPlot_IsBase(bool value) const { qcpfinancial_initializeparentplot_isbase = value; }
    inline void setQCPFinancial_SetParentLayerable_IsBase(bool value) const { qcpfinancial_setparentlayerable_isbase = value; }
    inline void setQCPFinancial_MoveToLayer_IsBase(bool value) const { qcpfinancial_movetolayer_isbase = value; }
    inline void setQCPFinancial_ApplyAntialiasingHint_IsBase(bool value) const { qcpfinancial_applyantialiasinghint_isbase = value; }
    inline void setQCPFinancial_Sender_IsBase(bool value) const { qcpfinancial_sender_isbase = value; }
    inline void setQCPFinancial_SenderSignalIndex_IsBase(bool value) const { qcpfinancial_sendersignalindex_isbase = value; }
    inline void setQCPFinancial_Receivers_IsBase(bool value) const { qcpfinancial_receivers_isbase = value; }
    inline void setQCPFinancial_IsSignalConnected_IsBase(bool value) const { qcpfinancial_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpfinancial_metacall_isbase) {
            qcpfinancial_metacall_isbase = false;
            return QCPFinancial::qt_metacall(param1, param2, param3);
        } else if (qcpfinancial_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpfinancial_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPFinancial::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPDataSelection selectTestRect(const QRectF& rect, bool onlySelectable) const override {
        if (qcpfinancial_selecttestrect_isbase) {
            qcpfinancial_selecttestrect_isbase = false;
            return QCPFinancial::selectTestRect(rect, onlySelectable);
        } else if (qcpfinancial_selecttestrect_callback != nullptr) {
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval1 = const_cast<QRectF*>(&rect_ret);
            bool cbval2 = onlySelectable;

            QCPDataSelection* callback_ret = qcpfinancial_selecttestrect_callback(this, cbval1, cbval2);
            return *callback_ret;
        } else {
            return QCPFinancial::selectTestRect(rect, onlySelectable);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcpfinancial_selecttest_isbase) {
            qcpfinancial_selecttest_isbase = false;
            return QCPFinancial::selectTest(pos, onlySelectable, details);
        } else if (qcpfinancial_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcpfinancial_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPFinancial::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPRange getKeyRange(bool& foundRange, QCP::SignDomain inSignDomain) const override {
        if (qcpfinancial_getkeyrange_isbase) {
            qcpfinancial_getkeyrange_isbase = false;
            return QCPFinancial::getKeyRange(foundRange, inSignDomain);
        } else if (qcpfinancial_getkeyrange_callback != nullptr) {
            bool* cbval1 = &foundRange;
            int cbval2 = static_cast<int>(inSignDomain);

            QCPRange* callback_ret = qcpfinancial_getkeyrange_callback(this, cbval1, cbval2);
            return *callback_ret;
        } else {
            return QCPFinancial::getKeyRange(foundRange, inSignDomain);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPRange getValueRange(bool& foundRange, QCP::SignDomain inSignDomain, const QCPRange& inKeyRange) const override {
        if (qcpfinancial_getvaluerange_isbase) {
            qcpfinancial_getvaluerange_isbase = false;
            return QCPFinancial::getValueRange(foundRange, inSignDomain, inKeyRange);
        } else if (qcpfinancial_getvaluerange_callback != nullptr) {
            bool* cbval1 = &foundRange;
            int cbval2 = static_cast<int>(inSignDomain);
            const QCPRange& inKeyRange_ret = inKeyRange;
            // Cast returned reference into pointer
            QCPRange* cbval3 = const_cast<QCPRange*>(&inKeyRange_ret);

            QCPRange* callback_ret = qcpfinancial_getvaluerange_callback(this, cbval1, cbval2, cbval3);
            return *callback_ret;
        } else {
            return QCPFinancial::getValueRange(foundRange, inSignDomain, inKeyRange);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcpfinancial_draw_isbase) {
            qcpfinancial_draw_isbase = false;
            QCPFinancial::draw(painter);
        } else if (qcpfinancial_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpfinancial_draw_callback(this, cbval1);
        } else {
            QCPFinancial::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void drawLegendIcon(QCPPainter* painter, const QRectF& rect) const override {
        if (qcpfinancial_drawlegendicon_isbase) {
            qcpfinancial_drawlegendicon_isbase = false;
            QCPFinancial::drawLegendIcon(painter, rect);
        } else if (qcpfinancial_drawlegendicon_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval2 = const_cast<QRectF*>(&rect_ret);

            qcpfinancial_drawlegendicon_callback(this, cbval1, cbval2);
        } else {
            QCPFinancial::drawLegendIcon(painter, rect);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int dataCount() const override {
        if (qcpfinancial_datacount_callback != nullptr) {
            int callback_ret = qcpfinancial_datacount_callback();
            return static_cast<int>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double dataMainKey(int index) const override {
        if (qcpfinancial_datamainkey_callback != nullptr) {
            int cbval1 = index;

            double callback_ret = qcpfinancial_datamainkey_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double dataSortKey(int index) const override {
        if (qcpfinancial_datasortkey_callback != nullptr) {
            int cbval1 = index;

            double callback_ret = qcpfinancial_datasortkey_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double dataMainValue(int index) const override {
        if (qcpfinancial_datamainvalue_callback != nullptr) {
            int cbval1 = index;

            double callback_ret = qcpfinancial_datamainvalue_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPRange dataValueRange(int index) const override {
        if (qcpfinancial_datavaluerange_callback != nullptr) {
            int cbval1 = index;

            QCPRange* callback_ret = qcpfinancial_datavaluerange_callback(this, cbval1);
            return *callback_ret;
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QPointF dataPixelPosition(int index) const override {
        if (qcpfinancial_datapixelposition_callback != nullptr) {
            int cbval1 = index;

            QPointF* callback_ret = qcpfinancial_datapixelposition_callback(this, cbval1);
            return *callback_ret;
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool sortKeyIsMainKey() const override {
        if (qcpfinancial_sortkeyismainkey_callback != nullptr) {
            bool callback_ret = qcpfinancial_sortkeyismainkey_callback();
            return callback_ret;
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int findBegin(double sortKey, bool expandedRange) const override {
        if (qcpfinancial_findbegin_callback != nullptr) {
            double cbval1 = sortKey;
            bool cbval2 = expandedRange;

            int callback_ret = qcpfinancial_findbegin_callback(this, cbval1, cbval2);
            return static_cast<int>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int findEnd(double sortKey, bool expandedRange) const override {
        if (qcpfinancial_findend_callback != nullptr) {
            double cbval1 = sortKey;
            bool cbval2 = expandedRange;

            int callback_ret = qcpfinancial_findend_callback(this, cbval1, cbval2);
            return static_cast<int>(callback_ret);
        } else {
            return {};
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPPlottableInterface1D* interface1D() override {
        if (qcpfinancial_interface1d_isbase) {
            qcpfinancial_interface1d_isbase = false;
            return QCPFinancial::interface1D();
        } else if (qcpfinancial_interface1d_callback != nullptr) {
            QCPPlottableInterface1D* callback_ret = qcpfinancial_interface1d_callback();
            return callback_ret;
        } else {
            return QCPFinancial::interface1D();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcpfinancial_cliprect_isbase) {
            qcpfinancial_cliprect_isbase = false;
            return QCPFinancial::clipRect();
        } else if (qcpfinancial_cliprect_callback != nullptr) {
            QRect* callback_ret = qcpfinancial_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPFinancial::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcpfinancial_selectioncategory_isbase) {
            qcpfinancial_selectioncategory_isbase = false;
            return QCPFinancial::selectionCategory();
        } else if (qcpfinancial_selectioncategory_callback != nullptr) {
            int callback_ret = qcpfinancial_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPFinancial::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcpfinancial_applydefaultantialiasinghint_isbase) {
            qcpfinancial_applydefaultantialiasinghint_isbase = false;
            QCPFinancial::applyDefaultAntialiasingHint(painter);
        } else if (qcpfinancial_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpfinancial_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPFinancial::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcpfinancial_selectevent_isbase) {
            qcpfinancial_selectevent_isbase = false;
            QCPFinancial::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcpfinancial_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcpfinancial_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPFinancial::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcpfinancial_deselectevent_isbase) {
            qcpfinancial_deselectevent_isbase = false;
            QCPFinancial::deselectEvent(selectionStateChanged);
        } else if (qcpfinancial_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcpfinancial_deselectevent_callback(this, cbval1);
        } else {
            QCPFinancial::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcpfinancial_parentplotinitialized_isbase) {
            qcpfinancial_parentplotinitialized_isbase = false;
            QCPFinancial::parentPlotInitialized(parentPlot);
        } else if (qcpfinancial_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpfinancial_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPFinancial::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpfinancial_mousepressevent_isbase) {
            qcpfinancial_mousepressevent_isbase = false;
            QCPFinancial::mousePressEvent(event, details);
        } else if (qcpfinancial_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpfinancial_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPFinancial::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpfinancial_mousemoveevent_isbase) {
            qcpfinancial_mousemoveevent_isbase = false;
            QCPFinancial::mouseMoveEvent(event, startPos);
        } else if (qcpfinancial_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpfinancial_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPFinancial::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpfinancial_mousereleaseevent_isbase) {
            qcpfinancial_mousereleaseevent_isbase = false;
            QCPFinancial::mouseReleaseEvent(event, startPos);
        } else if (qcpfinancial_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpfinancial_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPFinancial::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpfinancial_mousedoubleclickevent_isbase) {
            qcpfinancial_mousedoubleclickevent_isbase = false;
            QCPFinancial::mouseDoubleClickEvent(event, details);
        } else if (qcpfinancial_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpfinancial_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPFinancial::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcpfinancial_wheelevent_isbase) {
            qcpfinancial_wheelevent_isbase = false;
            QCPFinancial::wheelEvent(event);
        } else if (qcpfinancial_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcpfinancial_wheelevent_callback(this, cbval1);
        } else {
            QCPFinancial::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpfinancial_event_isbase) {
            qcpfinancial_event_isbase = false;
            return QCPFinancial::event(event);
        } else if (qcpfinancial_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpfinancial_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPFinancial::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpfinancial_eventfilter_isbase) {
            qcpfinancial_eventfilter_isbase = false;
            return QCPFinancial::eventFilter(watched, event);
        } else if (qcpfinancial_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpfinancial_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPFinancial::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpfinancial_timerevent_isbase) {
            qcpfinancial_timerevent_isbase = false;
            QCPFinancial::timerEvent(event);
        } else if (qcpfinancial_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpfinancial_timerevent_callback(this, cbval1);
        } else {
            QCPFinancial::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpfinancial_childevent_isbase) {
            qcpfinancial_childevent_isbase = false;
            QCPFinancial::childEvent(event);
        } else if (qcpfinancial_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpfinancial_childevent_callback(this, cbval1);
        } else {
            QCPFinancial::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpfinancial_customevent_isbase) {
            qcpfinancial_customevent_isbase = false;
            QCPFinancial::customEvent(event);
        } else if (qcpfinancial_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpfinancial_customevent_callback(this, cbval1);
        } else {
            QCPFinancial::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpfinancial_connectnotify_isbase) {
            qcpfinancial_connectnotify_isbase = false;
            QCPFinancial::connectNotify(signal);
        } else if (qcpfinancial_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpfinancial_connectnotify_callback(this, cbval1);
        } else {
            QCPFinancial::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpfinancial_disconnectnotify_isbase) {
            qcpfinancial_disconnectnotify_isbase = false;
            QCPFinancial::disconnectNotify(signal);
        } else if (qcpfinancial_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpfinancial_disconnectnotify_callback(this, cbval1);
        } else {
            QCPFinancial::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    double getPixelWidth(double key, double keyPixel) const {
        if (qcpfinancial_getpixelwidth_isbase) {
            qcpfinancial_getpixelwidth_isbase = false;
            return QCPFinancial::getPixelWidth(key, keyPixel);
        } else if (qcpfinancial_getpixelwidth_callback != nullptr) {
            double cbval1 = key;
            double cbval2 = keyPixel;

            double callback_ret = qcpfinancial_getpixelwidth_callback(this, cbval1, cbval2);
            return static_cast<double>(callback_ret);
        } else {
            return QCPFinancial::getPixelWidth(key, keyPixel);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyFillAntialiasingHint(QCPPainter* painter) const {
        if (qcpfinancial_applyfillantialiasinghint_isbase) {
            qcpfinancial_applyfillantialiasinghint_isbase = false;
            QCPFinancial::applyFillAntialiasingHint(painter);
        } else if (qcpfinancial_applyfillantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpfinancial_applyfillantialiasinghint_callback(this, cbval1);
        } else {
            QCPFinancial::applyFillAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyScattersAntialiasingHint(QCPPainter* painter) const {
        if (qcpfinancial_applyscattersantialiasinghint_isbase) {
            qcpfinancial_applyscattersantialiasinghint_isbase = false;
            QCPFinancial::applyScattersAntialiasingHint(painter);
        } else if (qcpfinancial_applyscattersantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpfinancial_applyscattersantialiasinghint_callback(this, cbval1);
        } else {
            QCPFinancial::applyScattersAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcpfinancial_initializeparentplot_isbase) {
            qcpfinancial_initializeparentplot_isbase = false;
            QCPFinancial::initializeParentPlot(parentPlot);
        } else if (qcpfinancial_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpfinancial_initializeparentplot_callback(this, cbval1);
        } else {
            QCPFinancial::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcpfinancial_setparentlayerable_isbase) {
            qcpfinancial_setparentlayerable_isbase = false;
            QCPFinancial::setParentLayerable(parentLayerable);
        } else if (qcpfinancial_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcpfinancial_setparentlayerable_callback(this, cbval1);
        } else {
            QCPFinancial::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcpfinancial_movetolayer_isbase) {
            qcpfinancial_movetolayer_isbase = false;
            return QCPFinancial::moveToLayer(layer, prepend);
        } else if (qcpfinancial_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcpfinancial_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPFinancial::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcpfinancial_applyantialiasinghint_isbase) {
            qcpfinancial_applyantialiasinghint_isbase = false;
            QCPFinancial::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcpfinancial_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcpfinancial_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPFinancial::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpfinancial_sender_isbase) {
            qcpfinancial_sender_isbase = false;
            return QCPFinancial::sender();
        } else if (qcpfinancial_sender_callback != nullptr) {
            QObject* callback_ret = qcpfinancial_sender_callback();
            return callback_ret;
        } else {
            return QCPFinancial::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpfinancial_sendersignalindex_isbase) {
            qcpfinancial_sendersignalindex_isbase = false;
            return QCPFinancial::senderSignalIndex();
        } else if (qcpfinancial_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpfinancial_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPFinancial::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpfinancial_receivers_isbase) {
            qcpfinancial_receivers_isbase = false;
            return QCPFinancial::receivers(signal);
        } else if (qcpfinancial_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpfinancial_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPFinancial::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpfinancial_issignalconnected_isbase) {
            qcpfinancial_issignalconnected_isbase = false;
            return QCPFinancial::isSignalConnected(signal);
        } else if (qcpfinancial_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpfinancial_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPFinancial::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPFinancial_Draw(QCPFinancial* self, QCPPainter* painter);
    friend void QCPFinancial_QBaseDraw(QCPFinancial* self, QCPPainter* painter);
    friend void QCPFinancial_DrawLegendIcon(const QCPFinancial* self, QCPPainter* painter, const QRectF* rect);
    friend void QCPFinancial_QBaseDrawLegendIcon(const QCPFinancial* self, QCPPainter* painter, const QRectF* rect);
    friend QRect* QCPFinancial_ClipRect(const QCPFinancial* self);
    friend QRect* QCPFinancial_QBaseClipRect(const QCPFinancial* self);
    friend int QCPFinancial_SelectionCategory(const QCPFinancial* self);
    friend int QCPFinancial_QBaseSelectionCategory(const QCPFinancial* self);
    friend void QCPFinancial_ApplyDefaultAntialiasingHint(const QCPFinancial* self, QCPPainter* painter);
    friend void QCPFinancial_QBaseApplyDefaultAntialiasingHint(const QCPFinancial* self, QCPPainter* painter);
    friend void QCPFinancial_SelectEvent(QCPFinancial* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPFinancial_QBaseSelectEvent(QCPFinancial* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPFinancial_DeselectEvent(QCPFinancial* self, bool* selectionStateChanged);
    friend void QCPFinancial_QBaseDeselectEvent(QCPFinancial* self, bool* selectionStateChanged);
    friend void QCPFinancial_ParentPlotInitialized(QCPFinancial* self, QCustomPlot* parentPlot);
    friend void QCPFinancial_QBaseParentPlotInitialized(QCPFinancial* self, QCustomPlot* parentPlot);
    friend void QCPFinancial_MousePressEvent(QCPFinancial* self, QMouseEvent* event, const QVariant* details);
    friend void QCPFinancial_QBaseMousePressEvent(QCPFinancial* self, QMouseEvent* event, const QVariant* details);
    friend void QCPFinancial_MouseMoveEvent(QCPFinancial* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPFinancial_QBaseMouseMoveEvent(QCPFinancial* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPFinancial_MouseReleaseEvent(QCPFinancial* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPFinancial_QBaseMouseReleaseEvent(QCPFinancial* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPFinancial_MouseDoubleClickEvent(QCPFinancial* self, QMouseEvent* event, const QVariant* details);
    friend void QCPFinancial_QBaseMouseDoubleClickEvent(QCPFinancial* self, QMouseEvent* event, const QVariant* details);
    friend void QCPFinancial_WheelEvent(QCPFinancial* self, QWheelEvent* event);
    friend void QCPFinancial_QBaseWheelEvent(QCPFinancial* self, QWheelEvent* event);
    friend void QCPFinancial_TimerEvent(QCPFinancial* self, QTimerEvent* event);
    friend void QCPFinancial_QBaseTimerEvent(QCPFinancial* self, QTimerEvent* event);
    friend void QCPFinancial_ChildEvent(QCPFinancial* self, QChildEvent* event);
    friend void QCPFinancial_QBaseChildEvent(QCPFinancial* self, QChildEvent* event);
    friend void QCPFinancial_CustomEvent(QCPFinancial* self, QEvent* event);
    friend void QCPFinancial_QBaseCustomEvent(QCPFinancial* self, QEvent* event);
    friend void QCPFinancial_ConnectNotify(QCPFinancial* self, const QMetaMethod* signal);
    friend void QCPFinancial_QBaseConnectNotify(QCPFinancial* self, const QMetaMethod* signal);
    friend void QCPFinancial_DisconnectNotify(QCPFinancial* self, const QMetaMethod* signal);
    friend void QCPFinancial_QBaseDisconnectNotify(QCPFinancial* self, const QMetaMethod* signal);
    friend double QCPFinancial_GetPixelWidth(const QCPFinancial* self, double key, double keyPixel);
    friend double QCPFinancial_QBaseGetPixelWidth(const QCPFinancial* self, double key, double keyPixel);
    friend void QCPFinancial_ApplyFillAntialiasingHint(const QCPFinancial* self, QCPPainter* painter);
    friend void QCPFinancial_QBaseApplyFillAntialiasingHint(const QCPFinancial* self, QCPPainter* painter);
    friend void QCPFinancial_ApplyScattersAntialiasingHint(const QCPFinancial* self, QCPPainter* painter);
    friend void QCPFinancial_QBaseApplyScattersAntialiasingHint(const QCPFinancial* self, QCPPainter* painter);
    friend void QCPFinancial_InitializeParentPlot(QCPFinancial* self, QCustomPlot* parentPlot);
    friend void QCPFinancial_QBaseInitializeParentPlot(QCPFinancial* self, QCustomPlot* parentPlot);
    friend void QCPFinancial_SetParentLayerable(QCPFinancial* self, QCPLayerable* parentLayerable);
    friend void QCPFinancial_QBaseSetParentLayerable(QCPFinancial* self, QCPLayerable* parentLayerable);
    friend bool QCPFinancial_MoveToLayer(QCPFinancial* self, QCPLayer* layer, bool prepend);
    friend bool QCPFinancial_QBaseMoveToLayer(QCPFinancial* self, QCPLayer* layer, bool prepend);
    friend void QCPFinancial_ApplyAntialiasingHint(const QCPFinancial* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPFinancial_QBaseApplyAntialiasingHint(const QCPFinancial* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPFinancial_Sender(const QCPFinancial* self);
    friend QObject* QCPFinancial_QBaseSender(const QCPFinancial* self);
    friend int QCPFinancial_SenderSignalIndex(const QCPFinancial* self);
    friend int QCPFinancial_QBaseSenderSignalIndex(const QCPFinancial* self);
    friend int QCPFinancial_Receivers(const QCPFinancial* self, const char* signal);
    friend int QCPFinancial_QBaseReceivers(const QCPFinancial* self, const char* signal);
    friend bool QCPFinancial_IsSignalConnected(const QCPFinancial* self, const QMetaMethod* signal);
    friend bool QCPFinancial_QBaseIsSignalConnected(const QCPFinancial* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPErrorBars so that we can call protected methods
class VirtualQCPErrorBars final : public QCPErrorBars {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPErrorBars = true;

    // Virtual class public types (including callbacks)
    using QCPErrorBars_Metacall_Callback = int (*)(QCPErrorBars*, int, int, void**);
    using QCPErrorBars_DataCount_Callback = int (*)();
    using QCPErrorBars_DataMainKey_Callback = double (*)(const QCPErrorBars*, int);
    using QCPErrorBars_DataSortKey_Callback = double (*)(const QCPErrorBars*, int);
    using QCPErrorBars_DataMainValue_Callback = double (*)(const QCPErrorBars*, int);
    using QCPErrorBars_DataValueRange_Callback = QCPRange* (*)(const QCPErrorBars*, int);
    using QCPErrorBars_DataPixelPosition_Callback = QPointF* (*)(const QCPErrorBars*, int);
    using QCPErrorBars_SortKeyIsMainKey_Callback = bool (*)();
    using QCPErrorBars_SelectTestRect_Callback = QCPDataSelection* (*)(const QCPErrorBars*, QRectF*, bool);
    using QCPErrorBars_FindBegin_Callback = int (*)(const QCPErrorBars*, double, bool);
    using QCPErrorBars_FindEnd_Callback = int (*)(const QCPErrorBars*, double, bool);
    using QCPErrorBars_SelectTest_Callback = double (*)(const QCPErrorBars*, QPointF*, bool, QVariant*);
    using QCPErrorBars_Interface1D_Callback = QCPPlottableInterface1D* (*)();
    using QCPErrorBars_Draw_Callback = void (*)(QCPErrorBars*, QCPPainter*);
    using QCPErrorBars_DrawLegendIcon_Callback = void (*)(const QCPErrorBars*, QCPPainter*, QRectF*);
    using QCPErrorBars_GetKeyRange_Callback = QCPRange* (*)(const QCPErrorBars*, bool*, int);
    using QCPErrorBars_GetValueRange_Callback = QCPRange* (*)(const QCPErrorBars*, bool*, int, QCPRange*);
    using QCPErrorBars_ClipRect_Callback = QRect* (*)();
    using QCPErrorBars_SelectionCategory_Callback = int (*)();
    using QCPErrorBars_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPErrorBars*, QCPPainter*);
    using QCPErrorBars_SelectEvent_Callback = void (*)(QCPErrorBars*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPErrorBars_DeselectEvent_Callback = void (*)(QCPErrorBars*, bool*);
    using QCPErrorBars_ParentPlotInitialized_Callback = void (*)(QCPErrorBars*, QCustomPlot*);
    using QCPErrorBars_MousePressEvent_Callback = void (*)(QCPErrorBars*, QMouseEvent*, QVariant*);
    using QCPErrorBars_MouseMoveEvent_Callback = void (*)(QCPErrorBars*, QMouseEvent*, QPointF*);
    using QCPErrorBars_MouseReleaseEvent_Callback = void (*)(QCPErrorBars*, QMouseEvent*, QPointF*);
    using QCPErrorBars_MouseDoubleClickEvent_Callback = void (*)(QCPErrorBars*, QMouseEvent*, QVariant*);
    using QCPErrorBars_WheelEvent_Callback = void (*)(QCPErrorBars*, QWheelEvent*);
    using QCPErrorBars_Event_Callback = bool (*)(QCPErrorBars*, QEvent*);
    using QCPErrorBars_EventFilter_Callback = bool (*)(QCPErrorBars*, QObject*, QEvent*);
    using QCPErrorBars_TimerEvent_Callback = void (*)(QCPErrorBars*, QTimerEvent*);
    using QCPErrorBars_ChildEvent_Callback = void (*)(QCPErrorBars*, QChildEvent*);
    using QCPErrorBars_CustomEvent_Callback = void (*)(QCPErrorBars*, QEvent*);
    using QCPErrorBars_ConnectNotify_Callback = void (*)(QCPErrorBars*, QMetaMethod*);
    using QCPErrorBars_DisconnectNotify_Callback = void (*)(QCPErrorBars*, QMetaMethod*);
    using QCPErrorBars_GetDataSegments_Callback = void (*)(const QCPErrorBars*, libqt_list /* of QCPDataRange* */, libqt_list /* of QCPDataRange* */);
    using QCPErrorBars_ErrorBarVisible_Callback = bool (*)(const QCPErrorBars*, int);
    using QCPErrorBars_RectIntersectsLine_Callback = bool (*)(const QCPErrorBars*, QRectF*, QLineF*);
    using QCPErrorBars_ApplyFillAntialiasingHint_Callback = void (*)(const QCPErrorBars*, QCPPainter*);
    using QCPErrorBars_ApplyScattersAntialiasingHint_Callback = void (*)(const QCPErrorBars*, QCPPainter*);
    using QCPErrorBars_InitializeParentPlot_Callback = void (*)(QCPErrorBars*, QCustomPlot*);
    using QCPErrorBars_SetParentLayerable_Callback = void (*)(QCPErrorBars*, QCPLayerable*);
    using QCPErrorBars_MoveToLayer_Callback = bool (*)(QCPErrorBars*, QCPLayer*, bool);
    using QCPErrorBars_ApplyAntialiasingHint_Callback = void (*)(const QCPErrorBars*, QCPPainter*, bool, int);
    using QCPErrorBars_Sender_Callback = QObject* (*)();
    using QCPErrorBars_SenderSignalIndex_Callback = int (*)();
    using QCPErrorBars_Receivers_Callback = int (*)(const QCPErrorBars*, const char*);
    using QCPErrorBars_IsSignalConnected_Callback = bool (*)(const QCPErrorBars*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPErrorBars_Metacall_Callback qcperrorbars_metacall_callback = nullptr;
    QCPErrorBars_DataCount_Callback qcperrorbars_datacount_callback = nullptr;
    QCPErrorBars_DataMainKey_Callback qcperrorbars_datamainkey_callback = nullptr;
    QCPErrorBars_DataSortKey_Callback qcperrorbars_datasortkey_callback = nullptr;
    QCPErrorBars_DataMainValue_Callback qcperrorbars_datamainvalue_callback = nullptr;
    QCPErrorBars_DataValueRange_Callback qcperrorbars_datavaluerange_callback = nullptr;
    QCPErrorBars_DataPixelPosition_Callback qcperrorbars_datapixelposition_callback = nullptr;
    QCPErrorBars_SortKeyIsMainKey_Callback qcperrorbars_sortkeyismainkey_callback = nullptr;
    QCPErrorBars_SelectTestRect_Callback qcperrorbars_selecttestrect_callback = nullptr;
    QCPErrorBars_FindBegin_Callback qcperrorbars_findbegin_callback = nullptr;
    QCPErrorBars_FindEnd_Callback qcperrorbars_findend_callback = nullptr;
    QCPErrorBars_SelectTest_Callback qcperrorbars_selecttest_callback = nullptr;
    QCPErrorBars_Interface1D_Callback qcperrorbars_interface1d_callback = nullptr;
    QCPErrorBars_Draw_Callback qcperrorbars_draw_callback = nullptr;
    QCPErrorBars_DrawLegendIcon_Callback qcperrorbars_drawlegendicon_callback = nullptr;
    QCPErrorBars_GetKeyRange_Callback qcperrorbars_getkeyrange_callback = nullptr;
    QCPErrorBars_GetValueRange_Callback qcperrorbars_getvaluerange_callback = nullptr;
    QCPErrorBars_ClipRect_Callback qcperrorbars_cliprect_callback = nullptr;
    QCPErrorBars_SelectionCategory_Callback qcperrorbars_selectioncategory_callback = nullptr;
    QCPErrorBars_ApplyDefaultAntialiasingHint_Callback qcperrorbars_applydefaultantialiasinghint_callback = nullptr;
    QCPErrorBars_SelectEvent_Callback qcperrorbars_selectevent_callback = nullptr;
    QCPErrorBars_DeselectEvent_Callback qcperrorbars_deselectevent_callback = nullptr;
    QCPErrorBars_ParentPlotInitialized_Callback qcperrorbars_parentplotinitialized_callback = nullptr;
    QCPErrorBars_MousePressEvent_Callback qcperrorbars_mousepressevent_callback = nullptr;
    QCPErrorBars_MouseMoveEvent_Callback qcperrorbars_mousemoveevent_callback = nullptr;
    QCPErrorBars_MouseReleaseEvent_Callback qcperrorbars_mousereleaseevent_callback = nullptr;
    QCPErrorBars_MouseDoubleClickEvent_Callback qcperrorbars_mousedoubleclickevent_callback = nullptr;
    QCPErrorBars_WheelEvent_Callback qcperrorbars_wheelevent_callback = nullptr;
    QCPErrorBars_Event_Callback qcperrorbars_event_callback = nullptr;
    QCPErrorBars_EventFilter_Callback qcperrorbars_eventfilter_callback = nullptr;
    QCPErrorBars_TimerEvent_Callback qcperrorbars_timerevent_callback = nullptr;
    QCPErrorBars_ChildEvent_Callback qcperrorbars_childevent_callback = nullptr;
    QCPErrorBars_CustomEvent_Callback qcperrorbars_customevent_callback = nullptr;
    QCPErrorBars_ConnectNotify_Callback qcperrorbars_connectnotify_callback = nullptr;
    QCPErrorBars_DisconnectNotify_Callback qcperrorbars_disconnectnotify_callback = nullptr;
    QCPErrorBars_GetDataSegments_Callback qcperrorbars_getdatasegments_callback = nullptr;
    QCPErrorBars_ErrorBarVisible_Callback qcperrorbars_errorbarvisible_callback = nullptr;
    QCPErrorBars_RectIntersectsLine_Callback qcperrorbars_rectintersectsline_callback = nullptr;
    QCPErrorBars_ApplyFillAntialiasingHint_Callback qcperrorbars_applyfillantialiasinghint_callback = nullptr;
    QCPErrorBars_ApplyScattersAntialiasingHint_Callback qcperrorbars_applyscattersantialiasinghint_callback = nullptr;
    QCPErrorBars_InitializeParentPlot_Callback qcperrorbars_initializeparentplot_callback = nullptr;
    QCPErrorBars_SetParentLayerable_Callback qcperrorbars_setparentlayerable_callback = nullptr;
    QCPErrorBars_MoveToLayer_Callback qcperrorbars_movetolayer_callback = nullptr;
    QCPErrorBars_ApplyAntialiasingHint_Callback qcperrorbars_applyantialiasinghint_callback = nullptr;
    QCPErrorBars_Sender_Callback qcperrorbars_sender_callback = nullptr;
    QCPErrorBars_SenderSignalIndex_Callback qcperrorbars_sendersignalindex_callback = nullptr;
    QCPErrorBars_Receivers_Callback qcperrorbars_receivers_callback = nullptr;
    QCPErrorBars_IsSignalConnected_Callback qcperrorbars_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcperrorbars_metacall_isbase = false;
    mutable bool qcperrorbars_datacount_isbase = false;
    mutable bool qcperrorbars_datamainkey_isbase = false;
    mutable bool qcperrorbars_datasortkey_isbase = false;
    mutable bool qcperrorbars_datamainvalue_isbase = false;
    mutable bool qcperrorbars_datavaluerange_isbase = false;
    mutable bool qcperrorbars_datapixelposition_isbase = false;
    mutable bool qcperrorbars_sortkeyismainkey_isbase = false;
    mutable bool qcperrorbars_selecttestrect_isbase = false;
    mutable bool qcperrorbars_findbegin_isbase = false;
    mutable bool qcperrorbars_findend_isbase = false;
    mutable bool qcperrorbars_selecttest_isbase = false;
    mutable bool qcperrorbars_interface1d_isbase = false;
    mutable bool qcperrorbars_draw_isbase = false;
    mutable bool qcperrorbars_drawlegendicon_isbase = false;
    mutable bool qcperrorbars_getkeyrange_isbase = false;
    mutable bool qcperrorbars_getvaluerange_isbase = false;
    mutable bool qcperrorbars_cliprect_isbase = false;
    mutable bool qcperrorbars_selectioncategory_isbase = false;
    mutable bool qcperrorbars_applydefaultantialiasinghint_isbase = false;
    mutable bool qcperrorbars_selectevent_isbase = false;
    mutable bool qcperrorbars_deselectevent_isbase = false;
    mutable bool qcperrorbars_parentplotinitialized_isbase = false;
    mutable bool qcperrorbars_mousepressevent_isbase = false;
    mutable bool qcperrorbars_mousemoveevent_isbase = false;
    mutable bool qcperrorbars_mousereleaseevent_isbase = false;
    mutable bool qcperrorbars_mousedoubleclickevent_isbase = false;
    mutable bool qcperrorbars_wheelevent_isbase = false;
    mutable bool qcperrorbars_event_isbase = false;
    mutable bool qcperrorbars_eventfilter_isbase = false;
    mutable bool qcperrorbars_timerevent_isbase = false;
    mutable bool qcperrorbars_childevent_isbase = false;
    mutable bool qcperrorbars_customevent_isbase = false;
    mutable bool qcperrorbars_connectnotify_isbase = false;
    mutable bool qcperrorbars_disconnectnotify_isbase = false;
    mutable bool qcperrorbars_getdatasegments_isbase = false;
    mutable bool qcperrorbars_errorbarvisible_isbase = false;
    mutable bool qcperrorbars_rectintersectsline_isbase = false;
    mutable bool qcperrorbars_applyfillantialiasinghint_isbase = false;
    mutable bool qcperrorbars_applyscattersantialiasinghint_isbase = false;
    mutable bool qcperrorbars_initializeparentplot_isbase = false;
    mutable bool qcperrorbars_setparentlayerable_isbase = false;
    mutable bool qcperrorbars_movetolayer_isbase = false;
    mutable bool qcperrorbars_applyantialiasinghint_isbase = false;
    mutable bool qcperrorbars_sender_isbase = false;
    mutable bool qcperrorbars_sendersignalindex_isbase = false;
    mutable bool qcperrorbars_receivers_isbase = false;
    mutable bool qcperrorbars_issignalconnected_isbase = false;

  public:
    VirtualQCPErrorBars(QCPAxis* keyAxis, QCPAxis* valueAxis) : QCPErrorBars(keyAxis, valueAxis) {};

    ~VirtualQCPErrorBars() {
        qcperrorbars_metacall_callback = nullptr;
        qcperrorbars_datacount_callback = nullptr;
        qcperrorbars_datamainkey_callback = nullptr;
        qcperrorbars_datasortkey_callback = nullptr;
        qcperrorbars_datamainvalue_callback = nullptr;
        qcperrorbars_datavaluerange_callback = nullptr;
        qcperrorbars_datapixelposition_callback = nullptr;
        qcperrorbars_sortkeyismainkey_callback = nullptr;
        qcperrorbars_selecttestrect_callback = nullptr;
        qcperrorbars_findbegin_callback = nullptr;
        qcperrorbars_findend_callback = nullptr;
        qcperrorbars_selecttest_callback = nullptr;
        qcperrorbars_interface1d_callback = nullptr;
        qcperrorbars_draw_callback = nullptr;
        qcperrorbars_drawlegendicon_callback = nullptr;
        qcperrorbars_getkeyrange_callback = nullptr;
        qcperrorbars_getvaluerange_callback = nullptr;
        qcperrorbars_cliprect_callback = nullptr;
        qcperrorbars_selectioncategory_callback = nullptr;
        qcperrorbars_applydefaultantialiasinghint_callback = nullptr;
        qcperrorbars_selectevent_callback = nullptr;
        qcperrorbars_deselectevent_callback = nullptr;
        qcperrorbars_parentplotinitialized_callback = nullptr;
        qcperrorbars_mousepressevent_callback = nullptr;
        qcperrorbars_mousemoveevent_callback = nullptr;
        qcperrorbars_mousereleaseevent_callback = nullptr;
        qcperrorbars_mousedoubleclickevent_callback = nullptr;
        qcperrorbars_wheelevent_callback = nullptr;
        qcperrorbars_event_callback = nullptr;
        qcperrorbars_eventfilter_callback = nullptr;
        qcperrorbars_timerevent_callback = nullptr;
        qcperrorbars_childevent_callback = nullptr;
        qcperrorbars_customevent_callback = nullptr;
        qcperrorbars_connectnotify_callback = nullptr;
        qcperrorbars_disconnectnotify_callback = nullptr;
        qcperrorbars_getdatasegments_callback = nullptr;
        qcperrorbars_errorbarvisible_callback = nullptr;
        qcperrorbars_rectintersectsline_callback = nullptr;
        qcperrorbars_applyfillantialiasinghint_callback = nullptr;
        qcperrorbars_applyscattersantialiasinghint_callback = nullptr;
        qcperrorbars_initializeparentplot_callback = nullptr;
        qcperrorbars_setparentlayerable_callback = nullptr;
        qcperrorbars_movetolayer_callback = nullptr;
        qcperrorbars_applyantialiasinghint_callback = nullptr;
        qcperrorbars_sender_callback = nullptr;
        qcperrorbars_sendersignalindex_callback = nullptr;
        qcperrorbars_receivers_callback = nullptr;
        qcperrorbars_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPErrorBars_Metacall_Callback(QCPErrorBars_Metacall_Callback cb) { qcperrorbars_metacall_callback = cb; }
    inline void setQCPErrorBars_DataCount_Callback(QCPErrorBars_DataCount_Callback cb) { qcperrorbars_datacount_callback = cb; }
    inline void setQCPErrorBars_DataMainKey_Callback(QCPErrorBars_DataMainKey_Callback cb) { qcperrorbars_datamainkey_callback = cb; }
    inline void setQCPErrorBars_DataSortKey_Callback(QCPErrorBars_DataSortKey_Callback cb) { qcperrorbars_datasortkey_callback = cb; }
    inline void setQCPErrorBars_DataMainValue_Callback(QCPErrorBars_DataMainValue_Callback cb) { qcperrorbars_datamainvalue_callback = cb; }
    inline void setQCPErrorBars_DataValueRange_Callback(QCPErrorBars_DataValueRange_Callback cb) { qcperrorbars_datavaluerange_callback = cb; }
    inline void setQCPErrorBars_DataPixelPosition_Callback(QCPErrorBars_DataPixelPosition_Callback cb) { qcperrorbars_datapixelposition_callback = cb; }
    inline void setQCPErrorBars_SortKeyIsMainKey_Callback(QCPErrorBars_SortKeyIsMainKey_Callback cb) { qcperrorbars_sortkeyismainkey_callback = cb; }
    inline void setQCPErrorBars_SelectTestRect_Callback(QCPErrorBars_SelectTestRect_Callback cb) { qcperrorbars_selecttestrect_callback = cb; }
    inline void setQCPErrorBars_FindBegin_Callback(QCPErrorBars_FindBegin_Callback cb) { qcperrorbars_findbegin_callback = cb; }
    inline void setQCPErrorBars_FindEnd_Callback(QCPErrorBars_FindEnd_Callback cb) { qcperrorbars_findend_callback = cb; }
    inline void setQCPErrorBars_SelectTest_Callback(QCPErrorBars_SelectTest_Callback cb) { qcperrorbars_selecttest_callback = cb; }
    inline void setQCPErrorBars_Interface1D_Callback(QCPErrorBars_Interface1D_Callback cb) { qcperrorbars_interface1d_callback = cb; }
    inline void setQCPErrorBars_Draw_Callback(QCPErrorBars_Draw_Callback cb) { qcperrorbars_draw_callback = cb; }
    inline void setQCPErrorBars_DrawLegendIcon_Callback(QCPErrorBars_DrawLegendIcon_Callback cb) { qcperrorbars_drawlegendicon_callback = cb; }
    inline void setQCPErrorBars_GetKeyRange_Callback(QCPErrorBars_GetKeyRange_Callback cb) { qcperrorbars_getkeyrange_callback = cb; }
    inline void setQCPErrorBars_GetValueRange_Callback(QCPErrorBars_GetValueRange_Callback cb) { qcperrorbars_getvaluerange_callback = cb; }
    inline void setQCPErrorBars_ClipRect_Callback(QCPErrorBars_ClipRect_Callback cb) { qcperrorbars_cliprect_callback = cb; }
    inline void setQCPErrorBars_SelectionCategory_Callback(QCPErrorBars_SelectionCategory_Callback cb) { qcperrorbars_selectioncategory_callback = cb; }
    inline void setQCPErrorBars_ApplyDefaultAntialiasingHint_Callback(QCPErrorBars_ApplyDefaultAntialiasingHint_Callback cb) { qcperrorbars_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPErrorBars_SelectEvent_Callback(QCPErrorBars_SelectEvent_Callback cb) { qcperrorbars_selectevent_callback = cb; }
    inline void setQCPErrorBars_DeselectEvent_Callback(QCPErrorBars_DeselectEvent_Callback cb) { qcperrorbars_deselectevent_callback = cb; }
    inline void setQCPErrorBars_ParentPlotInitialized_Callback(QCPErrorBars_ParentPlotInitialized_Callback cb) { qcperrorbars_parentplotinitialized_callback = cb; }
    inline void setQCPErrorBars_MousePressEvent_Callback(QCPErrorBars_MousePressEvent_Callback cb) { qcperrorbars_mousepressevent_callback = cb; }
    inline void setQCPErrorBars_MouseMoveEvent_Callback(QCPErrorBars_MouseMoveEvent_Callback cb) { qcperrorbars_mousemoveevent_callback = cb; }
    inline void setQCPErrorBars_MouseReleaseEvent_Callback(QCPErrorBars_MouseReleaseEvent_Callback cb) { qcperrorbars_mousereleaseevent_callback = cb; }
    inline void setQCPErrorBars_MouseDoubleClickEvent_Callback(QCPErrorBars_MouseDoubleClickEvent_Callback cb) { qcperrorbars_mousedoubleclickevent_callback = cb; }
    inline void setQCPErrorBars_WheelEvent_Callback(QCPErrorBars_WheelEvent_Callback cb) { qcperrorbars_wheelevent_callback = cb; }
    inline void setQCPErrorBars_Event_Callback(QCPErrorBars_Event_Callback cb) { qcperrorbars_event_callback = cb; }
    inline void setQCPErrorBars_EventFilter_Callback(QCPErrorBars_EventFilter_Callback cb) { qcperrorbars_eventfilter_callback = cb; }
    inline void setQCPErrorBars_TimerEvent_Callback(QCPErrorBars_TimerEvent_Callback cb) { qcperrorbars_timerevent_callback = cb; }
    inline void setQCPErrorBars_ChildEvent_Callback(QCPErrorBars_ChildEvent_Callback cb) { qcperrorbars_childevent_callback = cb; }
    inline void setQCPErrorBars_CustomEvent_Callback(QCPErrorBars_CustomEvent_Callback cb) { qcperrorbars_customevent_callback = cb; }
    inline void setQCPErrorBars_ConnectNotify_Callback(QCPErrorBars_ConnectNotify_Callback cb) { qcperrorbars_connectnotify_callback = cb; }
    inline void setQCPErrorBars_DisconnectNotify_Callback(QCPErrorBars_DisconnectNotify_Callback cb) { qcperrorbars_disconnectnotify_callback = cb; }
    inline void setQCPErrorBars_GetDataSegments_Callback(QCPErrorBars_GetDataSegments_Callback cb) { qcperrorbars_getdatasegments_callback = cb; }
    inline void setQCPErrorBars_ErrorBarVisible_Callback(QCPErrorBars_ErrorBarVisible_Callback cb) { qcperrorbars_errorbarvisible_callback = cb; }
    inline void setQCPErrorBars_RectIntersectsLine_Callback(QCPErrorBars_RectIntersectsLine_Callback cb) { qcperrorbars_rectintersectsline_callback = cb; }
    inline void setQCPErrorBars_ApplyFillAntialiasingHint_Callback(QCPErrorBars_ApplyFillAntialiasingHint_Callback cb) { qcperrorbars_applyfillantialiasinghint_callback = cb; }
    inline void setQCPErrorBars_ApplyScattersAntialiasingHint_Callback(QCPErrorBars_ApplyScattersAntialiasingHint_Callback cb) { qcperrorbars_applyscattersantialiasinghint_callback = cb; }
    inline void setQCPErrorBars_InitializeParentPlot_Callback(QCPErrorBars_InitializeParentPlot_Callback cb) { qcperrorbars_initializeparentplot_callback = cb; }
    inline void setQCPErrorBars_SetParentLayerable_Callback(QCPErrorBars_SetParentLayerable_Callback cb) { qcperrorbars_setparentlayerable_callback = cb; }
    inline void setQCPErrorBars_MoveToLayer_Callback(QCPErrorBars_MoveToLayer_Callback cb) { qcperrorbars_movetolayer_callback = cb; }
    inline void setQCPErrorBars_ApplyAntialiasingHint_Callback(QCPErrorBars_ApplyAntialiasingHint_Callback cb) { qcperrorbars_applyantialiasinghint_callback = cb; }
    inline void setQCPErrorBars_Sender_Callback(QCPErrorBars_Sender_Callback cb) { qcperrorbars_sender_callback = cb; }
    inline void setQCPErrorBars_SenderSignalIndex_Callback(QCPErrorBars_SenderSignalIndex_Callback cb) { qcperrorbars_sendersignalindex_callback = cb; }
    inline void setQCPErrorBars_Receivers_Callback(QCPErrorBars_Receivers_Callback cb) { qcperrorbars_receivers_callback = cb; }
    inline void setQCPErrorBars_IsSignalConnected_Callback(QCPErrorBars_IsSignalConnected_Callback cb) { qcperrorbars_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPErrorBars_Metacall_IsBase(bool value) const { qcperrorbars_metacall_isbase = value; }
    inline void setQCPErrorBars_DataCount_IsBase(bool value) const { qcperrorbars_datacount_isbase = value; }
    inline void setQCPErrorBars_DataMainKey_IsBase(bool value) const { qcperrorbars_datamainkey_isbase = value; }
    inline void setQCPErrorBars_DataSortKey_IsBase(bool value) const { qcperrorbars_datasortkey_isbase = value; }
    inline void setQCPErrorBars_DataMainValue_IsBase(bool value) const { qcperrorbars_datamainvalue_isbase = value; }
    inline void setQCPErrorBars_DataValueRange_IsBase(bool value) const { qcperrorbars_datavaluerange_isbase = value; }
    inline void setQCPErrorBars_DataPixelPosition_IsBase(bool value) const { qcperrorbars_datapixelposition_isbase = value; }
    inline void setQCPErrorBars_SortKeyIsMainKey_IsBase(bool value) const { qcperrorbars_sortkeyismainkey_isbase = value; }
    inline void setQCPErrorBars_SelectTestRect_IsBase(bool value) const { qcperrorbars_selecttestrect_isbase = value; }
    inline void setQCPErrorBars_FindBegin_IsBase(bool value) const { qcperrorbars_findbegin_isbase = value; }
    inline void setQCPErrorBars_FindEnd_IsBase(bool value) const { qcperrorbars_findend_isbase = value; }
    inline void setQCPErrorBars_SelectTest_IsBase(bool value) const { qcperrorbars_selecttest_isbase = value; }
    inline void setQCPErrorBars_Interface1D_IsBase(bool value) const { qcperrorbars_interface1d_isbase = value; }
    inline void setQCPErrorBars_Draw_IsBase(bool value) const { qcperrorbars_draw_isbase = value; }
    inline void setQCPErrorBars_DrawLegendIcon_IsBase(bool value) const { qcperrorbars_drawlegendicon_isbase = value; }
    inline void setQCPErrorBars_GetKeyRange_IsBase(bool value) const { qcperrorbars_getkeyrange_isbase = value; }
    inline void setQCPErrorBars_GetValueRange_IsBase(bool value) const { qcperrorbars_getvaluerange_isbase = value; }
    inline void setQCPErrorBars_ClipRect_IsBase(bool value) const { qcperrorbars_cliprect_isbase = value; }
    inline void setQCPErrorBars_SelectionCategory_IsBase(bool value) const { qcperrorbars_selectioncategory_isbase = value; }
    inline void setQCPErrorBars_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcperrorbars_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPErrorBars_SelectEvent_IsBase(bool value) const { qcperrorbars_selectevent_isbase = value; }
    inline void setQCPErrorBars_DeselectEvent_IsBase(bool value) const { qcperrorbars_deselectevent_isbase = value; }
    inline void setQCPErrorBars_ParentPlotInitialized_IsBase(bool value) const { qcperrorbars_parentplotinitialized_isbase = value; }
    inline void setQCPErrorBars_MousePressEvent_IsBase(bool value) const { qcperrorbars_mousepressevent_isbase = value; }
    inline void setQCPErrorBars_MouseMoveEvent_IsBase(bool value) const { qcperrorbars_mousemoveevent_isbase = value; }
    inline void setQCPErrorBars_MouseReleaseEvent_IsBase(bool value) const { qcperrorbars_mousereleaseevent_isbase = value; }
    inline void setQCPErrorBars_MouseDoubleClickEvent_IsBase(bool value) const { qcperrorbars_mousedoubleclickevent_isbase = value; }
    inline void setQCPErrorBars_WheelEvent_IsBase(bool value) const { qcperrorbars_wheelevent_isbase = value; }
    inline void setQCPErrorBars_Event_IsBase(bool value) const { qcperrorbars_event_isbase = value; }
    inline void setQCPErrorBars_EventFilter_IsBase(bool value) const { qcperrorbars_eventfilter_isbase = value; }
    inline void setQCPErrorBars_TimerEvent_IsBase(bool value) const { qcperrorbars_timerevent_isbase = value; }
    inline void setQCPErrorBars_ChildEvent_IsBase(bool value) const { qcperrorbars_childevent_isbase = value; }
    inline void setQCPErrorBars_CustomEvent_IsBase(bool value) const { qcperrorbars_customevent_isbase = value; }
    inline void setQCPErrorBars_ConnectNotify_IsBase(bool value) const { qcperrorbars_connectnotify_isbase = value; }
    inline void setQCPErrorBars_DisconnectNotify_IsBase(bool value) const { qcperrorbars_disconnectnotify_isbase = value; }
    inline void setQCPErrorBars_GetDataSegments_IsBase(bool value) const { qcperrorbars_getdatasegments_isbase = value; }
    inline void setQCPErrorBars_ErrorBarVisible_IsBase(bool value) const { qcperrorbars_errorbarvisible_isbase = value; }
    inline void setQCPErrorBars_RectIntersectsLine_IsBase(bool value) const { qcperrorbars_rectintersectsline_isbase = value; }
    inline void setQCPErrorBars_ApplyFillAntialiasingHint_IsBase(bool value) const { qcperrorbars_applyfillantialiasinghint_isbase = value; }
    inline void setQCPErrorBars_ApplyScattersAntialiasingHint_IsBase(bool value) const { qcperrorbars_applyscattersantialiasinghint_isbase = value; }
    inline void setQCPErrorBars_InitializeParentPlot_IsBase(bool value) const { qcperrorbars_initializeparentplot_isbase = value; }
    inline void setQCPErrorBars_SetParentLayerable_IsBase(bool value) const { qcperrorbars_setparentlayerable_isbase = value; }
    inline void setQCPErrorBars_MoveToLayer_IsBase(bool value) const { qcperrorbars_movetolayer_isbase = value; }
    inline void setQCPErrorBars_ApplyAntialiasingHint_IsBase(bool value) const { qcperrorbars_applyantialiasinghint_isbase = value; }
    inline void setQCPErrorBars_Sender_IsBase(bool value) const { qcperrorbars_sender_isbase = value; }
    inline void setQCPErrorBars_SenderSignalIndex_IsBase(bool value) const { qcperrorbars_sendersignalindex_isbase = value; }
    inline void setQCPErrorBars_Receivers_IsBase(bool value) const { qcperrorbars_receivers_isbase = value; }
    inline void setQCPErrorBars_IsSignalConnected_IsBase(bool value) const { qcperrorbars_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcperrorbars_metacall_isbase) {
            qcperrorbars_metacall_isbase = false;
            return QCPErrorBars::qt_metacall(param1, param2, param3);
        } else if (qcperrorbars_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcperrorbars_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPErrorBars::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int dataCount() const override {
        if (qcperrorbars_datacount_isbase) {
            qcperrorbars_datacount_isbase = false;
            return QCPErrorBars::dataCount();
        } else if (qcperrorbars_datacount_callback != nullptr) {
            int callback_ret = qcperrorbars_datacount_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPErrorBars::dataCount();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double dataMainKey(int index) const override {
        if (qcperrorbars_datamainkey_isbase) {
            qcperrorbars_datamainkey_isbase = false;
            return QCPErrorBars::dataMainKey(index);
        } else if (qcperrorbars_datamainkey_callback != nullptr) {
            int cbval1 = index;

            double callback_ret = qcperrorbars_datamainkey_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return QCPErrorBars::dataMainKey(index);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double dataSortKey(int index) const override {
        if (qcperrorbars_datasortkey_isbase) {
            qcperrorbars_datasortkey_isbase = false;
            return QCPErrorBars::dataSortKey(index);
        } else if (qcperrorbars_datasortkey_callback != nullptr) {
            int cbval1 = index;

            double callback_ret = qcperrorbars_datasortkey_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return QCPErrorBars::dataSortKey(index);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double dataMainValue(int index) const override {
        if (qcperrorbars_datamainvalue_isbase) {
            qcperrorbars_datamainvalue_isbase = false;
            return QCPErrorBars::dataMainValue(index);
        } else if (qcperrorbars_datamainvalue_callback != nullptr) {
            int cbval1 = index;

            double callback_ret = qcperrorbars_datamainvalue_callback(this, cbval1);
            return static_cast<double>(callback_ret);
        } else {
            return QCPErrorBars::dataMainValue(index);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPRange dataValueRange(int index) const override {
        if (qcperrorbars_datavaluerange_isbase) {
            qcperrorbars_datavaluerange_isbase = false;
            return QCPErrorBars::dataValueRange(index);
        } else if (qcperrorbars_datavaluerange_callback != nullptr) {
            int cbval1 = index;

            QCPRange* callback_ret = qcperrorbars_datavaluerange_callback(this, cbval1);
            return *callback_ret;
        } else {
            return QCPErrorBars::dataValueRange(index);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QPointF dataPixelPosition(int index) const override {
        if (qcperrorbars_datapixelposition_isbase) {
            qcperrorbars_datapixelposition_isbase = false;
            return QCPErrorBars::dataPixelPosition(index);
        } else if (qcperrorbars_datapixelposition_callback != nullptr) {
            int cbval1 = index;

            QPointF* callback_ret = qcperrorbars_datapixelposition_callback(this, cbval1);
            return *callback_ret;
        } else {
            return QCPErrorBars::dataPixelPosition(index);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool sortKeyIsMainKey() const override {
        if (qcperrorbars_sortkeyismainkey_isbase) {
            qcperrorbars_sortkeyismainkey_isbase = false;
            return QCPErrorBars::sortKeyIsMainKey();
        } else if (qcperrorbars_sortkeyismainkey_callback != nullptr) {
            bool callback_ret = qcperrorbars_sortkeyismainkey_callback();
            return callback_ret;
        } else {
            return QCPErrorBars::sortKeyIsMainKey();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPDataSelection selectTestRect(const QRectF& rect, bool onlySelectable) const override {
        if (qcperrorbars_selecttestrect_isbase) {
            qcperrorbars_selecttestrect_isbase = false;
            return QCPErrorBars::selectTestRect(rect, onlySelectable);
        } else if (qcperrorbars_selecttestrect_callback != nullptr) {
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval1 = const_cast<QRectF*>(&rect_ret);
            bool cbval2 = onlySelectable;

            QCPDataSelection* callback_ret = qcperrorbars_selecttestrect_callback(this, cbval1, cbval2);
            return *callback_ret;
        } else {
            return QCPErrorBars::selectTestRect(rect, onlySelectable);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int findBegin(double sortKey, bool expandedRange) const override {
        if (qcperrorbars_findbegin_isbase) {
            qcperrorbars_findbegin_isbase = false;
            return QCPErrorBars::findBegin(sortKey, expandedRange);
        } else if (qcperrorbars_findbegin_callback != nullptr) {
            double cbval1 = sortKey;
            bool cbval2 = expandedRange;

            int callback_ret = qcperrorbars_findbegin_callback(this, cbval1, cbval2);
            return static_cast<int>(callback_ret);
        } else {
            return QCPErrorBars::findBegin(sortKey, expandedRange);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int findEnd(double sortKey, bool expandedRange) const override {
        if (qcperrorbars_findend_isbase) {
            qcperrorbars_findend_isbase = false;
            return QCPErrorBars::findEnd(sortKey, expandedRange);
        } else if (qcperrorbars_findend_callback != nullptr) {
            double cbval1 = sortKey;
            bool cbval2 = expandedRange;

            int callback_ret = qcperrorbars_findend_callback(this, cbval1, cbval2);
            return static_cast<int>(callback_ret);
        } else {
            return QCPErrorBars::findEnd(sortKey, expandedRange);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcperrorbars_selecttest_isbase) {
            qcperrorbars_selecttest_isbase = false;
            return QCPErrorBars::selectTest(pos, onlySelectable, details);
        } else if (qcperrorbars_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcperrorbars_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPErrorBars::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPPlottableInterface1D* interface1D() override {
        if (qcperrorbars_interface1d_isbase) {
            qcperrorbars_interface1d_isbase = false;
            return QCPErrorBars::interface1D();
        } else if (qcperrorbars_interface1d_callback != nullptr) {
            QCPPlottableInterface1D* callback_ret = qcperrorbars_interface1d_callback();
            return callback_ret;
        } else {
            return QCPErrorBars::interface1D();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcperrorbars_draw_isbase) {
            qcperrorbars_draw_isbase = false;
            QCPErrorBars::draw(painter);
        } else if (qcperrorbars_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcperrorbars_draw_callback(this, cbval1);
        } else {
            QCPErrorBars::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void drawLegendIcon(QCPPainter* painter, const QRectF& rect) const override {
        if (qcperrorbars_drawlegendicon_isbase) {
            qcperrorbars_drawlegendicon_isbase = false;
            QCPErrorBars::drawLegendIcon(painter, rect);
        } else if (qcperrorbars_drawlegendicon_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval2 = const_cast<QRectF*>(&rect_ret);

            qcperrorbars_drawlegendicon_callback(this, cbval1, cbval2);
        } else {
            QCPErrorBars::drawLegendIcon(painter, rect);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPRange getKeyRange(bool& foundRange, QCP::SignDomain inSignDomain) const override {
        if (qcperrorbars_getkeyrange_isbase) {
            qcperrorbars_getkeyrange_isbase = false;
            return QCPErrorBars::getKeyRange(foundRange, inSignDomain);
        } else if (qcperrorbars_getkeyrange_callback != nullptr) {
            bool* cbval1 = &foundRange;
            int cbval2 = static_cast<int>(inSignDomain);

            QCPRange* callback_ret = qcperrorbars_getkeyrange_callback(this, cbval1, cbval2);
            return *callback_ret;
        } else {
            return QCPErrorBars::getKeyRange(foundRange, inSignDomain);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPRange getValueRange(bool& foundRange, QCP::SignDomain inSignDomain, const QCPRange& inKeyRange) const override {
        if (qcperrorbars_getvaluerange_isbase) {
            qcperrorbars_getvaluerange_isbase = false;
            return QCPErrorBars::getValueRange(foundRange, inSignDomain, inKeyRange);
        } else if (qcperrorbars_getvaluerange_callback != nullptr) {
            bool* cbval1 = &foundRange;
            int cbval2 = static_cast<int>(inSignDomain);
            const QCPRange& inKeyRange_ret = inKeyRange;
            // Cast returned reference into pointer
            QCPRange* cbval3 = const_cast<QCPRange*>(&inKeyRange_ret);

            QCPRange* callback_ret = qcperrorbars_getvaluerange_callback(this, cbval1, cbval2, cbval3);
            return *callback_ret;
        } else {
            return QCPErrorBars::getValueRange(foundRange, inSignDomain, inKeyRange);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcperrorbars_cliprect_isbase) {
            qcperrorbars_cliprect_isbase = false;
            return QCPErrorBars::clipRect();
        } else if (qcperrorbars_cliprect_callback != nullptr) {
            QRect* callback_ret = qcperrorbars_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPErrorBars::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcperrorbars_selectioncategory_isbase) {
            qcperrorbars_selectioncategory_isbase = false;
            return QCPErrorBars::selectionCategory();
        } else if (qcperrorbars_selectioncategory_callback != nullptr) {
            int callback_ret = qcperrorbars_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPErrorBars::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcperrorbars_applydefaultantialiasinghint_isbase) {
            qcperrorbars_applydefaultantialiasinghint_isbase = false;
            QCPErrorBars::applyDefaultAntialiasingHint(painter);
        } else if (qcperrorbars_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcperrorbars_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPErrorBars::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcperrorbars_selectevent_isbase) {
            qcperrorbars_selectevent_isbase = false;
            QCPErrorBars::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcperrorbars_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcperrorbars_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPErrorBars::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcperrorbars_deselectevent_isbase) {
            qcperrorbars_deselectevent_isbase = false;
            QCPErrorBars::deselectEvent(selectionStateChanged);
        } else if (qcperrorbars_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcperrorbars_deselectevent_callback(this, cbval1);
        } else {
            QCPErrorBars::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcperrorbars_parentplotinitialized_isbase) {
            qcperrorbars_parentplotinitialized_isbase = false;
            QCPErrorBars::parentPlotInitialized(parentPlot);
        } else if (qcperrorbars_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcperrorbars_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPErrorBars::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcperrorbars_mousepressevent_isbase) {
            qcperrorbars_mousepressevent_isbase = false;
            QCPErrorBars::mousePressEvent(event, details);
        } else if (qcperrorbars_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcperrorbars_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPErrorBars::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcperrorbars_mousemoveevent_isbase) {
            qcperrorbars_mousemoveevent_isbase = false;
            QCPErrorBars::mouseMoveEvent(event, startPos);
        } else if (qcperrorbars_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcperrorbars_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPErrorBars::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcperrorbars_mousereleaseevent_isbase) {
            qcperrorbars_mousereleaseevent_isbase = false;
            QCPErrorBars::mouseReleaseEvent(event, startPos);
        } else if (qcperrorbars_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcperrorbars_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPErrorBars::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcperrorbars_mousedoubleclickevent_isbase) {
            qcperrorbars_mousedoubleclickevent_isbase = false;
            QCPErrorBars::mouseDoubleClickEvent(event, details);
        } else if (qcperrorbars_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcperrorbars_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPErrorBars::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcperrorbars_wheelevent_isbase) {
            qcperrorbars_wheelevent_isbase = false;
            QCPErrorBars::wheelEvent(event);
        } else if (qcperrorbars_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcperrorbars_wheelevent_callback(this, cbval1);
        } else {
            QCPErrorBars::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcperrorbars_event_isbase) {
            qcperrorbars_event_isbase = false;
            return QCPErrorBars::event(event);
        } else if (qcperrorbars_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcperrorbars_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPErrorBars::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcperrorbars_eventfilter_isbase) {
            qcperrorbars_eventfilter_isbase = false;
            return QCPErrorBars::eventFilter(watched, event);
        } else if (qcperrorbars_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcperrorbars_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPErrorBars::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcperrorbars_timerevent_isbase) {
            qcperrorbars_timerevent_isbase = false;
            QCPErrorBars::timerEvent(event);
        } else if (qcperrorbars_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcperrorbars_timerevent_callback(this, cbval1);
        } else {
            QCPErrorBars::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcperrorbars_childevent_isbase) {
            qcperrorbars_childevent_isbase = false;
            QCPErrorBars::childEvent(event);
        } else if (qcperrorbars_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcperrorbars_childevent_callback(this, cbval1);
        } else {
            QCPErrorBars::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcperrorbars_customevent_isbase) {
            qcperrorbars_customevent_isbase = false;
            QCPErrorBars::customEvent(event);
        } else if (qcperrorbars_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcperrorbars_customevent_callback(this, cbval1);
        } else {
            QCPErrorBars::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcperrorbars_connectnotify_isbase) {
            qcperrorbars_connectnotify_isbase = false;
            QCPErrorBars::connectNotify(signal);
        } else if (qcperrorbars_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcperrorbars_connectnotify_callback(this, cbval1);
        } else {
            QCPErrorBars::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcperrorbars_disconnectnotify_isbase) {
            qcperrorbars_disconnectnotify_isbase = false;
            QCPErrorBars::disconnectNotify(signal);
        } else if (qcperrorbars_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcperrorbars_disconnectnotify_callback(this, cbval1);
        } else {
            QCPErrorBars::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    void getDataSegments(QList<QCPDataRange>& selectedSegments, QList<QCPDataRange>& unselectedSegments) const {
        if (qcperrorbars_getdatasegments_isbase) {
            qcperrorbars_getdatasegments_isbase = false;
            QCPErrorBars::getDataSegments(selectedSegments, unselectedSegments);
        } else if (qcperrorbars_getdatasegments_callback != nullptr) {
            QList<QCPDataRange>& selectedSegments_ret = selectedSegments;
            // Convert QList<> from C++ memory to manually-managed C memory
            QCPDataRange** selectedSegments_arr = static_cast<QCPDataRange**>(malloc(sizeof(QCPDataRange*) * (selectedSegments_ret.size() + 1)));
            for (qsizetype i = 0; i < selectedSegments_ret.size(); ++i) {
                selectedSegments_arr[i] = new QCPDataRange(selectedSegments_ret[i]);
            }
            libqt_list selectedSegments_out;
            selectedSegments_out.len = selectedSegments_ret.size();
            selectedSegments_out.data = static_cast<void*>(selectedSegments_arr);
            libqt_list /* of QCPDataRange* */ cbval1 = selectedSegments_out;
            QList<QCPDataRange>& unselectedSegments_ret = unselectedSegments;
            // Convert QList<> from C++ memory to manually-managed C memory
            QCPDataRange** unselectedSegments_arr = static_cast<QCPDataRange**>(malloc(sizeof(QCPDataRange*) * (unselectedSegments_ret.size() + 1)));
            for (qsizetype i = 0; i < unselectedSegments_ret.size(); ++i) {
                unselectedSegments_arr[i] = new QCPDataRange(unselectedSegments_ret[i]);
            }
            libqt_list unselectedSegments_out;
            unselectedSegments_out.len = unselectedSegments_ret.size();
            unselectedSegments_out.data = static_cast<void*>(unselectedSegments_arr);
            libqt_list /* of QCPDataRange* */ cbval2 = unselectedSegments_out;

            qcperrorbars_getdatasegments_callback(this, cbval1, cbval2);
        } else {
            QCPErrorBars::getDataSegments(selectedSegments, unselectedSegments);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool errorBarVisible(int index) const {
        if (qcperrorbars_errorbarvisible_isbase) {
            qcperrorbars_errorbarvisible_isbase = false;
            return QCPErrorBars::errorBarVisible(index);
        } else if (qcperrorbars_errorbarvisible_callback != nullptr) {
            int cbval1 = index;

            bool callback_ret = qcperrorbars_errorbarvisible_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPErrorBars::errorBarVisible(index);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool rectIntersectsLine(const QRectF& pixelRect, const QLineF& line) const {
        if (qcperrorbars_rectintersectsline_isbase) {
            qcperrorbars_rectintersectsline_isbase = false;
            return QCPErrorBars::rectIntersectsLine(pixelRect, line);
        } else if (qcperrorbars_rectintersectsline_callback != nullptr) {
            const QRectF& pixelRect_ret = pixelRect;
            // Cast returned reference into pointer
            QRectF* cbval1 = const_cast<QRectF*>(&pixelRect_ret);
            const QLineF& line_ret = line;
            // Cast returned reference into pointer
            QLineF* cbval2 = const_cast<QLineF*>(&line_ret);

            bool callback_ret = qcperrorbars_rectintersectsline_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPErrorBars::rectIntersectsLine(pixelRect, line);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyFillAntialiasingHint(QCPPainter* painter) const {
        if (qcperrorbars_applyfillantialiasinghint_isbase) {
            qcperrorbars_applyfillantialiasinghint_isbase = false;
            QCPErrorBars::applyFillAntialiasingHint(painter);
        } else if (qcperrorbars_applyfillantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcperrorbars_applyfillantialiasinghint_callback(this, cbval1);
        } else {
            QCPErrorBars::applyFillAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyScattersAntialiasingHint(QCPPainter* painter) const {
        if (qcperrorbars_applyscattersantialiasinghint_isbase) {
            qcperrorbars_applyscattersantialiasinghint_isbase = false;
            QCPErrorBars::applyScattersAntialiasingHint(painter);
        } else if (qcperrorbars_applyscattersantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcperrorbars_applyscattersantialiasinghint_callback(this, cbval1);
        } else {
            QCPErrorBars::applyScattersAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcperrorbars_initializeparentplot_isbase) {
            qcperrorbars_initializeparentplot_isbase = false;
            QCPErrorBars::initializeParentPlot(parentPlot);
        } else if (qcperrorbars_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcperrorbars_initializeparentplot_callback(this, cbval1);
        } else {
            QCPErrorBars::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcperrorbars_setparentlayerable_isbase) {
            qcperrorbars_setparentlayerable_isbase = false;
            QCPErrorBars::setParentLayerable(parentLayerable);
        } else if (qcperrorbars_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcperrorbars_setparentlayerable_callback(this, cbval1);
        } else {
            QCPErrorBars::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcperrorbars_movetolayer_isbase) {
            qcperrorbars_movetolayer_isbase = false;
            return QCPErrorBars::moveToLayer(layer, prepend);
        } else if (qcperrorbars_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcperrorbars_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPErrorBars::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcperrorbars_applyantialiasinghint_isbase) {
            qcperrorbars_applyantialiasinghint_isbase = false;
            QCPErrorBars::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcperrorbars_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcperrorbars_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPErrorBars::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcperrorbars_sender_isbase) {
            qcperrorbars_sender_isbase = false;
            return QCPErrorBars::sender();
        } else if (qcperrorbars_sender_callback != nullptr) {
            QObject* callback_ret = qcperrorbars_sender_callback();
            return callback_ret;
        } else {
            return QCPErrorBars::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcperrorbars_sendersignalindex_isbase) {
            qcperrorbars_sendersignalindex_isbase = false;
            return QCPErrorBars::senderSignalIndex();
        } else if (qcperrorbars_sendersignalindex_callback != nullptr) {
            int callback_ret = qcperrorbars_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPErrorBars::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcperrorbars_receivers_isbase) {
            qcperrorbars_receivers_isbase = false;
            return QCPErrorBars::receivers(signal);
        } else if (qcperrorbars_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcperrorbars_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPErrorBars::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcperrorbars_issignalconnected_isbase) {
            qcperrorbars_issignalconnected_isbase = false;
            return QCPErrorBars::isSignalConnected(signal);
        } else if (qcperrorbars_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcperrorbars_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPErrorBars::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPErrorBars_Draw(QCPErrorBars* self, QCPPainter* painter);
    friend void QCPErrorBars_QBaseDraw(QCPErrorBars* self, QCPPainter* painter);
    friend void QCPErrorBars_DrawLegendIcon(const QCPErrorBars* self, QCPPainter* painter, const QRectF* rect);
    friend void QCPErrorBars_QBaseDrawLegendIcon(const QCPErrorBars* self, QCPPainter* painter, const QRectF* rect);
    friend QCPRange* QCPErrorBars_GetKeyRange(const QCPErrorBars* self, bool* foundRange, int inSignDomain);
    friend QCPRange* QCPErrorBars_QBaseGetKeyRange(const QCPErrorBars* self, bool* foundRange, int inSignDomain);
    friend QCPRange* QCPErrorBars_GetValueRange(const QCPErrorBars* self, bool* foundRange, int inSignDomain, const QCPRange* inKeyRange);
    friend QCPRange* QCPErrorBars_QBaseGetValueRange(const QCPErrorBars* self, bool* foundRange, int inSignDomain, const QCPRange* inKeyRange);
    friend QRect* QCPErrorBars_ClipRect(const QCPErrorBars* self);
    friend QRect* QCPErrorBars_QBaseClipRect(const QCPErrorBars* self);
    friend int QCPErrorBars_SelectionCategory(const QCPErrorBars* self);
    friend int QCPErrorBars_QBaseSelectionCategory(const QCPErrorBars* self);
    friend void QCPErrorBars_ApplyDefaultAntialiasingHint(const QCPErrorBars* self, QCPPainter* painter);
    friend void QCPErrorBars_QBaseApplyDefaultAntialiasingHint(const QCPErrorBars* self, QCPPainter* painter);
    friend void QCPErrorBars_SelectEvent(QCPErrorBars* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPErrorBars_QBaseSelectEvent(QCPErrorBars* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPErrorBars_DeselectEvent(QCPErrorBars* self, bool* selectionStateChanged);
    friend void QCPErrorBars_QBaseDeselectEvent(QCPErrorBars* self, bool* selectionStateChanged);
    friend void QCPErrorBars_ParentPlotInitialized(QCPErrorBars* self, QCustomPlot* parentPlot);
    friend void QCPErrorBars_QBaseParentPlotInitialized(QCPErrorBars* self, QCustomPlot* parentPlot);
    friend void QCPErrorBars_MousePressEvent(QCPErrorBars* self, QMouseEvent* event, const QVariant* details);
    friend void QCPErrorBars_QBaseMousePressEvent(QCPErrorBars* self, QMouseEvent* event, const QVariant* details);
    friend void QCPErrorBars_MouseMoveEvent(QCPErrorBars* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPErrorBars_QBaseMouseMoveEvent(QCPErrorBars* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPErrorBars_MouseReleaseEvent(QCPErrorBars* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPErrorBars_QBaseMouseReleaseEvent(QCPErrorBars* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPErrorBars_MouseDoubleClickEvent(QCPErrorBars* self, QMouseEvent* event, const QVariant* details);
    friend void QCPErrorBars_QBaseMouseDoubleClickEvent(QCPErrorBars* self, QMouseEvent* event, const QVariant* details);
    friend void QCPErrorBars_WheelEvent(QCPErrorBars* self, QWheelEvent* event);
    friend void QCPErrorBars_QBaseWheelEvent(QCPErrorBars* self, QWheelEvent* event);
    friend void QCPErrorBars_TimerEvent(QCPErrorBars* self, QTimerEvent* event);
    friend void QCPErrorBars_QBaseTimerEvent(QCPErrorBars* self, QTimerEvent* event);
    friend void QCPErrorBars_ChildEvent(QCPErrorBars* self, QChildEvent* event);
    friend void QCPErrorBars_QBaseChildEvent(QCPErrorBars* self, QChildEvent* event);
    friend void QCPErrorBars_CustomEvent(QCPErrorBars* self, QEvent* event);
    friend void QCPErrorBars_QBaseCustomEvent(QCPErrorBars* self, QEvent* event);
    friend void QCPErrorBars_ConnectNotify(QCPErrorBars* self, const QMetaMethod* signal);
    friend void QCPErrorBars_QBaseConnectNotify(QCPErrorBars* self, const QMetaMethod* signal);
    friend void QCPErrorBars_DisconnectNotify(QCPErrorBars* self, const QMetaMethod* signal);
    friend void QCPErrorBars_QBaseDisconnectNotify(QCPErrorBars* self, const QMetaMethod* signal);
    friend void QCPErrorBars_GetDataSegments(const QCPErrorBars* self, libqt_list /* of QCPDataRange* */ selectedSegments, libqt_list /* of QCPDataRange* */ unselectedSegments);
    friend void QCPErrorBars_QBaseGetDataSegments(const QCPErrorBars* self, libqt_list /* of QCPDataRange* */ selectedSegments, libqt_list /* of QCPDataRange* */ unselectedSegments);
    friend bool QCPErrorBars_ErrorBarVisible(const QCPErrorBars* self, int index);
    friend bool QCPErrorBars_QBaseErrorBarVisible(const QCPErrorBars* self, int index);
    friend bool QCPErrorBars_RectIntersectsLine(const QCPErrorBars* self, const QRectF* pixelRect, const QLineF* line);
    friend bool QCPErrorBars_QBaseRectIntersectsLine(const QCPErrorBars* self, const QRectF* pixelRect, const QLineF* line);
    friend void QCPErrorBars_ApplyFillAntialiasingHint(const QCPErrorBars* self, QCPPainter* painter);
    friend void QCPErrorBars_QBaseApplyFillAntialiasingHint(const QCPErrorBars* self, QCPPainter* painter);
    friend void QCPErrorBars_ApplyScattersAntialiasingHint(const QCPErrorBars* self, QCPPainter* painter);
    friend void QCPErrorBars_QBaseApplyScattersAntialiasingHint(const QCPErrorBars* self, QCPPainter* painter);
    friend void QCPErrorBars_InitializeParentPlot(QCPErrorBars* self, QCustomPlot* parentPlot);
    friend void QCPErrorBars_QBaseInitializeParentPlot(QCPErrorBars* self, QCustomPlot* parentPlot);
    friend void QCPErrorBars_SetParentLayerable(QCPErrorBars* self, QCPLayerable* parentLayerable);
    friend void QCPErrorBars_QBaseSetParentLayerable(QCPErrorBars* self, QCPLayerable* parentLayerable);
    friend bool QCPErrorBars_MoveToLayer(QCPErrorBars* self, QCPLayer* layer, bool prepend);
    friend bool QCPErrorBars_QBaseMoveToLayer(QCPErrorBars* self, QCPLayer* layer, bool prepend);
    friend void QCPErrorBars_ApplyAntialiasingHint(const QCPErrorBars* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPErrorBars_QBaseApplyAntialiasingHint(const QCPErrorBars* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPErrorBars_Sender(const QCPErrorBars* self);
    friend QObject* QCPErrorBars_QBaseSender(const QCPErrorBars* self);
    friend int QCPErrorBars_SenderSignalIndex(const QCPErrorBars* self);
    friend int QCPErrorBars_QBaseSenderSignalIndex(const QCPErrorBars* self);
    friend int QCPErrorBars_Receivers(const QCPErrorBars* self, const char* signal);
    friend int QCPErrorBars_QBaseReceivers(const QCPErrorBars* self, const char* signal);
    friend bool QCPErrorBars_IsSignalConnected(const QCPErrorBars* self, const QMetaMethod* signal);
    friend bool QCPErrorBars_QBaseIsSignalConnected(const QCPErrorBars* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPItemStraightLine so that we can call protected methods
class VirtualQCPItemStraightLine final : public QCPItemStraightLine {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPItemStraightLine = true;

    // Virtual class public types (including callbacks)
    using QCPItemStraightLine_Metacall_Callback = int (*)(QCPItemStraightLine*, int, int, void**);
    using QCPItemStraightLine_SelectTest_Callback = double (*)(const QCPItemStraightLine*, QPointF*, bool, QVariant*);
    using QCPItemStraightLine_Draw_Callback = void (*)(QCPItemStraightLine*, QCPPainter*);
    using QCPItemStraightLine_SelectionCategory_Callback = int (*)();
    using QCPItemStraightLine_ClipRect_Callback = QRect* (*)();
    using QCPItemStraightLine_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPItemStraightLine*, QCPPainter*);
    using QCPItemStraightLine_SelectEvent_Callback = void (*)(QCPItemStraightLine*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPItemStraightLine_DeselectEvent_Callback = void (*)(QCPItemStraightLine*, bool*);
    using QCPItemStraightLine_AnchorPixelPosition_Callback = QPointF* (*)(const QCPItemStraightLine*, int);
    using QCPItemStraightLine_ParentPlotInitialized_Callback = void (*)(QCPItemStraightLine*, QCustomPlot*);
    using QCPItemStraightLine_MousePressEvent_Callback = void (*)(QCPItemStraightLine*, QMouseEvent*, QVariant*);
    using QCPItemStraightLine_MouseMoveEvent_Callback = void (*)(QCPItemStraightLine*, QMouseEvent*, QPointF*);
    using QCPItemStraightLine_MouseReleaseEvent_Callback = void (*)(QCPItemStraightLine*, QMouseEvent*, QPointF*);
    using QCPItemStraightLine_MouseDoubleClickEvent_Callback = void (*)(QCPItemStraightLine*, QMouseEvent*, QVariant*);
    using QCPItemStraightLine_WheelEvent_Callback = void (*)(QCPItemStraightLine*, QWheelEvent*);
    using QCPItemStraightLine_Event_Callback = bool (*)(QCPItemStraightLine*, QEvent*);
    using QCPItemStraightLine_EventFilter_Callback = bool (*)(QCPItemStraightLine*, QObject*, QEvent*);
    using QCPItemStraightLine_TimerEvent_Callback = void (*)(QCPItemStraightLine*, QTimerEvent*);
    using QCPItemStraightLine_ChildEvent_Callback = void (*)(QCPItemStraightLine*, QChildEvent*);
    using QCPItemStraightLine_CustomEvent_Callback = void (*)(QCPItemStraightLine*, QEvent*);
    using QCPItemStraightLine_ConnectNotify_Callback = void (*)(QCPItemStraightLine*, QMetaMethod*);
    using QCPItemStraightLine_DisconnectNotify_Callback = void (*)(QCPItemStraightLine*, QMetaMethod*);
    using QCPItemStraightLine_GetRectClippedStraightLine_Callback = QLineF* (*)(const QCPItemStraightLine*, QCPVector2D*, QCPVector2D*, QRect*);
    using QCPItemStraightLine_MainPen_Callback = QPen* (*)();
    using QCPItemStraightLine_RectDistance_Callback = double (*)(const QCPItemStraightLine*, QRectF*, QPointF*, bool);
    using QCPItemStraightLine_CreatePosition_Callback = QCPItemPosition* (*)(QCPItemStraightLine*, libqt_string);
    using QCPItemStraightLine_CreateAnchor_Callback = QCPItemAnchor* (*)(QCPItemStraightLine*, libqt_string, int);
    using QCPItemStraightLine_InitializeParentPlot_Callback = void (*)(QCPItemStraightLine*, QCustomPlot*);
    using QCPItemStraightLine_SetParentLayerable_Callback = void (*)(QCPItemStraightLine*, QCPLayerable*);
    using QCPItemStraightLine_MoveToLayer_Callback = bool (*)(QCPItemStraightLine*, QCPLayer*, bool);
    using QCPItemStraightLine_ApplyAntialiasingHint_Callback = void (*)(const QCPItemStraightLine*, QCPPainter*, bool, int);
    using QCPItemStraightLine_Sender_Callback = QObject* (*)();
    using QCPItemStraightLine_SenderSignalIndex_Callback = int (*)();
    using QCPItemStraightLine_Receivers_Callback = int (*)(const QCPItemStraightLine*, const char*);
    using QCPItemStraightLine_IsSignalConnected_Callback = bool (*)(const QCPItemStraightLine*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPItemStraightLine_Metacall_Callback qcpitemstraightline_metacall_callback = nullptr;
    QCPItemStraightLine_SelectTest_Callback qcpitemstraightline_selecttest_callback = nullptr;
    QCPItemStraightLine_Draw_Callback qcpitemstraightline_draw_callback = nullptr;
    QCPItemStraightLine_SelectionCategory_Callback qcpitemstraightline_selectioncategory_callback = nullptr;
    QCPItemStraightLine_ClipRect_Callback qcpitemstraightline_cliprect_callback = nullptr;
    QCPItemStraightLine_ApplyDefaultAntialiasingHint_Callback qcpitemstraightline_applydefaultantialiasinghint_callback = nullptr;
    QCPItemStraightLine_SelectEvent_Callback qcpitemstraightline_selectevent_callback = nullptr;
    QCPItemStraightLine_DeselectEvent_Callback qcpitemstraightline_deselectevent_callback = nullptr;
    QCPItemStraightLine_AnchorPixelPosition_Callback qcpitemstraightline_anchorpixelposition_callback = nullptr;
    QCPItemStraightLine_ParentPlotInitialized_Callback qcpitemstraightline_parentplotinitialized_callback = nullptr;
    QCPItemStraightLine_MousePressEvent_Callback qcpitemstraightline_mousepressevent_callback = nullptr;
    QCPItemStraightLine_MouseMoveEvent_Callback qcpitemstraightline_mousemoveevent_callback = nullptr;
    QCPItemStraightLine_MouseReleaseEvent_Callback qcpitemstraightline_mousereleaseevent_callback = nullptr;
    QCPItemStraightLine_MouseDoubleClickEvent_Callback qcpitemstraightline_mousedoubleclickevent_callback = nullptr;
    QCPItemStraightLine_WheelEvent_Callback qcpitemstraightline_wheelevent_callback = nullptr;
    QCPItemStraightLine_Event_Callback qcpitemstraightline_event_callback = nullptr;
    QCPItemStraightLine_EventFilter_Callback qcpitemstraightline_eventfilter_callback = nullptr;
    QCPItemStraightLine_TimerEvent_Callback qcpitemstraightline_timerevent_callback = nullptr;
    QCPItemStraightLine_ChildEvent_Callback qcpitemstraightline_childevent_callback = nullptr;
    QCPItemStraightLine_CustomEvent_Callback qcpitemstraightline_customevent_callback = nullptr;
    QCPItemStraightLine_ConnectNotify_Callback qcpitemstraightline_connectnotify_callback = nullptr;
    QCPItemStraightLine_DisconnectNotify_Callback qcpitemstraightline_disconnectnotify_callback = nullptr;
    QCPItemStraightLine_GetRectClippedStraightLine_Callback qcpitemstraightline_getrectclippedstraightline_callback = nullptr;
    QCPItemStraightLine_MainPen_Callback qcpitemstraightline_mainpen_callback = nullptr;
    QCPItemStraightLine_RectDistance_Callback qcpitemstraightline_rectdistance_callback = nullptr;
    QCPItemStraightLine_CreatePosition_Callback qcpitemstraightline_createposition_callback = nullptr;
    QCPItemStraightLine_CreateAnchor_Callback qcpitemstraightline_createanchor_callback = nullptr;
    QCPItemStraightLine_InitializeParentPlot_Callback qcpitemstraightline_initializeparentplot_callback = nullptr;
    QCPItemStraightLine_SetParentLayerable_Callback qcpitemstraightline_setparentlayerable_callback = nullptr;
    QCPItemStraightLine_MoveToLayer_Callback qcpitemstraightline_movetolayer_callback = nullptr;
    QCPItemStraightLine_ApplyAntialiasingHint_Callback qcpitemstraightline_applyantialiasinghint_callback = nullptr;
    QCPItemStraightLine_Sender_Callback qcpitemstraightline_sender_callback = nullptr;
    QCPItemStraightLine_SenderSignalIndex_Callback qcpitemstraightline_sendersignalindex_callback = nullptr;
    QCPItemStraightLine_Receivers_Callback qcpitemstraightline_receivers_callback = nullptr;
    QCPItemStraightLine_IsSignalConnected_Callback qcpitemstraightline_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpitemstraightline_metacall_isbase = false;
    mutable bool qcpitemstraightline_selecttest_isbase = false;
    mutable bool qcpitemstraightline_draw_isbase = false;
    mutable bool qcpitemstraightline_selectioncategory_isbase = false;
    mutable bool qcpitemstraightline_cliprect_isbase = false;
    mutable bool qcpitemstraightline_applydefaultantialiasinghint_isbase = false;
    mutable bool qcpitemstraightline_selectevent_isbase = false;
    mutable bool qcpitemstraightline_deselectevent_isbase = false;
    mutable bool qcpitemstraightline_anchorpixelposition_isbase = false;
    mutable bool qcpitemstraightline_parentplotinitialized_isbase = false;
    mutable bool qcpitemstraightline_mousepressevent_isbase = false;
    mutable bool qcpitemstraightline_mousemoveevent_isbase = false;
    mutable bool qcpitemstraightline_mousereleaseevent_isbase = false;
    mutable bool qcpitemstraightline_mousedoubleclickevent_isbase = false;
    mutable bool qcpitemstraightline_wheelevent_isbase = false;
    mutable bool qcpitemstraightline_event_isbase = false;
    mutable bool qcpitemstraightline_eventfilter_isbase = false;
    mutable bool qcpitemstraightline_timerevent_isbase = false;
    mutable bool qcpitemstraightline_childevent_isbase = false;
    mutable bool qcpitemstraightline_customevent_isbase = false;
    mutable bool qcpitemstraightline_connectnotify_isbase = false;
    mutable bool qcpitemstraightline_disconnectnotify_isbase = false;
    mutable bool qcpitemstraightline_getrectclippedstraightline_isbase = false;
    mutable bool qcpitemstraightline_mainpen_isbase = false;
    mutable bool qcpitemstraightline_rectdistance_isbase = false;
    mutable bool qcpitemstraightline_createposition_isbase = false;
    mutable bool qcpitemstraightline_createanchor_isbase = false;
    mutable bool qcpitemstraightline_initializeparentplot_isbase = false;
    mutable bool qcpitemstraightline_setparentlayerable_isbase = false;
    mutable bool qcpitemstraightline_movetolayer_isbase = false;
    mutable bool qcpitemstraightline_applyantialiasinghint_isbase = false;
    mutable bool qcpitemstraightline_sender_isbase = false;
    mutable bool qcpitemstraightline_sendersignalindex_isbase = false;
    mutable bool qcpitemstraightline_receivers_isbase = false;
    mutable bool qcpitemstraightline_issignalconnected_isbase = false;

  public:
    VirtualQCPItemStraightLine(QCustomPlot* parentPlot) : QCPItemStraightLine(parentPlot) {};

    ~VirtualQCPItemStraightLine() {
        qcpitemstraightline_metacall_callback = nullptr;
        qcpitemstraightline_selecttest_callback = nullptr;
        qcpitemstraightline_draw_callback = nullptr;
        qcpitemstraightline_selectioncategory_callback = nullptr;
        qcpitemstraightline_cliprect_callback = nullptr;
        qcpitemstraightline_applydefaultantialiasinghint_callback = nullptr;
        qcpitemstraightline_selectevent_callback = nullptr;
        qcpitemstraightline_deselectevent_callback = nullptr;
        qcpitemstraightline_anchorpixelposition_callback = nullptr;
        qcpitemstraightline_parentplotinitialized_callback = nullptr;
        qcpitemstraightline_mousepressevent_callback = nullptr;
        qcpitemstraightline_mousemoveevent_callback = nullptr;
        qcpitemstraightline_mousereleaseevent_callback = nullptr;
        qcpitemstraightline_mousedoubleclickevent_callback = nullptr;
        qcpitemstraightline_wheelevent_callback = nullptr;
        qcpitemstraightline_event_callback = nullptr;
        qcpitemstraightline_eventfilter_callback = nullptr;
        qcpitemstraightline_timerevent_callback = nullptr;
        qcpitemstraightline_childevent_callback = nullptr;
        qcpitemstraightline_customevent_callback = nullptr;
        qcpitemstraightline_connectnotify_callback = nullptr;
        qcpitemstraightline_disconnectnotify_callback = nullptr;
        qcpitemstraightline_getrectclippedstraightline_callback = nullptr;
        qcpitemstraightline_mainpen_callback = nullptr;
        qcpitemstraightline_rectdistance_callback = nullptr;
        qcpitemstraightline_createposition_callback = nullptr;
        qcpitemstraightline_createanchor_callback = nullptr;
        qcpitemstraightline_initializeparentplot_callback = nullptr;
        qcpitemstraightline_setparentlayerable_callback = nullptr;
        qcpitemstraightline_movetolayer_callback = nullptr;
        qcpitemstraightline_applyantialiasinghint_callback = nullptr;
        qcpitemstraightline_sender_callback = nullptr;
        qcpitemstraightline_sendersignalindex_callback = nullptr;
        qcpitemstraightline_receivers_callback = nullptr;
        qcpitemstraightline_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPItemStraightLine_Metacall_Callback(QCPItemStraightLine_Metacall_Callback cb) { qcpitemstraightline_metacall_callback = cb; }
    inline void setQCPItemStraightLine_SelectTest_Callback(QCPItemStraightLine_SelectTest_Callback cb) { qcpitemstraightline_selecttest_callback = cb; }
    inline void setQCPItemStraightLine_Draw_Callback(QCPItemStraightLine_Draw_Callback cb) { qcpitemstraightline_draw_callback = cb; }
    inline void setQCPItemStraightLine_SelectionCategory_Callback(QCPItemStraightLine_SelectionCategory_Callback cb) { qcpitemstraightline_selectioncategory_callback = cb; }
    inline void setQCPItemStraightLine_ClipRect_Callback(QCPItemStraightLine_ClipRect_Callback cb) { qcpitemstraightline_cliprect_callback = cb; }
    inline void setQCPItemStraightLine_ApplyDefaultAntialiasingHint_Callback(QCPItemStraightLine_ApplyDefaultAntialiasingHint_Callback cb) { qcpitemstraightline_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPItemStraightLine_SelectEvent_Callback(QCPItemStraightLine_SelectEvent_Callback cb) { qcpitemstraightline_selectevent_callback = cb; }
    inline void setQCPItemStraightLine_DeselectEvent_Callback(QCPItemStraightLine_DeselectEvent_Callback cb) { qcpitemstraightline_deselectevent_callback = cb; }
    inline void setQCPItemStraightLine_AnchorPixelPosition_Callback(QCPItemStraightLine_AnchorPixelPosition_Callback cb) { qcpitemstraightline_anchorpixelposition_callback = cb; }
    inline void setQCPItemStraightLine_ParentPlotInitialized_Callback(QCPItemStraightLine_ParentPlotInitialized_Callback cb) { qcpitemstraightline_parentplotinitialized_callback = cb; }
    inline void setQCPItemStraightLine_MousePressEvent_Callback(QCPItemStraightLine_MousePressEvent_Callback cb) { qcpitemstraightline_mousepressevent_callback = cb; }
    inline void setQCPItemStraightLine_MouseMoveEvent_Callback(QCPItemStraightLine_MouseMoveEvent_Callback cb) { qcpitemstraightline_mousemoveevent_callback = cb; }
    inline void setQCPItemStraightLine_MouseReleaseEvent_Callback(QCPItemStraightLine_MouseReleaseEvent_Callback cb) { qcpitemstraightline_mousereleaseevent_callback = cb; }
    inline void setQCPItemStraightLine_MouseDoubleClickEvent_Callback(QCPItemStraightLine_MouseDoubleClickEvent_Callback cb) { qcpitemstraightline_mousedoubleclickevent_callback = cb; }
    inline void setQCPItemStraightLine_WheelEvent_Callback(QCPItemStraightLine_WheelEvent_Callback cb) { qcpitemstraightline_wheelevent_callback = cb; }
    inline void setQCPItemStraightLine_Event_Callback(QCPItemStraightLine_Event_Callback cb) { qcpitemstraightline_event_callback = cb; }
    inline void setQCPItemStraightLine_EventFilter_Callback(QCPItemStraightLine_EventFilter_Callback cb) { qcpitemstraightline_eventfilter_callback = cb; }
    inline void setQCPItemStraightLine_TimerEvent_Callback(QCPItemStraightLine_TimerEvent_Callback cb) { qcpitemstraightline_timerevent_callback = cb; }
    inline void setQCPItemStraightLine_ChildEvent_Callback(QCPItemStraightLine_ChildEvent_Callback cb) { qcpitemstraightline_childevent_callback = cb; }
    inline void setQCPItemStraightLine_CustomEvent_Callback(QCPItemStraightLine_CustomEvent_Callback cb) { qcpitemstraightline_customevent_callback = cb; }
    inline void setQCPItemStraightLine_ConnectNotify_Callback(QCPItemStraightLine_ConnectNotify_Callback cb) { qcpitemstraightline_connectnotify_callback = cb; }
    inline void setQCPItemStraightLine_DisconnectNotify_Callback(QCPItemStraightLine_DisconnectNotify_Callback cb) { qcpitemstraightline_disconnectnotify_callback = cb; }
    inline void setQCPItemStraightLine_GetRectClippedStraightLine_Callback(QCPItemStraightLine_GetRectClippedStraightLine_Callback cb) { qcpitemstraightline_getrectclippedstraightline_callback = cb; }
    inline void setQCPItemStraightLine_MainPen_Callback(QCPItemStraightLine_MainPen_Callback cb) { qcpitemstraightline_mainpen_callback = cb; }
    inline void setQCPItemStraightLine_RectDistance_Callback(QCPItemStraightLine_RectDistance_Callback cb) { qcpitemstraightline_rectdistance_callback = cb; }
    inline void setQCPItemStraightLine_CreatePosition_Callback(QCPItemStraightLine_CreatePosition_Callback cb) { qcpitemstraightline_createposition_callback = cb; }
    inline void setQCPItemStraightLine_CreateAnchor_Callback(QCPItemStraightLine_CreateAnchor_Callback cb) { qcpitemstraightline_createanchor_callback = cb; }
    inline void setQCPItemStraightLine_InitializeParentPlot_Callback(QCPItemStraightLine_InitializeParentPlot_Callback cb) { qcpitemstraightline_initializeparentplot_callback = cb; }
    inline void setQCPItemStraightLine_SetParentLayerable_Callback(QCPItemStraightLine_SetParentLayerable_Callback cb) { qcpitemstraightline_setparentlayerable_callback = cb; }
    inline void setQCPItemStraightLine_MoveToLayer_Callback(QCPItemStraightLine_MoveToLayer_Callback cb) { qcpitemstraightline_movetolayer_callback = cb; }
    inline void setQCPItemStraightLine_ApplyAntialiasingHint_Callback(QCPItemStraightLine_ApplyAntialiasingHint_Callback cb) { qcpitemstraightline_applyantialiasinghint_callback = cb; }
    inline void setQCPItemStraightLine_Sender_Callback(QCPItemStraightLine_Sender_Callback cb) { qcpitemstraightline_sender_callback = cb; }
    inline void setQCPItemStraightLine_SenderSignalIndex_Callback(QCPItemStraightLine_SenderSignalIndex_Callback cb) { qcpitemstraightline_sendersignalindex_callback = cb; }
    inline void setQCPItemStraightLine_Receivers_Callback(QCPItemStraightLine_Receivers_Callback cb) { qcpitemstraightline_receivers_callback = cb; }
    inline void setQCPItemStraightLine_IsSignalConnected_Callback(QCPItemStraightLine_IsSignalConnected_Callback cb) { qcpitemstraightline_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPItemStraightLine_Metacall_IsBase(bool value) const { qcpitemstraightline_metacall_isbase = value; }
    inline void setQCPItemStraightLine_SelectTest_IsBase(bool value) const { qcpitemstraightline_selecttest_isbase = value; }
    inline void setQCPItemStraightLine_Draw_IsBase(bool value) const { qcpitemstraightline_draw_isbase = value; }
    inline void setQCPItemStraightLine_SelectionCategory_IsBase(bool value) const { qcpitemstraightline_selectioncategory_isbase = value; }
    inline void setQCPItemStraightLine_ClipRect_IsBase(bool value) const { qcpitemstraightline_cliprect_isbase = value; }
    inline void setQCPItemStraightLine_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcpitemstraightline_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPItemStraightLine_SelectEvent_IsBase(bool value) const { qcpitemstraightline_selectevent_isbase = value; }
    inline void setQCPItemStraightLine_DeselectEvent_IsBase(bool value) const { qcpitemstraightline_deselectevent_isbase = value; }
    inline void setQCPItemStraightLine_AnchorPixelPosition_IsBase(bool value) const { qcpitemstraightline_anchorpixelposition_isbase = value; }
    inline void setQCPItemStraightLine_ParentPlotInitialized_IsBase(bool value) const { qcpitemstraightline_parentplotinitialized_isbase = value; }
    inline void setQCPItemStraightLine_MousePressEvent_IsBase(bool value) const { qcpitemstraightline_mousepressevent_isbase = value; }
    inline void setQCPItemStraightLine_MouseMoveEvent_IsBase(bool value) const { qcpitemstraightline_mousemoveevent_isbase = value; }
    inline void setQCPItemStraightLine_MouseReleaseEvent_IsBase(bool value) const { qcpitemstraightline_mousereleaseevent_isbase = value; }
    inline void setQCPItemStraightLine_MouseDoubleClickEvent_IsBase(bool value) const { qcpitemstraightline_mousedoubleclickevent_isbase = value; }
    inline void setQCPItemStraightLine_WheelEvent_IsBase(bool value) const { qcpitemstraightline_wheelevent_isbase = value; }
    inline void setQCPItemStraightLine_Event_IsBase(bool value) const { qcpitemstraightline_event_isbase = value; }
    inline void setQCPItemStraightLine_EventFilter_IsBase(bool value) const { qcpitemstraightline_eventfilter_isbase = value; }
    inline void setQCPItemStraightLine_TimerEvent_IsBase(bool value) const { qcpitemstraightline_timerevent_isbase = value; }
    inline void setQCPItemStraightLine_ChildEvent_IsBase(bool value) const { qcpitemstraightline_childevent_isbase = value; }
    inline void setQCPItemStraightLine_CustomEvent_IsBase(bool value) const { qcpitemstraightline_customevent_isbase = value; }
    inline void setQCPItemStraightLine_ConnectNotify_IsBase(bool value) const { qcpitemstraightline_connectnotify_isbase = value; }
    inline void setQCPItemStraightLine_DisconnectNotify_IsBase(bool value) const { qcpitemstraightline_disconnectnotify_isbase = value; }
    inline void setQCPItemStraightLine_GetRectClippedStraightLine_IsBase(bool value) const { qcpitemstraightline_getrectclippedstraightline_isbase = value; }
    inline void setQCPItemStraightLine_MainPen_IsBase(bool value) const { qcpitemstraightline_mainpen_isbase = value; }
    inline void setQCPItemStraightLine_RectDistance_IsBase(bool value) const { qcpitemstraightline_rectdistance_isbase = value; }
    inline void setQCPItemStraightLine_CreatePosition_IsBase(bool value) const { qcpitemstraightline_createposition_isbase = value; }
    inline void setQCPItemStraightLine_CreateAnchor_IsBase(bool value) const { qcpitemstraightline_createanchor_isbase = value; }
    inline void setQCPItemStraightLine_InitializeParentPlot_IsBase(bool value) const { qcpitemstraightline_initializeparentplot_isbase = value; }
    inline void setQCPItemStraightLine_SetParentLayerable_IsBase(bool value) const { qcpitemstraightline_setparentlayerable_isbase = value; }
    inline void setQCPItemStraightLine_MoveToLayer_IsBase(bool value) const { qcpitemstraightline_movetolayer_isbase = value; }
    inline void setQCPItemStraightLine_ApplyAntialiasingHint_IsBase(bool value) const { qcpitemstraightline_applyantialiasinghint_isbase = value; }
    inline void setQCPItemStraightLine_Sender_IsBase(bool value) const { qcpitemstraightline_sender_isbase = value; }
    inline void setQCPItemStraightLine_SenderSignalIndex_IsBase(bool value) const { qcpitemstraightline_sendersignalindex_isbase = value; }
    inline void setQCPItemStraightLine_Receivers_IsBase(bool value) const { qcpitemstraightline_receivers_isbase = value; }
    inline void setQCPItemStraightLine_IsSignalConnected_IsBase(bool value) const { qcpitemstraightline_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpitemstraightline_metacall_isbase) {
            qcpitemstraightline_metacall_isbase = false;
            return QCPItemStraightLine::qt_metacall(param1, param2, param3);
        } else if (qcpitemstraightline_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpitemstraightline_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemStraightLine::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcpitemstraightline_selecttest_isbase) {
            qcpitemstraightline_selecttest_isbase = false;
            return QCPItemStraightLine::selectTest(pos, onlySelectable, details);
        } else if (qcpitemstraightline_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcpitemstraightline_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPItemStraightLine::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcpitemstraightline_draw_isbase) {
            qcpitemstraightline_draw_isbase = false;
            QCPItemStraightLine::draw(painter);
        } else if (qcpitemstraightline_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpitemstraightline_draw_callback(this, cbval1);
        } else {
            QCPItemStraightLine::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcpitemstraightline_selectioncategory_isbase) {
            qcpitemstraightline_selectioncategory_isbase = false;
            return QCPItemStraightLine::selectionCategory();
        } else if (qcpitemstraightline_selectioncategory_callback != nullptr) {
            int callback_ret = qcpitemstraightline_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPItemStraightLine::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcpitemstraightline_cliprect_isbase) {
            qcpitemstraightline_cliprect_isbase = false;
            return QCPItemStraightLine::clipRect();
        } else if (qcpitemstraightline_cliprect_callback != nullptr) {
            QRect* callback_ret = qcpitemstraightline_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPItemStraightLine::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcpitemstraightline_applydefaultantialiasinghint_isbase) {
            qcpitemstraightline_applydefaultantialiasinghint_isbase = false;
            QCPItemStraightLine::applyDefaultAntialiasingHint(painter);
        } else if (qcpitemstraightline_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpitemstraightline_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPItemStraightLine::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcpitemstraightline_selectevent_isbase) {
            qcpitemstraightline_selectevent_isbase = false;
            QCPItemStraightLine::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcpitemstraightline_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcpitemstraightline_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPItemStraightLine::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcpitemstraightline_deselectevent_isbase) {
            qcpitemstraightline_deselectevent_isbase = false;
            QCPItemStraightLine::deselectEvent(selectionStateChanged);
        } else if (qcpitemstraightline_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcpitemstraightline_deselectevent_callback(this, cbval1);
        } else {
            QCPItemStraightLine::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QPointF anchorPixelPosition(int anchorId) const override {
        if (qcpitemstraightline_anchorpixelposition_isbase) {
            qcpitemstraightline_anchorpixelposition_isbase = false;
            return QCPItemStraightLine::anchorPixelPosition(anchorId);
        } else if (qcpitemstraightline_anchorpixelposition_callback != nullptr) {
            int cbval1 = anchorId;

            QPointF* callback_ret = qcpitemstraightline_anchorpixelposition_callback(this, cbval1);
            return *callback_ret;
        } else {
            return QCPItemStraightLine::anchorPixelPosition(anchorId);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcpitemstraightline_parentplotinitialized_isbase) {
            qcpitemstraightline_parentplotinitialized_isbase = false;
            QCPItemStraightLine::parentPlotInitialized(parentPlot);
        } else if (qcpitemstraightline_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpitemstraightline_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPItemStraightLine::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpitemstraightline_mousepressevent_isbase) {
            qcpitemstraightline_mousepressevent_isbase = false;
            QCPItemStraightLine::mousePressEvent(event, details);
        } else if (qcpitemstraightline_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpitemstraightline_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemStraightLine::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpitemstraightline_mousemoveevent_isbase) {
            qcpitemstraightline_mousemoveevent_isbase = false;
            QCPItemStraightLine::mouseMoveEvent(event, startPos);
        } else if (qcpitemstraightline_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpitemstraightline_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemStraightLine::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpitemstraightline_mousereleaseevent_isbase) {
            qcpitemstraightline_mousereleaseevent_isbase = false;
            QCPItemStraightLine::mouseReleaseEvent(event, startPos);
        } else if (qcpitemstraightline_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpitemstraightline_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemStraightLine::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpitemstraightline_mousedoubleclickevent_isbase) {
            qcpitemstraightline_mousedoubleclickevent_isbase = false;
            QCPItemStraightLine::mouseDoubleClickEvent(event, details);
        } else if (qcpitemstraightline_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpitemstraightline_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemStraightLine::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcpitemstraightline_wheelevent_isbase) {
            qcpitemstraightline_wheelevent_isbase = false;
            QCPItemStraightLine::wheelEvent(event);
        } else if (qcpitemstraightline_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcpitemstraightline_wheelevent_callback(this, cbval1);
        } else {
            QCPItemStraightLine::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpitemstraightline_event_isbase) {
            qcpitemstraightline_event_isbase = false;
            return QCPItemStraightLine::event(event);
        } else if (qcpitemstraightline_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpitemstraightline_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemStraightLine::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpitemstraightline_eventfilter_isbase) {
            qcpitemstraightline_eventfilter_isbase = false;
            return QCPItemStraightLine::eventFilter(watched, event);
        } else if (qcpitemstraightline_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpitemstraightline_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemStraightLine::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpitemstraightline_timerevent_isbase) {
            qcpitemstraightline_timerevent_isbase = false;
            QCPItemStraightLine::timerEvent(event);
        } else if (qcpitemstraightline_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpitemstraightline_timerevent_callback(this, cbval1);
        } else {
            QCPItemStraightLine::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpitemstraightline_childevent_isbase) {
            qcpitemstraightline_childevent_isbase = false;
            QCPItemStraightLine::childEvent(event);
        } else if (qcpitemstraightline_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpitemstraightline_childevent_callback(this, cbval1);
        } else {
            QCPItemStraightLine::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpitemstraightline_customevent_isbase) {
            qcpitemstraightline_customevent_isbase = false;
            QCPItemStraightLine::customEvent(event);
        } else if (qcpitemstraightline_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpitemstraightline_customevent_callback(this, cbval1);
        } else {
            QCPItemStraightLine::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpitemstraightline_connectnotify_isbase) {
            qcpitemstraightline_connectnotify_isbase = false;
            QCPItemStraightLine::connectNotify(signal);
        } else if (qcpitemstraightline_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpitemstraightline_connectnotify_callback(this, cbval1);
        } else {
            QCPItemStraightLine::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpitemstraightline_disconnectnotify_isbase) {
            qcpitemstraightline_disconnectnotify_isbase = false;
            QCPItemStraightLine::disconnectNotify(signal);
        } else if (qcpitemstraightline_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpitemstraightline_disconnectnotify_callback(this, cbval1);
        } else {
            QCPItemStraightLine::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    QLineF getRectClippedStraightLine(const QCPVector2D& base, const QCPVector2D& vec, const QRect& rect) const {
        if (qcpitemstraightline_getrectclippedstraightline_isbase) {
            qcpitemstraightline_getrectclippedstraightline_isbase = false;
            return QCPItemStraightLine::getRectClippedStraightLine(base, vec, rect);
        } else if (qcpitemstraightline_getrectclippedstraightline_callback != nullptr) {
            const QCPVector2D& base_ret = base;
            // Cast returned reference into pointer
            QCPVector2D* cbval1 = const_cast<QCPVector2D*>(&base_ret);
            const QCPVector2D& vec_ret = vec;
            // Cast returned reference into pointer
            QCPVector2D* cbval2 = const_cast<QCPVector2D*>(&vec_ret);
            const QRect& rect_ret = rect;
            // Cast returned reference into pointer
            QRect* cbval3 = const_cast<QRect*>(&rect_ret);

            QLineF* callback_ret = qcpitemstraightline_getrectclippedstraightline_callback(this, cbval1, cbval2, cbval3);
            return *callback_ret;
        } else {
            return QCPItemStraightLine::getRectClippedStraightLine(base, vec, rect);
        }
    }

    // Virtual method for C ABI access and custom callback
    QPen mainPen() const {
        if (qcpitemstraightline_mainpen_isbase) {
            qcpitemstraightline_mainpen_isbase = false;
            return QCPItemStraightLine::mainPen();
        } else if (qcpitemstraightline_mainpen_callback != nullptr) {
            QPen* callback_ret = qcpitemstraightline_mainpen_callback();
            return *callback_ret;
        } else {
            return QCPItemStraightLine::mainPen();
        }
    }

    // Virtual method for C ABI access and custom callback
    double rectDistance(const QRectF& rect, const QPointF& pos, bool filledRect) const {
        if (qcpitemstraightline_rectdistance_isbase) {
            qcpitemstraightline_rectdistance_isbase = false;
            return QCPItemStraightLine::rectDistance(rect, pos, filledRect);
        } else if (qcpitemstraightline_rectdistance_callback != nullptr) {
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval1 = const_cast<QRectF*>(&rect_ret);
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&pos_ret);
            bool cbval3 = filledRect;

            double callback_ret = qcpitemstraightline_rectdistance_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPItemStraightLine::rectDistance(rect, pos, filledRect);
        }
    }

    // Virtual method for C ABI access and custom callback
    QCPItemPosition* createPosition(const QString& name) {
        if (qcpitemstraightline_createposition_isbase) {
            qcpitemstraightline_createposition_isbase = false;
            return QCPItemStraightLine::createPosition(name);
        } else if (qcpitemstraightline_createposition_callback != nullptr) {
            const QString name_ret = name;
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray name_b = name_ret.toUtf8();
            libqt_string name_str;
            name_str.len = name_b.length();
            name_str.data = static_cast<const char*>(malloc(name_str.len + 1));
            memcpy((void*)name_str.data, name_b.data(), name_str.len);
            ((char*)name_str.data)[name_str.len] = '\0';
            libqt_string cbval1 = name_str;

            QCPItemPosition* callback_ret = qcpitemstraightline_createposition_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemStraightLine::createPosition(name);
        }
    }

    // Virtual method for C ABI access and custom callback
    QCPItemAnchor* createAnchor(const QString& name, int anchorId) {
        if (qcpitemstraightline_createanchor_isbase) {
            qcpitemstraightline_createanchor_isbase = false;
            return QCPItemStraightLine::createAnchor(name, anchorId);
        } else if (qcpitemstraightline_createanchor_callback != nullptr) {
            const QString name_ret = name;
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray name_b = name_ret.toUtf8();
            libqt_string name_str;
            name_str.len = name_b.length();
            name_str.data = static_cast<const char*>(malloc(name_str.len + 1));
            memcpy((void*)name_str.data, name_b.data(), name_str.len);
            ((char*)name_str.data)[name_str.len] = '\0';
            libqt_string cbval1 = name_str;
            int cbval2 = anchorId;

            QCPItemAnchor* callback_ret = qcpitemstraightline_createanchor_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemStraightLine::createAnchor(name, anchorId);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcpitemstraightline_initializeparentplot_isbase) {
            qcpitemstraightline_initializeparentplot_isbase = false;
            QCPItemStraightLine::initializeParentPlot(parentPlot);
        } else if (qcpitemstraightline_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpitemstraightline_initializeparentplot_callback(this, cbval1);
        } else {
            QCPItemStraightLine::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcpitemstraightline_setparentlayerable_isbase) {
            qcpitemstraightline_setparentlayerable_isbase = false;
            QCPItemStraightLine::setParentLayerable(parentLayerable);
        } else if (qcpitemstraightline_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcpitemstraightline_setparentlayerable_callback(this, cbval1);
        } else {
            QCPItemStraightLine::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcpitemstraightline_movetolayer_isbase) {
            qcpitemstraightline_movetolayer_isbase = false;
            return QCPItemStraightLine::moveToLayer(layer, prepend);
        } else if (qcpitemstraightline_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcpitemstraightline_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemStraightLine::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcpitemstraightline_applyantialiasinghint_isbase) {
            qcpitemstraightline_applyantialiasinghint_isbase = false;
            QCPItemStraightLine::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcpitemstraightline_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcpitemstraightline_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPItemStraightLine::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpitemstraightline_sender_isbase) {
            qcpitemstraightline_sender_isbase = false;
            return QCPItemStraightLine::sender();
        } else if (qcpitemstraightline_sender_callback != nullptr) {
            QObject* callback_ret = qcpitemstraightline_sender_callback();
            return callback_ret;
        } else {
            return QCPItemStraightLine::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpitemstraightline_sendersignalindex_isbase) {
            qcpitemstraightline_sendersignalindex_isbase = false;
            return QCPItemStraightLine::senderSignalIndex();
        } else if (qcpitemstraightline_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpitemstraightline_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemStraightLine::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpitemstraightline_receivers_isbase) {
            qcpitemstraightline_receivers_isbase = false;
            return QCPItemStraightLine::receivers(signal);
        } else if (qcpitemstraightline_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpitemstraightline_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemStraightLine::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpitemstraightline_issignalconnected_isbase) {
            qcpitemstraightline_issignalconnected_isbase = false;
            return QCPItemStraightLine::isSignalConnected(signal);
        } else if (qcpitemstraightline_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpitemstraightline_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemStraightLine::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPItemStraightLine_Draw(QCPItemStraightLine* self, QCPPainter* painter);
    friend void QCPItemStraightLine_QBaseDraw(QCPItemStraightLine* self, QCPPainter* painter);
    friend int QCPItemStraightLine_SelectionCategory(const QCPItemStraightLine* self);
    friend int QCPItemStraightLine_QBaseSelectionCategory(const QCPItemStraightLine* self);
    friend QRect* QCPItemStraightLine_ClipRect(const QCPItemStraightLine* self);
    friend QRect* QCPItemStraightLine_QBaseClipRect(const QCPItemStraightLine* self);
    friend void QCPItemStraightLine_ApplyDefaultAntialiasingHint(const QCPItemStraightLine* self, QCPPainter* painter);
    friend void QCPItemStraightLine_QBaseApplyDefaultAntialiasingHint(const QCPItemStraightLine* self, QCPPainter* painter);
    friend void QCPItemStraightLine_SelectEvent(QCPItemStraightLine* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPItemStraightLine_QBaseSelectEvent(QCPItemStraightLine* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPItemStraightLine_DeselectEvent(QCPItemStraightLine* self, bool* selectionStateChanged);
    friend void QCPItemStraightLine_QBaseDeselectEvent(QCPItemStraightLine* self, bool* selectionStateChanged);
    friend QPointF* QCPItemStraightLine_AnchorPixelPosition(const QCPItemStraightLine* self, int anchorId);
    friend QPointF* QCPItemStraightLine_QBaseAnchorPixelPosition(const QCPItemStraightLine* self, int anchorId);
    friend void QCPItemStraightLine_ParentPlotInitialized(QCPItemStraightLine* self, QCustomPlot* parentPlot);
    friend void QCPItemStraightLine_QBaseParentPlotInitialized(QCPItemStraightLine* self, QCustomPlot* parentPlot);
    friend void QCPItemStraightLine_MousePressEvent(QCPItemStraightLine* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemStraightLine_QBaseMousePressEvent(QCPItemStraightLine* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemStraightLine_MouseMoveEvent(QCPItemStraightLine* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemStraightLine_QBaseMouseMoveEvent(QCPItemStraightLine* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemStraightLine_MouseReleaseEvent(QCPItemStraightLine* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemStraightLine_QBaseMouseReleaseEvent(QCPItemStraightLine* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemStraightLine_MouseDoubleClickEvent(QCPItemStraightLine* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemStraightLine_QBaseMouseDoubleClickEvent(QCPItemStraightLine* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemStraightLine_WheelEvent(QCPItemStraightLine* self, QWheelEvent* event);
    friend void QCPItemStraightLine_QBaseWheelEvent(QCPItemStraightLine* self, QWheelEvent* event);
    friend void QCPItemStraightLine_TimerEvent(QCPItemStraightLine* self, QTimerEvent* event);
    friend void QCPItemStraightLine_QBaseTimerEvent(QCPItemStraightLine* self, QTimerEvent* event);
    friend void QCPItemStraightLine_ChildEvent(QCPItemStraightLine* self, QChildEvent* event);
    friend void QCPItemStraightLine_QBaseChildEvent(QCPItemStraightLine* self, QChildEvent* event);
    friend void QCPItemStraightLine_CustomEvent(QCPItemStraightLine* self, QEvent* event);
    friend void QCPItemStraightLine_QBaseCustomEvent(QCPItemStraightLine* self, QEvent* event);
    friend void QCPItemStraightLine_ConnectNotify(QCPItemStraightLine* self, const QMetaMethod* signal);
    friend void QCPItemStraightLine_QBaseConnectNotify(QCPItemStraightLine* self, const QMetaMethod* signal);
    friend void QCPItemStraightLine_DisconnectNotify(QCPItemStraightLine* self, const QMetaMethod* signal);
    friend void QCPItemStraightLine_QBaseDisconnectNotify(QCPItemStraightLine* self, const QMetaMethod* signal);
    friend QLineF* QCPItemStraightLine_GetRectClippedStraightLine(const QCPItemStraightLine* self, const QCPVector2D* base, const QCPVector2D* vec, const QRect* rect);
    friend QLineF* QCPItemStraightLine_QBaseGetRectClippedStraightLine(const QCPItemStraightLine* self, const QCPVector2D* base, const QCPVector2D* vec, const QRect* rect);
    friend QPen* QCPItemStraightLine_MainPen(const QCPItemStraightLine* self);
    friend QPen* QCPItemStraightLine_QBaseMainPen(const QCPItemStraightLine* self);
    friend double QCPItemStraightLine_RectDistance(const QCPItemStraightLine* self, const QRectF* rect, const QPointF* pos, bool filledRect);
    friend double QCPItemStraightLine_QBaseRectDistance(const QCPItemStraightLine* self, const QRectF* rect, const QPointF* pos, bool filledRect);
    friend QCPItemPosition* QCPItemStraightLine_CreatePosition(QCPItemStraightLine* self, const libqt_string name);
    friend QCPItemPosition* QCPItemStraightLine_QBaseCreatePosition(QCPItemStraightLine* self, const libqt_string name);
    friend QCPItemAnchor* QCPItemStraightLine_CreateAnchor(QCPItemStraightLine* self, const libqt_string name, int anchorId);
    friend QCPItemAnchor* QCPItemStraightLine_QBaseCreateAnchor(QCPItemStraightLine* self, const libqt_string name, int anchorId);
    friend void QCPItemStraightLine_InitializeParentPlot(QCPItemStraightLine* self, QCustomPlot* parentPlot);
    friend void QCPItemStraightLine_QBaseInitializeParentPlot(QCPItemStraightLine* self, QCustomPlot* parentPlot);
    friend void QCPItemStraightLine_SetParentLayerable(QCPItemStraightLine* self, QCPLayerable* parentLayerable);
    friend void QCPItemStraightLine_QBaseSetParentLayerable(QCPItemStraightLine* self, QCPLayerable* parentLayerable);
    friend bool QCPItemStraightLine_MoveToLayer(QCPItemStraightLine* self, QCPLayer* layer, bool prepend);
    friend bool QCPItemStraightLine_QBaseMoveToLayer(QCPItemStraightLine* self, QCPLayer* layer, bool prepend);
    friend void QCPItemStraightLine_ApplyAntialiasingHint(const QCPItemStraightLine* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPItemStraightLine_QBaseApplyAntialiasingHint(const QCPItemStraightLine* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPItemStraightLine_Sender(const QCPItemStraightLine* self);
    friend QObject* QCPItemStraightLine_QBaseSender(const QCPItemStraightLine* self);
    friend int QCPItemStraightLine_SenderSignalIndex(const QCPItemStraightLine* self);
    friend int QCPItemStraightLine_QBaseSenderSignalIndex(const QCPItemStraightLine* self);
    friend int QCPItemStraightLine_Receivers(const QCPItemStraightLine* self, const char* signal);
    friend int QCPItemStraightLine_QBaseReceivers(const QCPItemStraightLine* self, const char* signal);
    friend bool QCPItemStraightLine_IsSignalConnected(const QCPItemStraightLine* self, const QMetaMethod* signal);
    friend bool QCPItemStraightLine_QBaseIsSignalConnected(const QCPItemStraightLine* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPItemLine so that we can call protected methods
class VirtualQCPItemLine final : public QCPItemLine {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPItemLine = true;

    // Virtual class public types (including callbacks)
    using QCPItemLine_Metacall_Callback = int (*)(QCPItemLine*, int, int, void**);
    using QCPItemLine_SelectTest_Callback = double (*)(const QCPItemLine*, QPointF*, bool, QVariant*);
    using QCPItemLine_Draw_Callback = void (*)(QCPItemLine*, QCPPainter*);
    using QCPItemLine_SelectionCategory_Callback = int (*)();
    using QCPItemLine_ClipRect_Callback = QRect* (*)();
    using QCPItemLine_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPItemLine*, QCPPainter*);
    using QCPItemLine_SelectEvent_Callback = void (*)(QCPItemLine*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPItemLine_DeselectEvent_Callback = void (*)(QCPItemLine*, bool*);
    using QCPItemLine_AnchorPixelPosition_Callback = QPointF* (*)(const QCPItemLine*, int);
    using QCPItemLine_ParentPlotInitialized_Callback = void (*)(QCPItemLine*, QCustomPlot*);
    using QCPItemLine_MousePressEvent_Callback = void (*)(QCPItemLine*, QMouseEvent*, QVariant*);
    using QCPItemLine_MouseMoveEvent_Callback = void (*)(QCPItemLine*, QMouseEvent*, QPointF*);
    using QCPItemLine_MouseReleaseEvent_Callback = void (*)(QCPItemLine*, QMouseEvent*, QPointF*);
    using QCPItemLine_MouseDoubleClickEvent_Callback = void (*)(QCPItemLine*, QMouseEvent*, QVariant*);
    using QCPItemLine_WheelEvent_Callback = void (*)(QCPItemLine*, QWheelEvent*);
    using QCPItemLine_Event_Callback = bool (*)(QCPItemLine*, QEvent*);
    using QCPItemLine_EventFilter_Callback = bool (*)(QCPItemLine*, QObject*, QEvent*);
    using QCPItemLine_TimerEvent_Callback = void (*)(QCPItemLine*, QTimerEvent*);
    using QCPItemLine_ChildEvent_Callback = void (*)(QCPItemLine*, QChildEvent*);
    using QCPItemLine_CustomEvent_Callback = void (*)(QCPItemLine*, QEvent*);
    using QCPItemLine_ConnectNotify_Callback = void (*)(QCPItemLine*, QMetaMethod*);
    using QCPItemLine_DisconnectNotify_Callback = void (*)(QCPItemLine*, QMetaMethod*);
    using QCPItemLine_GetRectClippedLine_Callback = QLineF* (*)(const QCPItemLine*, QCPVector2D*, QCPVector2D*, QRect*);
    using QCPItemLine_MainPen_Callback = QPen* (*)();
    using QCPItemLine_RectDistance_Callback = double (*)(const QCPItemLine*, QRectF*, QPointF*, bool);
    using QCPItemLine_CreatePosition_Callback = QCPItemPosition* (*)(QCPItemLine*, libqt_string);
    using QCPItemLine_CreateAnchor_Callback = QCPItemAnchor* (*)(QCPItemLine*, libqt_string, int);
    using QCPItemLine_InitializeParentPlot_Callback = void (*)(QCPItemLine*, QCustomPlot*);
    using QCPItemLine_SetParentLayerable_Callback = void (*)(QCPItemLine*, QCPLayerable*);
    using QCPItemLine_MoveToLayer_Callback = bool (*)(QCPItemLine*, QCPLayer*, bool);
    using QCPItemLine_ApplyAntialiasingHint_Callback = void (*)(const QCPItemLine*, QCPPainter*, bool, int);
    using QCPItemLine_Sender_Callback = QObject* (*)();
    using QCPItemLine_SenderSignalIndex_Callback = int (*)();
    using QCPItemLine_Receivers_Callback = int (*)(const QCPItemLine*, const char*);
    using QCPItemLine_IsSignalConnected_Callback = bool (*)(const QCPItemLine*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPItemLine_Metacall_Callback qcpitemline_metacall_callback = nullptr;
    QCPItemLine_SelectTest_Callback qcpitemline_selecttest_callback = nullptr;
    QCPItemLine_Draw_Callback qcpitemline_draw_callback = nullptr;
    QCPItemLine_SelectionCategory_Callback qcpitemline_selectioncategory_callback = nullptr;
    QCPItemLine_ClipRect_Callback qcpitemline_cliprect_callback = nullptr;
    QCPItemLine_ApplyDefaultAntialiasingHint_Callback qcpitemline_applydefaultantialiasinghint_callback = nullptr;
    QCPItemLine_SelectEvent_Callback qcpitemline_selectevent_callback = nullptr;
    QCPItemLine_DeselectEvent_Callback qcpitemline_deselectevent_callback = nullptr;
    QCPItemLine_AnchorPixelPosition_Callback qcpitemline_anchorpixelposition_callback = nullptr;
    QCPItemLine_ParentPlotInitialized_Callback qcpitemline_parentplotinitialized_callback = nullptr;
    QCPItemLine_MousePressEvent_Callback qcpitemline_mousepressevent_callback = nullptr;
    QCPItemLine_MouseMoveEvent_Callback qcpitemline_mousemoveevent_callback = nullptr;
    QCPItemLine_MouseReleaseEvent_Callback qcpitemline_mousereleaseevent_callback = nullptr;
    QCPItemLine_MouseDoubleClickEvent_Callback qcpitemline_mousedoubleclickevent_callback = nullptr;
    QCPItemLine_WheelEvent_Callback qcpitemline_wheelevent_callback = nullptr;
    QCPItemLine_Event_Callback qcpitemline_event_callback = nullptr;
    QCPItemLine_EventFilter_Callback qcpitemline_eventfilter_callback = nullptr;
    QCPItemLine_TimerEvent_Callback qcpitemline_timerevent_callback = nullptr;
    QCPItemLine_ChildEvent_Callback qcpitemline_childevent_callback = nullptr;
    QCPItemLine_CustomEvent_Callback qcpitemline_customevent_callback = nullptr;
    QCPItemLine_ConnectNotify_Callback qcpitemline_connectnotify_callback = nullptr;
    QCPItemLine_DisconnectNotify_Callback qcpitemline_disconnectnotify_callback = nullptr;
    QCPItemLine_GetRectClippedLine_Callback qcpitemline_getrectclippedline_callback = nullptr;
    QCPItemLine_MainPen_Callback qcpitemline_mainpen_callback = nullptr;
    QCPItemLine_RectDistance_Callback qcpitemline_rectdistance_callback = nullptr;
    QCPItemLine_CreatePosition_Callback qcpitemline_createposition_callback = nullptr;
    QCPItemLine_CreateAnchor_Callback qcpitemline_createanchor_callback = nullptr;
    QCPItemLine_InitializeParentPlot_Callback qcpitemline_initializeparentplot_callback = nullptr;
    QCPItemLine_SetParentLayerable_Callback qcpitemline_setparentlayerable_callback = nullptr;
    QCPItemLine_MoveToLayer_Callback qcpitemline_movetolayer_callback = nullptr;
    QCPItemLine_ApplyAntialiasingHint_Callback qcpitemline_applyantialiasinghint_callback = nullptr;
    QCPItemLine_Sender_Callback qcpitemline_sender_callback = nullptr;
    QCPItemLine_SenderSignalIndex_Callback qcpitemline_sendersignalindex_callback = nullptr;
    QCPItemLine_Receivers_Callback qcpitemline_receivers_callback = nullptr;
    QCPItemLine_IsSignalConnected_Callback qcpitemline_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpitemline_metacall_isbase = false;
    mutable bool qcpitemline_selecttest_isbase = false;
    mutable bool qcpitemline_draw_isbase = false;
    mutable bool qcpitemline_selectioncategory_isbase = false;
    mutable bool qcpitemline_cliprect_isbase = false;
    mutable bool qcpitemline_applydefaultantialiasinghint_isbase = false;
    mutable bool qcpitemline_selectevent_isbase = false;
    mutable bool qcpitemline_deselectevent_isbase = false;
    mutable bool qcpitemline_anchorpixelposition_isbase = false;
    mutable bool qcpitemline_parentplotinitialized_isbase = false;
    mutable bool qcpitemline_mousepressevent_isbase = false;
    mutable bool qcpitemline_mousemoveevent_isbase = false;
    mutable bool qcpitemline_mousereleaseevent_isbase = false;
    mutable bool qcpitemline_mousedoubleclickevent_isbase = false;
    mutable bool qcpitemline_wheelevent_isbase = false;
    mutable bool qcpitemline_event_isbase = false;
    mutable bool qcpitemline_eventfilter_isbase = false;
    mutable bool qcpitemline_timerevent_isbase = false;
    mutable bool qcpitemline_childevent_isbase = false;
    mutable bool qcpitemline_customevent_isbase = false;
    mutable bool qcpitemline_connectnotify_isbase = false;
    mutable bool qcpitemline_disconnectnotify_isbase = false;
    mutable bool qcpitemline_getrectclippedline_isbase = false;
    mutable bool qcpitemline_mainpen_isbase = false;
    mutable bool qcpitemline_rectdistance_isbase = false;
    mutable bool qcpitemline_createposition_isbase = false;
    mutable bool qcpitemline_createanchor_isbase = false;
    mutable bool qcpitemline_initializeparentplot_isbase = false;
    mutable bool qcpitemline_setparentlayerable_isbase = false;
    mutable bool qcpitemline_movetolayer_isbase = false;
    mutable bool qcpitemline_applyantialiasinghint_isbase = false;
    mutable bool qcpitemline_sender_isbase = false;
    mutable bool qcpitemline_sendersignalindex_isbase = false;
    mutable bool qcpitemline_receivers_isbase = false;
    mutable bool qcpitemline_issignalconnected_isbase = false;

  public:
    VirtualQCPItemLine(QCustomPlot* parentPlot) : QCPItemLine(parentPlot) {};

    ~VirtualQCPItemLine() {
        qcpitemline_metacall_callback = nullptr;
        qcpitemline_selecttest_callback = nullptr;
        qcpitemline_draw_callback = nullptr;
        qcpitemline_selectioncategory_callback = nullptr;
        qcpitemline_cliprect_callback = nullptr;
        qcpitemline_applydefaultantialiasinghint_callback = nullptr;
        qcpitemline_selectevent_callback = nullptr;
        qcpitemline_deselectevent_callback = nullptr;
        qcpitemline_anchorpixelposition_callback = nullptr;
        qcpitemline_parentplotinitialized_callback = nullptr;
        qcpitemline_mousepressevent_callback = nullptr;
        qcpitemline_mousemoveevent_callback = nullptr;
        qcpitemline_mousereleaseevent_callback = nullptr;
        qcpitemline_mousedoubleclickevent_callback = nullptr;
        qcpitemline_wheelevent_callback = nullptr;
        qcpitemline_event_callback = nullptr;
        qcpitemline_eventfilter_callback = nullptr;
        qcpitemline_timerevent_callback = nullptr;
        qcpitemline_childevent_callback = nullptr;
        qcpitemline_customevent_callback = nullptr;
        qcpitemline_connectnotify_callback = nullptr;
        qcpitemline_disconnectnotify_callback = nullptr;
        qcpitemline_getrectclippedline_callback = nullptr;
        qcpitemline_mainpen_callback = nullptr;
        qcpitemline_rectdistance_callback = nullptr;
        qcpitemline_createposition_callback = nullptr;
        qcpitemline_createanchor_callback = nullptr;
        qcpitemline_initializeparentplot_callback = nullptr;
        qcpitemline_setparentlayerable_callback = nullptr;
        qcpitemline_movetolayer_callback = nullptr;
        qcpitemline_applyantialiasinghint_callback = nullptr;
        qcpitemline_sender_callback = nullptr;
        qcpitemline_sendersignalindex_callback = nullptr;
        qcpitemline_receivers_callback = nullptr;
        qcpitemline_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPItemLine_Metacall_Callback(QCPItemLine_Metacall_Callback cb) { qcpitemline_metacall_callback = cb; }
    inline void setQCPItemLine_SelectTest_Callback(QCPItemLine_SelectTest_Callback cb) { qcpitemline_selecttest_callback = cb; }
    inline void setQCPItemLine_Draw_Callback(QCPItemLine_Draw_Callback cb) { qcpitemline_draw_callback = cb; }
    inline void setQCPItemLine_SelectionCategory_Callback(QCPItemLine_SelectionCategory_Callback cb) { qcpitemline_selectioncategory_callback = cb; }
    inline void setQCPItemLine_ClipRect_Callback(QCPItemLine_ClipRect_Callback cb) { qcpitemline_cliprect_callback = cb; }
    inline void setQCPItemLine_ApplyDefaultAntialiasingHint_Callback(QCPItemLine_ApplyDefaultAntialiasingHint_Callback cb) { qcpitemline_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPItemLine_SelectEvent_Callback(QCPItemLine_SelectEvent_Callback cb) { qcpitemline_selectevent_callback = cb; }
    inline void setQCPItemLine_DeselectEvent_Callback(QCPItemLine_DeselectEvent_Callback cb) { qcpitemline_deselectevent_callback = cb; }
    inline void setQCPItemLine_AnchorPixelPosition_Callback(QCPItemLine_AnchorPixelPosition_Callback cb) { qcpitemline_anchorpixelposition_callback = cb; }
    inline void setQCPItemLine_ParentPlotInitialized_Callback(QCPItemLine_ParentPlotInitialized_Callback cb) { qcpitemline_parentplotinitialized_callback = cb; }
    inline void setQCPItemLine_MousePressEvent_Callback(QCPItemLine_MousePressEvent_Callback cb) { qcpitemline_mousepressevent_callback = cb; }
    inline void setQCPItemLine_MouseMoveEvent_Callback(QCPItemLine_MouseMoveEvent_Callback cb) { qcpitemline_mousemoveevent_callback = cb; }
    inline void setQCPItemLine_MouseReleaseEvent_Callback(QCPItemLine_MouseReleaseEvent_Callback cb) { qcpitemline_mousereleaseevent_callback = cb; }
    inline void setQCPItemLine_MouseDoubleClickEvent_Callback(QCPItemLine_MouseDoubleClickEvent_Callback cb) { qcpitemline_mousedoubleclickevent_callback = cb; }
    inline void setQCPItemLine_WheelEvent_Callback(QCPItemLine_WheelEvent_Callback cb) { qcpitemline_wheelevent_callback = cb; }
    inline void setQCPItemLine_Event_Callback(QCPItemLine_Event_Callback cb) { qcpitemline_event_callback = cb; }
    inline void setQCPItemLine_EventFilter_Callback(QCPItemLine_EventFilter_Callback cb) { qcpitemline_eventfilter_callback = cb; }
    inline void setQCPItemLine_TimerEvent_Callback(QCPItemLine_TimerEvent_Callback cb) { qcpitemline_timerevent_callback = cb; }
    inline void setQCPItemLine_ChildEvent_Callback(QCPItemLine_ChildEvent_Callback cb) { qcpitemline_childevent_callback = cb; }
    inline void setQCPItemLine_CustomEvent_Callback(QCPItemLine_CustomEvent_Callback cb) { qcpitemline_customevent_callback = cb; }
    inline void setQCPItemLine_ConnectNotify_Callback(QCPItemLine_ConnectNotify_Callback cb) { qcpitemline_connectnotify_callback = cb; }
    inline void setQCPItemLine_DisconnectNotify_Callback(QCPItemLine_DisconnectNotify_Callback cb) { qcpitemline_disconnectnotify_callback = cb; }
    inline void setQCPItemLine_GetRectClippedLine_Callback(QCPItemLine_GetRectClippedLine_Callback cb) { qcpitemline_getrectclippedline_callback = cb; }
    inline void setQCPItemLine_MainPen_Callback(QCPItemLine_MainPen_Callback cb) { qcpitemline_mainpen_callback = cb; }
    inline void setQCPItemLine_RectDistance_Callback(QCPItemLine_RectDistance_Callback cb) { qcpitemline_rectdistance_callback = cb; }
    inline void setQCPItemLine_CreatePosition_Callback(QCPItemLine_CreatePosition_Callback cb) { qcpitemline_createposition_callback = cb; }
    inline void setQCPItemLine_CreateAnchor_Callback(QCPItemLine_CreateAnchor_Callback cb) { qcpitemline_createanchor_callback = cb; }
    inline void setQCPItemLine_InitializeParentPlot_Callback(QCPItemLine_InitializeParentPlot_Callback cb) { qcpitemline_initializeparentplot_callback = cb; }
    inline void setQCPItemLine_SetParentLayerable_Callback(QCPItemLine_SetParentLayerable_Callback cb) { qcpitemline_setparentlayerable_callback = cb; }
    inline void setQCPItemLine_MoveToLayer_Callback(QCPItemLine_MoveToLayer_Callback cb) { qcpitemline_movetolayer_callback = cb; }
    inline void setQCPItemLine_ApplyAntialiasingHint_Callback(QCPItemLine_ApplyAntialiasingHint_Callback cb) { qcpitemline_applyantialiasinghint_callback = cb; }
    inline void setQCPItemLine_Sender_Callback(QCPItemLine_Sender_Callback cb) { qcpitemline_sender_callback = cb; }
    inline void setQCPItemLine_SenderSignalIndex_Callback(QCPItemLine_SenderSignalIndex_Callback cb) { qcpitemline_sendersignalindex_callback = cb; }
    inline void setQCPItemLine_Receivers_Callback(QCPItemLine_Receivers_Callback cb) { qcpitemline_receivers_callback = cb; }
    inline void setQCPItemLine_IsSignalConnected_Callback(QCPItemLine_IsSignalConnected_Callback cb) { qcpitemline_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPItemLine_Metacall_IsBase(bool value) const { qcpitemline_metacall_isbase = value; }
    inline void setQCPItemLine_SelectTest_IsBase(bool value) const { qcpitemline_selecttest_isbase = value; }
    inline void setQCPItemLine_Draw_IsBase(bool value) const { qcpitemline_draw_isbase = value; }
    inline void setQCPItemLine_SelectionCategory_IsBase(bool value) const { qcpitemline_selectioncategory_isbase = value; }
    inline void setQCPItemLine_ClipRect_IsBase(bool value) const { qcpitemline_cliprect_isbase = value; }
    inline void setQCPItemLine_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcpitemline_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPItemLine_SelectEvent_IsBase(bool value) const { qcpitemline_selectevent_isbase = value; }
    inline void setQCPItemLine_DeselectEvent_IsBase(bool value) const { qcpitemline_deselectevent_isbase = value; }
    inline void setQCPItemLine_AnchorPixelPosition_IsBase(bool value) const { qcpitemline_anchorpixelposition_isbase = value; }
    inline void setQCPItemLine_ParentPlotInitialized_IsBase(bool value) const { qcpitemline_parentplotinitialized_isbase = value; }
    inline void setQCPItemLine_MousePressEvent_IsBase(bool value) const { qcpitemline_mousepressevent_isbase = value; }
    inline void setQCPItemLine_MouseMoveEvent_IsBase(bool value) const { qcpitemline_mousemoveevent_isbase = value; }
    inline void setQCPItemLine_MouseReleaseEvent_IsBase(bool value) const { qcpitemline_mousereleaseevent_isbase = value; }
    inline void setQCPItemLine_MouseDoubleClickEvent_IsBase(bool value) const { qcpitemline_mousedoubleclickevent_isbase = value; }
    inline void setQCPItemLine_WheelEvent_IsBase(bool value) const { qcpitemline_wheelevent_isbase = value; }
    inline void setQCPItemLine_Event_IsBase(bool value) const { qcpitemline_event_isbase = value; }
    inline void setQCPItemLine_EventFilter_IsBase(bool value) const { qcpitemline_eventfilter_isbase = value; }
    inline void setQCPItemLine_TimerEvent_IsBase(bool value) const { qcpitemline_timerevent_isbase = value; }
    inline void setQCPItemLine_ChildEvent_IsBase(bool value) const { qcpitemline_childevent_isbase = value; }
    inline void setQCPItemLine_CustomEvent_IsBase(bool value) const { qcpitemline_customevent_isbase = value; }
    inline void setQCPItemLine_ConnectNotify_IsBase(bool value) const { qcpitemline_connectnotify_isbase = value; }
    inline void setQCPItemLine_DisconnectNotify_IsBase(bool value) const { qcpitemline_disconnectnotify_isbase = value; }
    inline void setQCPItemLine_GetRectClippedLine_IsBase(bool value) const { qcpitemline_getrectclippedline_isbase = value; }
    inline void setQCPItemLine_MainPen_IsBase(bool value) const { qcpitemline_mainpen_isbase = value; }
    inline void setQCPItemLine_RectDistance_IsBase(bool value) const { qcpitemline_rectdistance_isbase = value; }
    inline void setQCPItemLine_CreatePosition_IsBase(bool value) const { qcpitemline_createposition_isbase = value; }
    inline void setQCPItemLine_CreateAnchor_IsBase(bool value) const { qcpitemline_createanchor_isbase = value; }
    inline void setQCPItemLine_InitializeParentPlot_IsBase(bool value) const { qcpitemline_initializeparentplot_isbase = value; }
    inline void setQCPItemLine_SetParentLayerable_IsBase(bool value) const { qcpitemline_setparentlayerable_isbase = value; }
    inline void setQCPItemLine_MoveToLayer_IsBase(bool value) const { qcpitemline_movetolayer_isbase = value; }
    inline void setQCPItemLine_ApplyAntialiasingHint_IsBase(bool value) const { qcpitemline_applyantialiasinghint_isbase = value; }
    inline void setQCPItemLine_Sender_IsBase(bool value) const { qcpitemline_sender_isbase = value; }
    inline void setQCPItemLine_SenderSignalIndex_IsBase(bool value) const { qcpitemline_sendersignalindex_isbase = value; }
    inline void setQCPItemLine_Receivers_IsBase(bool value) const { qcpitemline_receivers_isbase = value; }
    inline void setQCPItemLine_IsSignalConnected_IsBase(bool value) const { qcpitemline_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpitemline_metacall_isbase) {
            qcpitemline_metacall_isbase = false;
            return QCPItemLine::qt_metacall(param1, param2, param3);
        } else if (qcpitemline_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpitemline_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemLine::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcpitemline_selecttest_isbase) {
            qcpitemline_selecttest_isbase = false;
            return QCPItemLine::selectTest(pos, onlySelectable, details);
        } else if (qcpitemline_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcpitemline_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPItemLine::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcpitemline_draw_isbase) {
            qcpitemline_draw_isbase = false;
            QCPItemLine::draw(painter);
        } else if (qcpitemline_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpitemline_draw_callback(this, cbval1);
        } else {
            QCPItemLine::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcpitemline_selectioncategory_isbase) {
            qcpitemline_selectioncategory_isbase = false;
            return QCPItemLine::selectionCategory();
        } else if (qcpitemline_selectioncategory_callback != nullptr) {
            int callback_ret = qcpitemline_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPItemLine::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcpitemline_cliprect_isbase) {
            qcpitemline_cliprect_isbase = false;
            return QCPItemLine::clipRect();
        } else if (qcpitemline_cliprect_callback != nullptr) {
            QRect* callback_ret = qcpitemline_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPItemLine::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcpitemline_applydefaultantialiasinghint_isbase) {
            qcpitemline_applydefaultantialiasinghint_isbase = false;
            QCPItemLine::applyDefaultAntialiasingHint(painter);
        } else if (qcpitemline_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpitemline_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPItemLine::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcpitemline_selectevent_isbase) {
            qcpitemline_selectevent_isbase = false;
            QCPItemLine::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcpitemline_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcpitemline_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPItemLine::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcpitemline_deselectevent_isbase) {
            qcpitemline_deselectevent_isbase = false;
            QCPItemLine::deselectEvent(selectionStateChanged);
        } else if (qcpitemline_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcpitemline_deselectevent_callback(this, cbval1);
        } else {
            QCPItemLine::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QPointF anchorPixelPosition(int anchorId) const override {
        if (qcpitemline_anchorpixelposition_isbase) {
            qcpitemline_anchorpixelposition_isbase = false;
            return QCPItemLine::anchorPixelPosition(anchorId);
        } else if (qcpitemline_anchorpixelposition_callback != nullptr) {
            int cbval1 = anchorId;

            QPointF* callback_ret = qcpitemline_anchorpixelposition_callback(this, cbval1);
            return *callback_ret;
        } else {
            return QCPItemLine::anchorPixelPosition(anchorId);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcpitemline_parentplotinitialized_isbase) {
            qcpitemline_parentplotinitialized_isbase = false;
            QCPItemLine::parentPlotInitialized(parentPlot);
        } else if (qcpitemline_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpitemline_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPItemLine::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpitemline_mousepressevent_isbase) {
            qcpitemline_mousepressevent_isbase = false;
            QCPItemLine::mousePressEvent(event, details);
        } else if (qcpitemline_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpitemline_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemLine::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpitemline_mousemoveevent_isbase) {
            qcpitemline_mousemoveevent_isbase = false;
            QCPItemLine::mouseMoveEvent(event, startPos);
        } else if (qcpitemline_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpitemline_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemLine::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpitemline_mousereleaseevent_isbase) {
            qcpitemline_mousereleaseevent_isbase = false;
            QCPItemLine::mouseReleaseEvent(event, startPos);
        } else if (qcpitemline_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpitemline_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemLine::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpitemline_mousedoubleclickevent_isbase) {
            qcpitemline_mousedoubleclickevent_isbase = false;
            QCPItemLine::mouseDoubleClickEvent(event, details);
        } else if (qcpitemline_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpitemline_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemLine::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcpitemline_wheelevent_isbase) {
            qcpitemline_wheelevent_isbase = false;
            QCPItemLine::wheelEvent(event);
        } else if (qcpitemline_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcpitemline_wheelevent_callback(this, cbval1);
        } else {
            QCPItemLine::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpitemline_event_isbase) {
            qcpitemline_event_isbase = false;
            return QCPItemLine::event(event);
        } else if (qcpitemline_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpitemline_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemLine::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpitemline_eventfilter_isbase) {
            qcpitemline_eventfilter_isbase = false;
            return QCPItemLine::eventFilter(watched, event);
        } else if (qcpitemline_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpitemline_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemLine::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpitemline_timerevent_isbase) {
            qcpitemline_timerevent_isbase = false;
            QCPItemLine::timerEvent(event);
        } else if (qcpitemline_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpitemline_timerevent_callback(this, cbval1);
        } else {
            QCPItemLine::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpitemline_childevent_isbase) {
            qcpitemline_childevent_isbase = false;
            QCPItemLine::childEvent(event);
        } else if (qcpitemline_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpitemline_childevent_callback(this, cbval1);
        } else {
            QCPItemLine::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpitemline_customevent_isbase) {
            qcpitemline_customevent_isbase = false;
            QCPItemLine::customEvent(event);
        } else if (qcpitemline_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpitemline_customevent_callback(this, cbval1);
        } else {
            QCPItemLine::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpitemline_connectnotify_isbase) {
            qcpitemline_connectnotify_isbase = false;
            QCPItemLine::connectNotify(signal);
        } else if (qcpitemline_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpitemline_connectnotify_callback(this, cbval1);
        } else {
            QCPItemLine::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpitemline_disconnectnotify_isbase) {
            qcpitemline_disconnectnotify_isbase = false;
            QCPItemLine::disconnectNotify(signal);
        } else if (qcpitemline_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpitemline_disconnectnotify_callback(this, cbval1);
        } else {
            QCPItemLine::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    QLineF getRectClippedLine(const QCPVector2D& start, const QCPVector2D& end, const QRect& rect) const {
        if (qcpitemline_getrectclippedline_isbase) {
            qcpitemline_getrectclippedline_isbase = false;
            return QCPItemLine::getRectClippedLine(start, end, rect);
        } else if (qcpitemline_getrectclippedline_callback != nullptr) {
            const QCPVector2D& start_ret = start;
            // Cast returned reference into pointer
            QCPVector2D* cbval1 = const_cast<QCPVector2D*>(&start_ret);
            const QCPVector2D& end_ret = end;
            // Cast returned reference into pointer
            QCPVector2D* cbval2 = const_cast<QCPVector2D*>(&end_ret);
            const QRect& rect_ret = rect;
            // Cast returned reference into pointer
            QRect* cbval3 = const_cast<QRect*>(&rect_ret);

            QLineF* callback_ret = qcpitemline_getrectclippedline_callback(this, cbval1, cbval2, cbval3);
            return *callback_ret;
        } else {
            return QCPItemLine::getRectClippedLine(start, end, rect);
        }
    }

    // Virtual method for C ABI access and custom callback
    QPen mainPen() const {
        if (qcpitemline_mainpen_isbase) {
            qcpitemline_mainpen_isbase = false;
            return QCPItemLine::mainPen();
        } else if (qcpitemline_mainpen_callback != nullptr) {
            QPen* callback_ret = qcpitemline_mainpen_callback();
            return *callback_ret;
        } else {
            return QCPItemLine::mainPen();
        }
    }

    // Virtual method for C ABI access and custom callback
    double rectDistance(const QRectF& rect, const QPointF& pos, bool filledRect) const {
        if (qcpitemline_rectdistance_isbase) {
            qcpitemline_rectdistance_isbase = false;
            return QCPItemLine::rectDistance(rect, pos, filledRect);
        } else if (qcpitemline_rectdistance_callback != nullptr) {
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval1 = const_cast<QRectF*>(&rect_ret);
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&pos_ret);
            bool cbval3 = filledRect;

            double callback_ret = qcpitemline_rectdistance_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPItemLine::rectDistance(rect, pos, filledRect);
        }
    }

    // Virtual method for C ABI access and custom callback
    QCPItemPosition* createPosition(const QString& name) {
        if (qcpitemline_createposition_isbase) {
            qcpitemline_createposition_isbase = false;
            return QCPItemLine::createPosition(name);
        } else if (qcpitemline_createposition_callback != nullptr) {
            const QString name_ret = name;
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray name_b = name_ret.toUtf8();
            libqt_string name_str;
            name_str.len = name_b.length();
            name_str.data = static_cast<const char*>(malloc(name_str.len + 1));
            memcpy((void*)name_str.data, name_b.data(), name_str.len);
            ((char*)name_str.data)[name_str.len] = '\0';
            libqt_string cbval1 = name_str;

            QCPItemPosition* callback_ret = qcpitemline_createposition_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemLine::createPosition(name);
        }
    }

    // Virtual method for C ABI access and custom callback
    QCPItemAnchor* createAnchor(const QString& name, int anchorId) {
        if (qcpitemline_createanchor_isbase) {
            qcpitemline_createanchor_isbase = false;
            return QCPItemLine::createAnchor(name, anchorId);
        } else if (qcpitemline_createanchor_callback != nullptr) {
            const QString name_ret = name;
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray name_b = name_ret.toUtf8();
            libqt_string name_str;
            name_str.len = name_b.length();
            name_str.data = static_cast<const char*>(malloc(name_str.len + 1));
            memcpy((void*)name_str.data, name_b.data(), name_str.len);
            ((char*)name_str.data)[name_str.len] = '\0';
            libqt_string cbval1 = name_str;
            int cbval2 = anchorId;

            QCPItemAnchor* callback_ret = qcpitemline_createanchor_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemLine::createAnchor(name, anchorId);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcpitemline_initializeparentplot_isbase) {
            qcpitemline_initializeparentplot_isbase = false;
            QCPItemLine::initializeParentPlot(parentPlot);
        } else if (qcpitemline_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpitemline_initializeparentplot_callback(this, cbval1);
        } else {
            QCPItemLine::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcpitemline_setparentlayerable_isbase) {
            qcpitemline_setparentlayerable_isbase = false;
            QCPItemLine::setParentLayerable(parentLayerable);
        } else if (qcpitemline_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcpitemline_setparentlayerable_callback(this, cbval1);
        } else {
            QCPItemLine::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcpitemline_movetolayer_isbase) {
            qcpitemline_movetolayer_isbase = false;
            return QCPItemLine::moveToLayer(layer, prepend);
        } else if (qcpitemline_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcpitemline_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemLine::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcpitemline_applyantialiasinghint_isbase) {
            qcpitemline_applyantialiasinghint_isbase = false;
            QCPItemLine::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcpitemline_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcpitemline_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPItemLine::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpitemline_sender_isbase) {
            qcpitemline_sender_isbase = false;
            return QCPItemLine::sender();
        } else if (qcpitemline_sender_callback != nullptr) {
            QObject* callback_ret = qcpitemline_sender_callback();
            return callback_ret;
        } else {
            return QCPItemLine::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpitemline_sendersignalindex_isbase) {
            qcpitemline_sendersignalindex_isbase = false;
            return QCPItemLine::senderSignalIndex();
        } else if (qcpitemline_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpitemline_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemLine::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpitemline_receivers_isbase) {
            qcpitemline_receivers_isbase = false;
            return QCPItemLine::receivers(signal);
        } else if (qcpitemline_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpitemline_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemLine::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpitemline_issignalconnected_isbase) {
            qcpitemline_issignalconnected_isbase = false;
            return QCPItemLine::isSignalConnected(signal);
        } else if (qcpitemline_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpitemline_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemLine::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPItemLine_Draw(QCPItemLine* self, QCPPainter* painter);
    friend void QCPItemLine_QBaseDraw(QCPItemLine* self, QCPPainter* painter);
    friend int QCPItemLine_SelectionCategory(const QCPItemLine* self);
    friend int QCPItemLine_QBaseSelectionCategory(const QCPItemLine* self);
    friend QRect* QCPItemLine_ClipRect(const QCPItemLine* self);
    friend QRect* QCPItemLine_QBaseClipRect(const QCPItemLine* self);
    friend void QCPItemLine_ApplyDefaultAntialiasingHint(const QCPItemLine* self, QCPPainter* painter);
    friend void QCPItemLine_QBaseApplyDefaultAntialiasingHint(const QCPItemLine* self, QCPPainter* painter);
    friend void QCPItemLine_SelectEvent(QCPItemLine* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPItemLine_QBaseSelectEvent(QCPItemLine* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPItemLine_DeselectEvent(QCPItemLine* self, bool* selectionStateChanged);
    friend void QCPItemLine_QBaseDeselectEvent(QCPItemLine* self, bool* selectionStateChanged);
    friend QPointF* QCPItemLine_AnchorPixelPosition(const QCPItemLine* self, int anchorId);
    friend QPointF* QCPItemLine_QBaseAnchorPixelPosition(const QCPItemLine* self, int anchorId);
    friend void QCPItemLine_ParentPlotInitialized(QCPItemLine* self, QCustomPlot* parentPlot);
    friend void QCPItemLine_QBaseParentPlotInitialized(QCPItemLine* self, QCustomPlot* parentPlot);
    friend void QCPItemLine_MousePressEvent(QCPItemLine* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemLine_QBaseMousePressEvent(QCPItemLine* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemLine_MouseMoveEvent(QCPItemLine* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemLine_QBaseMouseMoveEvent(QCPItemLine* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemLine_MouseReleaseEvent(QCPItemLine* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemLine_QBaseMouseReleaseEvent(QCPItemLine* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemLine_MouseDoubleClickEvent(QCPItemLine* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemLine_QBaseMouseDoubleClickEvent(QCPItemLine* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemLine_WheelEvent(QCPItemLine* self, QWheelEvent* event);
    friend void QCPItemLine_QBaseWheelEvent(QCPItemLine* self, QWheelEvent* event);
    friend void QCPItemLine_TimerEvent(QCPItemLine* self, QTimerEvent* event);
    friend void QCPItemLine_QBaseTimerEvent(QCPItemLine* self, QTimerEvent* event);
    friend void QCPItemLine_ChildEvent(QCPItemLine* self, QChildEvent* event);
    friend void QCPItemLine_QBaseChildEvent(QCPItemLine* self, QChildEvent* event);
    friend void QCPItemLine_CustomEvent(QCPItemLine* self, QEvent* event);
    friend void QCPItemLine_QBaseCustomEvent(QCPItemLine* self, QEvent* event);
    friend void QCPItemLine_ConnectNotify(QCPItemLine* self, const QMetaMethod* signal);
    friend void QCPItemLine_QBaseConnectNotify(QCPItemLine* self, const QMetaMethod* signal);
    friend void QCPItemLine_DisconnectNotify(QCPItemLine* self, const QMetaMethod* signal);
    friend void QCPItemLine_QBaseDisconnectNotify(QCPItemLine* self, const QMetaMethod* signal);
    friend QLineF* QCPItemLine_GetRectClippedLine(const QCPItemLine* self, const QCPVector2D* start, const QCPVector2D* end, const QRect* rect);
    friend QLineF* QCPItemLine_QBaseGetRectClippedLine(const QCPItemLine* self, const QCPVector2D* start, const QCPVector2D* end, const QRect* rect);
    friend QPen* QCPItemLine_MainPen(const QCPItemLine* self);
    friend QPen* QCPItemLine_QBaseMainPen(const QCPItemLine* self);
    friend double QCPItemLine_RectDistance(const QCPItemLine* self, const QRectF* rect, const QPointF* pos, bool filledRect);
    friend double QCPItemLine_QBaseRectDistance(const QCPItemLine* self, const QRectF* rect, const QPointF* pos, bool filledRect);
    friend QCPItemPosition* QCPItemLine_CreatePosition(QCPItemLine* self, const libqt_string name);
    friend QCPItemPosition* QCPItemLine_QBaseCreatePosition(QCPItemLine* self, const libqt_string name);
    friend QCPItemAnchor* QCPItemLine_CreateAnchor(QCPItemLine* self, const libqt_string name, int anchorId);
    friend QCPItemAnchor* QCPItemLine_QBaseCreateAnchor(QCPItemLine* self, const libqt_string name, int anchorId);
    friend void QCPItemLine_InitializeParentPlot(QCPItemLine* self, QCustomPlot* parentPlot);
    friend void QCPItemLine_QBaseInitializeParentPlot(QCPItemLine* self, QCustomPlot* parentPlot);
    friend void QCPItemLine_SetParentLayerable(QCPItemLine* self, QCPLayerable* parentLayerable);
    friend void QCPItemLine_QBaseSetParentLayerable(QCPItemLine* self, QCPLayerable* parentLayerable);
    friend bool QCPItemLine_MoveToLayer(QCPItemLine* self, QCPLayer* layer, bool prepend);
    friend bool QCPItemLine_QBaseMoveToLayer(QCPItemLine* self, QCPLayer* layer, bool prepend);
    friend void QCPItemLine_ApplyAntialiasingHint(const QCPItemLine* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPItemLine_QBaseApplyAntialiasingHint(const QCPItemLine* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPItemLine_Sender(const QCPItemLine* self);
    friend QObject* QCPItemLine_QBaseSender(const QCPItemLine* self);
    friend int QCPItemLine_SenderSignalIndex(const QCPItemLine* self);
    friend int QCPItemLine_QBaseSenderSignalIndex(const QCPItemLine* self);
    friend int QCPItemLine_Receivers(const QCPItemLine* self, const char* signal);
    friend int QCPItemLine_QBaseReceivers(const QCPItemLine* self, const char* signal);
    friend bool QCPItemLine_IsSignalConnected(const QCPItemLine* self, const QMetaMethod* signal);
    friend bool QCPItemLine_QBaseIsSignalConnected(const QCPItemLine* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPItemCurve so that we can call protected methods
class VirtualQCPItemCurve final : public QCPItemCurve {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPItemCurve = true;

    // Virtual class public types (including callbacks)
    using QCPItemCurve_Metacall_Callback = int (*)(QCPItemCurve*, int, int, void**);
    using QCPItemCurve_SelectTest_Callback = double (*)(const QCPItemCurve*, QPointF*, bool, QVariant*);
    using QCPItemCurve_Draw_Callback = void (*)(QCPItemCurve*, QCPPainter*);
    using QCPItemCurve_SelectionCategory_Callback = int (*)();
    using QCPItemCurve_ClipRect_Callback = QRect* (*)();
    using QCPItemCurve_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPItemCurve*, QCPPainter*);
    using QCPItemCurve_SelectEvent_Callback = void (*)(QCPItemCurve*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPItemCurve_DeselectEvent_Callback = void (*)(QCPItemCurve*, bool*);
    using QCPItemCurve_AnchorPixelPosition_Callback = QPointF* (*)(const QCPItemCurve*, int);
    using QCPItemCurve_ParentPlotInitialized_Callback = void (*)(QCPItemCurve*, QCustomPlot*);
    using QCPItemCurve_MousePressEvent_Callback = void (*)(QCPItemCurve*, QMouseEvent*, QVariant*);
    using QCPItemCurve_MouseMoveEvent_Callback = void (*)(QCPItemCurve*, QMouseEvent*, QPointF*);
    using QCPItemCurve_MouseReleaseEvent_Callback = void (*)(QCPItemCurve*, QMouseEvent*, QPointF*);
    using QCPItemCurve_MouseDoubleClickEvent_Callback = void (*)(QCPItemCurve*, QMouseEvent*, QVariant*);
    using QCPItemCurve_WheelEvent_Callback = void (*)(QCPItemCurve*, QWheelEvent*);
    using QCPItemCurve_Event_Callback = bool (*)(QCPItemCurve*, QEvent*);
    using QCPItemCurve_EventFilter_Callback = bool (*)(QCPItemCurve*, QObject*, QEvent*);
    using QCPItemCurve_TimerEvent_Callback = void (*)(QCPItemCurve*, QTimerEvent*);
    using QCPItemCurve_ChildEvent_Callback = void (*)(QCPItemCurve*, QChildEvent*);
    using QCPItemCurve_CustomEvent_Callback = void (*)(QCPItemCurve*, QEvent*);
    using QCPItemCurve_ConnectNotify_Callback = void (*)(QCPItemCurve*, QMetaMethod*);
    using QCPItemCurve_DisconnectNotify_Callback = void (*)(QCPItemCurve*, QMetaMethod*);
    using QCPItemCurve_MainPen_Callback = QPen* (*)();
    using QCPItemCurve_RectDistance_Callback = double (*)(const QCPItemCurve*, QRectF*, QPointF*, bool);
    using QCPItemCurve_CreatePosition_Callback = QCPItemPosition* (*)(QCPItemCurve*, libqt_string);
    using QCPItemCurve_CreateAnchor_Callback = QCPItemAnchor* (*)(QCPItemCurve*, libqt_string, int);
    using QCPItemCurve_InitializeParentPlot_Callback = void (*)(QCPItemCurve*, QCustomPlot*);
    using QCPItemCurve_SetParentLayerable_Callback = void (*)(QCPItemCurve*, QCPLayerable*);
    using QCPItemCurve_MoveToLayer_Callback = bool (*)(QCPItemCurve*, QCPLayer*, bool);
    using QCPItemCurve_ApplyAntialiasingHint_Callback = void (*)(const QCPItemCurve*, QCPPainter*, bool, int);
    using QCPItemCurve_Sender_Callback = QObject* (*)();
    using QCPItemCurve_SenderSignalIndex_Callback = int (*)();
    using QCPItemCurve_Receivers_Callback = int (*)(const QCPItemCurve*, const char*);
    using QCPItemCurve_IsSignalConnected_Callback = bool (*)(const QCPItemCurve*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPItemCurve_Metacall_Callback qcpitemcurve_metacall_callback = nullptr;
    QCPItemCurve_SelectTest_Callback qcpitemcurve_selecttest_callback = nullptr;
    QCPItemCurve_Draw_Callback qcpitemcurve_draw_callback = nullptr;
    QCPItemCurve_SelectionCategory_Callback qcpitemcurve_selectioncategory_callback = nullptr;
    QCPItemCurve_ClipRect_Callback qcpitemcurve_cliprect_callback = nullptr;
    QCPItemCurve_ApplyDefaultAntialiasingHint_Callback qcpitemcurve_applydefaultantialiasinghint_callback = nullptr;
    QCPItemCurve_SelectEvent_Callback qcpitemcurve_selectevent_callback = nullptr;
    QCPItemCurve_DeselectEvent_Callback qcpitemcurve_deselectevent_callback = nullptr;
    QCPItemCurve_AnchorPixelPosition_Callback qcpitemcurve_anchorpixelposition_callback = nullptr;
    QCPItemCurve_ParentPlotInitialized_Callback qcpitemcurve_parentplotinitialized_callback = nullptr;
    QCPItemCurve_MousePressEvent_Callback qcpitemcurve_mousepressevent_callback = nullptr;
    QCPItemCurve_MouseMoveEvent_Callback qcpitemcurve_mousemoveevent_callback = nullptr;
    QCPItemCurve_MouseReleaseEvent_Callback qcpitemcurve_mousereleaseevent_callback = nullptr;
    QCPItemCurve_MouseDoubleClickEvent_Callback qcpitemcurve_mousedoubleclickevent_callback = nullptr;
    QCPItemCurve_WheelEvent_Callback qcpitemcurve_wheelevent_callback = nullptr;
    QCPItemCurve_Event_Callback qcpitemcurve_event_callback = nullptr;
    QCPItemCurve_EventFilter_Callback qcpitemcurve_eventfilter_callback = nullptr;
    QCPItemCurve_TimerEvent_Callback qcpitemcurve_timerevent_callback = nullptr;
    QCPItemCurve_ChildEvent_Callback qcpitemcurve_childevent_callback = nullptr;
    QCPItemCurve_CustomEvent_Callback qcpitemcurve_customevent_callback = nullptr;
    QCPItemCurve_ConnectNotify_Callback qcpitemcurve_connectnotify_callback = nullptr;
    QCPItemCurve_DisconnectNotify_Callback qcpitemcurve_disconnectnotify_callback = nullptr;
    QCPItemCurve_MainPen_Callback qcpitemcurve_mainpen_callback = nullptr;
    QCPItemCurve_RectDistance_Callback qcpitemcurve_rectdistance_callback = nullptr;
    QCPItemCurve_CreatePosition_Callback qcpitemcurve_createposition_callback = nullptr;
    QCPItemCurve_CreateAnchor_Callback qcpitemcurve_createanchor_callback = nullptr;
    QCPItemCurve_InitializeParentPlot_Callback qcpitemcurve_initializeparentplot_callback = nullptr;
    QCPItemCurve_SetParentLayerable_Callback qcpitemcurve_setparentlayerable_callback = nullptr;
    QCPItemCurve_MoveToLayer_Callback qcpitemcurve_movetolayer_callback = nullptr;
    QCPItemCurve_ApplyAntialiasingHint_Callback qcpitemcurve_applyantialiasinghint_callback = nullptr;
    QCPItemCurve_Sender_Callback qcpitemcurve_sender_callback = nullptr;
    QCPItemCurve_SenderSignalIndex_Callback qcpitemcurve_sendersignalindex_callback = nullptr;
    QCPItemCurve_Receivers_Callback qcpitemcurve_receivers_callback = nullptr;
    QCPItemCurve_IsSignalConnected_Callback qcpitemcurve_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpitemcurve_metacall_isbase = false;
    mutable bool qcpitemcurve_selecttest_isbase = false;
    mutable bool qcpitemcurve_draw_isbase = false;
    mutable bool qcpitemcurve_selectioncategory_isbase = false;
    mutable bool qcpitemcurve_cliprect_isbase = false;
    mutable bool qcpitemcurve_applydefaultantialiasinghint_isbase = false;
    mutable bool qcpitemcurve_selectevent_isbase = false;
    mutable bool qcpitemcurve_deselectevent_isbase = false;
    mutable bool qcpitemcurve_anchorpixelposition_isbase = false;
    mutable bool qcpitemcurve_parentplotinitialized_isbase = false;
    mutable bool qcpitemcurve_mousepressevent_isbase = false;
    mutable bool qcpitemcurve_mousemoveevent_isbase = false;
    mutable bool qcpitemcurve_mousereleaseevent_isbase = false;
    mutable bool qcpitemcurve_mousedoubleclickevent_isbase = false;
    mutable bool qcpitemcurve_wheelevent_isbase = false;
    mutable bool qcpitemcurve_event_isbase = false;
    mutable bool qcpitemcurve_eventfilter_isbase = false;
    mutable bool qcpitemcurve_timerevent_isbase = false;
    mutable bool qcpitemcurve_childevent_isbase = false;
    mutable bool qcpitemcurve_customevent_isbase = false;
    mutable bool qcpitemcurve_connectnotify_isbase = false;
    mutable bool qcpitemcurve_disconnectnotify_isbase = false;
    mutable bool qcpitemcurve_mainpen_isbase = false;
    mutable bool qcpitemcurve_rectdistance_isbase = false;
    mutable bool qcpitemcurve_createposition_isbase = false;
    mutable bool qcpitemcurve_createanchor_isbase = false;
    mutable bool qcpitemcurve_initializeparentplot_isbase = false;
    mutable bool qcpitemcurve_setparentlayerable_isbase = false;
    mutable bool qcpitemcurve_movetolayer_isbase = false;
    mutable bool qcpitemcurve_applyantialiasinghint_isbase = false;
    mutable bool qcpitemcurve_sender_isbase = false;
    mutable bool qcpitemcurve_sendersignalindex_isbase = false;
    mutable bool qcpitemcurve_receivers_isbase = false;
    mutable bool qcpitemcurve_issignalconnected_isbase = false;

  public:
    VirtualQCPItemCurve(QCustomPlot* parentPlot) : QCPItemCurve(parentPlot) {};

    ~VirtualQCPItemCurve() {
        qcpitemcurve_metacall_callback = nullptr;
        qcpitemcurve_selecttest_callback = nullptr;
        qcpitemcurve_draw_callback = nullptr;
        qcpitemcurve_selectioncategory_callback = nullptr;
        qcpitemcurve_cliprect_callback = nullptr;
        qcpitemcurve_applydefaultantialiasinghint_callback = nullptr;
        qcpitemcurve_selectevent_callback = nullptr;
        qcpitemcurve_deselectevent_callback = nullptr;
        qcpitemcurve_anchorpixelposition_callback = nullptr;
        qcpitemcurve_parentplotinitialized_callback = nullptr;
        qcpitemcurve_mousepressevent_callback = nullptr;
        qcpitemcurve_mousemoveevent_callback = nullptr;
        qcpitemcurve_mousereleaseevent_callback = nullptr;
        qcpitemcurve_mousedoubleclickevent_callback = nullptr;
        qcpitemcurve_wheelevent_callback = nullptr;
        qcpitemcurve_event_callback = nullptr;
        qcpitemcurve_eventfilter_callback = nullptr;
        qcpitemcurve_timerevent_callback = nullptr;
        qcpitemcurve_childevent_callback = nullptr;
        qcpitemcurve_customevent_callback = nullptr;
        qcpitemcurve_connectnotify_callback = nullptr;
        qcpitemcurve_disconnectnotify_callback = nullptr;
        qcpitemcurve_mainpen_callback = nullptr;
        qcpitemcurve_rectdistance_callback = nullptr;
        qcpitemcurve_createposition_callback = nullptr;
        qcpitemcurve_createanchor_callback = nullptr;
        qcpitemcurve_initializeparentplot_callback = nullptr;
        qcpitemcurve_setparentlayerable_callback = nullptr;
        qcpitemcurve_movetolayer_callback = nullptr;
        qcpitemcurve_applyantialiasinghint_callback = nullptr;
        qcpitemcurve_sender_callback = nullptr;
        qcpitemcurve_sendersignalindex_callback = nullptr;
        qcpitemcurve_receivers_callback = nullptr;
        qcpitemcurve_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPItemCurve_Metacall_Callback(QCPItemCurve_Metacall_Callback cb) { qcpitemcurve_metacall_callback = cb; }
    inline void setQCPItemCurve_SelectTest_Callback(QCPItemCurve_SelectTest_Callback cb) { qcpitemcurve_selecttest_callback = cb; }
    inline void setQCPItemCurve_Draw_Callback(QCPItemCurve_Draw_Callback cb) { qcpitemcurve_draw_callback = cb; }
    inline void setQCPItemCurve_SelectionCategory_Callback(QCPItemCurve_SelectionCategory_Callback cb) { qcpitemcurve_selectioncategory_callback = cb; }
    inline void setQCPItemCurve_ClipRect_Callback(QCPItemCurve_ClipRect_Callback cb) { qcpitemcurve_cliprect_callback = cb; }
    inline void setQCPItemCurve_ApplyDefaultAntialiasingHint_Callback(QCPItemCurve_ApplyDefaultAntialiasingHint_Callback cb) { qcpitemcurve_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPItemCurve_SelectEvent_Callback(QCPItemCurve_SelectEvent_Callback cb) { qcpitemcurve_selectevent_callback = cb; }
    inline void setQCPItemCurve_DeselectEvent_Callback(QCPItemCurve_DeselectEvent_Callback cb) { qcpitemcurve_deselectevent_callback = cb; }
    inline void setQCPItemCurve_AnchorPixelPosition_Callback(QCPItemCurve_AnchorPixelPosition_Callback cb) { qcpitemcurve_anchorpixelposition_callback = cb; }
    inline void setQCPItemCurve_ParentPlotInitialized_Callback(QCPItemCurve_ParentPlotInitialized_Callback cb) { qcpitemcurve_parentplotinitialized_callback = cb; }
    inline void setQCPItemCurve_MousePressEvent_Callback(QCPItemCurve_MousePressEvent_Callback cb) { qcpitemcurve_mousepressevent_callback = cb; }
    inline void setQCPItemCurve_MouseMoveEvent_Callback(QCPItemCurve_MouseMoveEvent_Callback cb) { qcpitemcurve_mousemoveevent_callback = cb; }
    inline void setQCPItemCurve_MouseReleaseEvent_Callback(QCPItemCurve_MouseReleaseEvent_Callback cb) { qcpitemcurve_mousereleaseevent_callback = cb; }
    inline void setQCPItemCurve_MouseDoubleClickEvent_Callback(QCPItemCurve_MouseDoubleClickEvent_Callback cb) { qcpitemcurve_mousedoubleclickevent_callback = cb; }
    inline void setQCPItemCurve_WheelEvent_Callback(QCPItemCurve_WheelEvent_Callback cb) { qcpitemcurve_wheelevent_callback = cb; }
    inline void setQCPItemCurve_Event_Callback(QCPItemCurve_Event_Callback cb) { qcpitemcurve_event_callback = cb; }
    inline void setQCPItemCurve_EventFilter_Callback(QCPItemCurve_EventFilter_Callback cb) { qcpitemcurve_eventfilter_callback = cb; }
    inline void setQCPItemCurve_TimerEvent_Callback(QCPItemCurve_TimerEvent_Callback cb) { qcpitemcurve_timerevent_callback = cb; }
    inline void setQCPItemCurve_ChildEvent_Callback(QCPItemCurve_ChildEvent_Callback cb) { qcpitemcurve_childevent_callback = cb; }
    inline void setQCPItemCurve_CustomEvent_Callback(QCPItemCurve_CustomEvent_Callback cb) { qcpitemcurve_customevent_callback = cb; }
    inline void setQCPItemCurve_ConnectNotify_Callback(QCPItemCurve_ConnectNotify_Callback cb) { qcpitemcurve_connectnotify_callback = cb; }
    inline void setQCPItemCurve_DisconnectNotify_Callback(QCPItemCurve_DisconnectNotify_Callback cb) { qcpitemcurve_disconnectnotify_callback = cb; }
    inline void setQCPItemCurve_MainPen_Callback(QCPItemCurve_MainPen_Callback cb) { qcpitemcurve_mainpen_callback = cb; }
    inline void setQCPItemCurve_RectDistance_Callback(QCPItemCurve_RectDistance_Callback cb) { qcpitemcurve_rectdistance_callback = cb; }
    inline void setQCPItemCurve_CreatePosition_Callback(QCPItemCurve_CreatePosition_Callback cb) { qcpitemcurve_createposition_callback = cb; }
    inline void setQCPItemCurve_CreateAnchor_Callback(QCPItemCurve_CreateAnchor_Callback cb) { qcpitemcurve_createanchor_callback = cb; }
    inline void setQCPItemCurve_InitializeParentPlot_Callback(QCPItemCurve_InitializeParentPlot_Callback cb) { qcpitemcurve_initializeparentplot_callback = cb; }
    inline void setQCPItemCurve_SetParentLayerable_Callback(QCPItemCurve_SetParentLayerable_Callback cb) { qcpitemcurve_setparentlayerable_callback = cb; }
    inline void setQCPItemCurve_MoveToLayer_Callback(QCPItemCurve_MoveToLayer_Callback cb) { qcpitemcurve_movetolayer_callback = cb; }
    inline void setQCPItemCurve_ApplyAntialiasingHint_Callback(QCPItemCurve_ApplyAntialiasingHint_Callback cb) { qcpitemcurve_applyantialiasinghint_callback = cb; }
    inline void setQCPItemCurve_Sender_Callback(QCPItemCurve_Sender_Callback cb) { qcpitemcurve_sender_callback = cb; }
    inline void setQCPItemCurve_SenderSignalIndex_Callback(QCPItemCurve_SenderSignalIndex_Callback cb) { qcpitemcurve_sendersignalindex_callback = cb; }
    inline void setQCPItemCurve_Receivers_Callback(QCPItemCurve_Receivers_Callback cb) { qcpitemcurve_receivers_callback = cb; }
    inline void setQCPItemCurve_IsSignalConnected_Callback(QCPItemCurve_IsSignalConnected_Callback cb) { qcpitemcurve_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPItemCurve_Metacall_IsBase(bool value) const { qcpitemcurve_metacall_isbase = value; }
    inline void setQCPItemCurve_SelectTest_IsBase(bool value) const { qcpitemcurve_selecttest_isbase = value; }
    inline void setQCPItemCurve_Draw_IsBase(bool value) const { qcpitemcurve_draw_isbase = value; }
    inline void setQCPItemCurve_SelectionCategory_IsBase(bool value) const { qcpitemcurve_selectioncategory_isbase = value; }
    inline void setQCPItemCurve_ClipRect_IsBase(bool value) const { qcpitemcurve_cliprect_isbase = value; }
    inline void setQCPItemCurve_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcpitemcurve_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPItemCurve_SelectEvent_IsBase(bool value) const { qcpitemcurve_selectevent_isbase = value; }
    inline void setQCPItemCurve_DeselectEvent_IsBase(bool value) const { qcpitemcurve_deselectevent_isbase = value; }
    inline void setQCPItemCurve_AnchorPixelPosition_IsBase(bool value) const { qcpitemcurve_anchorpixelposition_isbase = value; }
    inline void setQCPItemCurve_ParentPlotInitialized_IsBase(bool value) const { qcpitemcurve_parentplotinitialized_isbase = value; }
    inline void setQCPItemCurve_MousePressEvent_IsBase(bool value) const { qcpitemcurve_mousepressevent_isbase = value; }
    inline void setQCPItemCurve_MouseMoveEvent_IsBase(bool value) const { qcpitemcurve_mousemoveevent_isbase = value; }
    inline void setQCPItemCurve_MouseReleaseEvent_IsBase(bool value) const { qcpitemcurve_mousereleaseevent_isbase = value; }
    inline void setQCPItemCurve_MouseDoubleClickEvent_IsBase(bool value) const { qcpitemcurve_mousedoubleclickevent_isbase = value; }
    inline void setQCPItemCurve_WheelEvent_IsBase(bool value) const { qcpitemcurve_wheelevent_isbase = value; }
    inline void setQCPItemCurve_Event_IsBase(bool value) const { qcpitemcurve_event_isbase = value; }
    inline void setQCPItemCurve_EventFilter_IsBase(bool value) const { qcpitemcurve_eventfilter_isbase = value; }
    inline void setQCPItemCurve_TimerEvent_IsBase(bool value) const { qcpitemcurve_timerevent_isbase = value; }
    inline void setQCPItemCurve_ChildEvent_IsBase(bool value) const { qcpitemcurve_childevent_isbase = value; }
    inline void setQCPItemCurve_CustomEvent_IsBase(bool value) const { qcpitemcurve_customevent_isbase = value; }
    inline void setQCPItemCurve_ConnectNotify_IsBase(bool value) const { qcpitemcurve_connectnotify_isbase = value; }
    inline void setQCPItemCurve_DisconnectNotify_IsBase(bool value) const { qcpitemcurve_disconnectnotify_isbase = value; }
    inline void setQCPItemCurve_MainPen_IsBase(bool value) const { qcpitemcurve_mainpen_isbase = value; }
    inline void setQCPItemCurve_RectDistance_IsBase(bool value) const { qcpitemcurve_rectdistance_isbase = value; }
    inline void setQCPItemCurve_CreatePosition_IsBase(bool value) const { qcpitemcurve_createposition_isbase = value; }
    inline void setQCPItemCurve_CreateAnchor_IsBase(bool value) const { qcpitemcurve_createanchor_isbase = value; }
    inline void setQCPItemCurve_InitializeParentPlot_IsBase(bool value) const { qcpitemcurve_initializeparentplot_isbase = value; }
    inline void setQCPItemCurve_SetParentLayerable_IsBase(bool value) const { qcpitemcurve_setparentlayerable_isbase = value; }
    inline void setQCPItemCurve_MoveToLayer_IsBase(bool value) const { qcpitemcurve_movetolayer_isbase = value; }
    inline void setQCPItemCurve_ApplyAntialiasingHint_IsBase(bool value) const { qcpitemcurve_applyantialiasinghint_isbase = value; }
    inline void setQCPItemCurve_Sender_IsBase(bool value) const { qcpitemcurve_sender_isbase = value; }
    inline void setQCPItemCurve_SenderSignalIndex_IsBase(bool value) const { qcpitemcurve_sendersignalindex_isbase = value; }
    inline void setQCPItemCurve_Receivers_IsBase(bool value) const { qcpitemcurve_receivers_isbase = value; }
    inline void setQCPItemCurve_IsSignalConnected_IsBase(bool value) const { qcpitemcurve_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpitemcurve_metacall_isbase) {
            qcpitemcurve_metacall_isbase = false;
            return QCPItemCurve::qt_metacall(param1, param2, param3);
        } else if (qcpitemcurve_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpitemcurve_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemCurve::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcpitemcurve_selecttest_isbase) {
            qcpitemcurve_selecttest_isbase = false;
            return QCPItemCurve::selectTest(pos, onlySelectable, details);
        } else if (qcpitemcurve_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcpitemcurve_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPItemCurve::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcpitemcurve_draw_isbase) {
            qcpitemcurve_draw_isbase = false;
            QCPItemCurve::draw(painter);
        } else if (qcpitemcurve_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpitemcurve_draw_callback(this, cbval1);
        } else {
            QCPItemCurve::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcpitemcurve_selectioncategory_isbase) {
            qcpitemcurve_selectioncategory_isbase = false;
            return QCPItemCurve::selectionCategory();
        } else if (qcpitemcurve_selectioncategory_callback != nullptr) {
            int callback_ret = qcpitemcurve_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPItemCurve::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcpitemcurve_cliprect_isbase) {
            qcpitemcurve_cliprect_isbase = false;
            return QCPItemCurve::clipRect();
        } else if (qcpitemcurve_cliprect_callback != nullptr) {
            QRect* callback_ret = qcpitemcurve_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPItemCurve::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcpitemcurve_applydefaultantialiasinghint_isbase) {
            qcpitemcurve_applydefaultantialiasinghint_isbase = false;
            QCPItemCurve::applyDefaultAntialiasingHint(painter);
        } else if (qcpitemcurve_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpitemcurve_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPItemCurve::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcpitemcurve_selectevent_isbase) {
            qcpitemcurve_selectevent_isbase = false;
            QCPItemCurve::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcpitemcurve_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcpitemcurve_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPItemCurve::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcpitemcurve_deselectevent_isbase) {
            qcpitemcurve_deselectevent_isbase = false;
            QCPItemCurve::deselectEvent(selectionStateChanged);
        } else if (qcpitemcurve_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcpitemcurve_deselectevent_callback(this, cbval1);
        } else {
            QCPItemCurve::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QPointF anchorPixelPosition(int anchorId) const override {
        if (qcpitemcurve_anchorpixelposition_isbase) {
            qcpitemcurve_anchorpixelposition_isbase = false;
            return QCPItemCurve::anchorPixelPosition(anchorId);
        } else if (qcpitemcurve_anchorpixelposition_callback != nullptr) {
            int cbval1 = anchorId;

            QPointF* callback_ret = qcpitemcurve_anchorpixelposition_callback(this, cbval1);
            return *callback_ret;
        } else {
            return QCPItemCurve::anchorPixelPosition(anchorId);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcpitemcurve_parentplotinitialized_isbase) {
            qcpitemcurve_parentplotinitialized_isbase = false;
            QCPItemCurve::parentPlotInitialized(parentPlot);
        } else if (qcpitemcurve_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpitemcurve_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPItemCurve::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpitemcurve_mousepressevent_isbase) {
            qcpitemcurve_mousepressevent_isbase = false;
            QCPItemCurve::mousePressEvent(event, details);
        } else if (qcpitemcurve_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpitemcurve_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemCurve::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpitemcurve_mousemoveevent_isbase) {
            qcpitemcurve_mousemoveevent_isbase = false;
            QCPItemCurve::mouseMoveEvent(event, startPos);
        } else if (qcpitemcurve_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpitemcurve_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemCurve::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpitemcurve_mousereleaseevent_isbase) {
            qcpitemcurve_mousereleaseevent_isbase = false;
            QCPItemCurve::mouseReleaseEvent(event, startPos);
        } else if (qcpitemcurve_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpitemcurve_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemCurve::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpitemcurve_mousedoubleclickevent_isbase) {
            qcpitemcurve_mousedoubleclickevent_isbase = false;
            QCPItemCurve::mouseDoubleClickEvent(event, details);
        } else if (qcpitemcurve_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpitemcurve_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemCurve::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcpitemcurve_wheelevent_isbase) {
            qcpitemcurve_wheelevent_isbase = false;
            QCPItemCurve::wheelEvent(event);
        } else if (qcpitemcurve_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcpitemcurve_wheelevent_callback(this, cbval1);
        } else {
            QCPItemCurve::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpitemcurve_event_isbase) {
            qcpitemcurve_event_isbase = false;
            return QCPItemCurve::event(event);
        } else if (qcpitemcurve_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpitemcurve_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemCurve::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpitemcurve_eventfilter_isbase) {
            qcpitemcurve_eventfilter_isbase = false;
            return QCPItemCurve::eventFilter(watched, event);
        } else if (qcpitemcurve_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpitemcurve_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemCurve::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpitemcurve_timerevent_isbase) {
            qcpitemcurve_timerevent_isbase = false;
            QCPItemCurve::timerEvent(event);
        } else if (qcpitemcurve_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpitemcurve_timerevent_callback(this, cbval1);
        } else {
            QCPItemCurve::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpitemcurve_childevent_isbase) {
            qcpitemcurve_childevent_isbase = false;
            QCPItemCurve::childEvent(event);
        } else if (qcpitemcurve_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpitemcurve_childevent_callback(this, cbval1);
        } else {
            QCPItemCurve::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpitemcurve_customevent_isbase) {
            qcpitemcurve_customevent_isbase = false;
            QCPItemCurve::customEvent(event);
        } else if (qcpitemcurve_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpitemcurve_customevent_callback(this, cbval1);
        } else {
            QCPItemCurve::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpitemcurve_connectnotify_isbase) {
            qcpitemcurve_connectnotify_isbase = false;
            QCPItemCurve::connectNotify(signal);
        } else if (qcpitemcurve_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpitemcurve_connectnotify_callback(this, cbval1);
        } else {
            QCPItemCurve::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpitemcurve_disconnectnotify_isbase) {
            qcpitemcurve_disconnectnotify_isbase = false;
            QCPItemCurve::disconnectNotify(signal);
        } else if (qcpitemcurve_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpitemcurve_disconnectnotify_callback(this, cbval1);
        } else {
            QCPItemCurve::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    QPen mainPen() const {
        if (qcpitemcurve_mainpen_isbase) {
            qcpitemcurve_mainpen_isbase = false;
            return QCPItemCurve::mainPen();
        } else if (qcpitemcurve_mainpen_callback != nullptr) {
            QPen* callback_ret = qcpitemcurve_mainpen_callback();
            return *callback_ret;
        } else {
            return QCPItemCurve::mainPen();
        }
    }

    // Virtual method for C ABI access and custom callback
    double rectDistance(const QRectF& rect, const QPointF& pos, bool filledRect) const {
        if (qcpitemcurve_rectdistance_isbase) {
            qcpitemcurve_rectdistance_isbase = false;
            return QCPItemCurve::rectDistance(rect, pos, filledRect);
        } else if (qcpitemcurve_rectdistance_callback != nullptr) {
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval1 = const_cast<QRectF*>(&rect_ret);
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&pos_ret);
            bool cbval3 = filledRect;

            double callback_ret = qcpitemcurve_rectdistance_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPItemCurve::rectDistance(rect, pos, filledRect);
        }
    }

    // Virtual method for C ABI access and custom callback
    QCPItemPosition* createPosition(const QString& name) {
        if (qcpitemcurve_createposition_isbase) {
            qcpitemcurve_createposition_isbase = false;
            return QCPItemCurve::createPosition(name);
        } else if (qcpitemcurve_createposition_callback != nullptr) {
            const QString name_ret = name;
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray name_b = name_ret.toUtf8();
            libqt_string name_str;
            name_str.len = name_b.length();
            name_str.data = static_cast<const char*>(malloc(name_str.len + 1));
            memcpy((void*)name_str.data, name_b.data(), name_str.len);
            ((char*)name_str.data)[name_str.len] = '\0';
            libqt_string cbval1 = name_str;

            QCPItemPosition* callback_ret = qcpitemcurve_createposition_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemCurve::createPosition(name);
        }
    }

    // Virtual method for C ABI access and custom callback
    QCPItemAnchor* createAnchor(const QString& name, int anchorId) {
        if (qcpitemcurve_createanchor_isbase) {
            qcpitemcurve_createanchor_isbase = false;
            return QCPItemCurve::createAnchor(name, anchorId);
        } else if (qcpitemcurve_createanchor_callback != nullptr) {
            const QString name_ret = name;
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray name_b = name_ret.toUtf8();
            libqt_string name_str;
            name_str.len = name_b.length();
            name_str.data = static_cast<const char*>(malloc(name_str.len + 1));
            memcpy((void*)name_str.data, name_b.data(), name_str.len);
            ((char*)name_str.data)[name_str.len] = '\0';
            libqt_string cbval1 = name_str;
            int cbval2 = anchorId;

            QCPItemAnchor* callback_ret = qcpitemcurve_createanchor_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemCurve::createAnchor(name, anchorId);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcpitemcurve_initializeparentplot_isbase) {
            qcpitemcurve_initializeparentplot_isbase = false;
            QCPItemCurve::initializeParentPlot(parentPlot);
        } else if (qcpitemcurve_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpitemcurve_initializeparentplot_callback(this, cbval1);
        } else {
            QCPItemCurve::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcpitemcurve_setparentlayerable_isbase) {
            qcpitemcurve_setparentlayerable_isbase = false;
            QCPItemCurve::setParentLayerable(parentLayerable);
        } else if (qcpitemcurve_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcpitemcurve_setparentlayerable_callback(this, cbval1);
        } else {
            QCPItemCurve::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcpitemcurve_movetolayer_isbase) {
            qcpitemcurve_movetolayer_isbase = false;
            return QCPItemCurve::moveToLayer(layer, prepend);
        } else if (qcpitemcurve_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcpitemcurve_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemCurve::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcpitemcurve_applyantialiasinghint_isbase) {
            qcpitemcurve_applyantialiasinghint_isbase = false;
            QCPItemCurve::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcpitemcurve_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcpitemcurve_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPItemCurve::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpitemcurve_sender_isbase) {
            qcpitemcurve_sender_isbase = false;
            return QCPItemCurve::sender();
        } else if (qcpitemcurve_sender_callback != nullptr) {
            QObject* callback_ret = qcpitemcurve_sender_callback();
            return callback_ret;
        } else {
            return QCPItemCurve::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpitemcurve_sendersignalindex_isbase) {
            qcpitemcurve_sendersignalindex_isbase = false;
            return QCPItemCurve::senderSignalIndex();
        } else if (qcpitemcurve_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpitemcurve_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemCurve::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpitemcurve_receivers_isbase) {
            qcpitemcurve_receivers_isbase = false;
            return QCPItemCurve::receivers(signal);
        } else if (qcpitemcurve_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpitemcurve_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemCurve::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpitemcurve_issignalconnected_isbase) {
            qcpitemcurve_issignalconnected_isbase = false;
            return QCPItemCurve::isSignalConnected(signal);
        } else if (qcpitemcurve_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpitemcurve_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemCurve::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPItemCurve_Draw(QCPItemCurve* self, QCPPainter* painter);
    friend void QCPItemCurve_QBaseDraw(QCPItemCurve* self, QCPPainter* painter);
    friend int QCPItemCurve_SelectionCategory(const QCPItemCurve* self);
    friend int QCPItemCurve_QBaseSelectionCategory(const QCPItemCurve* self);
    friend QRect* QCPItemCurve_ClipRect(const QCPItemCurve* self);
    friend QRect* QCPItemCurve_QBaseClipRect(const QCPItemCurve* self);
    friend void QCPItemCurve_ApplyDefaultAntialiasingHint(const QCPItemCurve* self, QCPPainter* painter);
    friend void QCPItemCurve_QBaseApplyDefaultAntialiasingHint(const QCPItemCurve* self, QCPPainter* painter);
    friend void QCPItemCurve_SelectEvent(QCPItemCurve* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPItemCurve_QBaseSelectEvent(QCPItemCurve* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPItemCurve_DeselectEvent(QCPItemCurve* self, bool* selectionStateChanged);
    friend void QCPItemCurve_QBaseDeselectEvent(QCPItemCurve* self, bool* selectionStateChanged);
    friend QPointF* QCPItemCurve_AnchorPixelPosition(const QCPItemCurve* self, int anchorId);
    friend QPointF* QCPItemCurve_QBaseAnchorPixelPosition(const QCPItemCurve* self, int anchorId);
    friend void QCPItemCurve_ParentPlotInitialized(QCPItemCurve* self, QCustomPlot* parentPlot);
    friend void QCPItemCurve_QBaseParentPlotInitialized(QCPItemCurve* self, QCustomPlot* parentPlot);
    friend void QCPItemCurve_MousePressEvent(QCPItemCurve* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemCurve_QBaseMousePressEvent(QCPItemCurve* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemCurve_MouseMoveEvent(QCPItemCurve* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemCurve_QBaseMouseMoveEvent(QCPItemCurve* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemCurve_MouseReleaseEvent(QCPItemCurve* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemCurve_QBaseMouseReleaseEvent(QCPItemCurve* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemCurve_MouseDoubleClickEvent(QCPItemCurve* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemCurve_QBaseMouseDoubleClickEvent(QCPItemCurve* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemCurve_WheelEvent(QCPItemCurve* self, QWheelEvent* event);
    friend void QCPItemCurve_QBaseWheelEvent(QCPItemCurve* self, QWheelEvent* event);
    friend void QCPItemCurve_TimerEvent(QCPItemCurve* self, QTimerEvent* event);
    friend void QCPItemCurve_QBaseTimerEvent(QCPItemCurve* self, QTimerEvent* event);
    friend void QCPItemCurve_ChildEvent(QCPItemCurve* self, QChildEvent* event);
    friend void QCPItemCurve_QBaseChildEvent(QCPItemCurve* self, QChildEvent* event);
    friend void QCPItemCurve_CustomEvent(QCPItemCurve* self, QEvent* event);
    friend void QCPItemCurve_QBaseCustomEvent(QCPItemCurve* self, QEvent* event);
    friend void QCPItemCurve_ConnectNotify(QCPItemCurve* self, const QMetaMethod* signal);
    friend void QCPItemCurve_QBaseConnectNotify(QCPItemCurve* self, const QMetaMethod* signal);
    friend void QCPItemCurve_DisconnectNotify(QCPItemCurve* self, const QMetaMethod* signal);
    friend void QCPItemCurve_QBaseDisconnectNotify(QCPItemCurve* self, const QMetaMethod* signal);
    friend QPen* QCPItemCurve_MainPen(const QCPItemCurve* self);
    friend QPen* QCPItemCurve_QBaseMainPen(const QCPItemCurve* self);
    friend double QCPItemCurve_RectDistance(const QCPItemCurve* self, const QRectF* rect, const QPointF* pos, bool filledRect);
    friend double QCPItemCurve_QBaseRectDistance(const QCPItemCurve* self, const QRectF* rect, const QPointF* pos, bool filledRect);
    friend QCPItemPosition* QCPItemCurve_CreatePosition(QCPItemCurve* self, const libqt_string name);
    friend QCPItemPosition* QCPItemCurve_QBaseCreatePosition(QCPItemCurve* self, const libqt_string name);
    friend QCPItemAnchor* QCPItemCurve_CreateAnchor(QCPItemCurve* self, const libqt_string name, int anchorId);
    friend QCPItemAnchor* QCPItemCurve_QBaseCreateAnchor(QCPItemCurve* self, const libqt_string name, int anchorId);
    friend void QCPItemCurve_InitializeParentPlot(QCPItemCurve* self, QCustomPlot* parentPlot);
    friend void QCPItemCurve_QBaseInitializeParentPlot(QCPItemCurve* self, QCustomPlot* parentPlot);
    friend void QCPItemCurve_SetParentLayerable(QCPItemCurve* self, QCPLayerable* parentLayerable);
    friend void QCPItemCurve_QBaseSetParentLayerable(QCPItemCurve* self, QCPLayerable* parentLayerable);
    friend bool QCPItemCurve_MoveToLayer(QCPItemCurve* self, QCPLayer* layer, bool prepend);
    friend bool QCPItemCurve_QBaseMoveToLayer(QCPItemCurve* self, QCPLayer* layer, bool prepend);
    friend void QCPItemCurve_ApplyAntialiasingHint(const QCPItemCurve* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPItemCurve_QBaseApplyAntialiasingHint(const QCPItemCurve* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPItemCurve_Sender(const QCPItemCurve* self);
    friend QObject* QCPItemCurve_QBaseSender(const QCPItemCurve* self);
    friend int QCPItemCurve_SenderSignalIndex(const QCPItemCurve* self);
    friend int QCPItemCurve_QBaseSenderSignalIndex(const QCPItemCurve* self);
    friend int QCPItemCurve_Receivers(const QCPItemCurve* self, const char* signal);
    friend int QCPItemCurve_QBaseReceivers(const QCPItemCurve* self, const char* signal);
    friend bool QCPItemCurve_IsSignalConnected(const QCPItemCurve* self, const QMetaMethod* signal);
    friend bool QCPItemCurve_QBaseIsSignalConnected(const QCPItemCurve* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPItemRect so that we can call protected methods
class VirtualQCPItemRect final : public QCPItemRect {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPItemRect = true;

    // Virtual class public types (including callbacks)
    using QCPItemRect::AnchorIndex;
    using QCPItemRect_Metacall_Callback = int (*)(QCPItemRect*, int, int, void**);
    using QCPItemRect_SelectTest_Callback = double (*)(const QCPItemRect*, QPointF*, bool, QVariant*);
    using QCPItemRect_Draw_Callback = void (*)(QCPItemRect*, QCPPainter*);
    using QCPItemRect_AnchorPixelPosition_Callback = QPointF* (*)(const QCPItemRect*, int);
    using QCPItemRect_SelectionCategory_Callback = int (*)();
    using QCPItemRect_ClipRect_Callback = QRect* (*)();
    using QCPItemRect_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPItemRect*, QCPPainter*);
    using QCPItemRect_SelectEvent_Callback = void (*)(QCPItemRect*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPItemRect_DeselectEvent_Callback = void (*)(QCPItemRect*, bool*);
    using QCPItemRect_ParentPlotInitialized_Callback = void (*)(QCPItemRect*, QCustomPlot*);
    using QCPItemRect_MousePressEvent_Callback = void (*)(QCPItemRect*, QMouseEvent*, QVariant*);
    using QCPItemRect_MouseMoveEvent_Callback = void (*)(QCPItemRect*, QMouseEvent*, QPointF*);
    using QCPItemRect_MouseReleaseEvent_Callback = void (*)(QCPItemRect*, QMouseEvent*, QPointF*);
    using QCPItemRect_MouseDoubleClickEvent_Callback = void (*)(QCPItemRect*, QMouseEvent*, QVariant*);
    using QCPItemRect_WheelEvent_Callback = void (*)(QCPItemRect*, QWheelEvent*);
    using QCPItemRect_Event_Callback = bool (*)(QCPItemRect*, QEvent*);
    using QCPItemRect_EventFilter_Callback = bool (*)(QCPItemRect*, QObject*, QEvent*);
    using QCPItemRect_TimerEvent_Callback = void (*)(QCPItemRect*, QTimerEvent*);
    using QCPItemRect_ChildEvent_Callback = void (*)(QCPItemRect*, QChildEvent*);
    using QCPItemRect_CustomEvent_Callback = void (*)(QCPItemRect*, QEvent*);
    using QCPItemRect_ConnectNotify_Callback = void (*)(QCPItemRect*, QMetaMethod*);
    using QCPItemRect_DisconnectNotify_Callback = void (*)(QCPItemRect*, QMetaMethod*);
    using QCPItemRect_MainPen_Callback = QPen* (*)();
    using QCPItemRect_MainBrush_Callback = QBrush* (*)();
    using QCPItemRect_RectDistance_Callback = double (*)(const QCPItemRect*, QRectF*, QPointF*, bool);
    using QCPItemRect_CreatePosition_Callback = QCPItemPosition* (*)(QCPItemRect*, libqt_string);
    using QCPItemRect_CreateAnchor_Callback = QCPItemAnchor* (*)(QCPItemRect*, libqt_string, int);
    using QCPItemRect_InitializeParentPlot_Callback = void (*)(QCPItemRect*, QCustomPlot*);
    using QCPItemRect_SetParentLayerable_Callback = void (*)(QCPItemRect*, QCPLayerable*);
    using QCPItemRect_MoveToLayer_Callback = bool (*)(QCPItemRect*, QCPLayer*, bool);
    using QCPItemRect_ApplyAntialiasingHint_Callback = void (*)(const QCPItemRect*, QCPPainter*, bool, int);
    using QCPItemRect_Sender_Callback = QObject* (*)();
    using QCPItemRect_SenderSignalIndex_Callback = int (*)();
    using QCPItemRect_Receivers_Callback = int (*)(const QCPItemRect*, const char*);
    using QCPItemRect_IsSignalConnected_Callback = bool (*)(const QCPItemRect*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPItemRect_Metacall_Callback qcpitemrect_metacall_callback = nullptr;
    QCPItemRect_SelectTest_Callback qcpitemrect_selecttest_callback = nullptr;
    QCPItemRect_Draw_Callback qcpitemrect_draw_callback = nullptr;
    QCPItemRect_AnchorPixelPosition_Callback qcpitemrect_anchorpixelposition_callback = nullptr;
    QCPItemRect_SelectionCategory_Callback qcpitemrect_selectioncategory_callback = nullptr;
    QCPItemRect_ClipRect_Callback qcpitemrect_cliprect_callback = nullptr;
    QCPItemRect_ApplyDefaultAntialiasingHint_Callback qcpitemrect_applydefaultantialiasinghint_callback = nullptr;
    QCPItemRect_SelectEvent_Callback qcpitemrect_selectevent_callback = nullptr;
    QCPItemRect_DeselectEvent_Callback qcpitemrect_deselectevent_callback = nullptr;
    QCPItemRect_ParentPlotInitialized_Callback qcpitemrect_parentplotinitialized_callback = nullptr;
    QCPItemRect_MousePressEvent_Callback qcpitemrect_mousepressevent_callback = nullptr;
    QCPItemRect_MouseMoveEvent_Callback qcpitemrect_mousemoveevent_callback = nullptr;
    QCPItemRect_MouseReleaseEvent_Callback qcpitemrect_mousereleaseevent_callback = nullptr;
    QCPItemRect_MouseDoubleClickEvent_Callback qcpitemrect_mousedoubleclickevent_callback = nullptr;
    QCPItemRect_WheelEvent_Callback qcpitemrect_wheelevent_callback = nullptr;
    QCPItemRect_Event_Callback qcpitemrect_event_callback = nullptr;
    QCPItemRect_EventFilter_Callback qcpitemrect_eventfilter_callback = nullptr;
    QCPItemRect_TimerEvent_Callback qcpitemrect_timerevent_callback = nullptr;
    QCPItemRect_ChildEvent_Callback qcpitemrect_childevent_callback = nullptr;
    QCPItemRect_CustomEvent_Callback qcpitemrect_customevent_callback = nullptr;
    QCPItemRect_ConnectNotify_Callback qcpitemrect_connectnotify_callback = nullptr;
    QCPItemRect_DisconnectNotify_Callback qcpitemrect_disconnectnotify_callback = nullptr;
    QCPItemRect_MainPen_Callback qcpitemrect_mainpen_callback = nullptr;
    QCPItemRect_MainBrush_Callback qcpitemrect_mainbrush_callback = nullptr;
    QCPItemRect_RectDistance_Callback qcpitemrect_rectdistance_callback = nullptr;
    QCPItemRect_CreatePosition_Callback qcpitemrect_createposition_callback = nullptr;
    QCPItemRect_CreateAnchor_Callback qcpitemrect_createanchor_callback = nullptr;
    QCPItemRect_InitializeParentPlot_Callback qcpitemrect_initializeparentplot_callback = nullptr;
    QCPItemRect_SetParentLayerable_Callback qcpitemrect_setparentlayerable_callback = nullptr;
    QCPItemRect_MoveToLayer_Callback qcpitemrect_movetolayer_callback = nullptr;
    QCPItemRect_ApplyAntialiasingHint_Callback qcpitemrect_applyantialiasinghint_callback = nullptr;
    QCPItemRect_Sender_Callback qcpitemrect_sender_callback = nullptr;
    QCPItemRect_SenderSignalIndex_Callback qcpitemrect_sendersignalindex_callback = nullptr;
    QCPItemRect_Receivers_Callback qcpitemrect_receivers_callback = nullptr;
    QCPItemRect_IsSignalConnected_Callback qcpitemrect_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpitemrect_metacall_isbase = false;
    mutable bool qcpitemrect_selecttest_isbase = false;
    mutable bool qcpitemrect_draw_isbase = false;
    mutable bool qcpitemrect_anchorpixelposition_isbase = false;
    mutable bool qcpitemrect_selectioncategory_isbase = false;
    mutable bool qcpitemrect_cliprect_isbase = false;
    mutable bool qcpitemrect_applydefaultantialiasinghint_isbase = false;
    mutable bool qcpitemrect_selectevent_isbase = false;
    mutable bool qcpitemrect_deselectevent_isbase = false;
    mutable bool qcpitemrect_parentplotinitialized_isbase = false;
    mutable bool qcpitemrect_mousepressevent_isbase = false;
    mutable bool qcpitemrect_mousemoveevent_isbase = false;
    mutable bool qcpitemrect_mousereleaseevent_isbase = false;
    mutable bool qcpitemrect_mousedoubleclickevent_isbase = false;
    mutable bool qcpitemrect_wheelevent_isbase = false;
    mutable bool qcpitemrect_event_isbase = false;
    mutable bool qcpitemrect_eventfilter_isbase = false;
    mutable bool qcpitemrect_timerevent_isbase = false;
    mutable bool qcpitemrect_childevent_isbase = false;
    mutable bool qcpitemrect_customevent_isbase = false;
    mutable bool qcpitemrect_connectnotify_isbase = false;
    mutable bool qcpitemrect_disconnectnotify_isbase = false;
    mutable bool qcpitemrect_mainpen_isbase = false;
    mutable bool qcpitemrect_mainbrush_isbase = false;
    mutable bool qcpitemrect_rectdistance_isbase = false;
    mutable bool qcpitemrect_createposition_isbase = false;
    mutable bool qcpitemrect_createanchor_isbase = false;
    mutable bool qcpitemrect_initializeparentplot_isbase = false;
    mutable bool qcpitemrect_setparentlayerable_isbase = false;
    mutable bool qcpitemrect_movetolayer_isbase = false;
    mutable bool qcpitemrect_applyantialiasinghint_isbase = false;
    mutable bool qcpitemrect_sender_isbase = false;
    mutable bool qcpitemrect_sendersignalindex_isbase = false;
    mutable bool qcpitemrect_receivers_isbase = false;
    mutable bool qcpitemrect_issignalconnected_isbase = false;

  public:
    VirtualQCPItemRect(QCustomPlot* parentPlot) : QCPItemRect(parentPlot) {};

    ~VirtualQCPItemRect() {
        qcpitemrect_metacall_callback = nullptr;
        qcpitemrect_selecttest_callback = nullptr;
        qcpitemrect_draw_callback = nullptr;
        qcpitemrect_anchorpixelposition_callback = nullptr;
        qcpitemrect_selectioncategory_callback = nullptr;
        qcpitemrect_cliprect_callback = nullptr;
        qcpitemrect_applydefaultantialiasinghint_callback = nullptr;
        qcpitemrect_selectevent_callback = nullptr;
        qcpitemrect_deselectevent_callback = nullptr;
        qcpitemrect_parentplotinitialized_callback = nullptr;
        qcpitemrect_mousepressevent_callback = nullptr;
        qcpitemrect_mousemoveevent_callback = nullptr;
        qcpitemrect_mousereleaseevent_callback = nullptr;
        qcpitemrect_mousedoubleclickevent_callback = nullptr;
        qcpitemrect_wheelevent_callback = nullptr;
        qcpitemrect_event_callback = nullptr;
        qcpitemrect_eventfilter_callback = nullptr;
        qcpitemrect_timerevent_callback = nullptr;
        qcpitemrect_childevent_callback = nullptr;
        qcpitemrect_customevent_callback = nullptr;
        qcpitemrect_connectnotify_callback = nullptr;
        qcpitemrect_disconnectnotify_callback = nullptr;
        qcpitemrect_mainpen_callback = nullptr;
        qcpitemrect_mainbrush_callback = nullptr;
        qcpitemrect_rectdistance_callback = nullptr;
        qcpitemrect_createposition_callback = nullptr;
        qcpitemrect_createanchor_callback = nullptr;
        qcpitemrect_initializeparentplot_callback = nullptr;
        qcpitemrect_setparentlayerable_callback = nullptr;
        qcpitemrect_movetolayer_callback = nullptr;
        qcpitemrect_applyantialiasinghint_callback = nullptr;
        qcpitemrect_sender_callback = nullptr;
        qcpitemrect_sendersignalindex_callback = nullptr;
        qcpitemrect_receivers_callback = nullptr;
        qcpitemrect_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPItemRect_Metacall_Callback(QCPItemRect_Metacall_Callback cb) { qcpitemrect_metacall_callback = cb; }
    inline void setQCPItemRect_SelectTest_Callback(QCPItemRect_SelectTest_Callback cb) { qcpitemrect_selecttest_callback = cb; }
    inline void setQCPItemRect_Draw_Callback(QCPItemRect_Draw_Callback cb) { qcpitemrect_draw_callback = cb; }
    inline void setQCPItemRect_AnchorPixelPosition_Callback(QCPItemRect_AnchorPixelPosition_Callback cb) { qcpitemrect_anchorpixelposition_callback = cb; }
    inline void setQCPItemRect_SelectionCategory_Callback(QCPItemRect_SelectionCategory_Callback cb) { qcpitemrect_selectioncategory_callback = cb; }
    inline void setQCPItemRect_ClipRect_Callback(QCPItemRect_ClipRect_Callback cb) { qcpitemrect_cliprect_callback = cb; }
    inline void setQCPItemRect_ApplyDefaultAntialiasingHint_Callback(QCPItemRect_ApplyDefaultAntialiasingHint_Callback cb) { qcpitemrect_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPItemRect_SelectEvent_Callback(QCPItemRect_SelectEvent_Callback cb) { qcpitemrect_selectevent_callback = cb; }
    inline void setQCPItemRect_DeselectEvent_Callback(QCPItemRect_DeselectEvent_Callback cb) { qcpitemrect_deselectevent_callback = cb; }
    inline void setQCPItemRect_ParentPlotInitialized_Callback(QCPItemRect_ParentPlotInitialized_Callback cb) { qcpitemrect_parentplotinitialized_callback = cb; }
    inline void setQCPItemRect_MousePressEvent_Callback(QCPItemRect_MousePressEvent_Callback cb) { qcpitemrect_mousepressevent_callback = cb; }
    inline void setQCPItemRect_MouseMoveEvent_Callback(QCPItemRect_MouseMoveEvent_Callback cb) { qcpitemrect_mousemoveevent_callback = cb; }
    inline void setQCPItemRect_MouseReleaseEvent_Callback(QCPItemRect_MouseReleaseEvent_Callback cb) { qcpitemrect_mousereleaseevent_callback = cb; }
    inline void setQCPItemRect_MouseDoubleClickEvent_Callback(QCPItemRect_MouseDoubleClickEvent_Callback cb) { qcpitemrect_mousedoubleclickevent_callback = cb; }
    inline void setQCPItemRect_WheelEvent_Callback(QCPItemRect_WheelEvent_Callback cb) { qcpitemrect_wheelevent_callback = cb; }
    inline void setQCPItemRect_Event_Callback(QCPItemRect_Event_Callback cb) { qcpitemrect_event_callback = cb; }
    inline void setQCPItemRect_EventFilter_Callback(QCPItemRect_EventFilter_Callback cb) { qcpitemrect_eventfilter_callback = cb; }
    inline void setQCPItemRect_TimerEvent_Callback(QCPItemRect_TimerEvent_Callback cb) { qcpitemrect_timerevent_callback = cb; }
    inline void setQCPItemRect_ChildEvent_Callback(QCPItemRect_ChildEvent_Callback cb) { qcpitemrect_childevent_callback = cb; }
    inline void setQCPItemRect_CustomEvent_Callback(QCPItemRect_CustomEvent_Callback cb) { qcpitemrect_customevent_callback = cb; }
    inline void setQCPItemRect_ConnectNotify_Callback(QCPItemRect_ConnectNotify_Callback cb) { qcpitemrect_connectnotify_callback = cb; }
    inline void setQCPItemRect_DisconnectNotify_Callback(QCPItemRect_DisconnectNotify_Callback cb) { qcpitemrect_disconnectnotify_callback = cb; }
    inline void setQCPItemRect_MainPen_Callback(QCPItemRect_MainPen_Callback cb) { qcpitemrect_mainpen_callback = cb; }
    inline void setQCPItemRect_MainBrush_Callback(QCPItemRect_MainBrush_Callback cb) { qcpitemrect_mainbrush_callback = cb; }
    inline void setQCPItemRect_RectDistance_Callback(QCPItemRect_RectDistance_Callback cb) { qcpitemrect_rectdistance_callback = cb; }
    inline void setQCPItemRect_CreatePosition_Callback(QCPItemRect_CreatePosition_Callback cb) { qcpitemrect_createposition_callback = cb; }
    inline void setQCPItemRect_CreateAnchor_Callback(QCPItemRect_CreateAnchor_Callback cb) { qcpitemrect_createanchor_callback = cb; }
    inline void setQCPItemRect_InitializeParentPlot_Callback(QCPItemRect_InitializeParentPlot_Callback cb) { qcpitemrect_initializeparentplot_callback = cb; }
    inline void setQCPItemRect_SetParentLayerable_Callback(QCPItemRect_SetParentLayerable_Callback cb) { qcpitemrect_setparentlayerable_callback = cb; }
    inline void setQCPItemRect_MoveToLayer_Callback(QCPItemRect_MoveToLayer_Callback cb) { qcpitemrect_movetolayer_callback = cb; }
    inline void setQCPItemRect_ApplyAntialiasingHint_Callback(QCPItemRect_ApplyAntialiasingHint_Callback cb) { qcpitemrect_applyantialiasinghint_callback = cb; }
    inline void setQCPItemRect_Sender_Callback(QCPItemRect_Sender_Callback cb) { qcpitemrect_sender_callback = cb; }
    inline void setQCPItemRect_SenderSignalIndex_Callback(QCPItemRect_SenderSignalIndex_Callback cb) { qcpitemrect_sendersignalindex_callback = cb; }
    inline void setQCPItemRect_Receivers_Callback(QCPItemRect_Receivers_Callback cb) { qcpitemrect_receivers_callback = cb; }
    inline void setQCPItemRect_IsSignalConnected_Callback(QCPItemRect_IsSignalConnected_Callback cb) { qcpitemrect_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPItemRect_Metacall_IsBase(bool value) const { qcpitemrect_metacall_isbase = value; }
    inline void setQCPItemRect_SelectTest_IsBase(bool value) const { qcpitemrect_selecttest_isbase = value; }
    inline void setQCPItemRect_Draw_IsBase(bool value) const { qcpitemrect_draw_isbase = value; }
    inline void setQCPItemRect_AnchorPixelPosition_IsBase(bool value) const { qcpitemrect_anchorpixelposition_isbase = value; }
    inline void setQCPItemRect_SelectionCategory_IsBase(bool value) const { qcpitemrect_selectioncategory_isbase = value; }
    inline void setQCPItemRect_ClipRect_IsBase(bool value) const { qcpitemrect_cliprect_isbase = value; }
    inline void setQCPItemRect_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcpitemrect_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPItemRect_SelectEvent_IsBase(bool value) const { qcpitemrect_selectevent_isbase = value; }
    inline void setQCPItemRect_DeselectEvent_IsBase(bool value) const { qcpitemrect_deselectevent_isbase = value; }
    inline void setQCPItemRect_ParentPlotInitialized_IsBase(bool value) const { qcpitemrect_parentplotinitialized_isbase = value; }
    inline void setQCPItemRect_MousePressEvent_IsBase(bool value) const { qcpitemrect_mousepressevent_isbase = value; }
    inline void setQCPItemRect_MouseMoveEvent_IsBase(bool value) const { qcpitemrect_mousemoveevent_isbase = value; }
    inline void setQCPItemRect_MouseReleaseEvent_IsBase(bool value) const { qcpitemrect_mousereleaseevent_isbase = value; }
    inline void setQCPItemRect_MouseDoubleClickEvent_IsBase(bool value) const { qcpitemrect_mousedoubleclickevent_isbase = value; }
    inline void setQCPItemRect_WheelEvent_IsBase(bool value) const { qcpitemrect_wheelevent_isbase = value; }
    inline void setQCPItemRect_Event_IsBase(bool value) const { qcpitemrect_event_isbase = value; }
    inline void setQCPItemRect_EventFilter_IsBase(bool value) const { qcpitemrect_eventfilter_isbase = value; }
    inline void setQCPItemRect_TimerEvent_IsBase(bool value) const { qcpitemrect_timerevent_isbase = value; }
    inline void setQCPItemRect_ChildEvent_IsBase(bool value) const { qcpitemrect_childevent_isbase = value; }
    inline void setQCPItemRect_CustomEvent_IsBase(bool value) const { qcpitemrect_customevent_isbase = value; }
    inline void setQCPItemRect_ConnectNotify_IsBase(bool value) const { qcpitemrect_connectnotify_isbase = value; }
    inline void setQCPItemRect_DisconnectNotify_IsBase(bool value) const { qcpitemrect_disconnectnotify_isbase = value; }
    inline void setQCPItemRect_MainPen_IsBase(bool value) const { qcpitemrect_mainpen_isbase = value; }
    inline void setQCPItemRect_MainBrush_IsBase(bool value) const { qcpitemrect_mainbrush_isbase = value; }
    inline void setQCPItemRect_RectDistance_IsBase(bool value) const { qcpitemrect_rectdistance_isbase = value; }
    inline void setQCPItemRect_CreatePosition_IsBase(bool value) const { qcpitemrect_createposition_isbase = value; }
    inline void setQCPItemRect_CreateAnchor_IsBase(bool value) const { qcpitemrect_createanchor_isbase = value; }
    inline void setQCPItemRect_InitializeParentPlot_IsBase(bool value) const { qcpitemrect_initializeparentplot_isbase = value; }
    inline void setQCPItemRect_SetParentLayerable_IsBase(bool value) const { qcpitemrect_setparentlayerable_isbase = value; }
    inline void setQCPItemRect_MoveToLayer_IsBase(bool value) const { qcpitemrect_movetolayer_isbase = value; }
    inline void setQCPItemRect_ApplyAntialiasingHint_IsBase(bool value) const { qcpitemrect_applyantialiasinghint_isbase = value; }
    inline void setQCPItemRect_Sender_IsBase(bool value) const { qcpitemrect_sender_isbase = value; }
    inline void setQCPItemRect_SenderSignalIndex_IsBase(bool value) const { qcpitemrect_sendersignalindex_isbase = value; }
    inline void setQCPItemRect_Receivers_IsBase(bool value) const { qcpitemrect_receivers_isbase = value; }
    inline void setQCPItemRect_IsSignalConnected_IsBase(bool value) const { qcpitemrect_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpitemrect_metacall_isbase) {
            qcpitemrect_metacall_isbase = false;
            return QCPItemRect::qt_metacall(param1, param2, param3);
        } else if (qcpitemrect_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpitemrect_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemRect::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcpitemrect_selecttest_isbase) {
            qcpitemrect_selecttest_isbase = false;
            return QCPItemRect::selectTest(pos, onlySelectable, details);
        } else if (qcpitemrect_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcpitemrect_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPItemRect::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcpitemrect_draw_isbase) {
            qcpitemrect_draw_isbase = false;
            QCPItemRect::draw(painter);
        } else if (qcpitemrect_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpitemrect_draw_callback(this, cbval1);
        } else {
            QCPItemRect::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QPointF anchorPixelPosition(int anchorId) const override {
        if (qcpitemrect_anchorpixelposition_isbase) {
            qcpitemrect_anchorpixelposition_isbase = false;
            return QCPItemRect::anchorPixelPosition(anchorId);
        } else if (qcpitemrect_anchorpixelposition_callback != nullptr) {
            int cbval1 = anchorId;

            QPointF* callback_ret = qcpitemrect_anchorpixelposition_callback(this, cbval1);
            return *callback_ret;
        } else {
            return QCPItemRect::anchorPixelPosition(anchorId);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcpitemrect_selectioncategory_isbase) {
            qcpitemrect_selectioncategory_isbase = false;
            return QCPItemRect::selectionCategory();
        } else if (qcpitemrect_selectioncategory_callback != nullptr) {
            int callback_ret = qcpitemrect_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPItemRect::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcpitemrect_cliprect_isbase) {
            qcpitemrect_cliprect_isbase = false;
            return QCPItemRect::clipRect();
        } else if (qcpitemrect_cliprect_callback != nullptr) {
            QRect* callback_ret = qcpitemrect_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPItemRect::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcpitemrect_applydefaultantialiasinghint_isbase) {
            qcpitemrect_applydefaultantialiasinghint_isbase = false;
            QCPItemRect::applyDefaultAntialiasingHint(painter);
        } else if (qcpitemrect_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpitemrect_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPItemRect::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcpitemrect_selectevent_isbase) {
            qcpitemrect_selectevent_isbase = false;
            QCPItemRect::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcpitemrect_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcpitemrect_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPItemRect::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcpitemrect_deselectevent_isbase) {
            qcpitemrect_deselectevent_isbase = false;
            QCPItemRect::deselectEvent(selectionStateChanged);
        } else if (qcpitemrect_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcpitemrect_deselectevent_callback(this, cbval1);
        } else {
            QCPItemRect::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcpitemrect_parentplotinitialized_isbase) {
            qcpitemrect_parentplotinitialized_isbase = false;
            QCPItemRect::parentPlotInitialized(parentPlot);
        } else if (qcpitemrect_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpitemrect_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPItemRect::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpitemrect_mousepressevent_isbase) {
            qcpitemrect_mousepressevent_isbase = false;
            QCPItemRect::mousePressEvent(event, details);
        } else if (qcpitemrect_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpitemrect_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemRect::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpitemrect_mousemoveevent_isbase) {
            qcpitemrect_mousemoveevent_isbase = false;
            QCPItemRect::mouseMoveEvent(event, startPos);
        } else if (qcpitemrect_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpitemrect_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemRect::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpitemrect_mousereleaseevent_isbase) {
            qcpitemrect_mousereleaseevent_isbase = false;
            QCPItemRect::mouseReleaseEvent(event, startPos);
        } else if (qcpitemrect_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpitemrect_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemRect::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpitemrect_mousedoubleclickevent_isbase) {
            qcpitemrect_mousedoubleclickevent_isbase = false;
            QCPItemRect::mouseDoubleClickEvent(event, details);
        } else if (qcpitemrect_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpitemrect_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemRect::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcpitemrect_wheelevent_isbase) {
            qcpitemrect_wheelevent_isbase = false;
            QCPItemRect::wheelEvent(event);
        } else if (qcpitemrect_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcpitemrect_wheelevent_callback(this, cbval1);
        } else {
            QCPItemRect::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpitemrect_event_isbase) {
            qcpitemrect_event_isbase = false;
            return QCPItemRect::event(event);
        } else if (qcpitemrect_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpitemrect_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemRect::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpitemrect_eventfilter_isbase) {
            qcpitemrect_eventfilter_isbase = false;
            return QCPItemRect::eventFilter(watched, event);
        } else if (qcpitemrect_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpitemrect_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemRect::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpitemrect_timerevent_isbase) {
            qcpitemrect_timerevent_isbase = false;
            QCPItemRect::timerEvent(event);
        } else if (qcpitemrect_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpitemrect_timerevent_callback(this, cbval1);
        } else {
            QCPItemRect::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpitemrect_childevent_isbase) {
            qcpitemrect_childevent_isbase = false;
            QCPItemRect::childEvent(event);
        } else if (qcpitemrect_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpitemrect_childevent_callback(this, cbval1);
        } else {
            QCPItemRect::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpitemrect_customevent_isbase) {
            qcpitemrect_customevent_isbase = false;
            QCPItemRect::customEvent(event);
        } else if (qcpitemrect_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpitemrect_customevent_callback(this, cbval1);
        } else {
            QCPItemRect::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpitemrect_connectnotify_isbase) {
            qcpitemrect_connectnotify_isbase = false;
            QCPItemRect::connectNotify(signal);
        } else if (qcpitemrect_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpitemrect_connectnotify_callback(this, cbval1);
        } else {
            QCPItemRect::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpitemrect_disconnectnotify_isbase) {
            qcpitemrect_disconnectnotify_isbase = false;
            QCPItemRect::disconnectNotify(signal);
        } else if (qcpitemrect_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpitemrect_disconnectnotify_callback(this, cbval1);
        } else {
            QCPItemRect::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    QPen mainPen() const {
        if (qcpitemrect_mainpen_isbase) {
            qcpitemrect_mainpen_isbase = false;
            return QCPItemRect::mainPen();
        } else if (qcpitemrect_mainpen_callback != nullptr) {
            QPen* callback_ret = qcpitemrect_mainpen_callback();
            return *callback_ret;
        } else {
            return QCPItemRect::mainPen();
        }
    }

    // Virtual method for C ABI access and custom callback
    QBrush mainBrush() const {
        if (qcpitemrect_mainbrush_isbase) {
            qcpitemrect_mainbrush_isbase = false;
            return QCPItemRect::mainBrush();
        } else if (qcpitemrect_mainbrush_callback != nullptr) {
            QBrush* callback_ret = qcpitemrect_mainbrush_callback();
            return *callback_ret;
        } else {
            return QCPItemRect::mainBrush();
        }
    }

    // Virtual method for C ABI access and custom callback
    double rectDistance(const QRectF& rect, const QPointF& pos, bool filledRect) const {
        if (qcpitemrect_rectdistance_isbase) {
            qcpitemrect_rectdistance_isbase = false;
            return QCPItemRect::rectDistance(rect, pos, filledRect);
        } else if (qcpitemrect_rectdistance_callback != nullptr) {
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval1 = const_cast<QRectF*>(&rect_ret);
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&pos_ret);
            bool cbval3 = filledRect;

            double callback_ret = qcpitemrect_rectdistance_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPItemRect::rectDistance(rect, pos, filledRect);
        }
    }

    // Virtual method for C ABI access and custom callback
    QCPItemPosition* createPosition(const QString& name) {
        if (qcpitemrect_createposition_isbase) {
            qcpitemrect_createposition_isbase = false;
            return QCPItemRect::createPosition(name);
        } else if (qcpitemrect_createposition_callback != nullptr) {
            const QString name_ret = name;
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray name_b = name_ret.toUtf8();
            libqt_string name_str;
            name_str.len = name_b.length();
            name_str.data = static_cast<const char*>(malloc(name_str.len + 1));
            memcpy((void*)name_str.data, name_b.data(), name_str.len);
            ((char*)name_str.data)[name_str.len] = '\0';
            libqt_string cbval1 = name_str;

            QCPItemPosition* callback_ret = qcpitemrect_createposition_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemRect::createPosition(name);
        }
    }

    // Virtual method for C ABI access and custom callback
    QCPItemAnchor* createAnchor(const QString& name, int anchorId) {
        if (qcpitemrect_createanchor_isbase) {
            qcpitemrect_createanchor_isbase = false;
            return QCPItemRect::createAnchor(name, anchorId);
        } else if (qcpitemrect_createanchor_callback != nullptr) {
            const QString name_ret = name;
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray name_b = name_ret.toUtf8();
            libqt_string name_str;
            name_str.len = name_b.length();
            name_str.data = static_cast<const char*>(malloc(name_str.len + 1));
            memcpy((void*)name_str.data, name_b.data(), name_str.len);
            ((char*)name_str.data)[name_str.len] = '\0';
            libqt_string cbval1 = name_str;
            int cbval2 = anchorId;

            QCPItemAnchor* callback_ret = qcpitemrect_createanchor_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemRect::createAnchor(name, anchorId);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcpitemrect_initializeparentplot_isbase) {
            qcpitemrect_initializeparentplot_isbase = false;
            QCPItemRect::initializeParentPlot(parentPlot);
        } else if (qcpitemrect_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpitemrect_initializeparentplot_callback(this, cbval1);
        } else {
            QCPItemRect::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcpitemrect_setparentlayerable_isbase) {
            qcpitemrect_setparentlayerable_isbase = false;
            QCPItemRect::setParentLayerable(parentLayerable);
        } else if (qcpitemrect_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcpitemrect_setparentlayerable_callback(this, cbval1);
        } else {
            QCPItemRect::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcpitemrect_movetolayer_isbase) {
            qcpitemrect_movetolayer_isbase = false;
            return QCPItemRect::moveToLayer(layer, prepend);
        } else if (qcpitemrect_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcpitemrect_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemRect::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcpitemrect_applyantialiasinghint_isbase) {
            qcpitemrect_applyantialiasinghint_isbase = false;
            QCPItemRect::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcpitemrect_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcpitemrect_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPItemRect::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpitemrect_sender_isbase) {
            qcpitemrect_sender_isbase = false;
            return QCPItemRect::sender();
        } else if (qcpitemrect_sender_callback != nullptr) {
            QObject* callback_ret = qcpitemrect_sender_callback();
            return callback_ret;
        } else {
            return QCPItemRect::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpitemrect_sendersignalindex_isbase) {
            qcpitemrect_sendersignalindex_isbase = false;
            return QCPItemRect::senderSignalIndex();
        } else if (qcpitemrect_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpitemrect_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemRect::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpitemrect_receivers_isbase) {
            qcpitemrect_receivers_isbase = false;
            return QCPItemRect::receivers(signal);
        } else if (qcpitemrect_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpitemrect_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemRect::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpitemrect_issignalconnected_isbase) {
            qcpitemrect_issignalconnected_isbase = false;
            return QCPItemRect::isSignalConnected(signal);
        } else if (qcpitemrect_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpitemrect_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemRect::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPItemRect_Draw(QCPItemRect* self, QCPPainter* painter);
    friend void QCPItemRect_QBaseDraw(QCPItemRect* self, QCPPainter* painter);
    friend QPointF* QCPItemRect_AnchorPixelPosition(const QCPItemRect* self, int anchorId);
    friend QPointF* QCPItemRect_QBaseAnchorPixelPosition(const QCPItemRect* self, int anchorId);
    friend int QCPItemRect_SelectionCategory(const QCPItemRect* self);
    friend int QCPItemRect_QBaseSelectionCategory(const QCPItemRect* self);
    friend QRect* QCPItemRect_ClipRect(const QCPItemRect* self);
    friend QRect* QCPItemRect_QBaseClipRect(const QCPItemRect* self);
    friend void QCPItemRect_ApplyDefaultAntialiasingHint(const QCPItemRect* self, QCPPainter* painter);
    friend void QCPItemRect_QBaseApplyDefaultAntialiasingHint(const QCPItemRect* self, QCPPainter* painter);
    friend void QCPItemRect_SelectEvent(QCPItemRect* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPItemRect_QBaseSelectEvent(QCPItemRect* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPItemRect_DeselectEvent(QCPItemRect* self, bool* selectionStateChanged);
    friend void QCPItemRect_QBaseDeselectEvent(QCPItemRect* self, bool* selectionStateChanged);
    friend void QCPItemRect_ParentPlotInitialized(QCPItemRect* self, QCustomPlot* parentPlot);
    friend void QCPItemRect_QBaseParentPlotInitialized(QCPItemRect* self, QCustomPlot* parentPlot);
    friend void QCPItemRect_MousePressEvent(QCPItemRect* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemRect_QBaseMousePressEvent(QCPItemRect* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemRect_MouseMoveEvent(QCPItemRect* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemRect_QBaseMouseMoveEvent(QCPItemRect* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemRect_MouseReleaseEvent(QCPItemRect* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemRect_QBaseMouseReleaseEvent(QCPItemRect* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemRect_MouseDoubleClickEvent(QCPItemRect* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemRect_QBaseMouseDoubleClickEvent(QCPItemRect* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemRect_WheelEvent(QCPItemRect* self, QWheelEvent* event);
    friend void QCPItemRect_QBaseWheelEvent(QCPItemRect* self, QWheelEvent* event);
    friend void QCPItemRect_TimerEvent(QCPItemRect* self, QTimerEvent* event);
    friend void QCPItemRect_QBaseTimerEvent(QCPItemRect* self, QTimerEvent* event);
    friend void QCPItemRect_ChildEvent(QCPItemRect* self, QChildEvent* event);
    friend void QCPItemRect_QBaseChildEvent(QCPItemRect* self, QChildEvent* event);
    friend void QCPItemRect_CustomEvent(QCPItemRect* self, QEvent* event);
    friend void QCPItemRect_QBaseCustomEvent(QCPItemRect* self, QEvent* event);
    friend void QCPItemRect_ConnectNotify(QCPItemRect* self, const QMetaMethod* signal);
    friend void QCPItemRect_QBaseConnectNotify(QCPItemRect* self, const QMetaMethod* signal);
    friend void QCPItemRect_DisconnectNotify(QCPItemRect* self, const QMetaMethod* signal);
    friend void QCPItemRect_QBaseDisconnectNotify(QCPItemRect* self, const QMetaMethod* signal);
    friend QPen* QCPItemRect_MainPen(const QCPItemRect* self);
    friend QPen* QCPItemRect_QBaseMainPen(const QCPItemRect* self);
    friend QBrush* QCPItemRect_MainBrush(const QCPItemRect* self);
    friend QBrush* QCPItemRect_QBaseMainBrush(const QCPItemRect* self);
    friend double QCPItemRect_RectDistance(const QCPItemRect* self, const QRectF* rect, const QPointF* pos, bool filledRect);
    friend double QCPItemRect_QBaseRectDistance(const QCPItemRect* self, const QRectF* rect, const QPointF* pos, bool filledRect);
    friend QCPItemPosition* QCPItemRect_CreatePosition(QCPItemRect* self, const libqt_string name);
    friend QCPItemPosition* QCPItemRect_QBaseCreatePosition(QCPItemRect* self, const libqt_string name);
    friend QCPItemAnchor* QCPItemRect_CreateAnchor(QCPItemRect* self, const libqt_string name, int anchorId);
    friend QCPItemAnchor* QCPItemRect_QBaseCreateAnchor(QCPItemRect* self, const libqt_string name, int anchorId);
    friend void QCPItemRect_InitializeParentPlot(QCPItemRect* self, QCustomPlot* parentPlot);
    friend void QCPItemRect_QBaseInitializeParentPlot(QCPItemRect* self, QCustomPlot* parentPlot);
    friend void QCPItemRect_SetParentLayerable(QCPItemRect* self, QCPLayerable* parentLayerable);
    friend void QCPItemRect_QBaseSetParentLayerable(QCPItemRect* self, QCPLayerable* parentLayerable);
    friend bool QCPItemRect_MoveToLayer(QCPItemRect* self, QCPLayer* layer, bool prepend);
    friend bool QCPItemRect_QBaseMoveToLayer(QCPItemRect* self, QCPLayer* layer, bool prepend);
    friend void QCPItemRect_ApplyAntialiasingHint(const QCPItemRect* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPItemRect_QBaseApplyAntialiasingHint(const QCPItemRect* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPItemRect_Sender(const QCPItemRect* self);
    friend QObject* QCPItemRect_QBaseSender(const QCPItemRect* self);
    friend int QCPItemRect_SenderSignalIndex(const QCPItemRect* self);
    friend int QCPItemRect_QBaseSenderSignalIndex(const QCPItemRect* self);
    friend int QCPItemRect_Receivers(const QCPItemRect* self, const char* signal);
    friend int QCPItemRect_QBaseReceivers(const QCPItemRect* self, const char* signal);
    friend bool QCPItemRect_IsSignalConnected(const QCPItemRect* self, const QMetaMethod* signal);
    friend bool QCPItemRect_QBaseIsSignalConnected(const QCPItemRect* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPItemText so that we can call protected methods
class VirtualQCPItemText final : public QCPItemText {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPItemText = true;

    // Virtual class public types (including callbacks)
    using QCPItemText::AnchorIndex;
    using QCPItemText_Metacall_Callback = int (*)(QCPItemText*, int, int, void**);
    using QCPItemText_SelectTest_Callback = double (*)(const QCPItemText*, QPointF*, bool, QVariant*);
    using QCPItemText_Draw_Callback = void (*)(QCPItemText*, QCPPainter*);
    using QCPItemText_AnchorPixelPosition_Callback = QPointF* (*)(const QCPItemText*, int);
    using QCPItemText_SelectionCategory_Callback = int (*)();
    using QCPItemText_ClipRect_Callback = QRect* (*)();
    using QCPItemText_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPItemText*, QCPPainter*);
    using QCPItemText_SelectEvent_Callback = void (*)(QCPItemText*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPItemText_DeselectEvent_Callback = void (*)(QCPItemText*, bool*);
    using QCPItemText_ParentPlotInitialized_Callback = void (*)(QCPItemText*, QCustomPlot*);
    using QCPItemText_MousePressEvent_Callback = void (*)(QCPItemText*, QMouseEvent*, QVariant*);
    using QCPItemText_MouseMoveEvent_Callback = void (*)(QCPItemText*, QMouseEvent*, QPointF*);
    using QCPItemText_MouseReleaseEvent_Callback = void (*)(QCPItemText*, QMouseEvent*, QPointF*);
    using QCPItemText_MouseDoubleClickEvent_Callback = void (*)(QCPItemText*, QMouseEvent*, QVariant*);
    using QCPItemText_WheelEvent_Callback = void (*)(QCPItemText*, QWheelEvent*);
    using QCPItemText_Event_Callback = bool (*)(QCPItemText*, QEvent*);
    using QCPItemText_EventFilter_Callback = bool (*)(QCPItemText*, QObject*, QEvent*);
    using QCPItemText_TimerEvent_Callback = void (*)(QCPItemText*, QTimerEvent*);
    using QCPItemText_ChildEvent_Callback = void (*)(QCPItemText*, QChildEvent*);
    using QCPItemText_CustomEvent_Callback = void (*)(QCPItemText*, QEvent*);
    using QCPItemText_ConnectNotify_Callback = void (*)(QCPItemText*, QMetaMethod*);
    using QCPItemText_DisconnectNotify_Callback = void (*)(QCPItemText*, QMetaMethod*);
    using QCPItemText_GetTextDrawPoint_Callback = QPointF* (*)(const QCPItemText*, QPointF*, QRectF*, int);
    using QCPItemText_MainFont_Callback = QFont* (*)();
    using QCPItemText_MainColor_Callback = QColor* (*)();
    using QCPItemText_MainPen_Callback = QPen* (*)();
    using QCPItemText_MainBrush_Callback = QBrush* (*)();
    using QCPItemText_RectDistance_Callback = double (*)(const QCPItemText*, QRectF*, QPointF*, bool);
    using QCPItemText_CreatePosition_Callback = QCPItemPosition* (*)(QCPItemText*, libqt_string);
    using QCPItemText_CreateAnchor_Callback = QCPItemAnchor* (*)(QCPItemText*, libqt_string, int);
    using QCPItemText_InitializeParentPlot_Callback = void (*)(QCPItemText*, QCustomPlot*);
    using QCPItemText_SetParentLayerable_Callback = void (*)(QCPItemText*, QCPLayerable*);
    using QCPItemText_MoveToLayer_Callback = bool (*)(QCPItemText*, QCPLayer*, bool);
    using QCPItemText_ApplyAntialiasingHint_Callback = void (*)(const QCPItemText*, QCPPainter*, bool, int);
    using QCPItemText_Sender_Callback = QObject* (*)();
    using QCPItemText_SenderSignalIndex_Callback = int (*)();
    using QCPItemText_Receivers_Callback = int (*)(const QCPItemText*, const char*);
    using QCPItemText_IsSignalConnected_Callback = bool (*)(const QCPItemText*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPItemText_Metacall_Callback qcpitemtext_metacall_callback = nullptr;
    QCPItemText_SelectTest_Callback qcpitemtext_selecttest_callback = nullptr;
    QCPItemText_Draw_Callback qcpitemtext_draw_callback = nullptr;
    QCPItemText_AnchorPixelPosition_Callback qcpitemtext_anchorpixelposition_callback = nullptr;
    QCPItemText_SelectionCategory_Callback qcpitemtext_selectioncategory_callback = nullptr;
    QCPItemText_ClipRect_Callback qcpitemtext_cliprect_callback = nullptr;
    QCPItemText_ApplyDefaultAntialiasingHint_Callback qcpitemtext_applydefaultantialiasinghint_callback = nullptr;
    QCPItemText_SelectEvent_Callback qcpitemtext_selectevent_callback = nullptr;
    QCPItemText_DeselectEvent_Callback qcpitemtext_deselectevent_callback = nullptr;
    QCPItemText_ParentPlotInitialized_Callback qcpitemtext_parentplotinitialized_callback = nullptr;
    QCPItemText_MousePressEvent_Callback qcpitemtext_mousepressevent_callback = nullptr;
    QCPItemText_MouseMoveEvent_Callback qcpitemtext_mousemoveevent_callback = nullptr;
    QCPItemText_MouseReleaseEvent_Callback qcpitemtext_mousereleaseevent_callback = nullptr;
    QCPItemText_MouseDoubleClickEvent_Callback qcpitemtext_mousedoubleclickevent_callback = nullptr;
    QCPItemText_WheelEvent_Callback qcpitemtext_wheelevent_callback = nullptr;
    QCPItemText_Event_Callback qcpitemtext_event_callback = nullptr;
    QCPItemText_EventFilter_Callback qcpitemtext_eventfilter_callback = nullptr;
    QCPItemText_TimerEvent_Callback qcpitemtext_timerevent_callback = nullptr;
    QCPItemText_ChildEvent_Callback qcpitemtext_childevent_callback = nullptr;
    QCPItemText_CustomEvent_Callback qcpitemtext_customevent_callback = nullptr;
    QCPItemText_ConnectNotify_Callback qcpitemtext_connectnotify_callback = nullptr;
    QCPItemText_DisconnectNotify_Callback qcpitemtext_disconnectnotify_callback = nullptr;
    QCPItemText_GetTextDrawPoint_Callback qcpitemtext_gettextdrawpoint_callback = nullptr;
    QCPItemText_MainFont_Callback qcpitemtext_mainfont_callback = nullptr;
    QCPItemText_MainColor_Callback qcpitemtext_maincolor_callback = nullptr;
    QCPItemText_MainPen_Callback qcpitemtext_mainpen_callback = nullptr;
    QCPItemText_MainBrush_Callback qcpitemtext_mainbrush_callback = nullptr;
    QCPItemText_RectDistance_Callback qcpitemtext_rectdistance_callback = nullptr;
    QCPItemText_CreatePosition_Callback qcpitemtext_createposition_callback = nullptr;
    QCPItemText_CreateAnchor_Callback qcpitemtext_createanchor_callback = nullptr;
    QCPItemText_InitializeParentPlot_Callback qcpitemtext_initializeparentplot_callback = nullptr;
    QCPItemText_SetParentLayerable_Callback qcpitemtext_setparentlayerable_callback = nullptr;
    QCPItemText_MoveToLayer_Callback qcpitemtext_movetolayer_callback = nullptr;
    QCPItemText_ApplyAntialiasingHint_Callback qcpitemtext_applyantialiasinghint_callback = nullptr;
    QCPItemText_Sender_Callback qcpitemtext_sender_callback = nullptr;
    QCPItemText_SenderSignalIndex_Callback qcpitemtext_sendersignalindex_callback = nullptr;
    QCPItemText_Receivers_Callback qcpitemtext_receivers_callback = nullptr;
    QCPItemText_IsSignalConnected_Callback qcpitemtext_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpitemtext_metacall_isbase = false;
    mutable bool qcpitemtext_selecttest_isbase = false;
    mutable bool qcpitemtext_draw_isbase = false;
    mutable bool qcpitemtext_anchorpixelposition_isbase = false;
    mutable bool qcpitemtext_selectioncategory_isbase = false;
    mutable bool qcpitemtext_cliprect_isbase = false;
    mutable bool qcpitemtext_applydefaultantialiasinghint_isbase = false;
    mutable bool qcpitemtext_selectevent_isbase = false;
    mutable bool qcpitemtext_deselectevent_isbase = false;
    mutable bool qcpitemtext_parentplotinitialized_isbase = false;
    mutable bool qcpitemtext_mousepressevent_isbase = false;
    mutable bool qcpitemtext_mousemoveevent_isbase = false;
    mutable bool qcpitemtext_mousereleaseevent_isbase = false;
    mutable bool qcpitemtext_mousedoubleclickevent_isbase = false;
    mutable bool qcpitemtext_wheelevent_isbase = false;
    mutable bool qcpitemtext_event_isbase = false;
    mutable bool qcpitemtext_eventfilter_isbase = false;
    mutable bool qcpitemtext_timerevent_isbase = false;
    mutable bool qcpitemtext_childevent_isbase = false;
    mutable bool qcpitemtext_customevent_isbase = false;
    mutable bool qcpitemtext_connectnotify_isbase = false;
    mutable bool qcpitemtext_disconnectnotify_isbase = false;
    mutable bool qcpitemtext_gettextdrawpoint_isbase = false;
    mutable bool qcpitemtext_mainfont_isbase = false;
    mutable bool qcpitemtext_maincolor_isbase = false;
    mutable bool qcpitemtext_mainpen_isbase = false;
    mutable bool qcpitemtext_mainbrush_isbase = false;
    mutable bool qcpitemtext_rectdistance_isbase = false;
    mutable bool qcpitemtext_createposition_isbase = false;
    mutable bool qcpitemtext_createanchor_isbase = false;
    mutable bool qcpitemtext_initializeparentplot_isbase = false;
    mutable bool qcpitemtext_setparentlayerable_isbase = false;
    mutable bool qcpitemtext_movetolayer_isbase = false;
    mutable bool qcpitemtext_applyantialiasinghint_isbase = false;
    mutable bool qcpitemtext_sender_isbase = false;
    mutable bool qcpitemtext_sendersignalindex_isbase = false;
    mutable bool qcpitemtext_receivers_isbase = false;
    mutable bool qcpitemtext_issignalconnected_isbase = false;

  public:
    VirtualQCPItemText(QCustomPlot* parentPlot) : QCPItemText(parentPlot) {};

    ~VirtualQCPItemText() {
        qcpitemtext_metacall_callback = nullptr;
        qcpitemtext_selecttest_callback = nullptr;
        qcpitemtext_draw_callback = nullptr;
        qcpitemtext_anchorpixelposition_callback = nullptr;
        qcpitemtext_selectioncategory_callback = nullptr;
        qcpitemtext_cliprect_callback = nullptr;
        qcpitemtext_applydefaultantialiasinghint_callback = nullptr;
        qcpitemtext_selectevent_callback = nullptr;
        qcpitemtext_deselectevent_callback = nullptr;
        qcpitemtext_parentplotinitialized_callback = nullptr;
        qcpitemtext_mousepressevent_callback = nullptr;
        qcpitemtext_mousemoveevent_callback = nullptr;
        qcpitemtext_mousereleaseevent_callback = nullptr;
        qcpitemtext_mousedoubleclickevent_callback = nullptr;
        qcpitemtext_wheelevent_callback = nullptr;
        qcpitemtext_event_callback = nullptr;
        qcpitemtext_eventfilter_callback = nullptr;
        qcpitemtext_timerevent_callback = nullptr;
        qcpitemtext_childevent_callback = nullptr;
        qcpitemtext_customevent_callback = nullptr;
        qcpitemtext_connectnotify_callback = nullptr;
        qcpitemtext_disconnectnotify_callback = nullptr;
        qcpitemtext_gettextdrawpoint_callback = nullptr;
        qcpitemtext_mainfont_callback = nullptr;
        qcpitemtext_maincolor_callback = nullptr;
        qcpitemtext_mainpen_callback = nullptr;
        qcpitemtext_mainbrush_callback = nullptr;
        qcpitemtext_rectdistance_callback = nullptr;
        qcpitemtext_createposition_callback = nullptr;
        qcpitemtext_createanchor_callback = nullptr;
        qcpitemtext_initializeparentplot_callback = nullptr;
        qcpitemtext_setparentlayerable_callback = nullptr;
        qcpitemtext_movetolayer_callback = nullptr;
        qcpitemtext_applyantialiasinghint_callback = nullptr;
        qcpitemtext_sender_callback = nullptr;
        qcpitemtext_sendersignalindex_callback = nullptr;
        qcpitemtext_receivers_callback = nullptr;
        qcpitemtext_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPItemText_Metacall_Callback(QCPItemText_Metacall_Callback cb) { qcpitemtext_metacall_callback = cb; }
    inline void setQCPItemText_SelectTest_Callback(QCPItemText_SelectTest_Callback cb) { qcpitemtext_selecttest_callback = cb; }
    inline void setQCPItemText_Draw_Callback(QCPItemText_Draw_Callback cb) { qcpitemtext_draw_callback = cb; }
    inline void setQCPItemText_AnchorPixelPosition_Callback(QCPItemText_AnchorPixelPosition_Callback cb) { qcpitemtext_anchorpixelposition_callback = cb; }
    inline void setQCPItemText_SelectionCategory_Callback(QCPItemText_SelectionCategory_Callback cb) { qcpitemtext_selectioncategory_callback = cb; }
    inline void setQCPItemText_ClipRect_Callback(QCPItemText_ClipRect_Callback cb) { qcpitemtext_cliprect_callback = cb; }
    inline void setQCPItemText_ApplyDefaultAntialiasingHint_Callback(QCPItemText_ApplyDefaultAntialiasingHint_Callback cb) { qcpitemtext_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPItemText_SelectEvent_Callback(QCPItemText_SelectEvent_Callback cb) { qcpitemtext_selectevent_callback = cb; }
    inline void setQCPItemText_DeselectEvent_Callback(QCPItemText_DeselectEvent_Callback cb) { qcpitemtext_deselectevent_callback = cb; }
    inline void setQCPItemText_ParentPlotInitialized_Callback(QCPItemText_ParentPlotInitialized_Callback cb) { qcpitemtext_parentplotinitialized_callback = cb; }
    inline void setQCPItemText_MousePressEvent_Callback(QCPItemText_MousePressEvent_Callback cb) { qcpitemtext_mousepressevent_callback = cb; }
    inline void setQCPItemText_MouseMoveEvent_Callback(QCPItemText_MouseMoveEvent_Callback cb) { qcpitemtext_mousemoveevent_callback = cb; }
    inline void setQCPItemText_MouseReleaseEvent_Callback(QCPItemText_MouseReleaseEvent_Callback cb) { qcpitemtext_mousereleaseevent_callback = cb; }
    inline void setQCPItemText_MouseDoubleClickEvent_Callback(QCPItemText_MouseDoubleClickEvent_Callback cb) { qcpitemtext_mousedoubleclickevent_callback = cb; }
    inline void setQCPItemText_WheelEvent_Callback(QCPItemText_WheelEvent_Callback cb) { qcpitemtext_wheelevent_callback = cb; }
    inline void setQCPItemText_Event_Callback(QCPItemText_Event_Callback cb) { qcpitemtext_event_callback = cb; }
    inline void setQCPItemText_EventFilter_Callback(QCPItemText_EventFilter_Callback cb) { qcpitemtext_eventfilter_callback = cb; }
    inline void setQCPItemText_TimerEvent_Callback(QCPItemText_TimerEvent_Callback cb) { qcpitemtext_timerevent_callback = cb; }
    inline void setQCPItemText_ChildEvent_Callback(QCPItemText_ChildEvent_Callback cb) { qcpitemtext_childevent_callback = cb; }
    inline void setQCPItemText_CustomEvent_Callback(QCPItemText_CustomEvent_Callback cb) { qcpitemtext_customevent_callback = cb; }
    inline void setQCPItemText_ConnectNotify_Callback(QCPItemText_ConnectNotify_Callback cb) { qcpitemtext_connectnotify_callback = cb; }
    inline void setQCPItemText_DisconnectNotify_Callback(QCPItemText_DisconnectNotify_Callback cb) { qcpitemtext_disconnectnotify_callback = cb; }
    inline void setQCPItemText_GetTextDrawPoint_Callback(QCPItemText_GetTextDrawPoint_Callback cb) { qcpitemtext_gettextdrawpoint_callback = cb; }
    inline void setQCPItemText_MainFont_Callback(QCPItemText_MainFont_Callback cb) { qcpitemtext_mainfont_callback = cb; }
    inline void setQCPItemText_MainColor_Callback(QCPItemText_MainColor_Callback cb) { qcpitemtext_maincolor_callback = cb; }
    inline void setQCPItemText_MainPen_Callback(QCPItemText_MainPen_Callback cb) { qcpitemtext_mainpen_callback = cb; }
    inline void setQCPItemText_MainBrush_Callback(QCPItemText_MainBrush_Callback cb) { qcpitemtext_mainbrush_callback = cb; }
    inline void setQCPItemText_RectDistance_Callback(QCPItemText_RectDistance_Callback cb) { qcpitemtext_rectdistance_callback = cb; }
    inline void setQCPItemText_CreatePosition_Callback(QCPItemText_CreatePosition_Callback cb) { qcpitemtext_createposition_callback = cb; }
    inline void setQCPItemText_CreateAnchor_Callback(QCPItemText_CreateAnchor_Callback cb) { qcpitemtext_createanchor_callback = cb; }
    inline void setQCPItemText_InitializeParentPlot_Callback(QCPItemText_InitializeParentPlot_Callback cb) { qcpitemtext_initializeparentplot_callback = cb; }
    inline void setQCPItemText_SetParentLayerable_Callback(QCPItemText_SetParentLayerable_Callback cb) { qcpitemtext_setparentlayerable_callback = cb; }
    inline void setQCPItemText_MoveToLayer_Callback(QCPItemText_MoveToLayer_Callback cb) { qcpitemtext_movetolayer_callback = cb; }
    inline void setQCPItemText_ApplyAntialiasingHint_Callback(QCPItemText_ApplyAntialiasingHint_Callback cb) { qcpitemtext_applyantialiasinghint_callback = cb; }
    inline void setQCPItemText_Sender_Callback(QCPItemText_Sender_Callback cb) { qcpitemtext_sender_callback = cb; }
    inline void setQCPItemText_SenderSignalIndex_Callback(QCPItemText_SenderSignalIndex_Callback cb) { qcpitemtext_sendersignalindex_callback = cb; }
    inline void setQCPItemText_Receivers_Callback(QCPItemText_Receivers_Callback cb) { qcpitemtext_receivers_callback = cb; }
    inline void setQCPItemText_IsSignalConnected_Callback(QCPItemText_IsSignalConnected_Callback cb) { qcpitemtext_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPItemText_Metacall_IsBase(bool value) const { qcpitemtext_metacall_isbase = value; }
    inline void setQCPItemText_SelectTest_IsBase(bool value) const { qcpitemtext_selecttest_isbase = value; }
    inline void setQCPItemText_Draw_IsBase(bool value) const { qcpitemtext_draw_isbase = value; }
    inline void setQCPItemText_AnchorPixelPosition_IsBase(bool value) const { qcpitemtext_anchorpixelposition_isbase = value; }
    inline void setQCPItemText_SelectionCategory_IsBase(bool value) const { qcpitemtext_selectioncategory_isbase = value; }
    inline void setQCPItemText_ClipRect_IsBase(bool value) const { qcpitemtext_cliprect_isbase = value; }
    inline void setQCPItemText_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcpitemtext_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPItemText_SelectEvent_IsBase(bool value) const { qcpitemtext_selectevent_isbase = value; }
    inline void setQCPItemText_DeselectEvent_IsBase(bool value) const { qcpitemtext_deselectevent_isbase = value; }
    inline void setQCPItemText_ParentPlotInitialized_IsBase(bool value) const { qcpitemtext_parentplotinitialized_isbase = value; }
    inline void setQCPItemText_MousePressEvent_IsBase(bool value) const { qcpitemtext_mousepressevent_isbase = value; }
    inline void setQCPItemText_MouseMoveEvent_IsBase(bool value) const { qcpitemtext_mousemoveevent_isbase = value; }
    inline void setQCPItemText_MouseReleaseEvent_IsBase(bool value) const { qcpitemtext_mousereleaseevent_isbase = value; }
    inline void setQCPItemText_MouseDoubleClickEvent_IsBase(bool value) const { qcpitemtext_mousedoubleclickevent_isbase = value; }
    inline void setQCPItemText_WheelEvent_IsBase(bool value) const { qcpitemtext_wheelevent_isbase = value; }
    inline void setQCPItemText_Event_IsBase(bool value) const { qcpitemtext_event_isbase = value; }
    inline void setQCPItemText_EventFilter_IsBase(bool value) const { qcpitemtext_eventfilter_isbase = value; }
    inline void setQCPItemText_TimerEvent_IsBase(bool value) const { qcpitemtext_timerevent_isbase = value; }
    inline void setQCPItemText_ChildEvent_IsBase(bool value) const { qcpitemtext_childevent_isbase = value; }
    inline void setQCPItemText_CustomEvent_IsBase(bool value) const { qcpitemtext_customevent_isbase = value; }
    inline void setQCPItemText_ConnectNotify_IsBase(bool value) const { qcpitemtext_connectnotify_isbase = value; }
    inline void setQCPItemText_DisconnectNotify_IsBase(bool value) const { qcpitemtext_disconnectnotify_isbase = value; }
    inline void setQCPItemText_GetTextDrawPoint_IsBase(bool value) const { qcpitemtext_gettextdrawpoint_isbase = value; }
    inline void setQCPItemText_MainFont_IsBase(bool value) const { qcpitemtext_mainfont_isbase = value; }
    inline void setQCPItemText_MainColor_IsBase(bool value) const { qcpitemtext_maincolor_isbase = value; }
    inline void setQCPItemText_MainPen_IsBase(bool value) const { qcpitemtext_mainpen_isbase = value; }
    inline void setQCPItemText_MainBrush_IsBase(bool value) const { qcpitemtext_mainbrush_isbase = value; }
    inline void setQCPItemText_RectDistance_IsBase(bool value) const { qcpitemtext_rectdistance_isbase = value; }
    inline void setQCPItemText_CreatePosition_IsBase(bool value) const { qcpitemtext_createposition_isbase = value; }
    inline void setQCPItemText_CreateAnchor_IsBase(bool value) const { qcpitemtext_createanchor_isbase = value; }
    inline void setQCPItemText_InitializeParentPlot_IsBase(bool value) const { qcpitemtext_initializeparentplot_isbase = value; }
    inline void setQCPItemText_SetParentLayerable_IsBase(bool value) const { qcpitemtext_setparentlayerable_isbase = value; }
    inline void setQCPItemText_MoveToLayer_IsBase(bool value) const { qcpitemtext_movetolayer_isbase = value; }
    inline void setQCPItemText_ApplyAntialiasingHint_IsBase(bool value) const { qcpitemtext_applyantialiasinghint_isbase = value; }
    inline void setQCPItemText_Sender_IsBase(bool value) const { qcpitemtext_sender_isbase = value; }
    inline void setQCPItemText_SenderSignalIndex_IsBase(bool value) const { qcpitemtext_sendersignalindex_isbase = value; }
    inline void setQCPItemText_Receivers_IsBase(bool value) const { qcpitemtext_receivers_isbase = value; }
    inline void setQCPItemText_IsSignalConnected_IsBase(bool value) const { qcpitemtext_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpitemtext_metacall_isbase) {
            qcpitemtext_metacall_isbase = false;
            return QCPItemText::qt_metacall(param1, param2, param3);
        } else if (qcpitemtext_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpitemtext_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemText::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcpitemtext_selecttest_isbase) {
            qcpitemtext_selecttest_isbase = false;
            return QCPItemText::selectTest(pos, onlySelectable, details);
        } else if (qcpitemtext_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcpitemtext_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPItemText::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcpitemtext_draw_isbase) {
            qcpitemtext_draw_isbase = false;
            QCPItemText::draw(painter);
        } else if (qcpitemtext_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpitemtext_draw_callback(this, cbval1);
        } else {
            QCPItemText::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QPointF anchorPixelPosition(int anchorId) const override {
        if (qcpitemtext_anchorpixelposition_isbase) {
            qcpitemtext_anchorpixelposition_isbase = false;
            return QCPItemText::anchorPixelPosition(anchorId);
        } else if (qcpitemtext_anchorpixelposition_callback != nullptr) {
            int cbval1 = anchorId;

            QPointF* callback_ret = qcpitemtext_anchorpixelposition_callback(this, cbval1);
            return *callback_ret;
        } else {
            return QCPItemText::anchorPixelPosition(anchorId);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcpitemtext_selectioncategory_isbase) {
            qcpitemtext_selectioncategory_isbase = false;
            return QCPItemText::selectionCategory();
        } else if (qcpitemtext_selectioncategory_callback != nullptr) {
            int callback_ret = qcpitemtext_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPItemText::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcpitemtext_cliprect_isbase) {
            qcpitemtext_cliprect_isbase = false;
            return QCPItemText::clipRect();
        } else if (qcpitemtext_cliprect_callback != nullptr) {
            QRect* callback_ret = qcpitemtext_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPItemText::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcpitemtext_applydefaultantialiasinghint_isbase) {
            qcpitemtext_applydefaultantialiasinghint_isbase = false;
            QCPItemText::applyDefaultAntialiasingHint(painter);
        } else if (qcpitemtext_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpitemtext_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPItemText::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcpitemtext_selectevent_isbase) {
            qcpitemtext_selectevent_isbase = false;
            QCPItemText::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcpitemtext_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcpitemtext_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPItemText::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcpitemtext_deselectevent_isbase) {
            qcpitemtext_deselectevent_isbase = false;
            QCPItemText::deselectEvent(selectionStateChanged);
        } else if (qcpitemtext_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcpitemtext_deselectevent_callback(this, cbval1);
        } else {
            QCPItemText::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcpitemtext_parentplotinitialized_isbase) {
            qcpitemtext_parentplotinitialized_isbase = false;
            QCPItemText::parentPlotInitialized(parentPlot);
        } else if (qcpitemtext_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpitemtext_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPItemText::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpitemtext_mousepressevent_isbase) {
            qcpitemtext_mousepressevent_isbase = false;
            QCPItemText::mousePressEvent(event, details);
        } else if (qcpitemtext_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpitemtext_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemText::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpitemtext_mousemoveevent_isbase) {
            qcpitemtext_mousemoveevent_isbase = false;
            QCPItemText::mouseMoveEvent(event, startPos);
        } else if (qcpitemtext_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpitemtext_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemText::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpitemtext_mousereleaseevent_isbase) {
            qcpitemtext_mousereleaseevent_isbase = false;
            QCPItemText::mouseReleaseEvent(event, startPos);
        } else if (qcpitemtext_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpitemtext_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemText::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpitemtext_mousedoubleclickevent_isbase) {
            qcpitemtext_mousedoubleclickevent_isbase = false;
            QCPItemText::mouseDoubleClickEvent(event, details);
        } else if (qcpitemtext_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpitemtext_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemText::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcpitemtext_wheelevent_isbase) {
            qcpitemtext_wheelevent_isbase = false;
            QCPItemText::wheelEvent(event);
        } else if (qcpitemtext_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcpitemtext_wheelevent_callback(this, cbval1);
        } else {
            QCPItemText::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpitemtext_event_isbase) {
            qcpitemtext_event_isbase = false;
            return QCPItemText::event(event);
        } else if (qcpitemtext_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpitemtext_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemText::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpitemtext_eventfilter_isbase) {
            qcpitemtext_eventfilter_isbase = false;
            return QCPItemText::eventFilter(watched, event);
        } else if (qcpitemtext_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpitemtext_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemText::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpitemtext_timerevent_isbase) {
            qcpitemtext_timerevent_isbase = false;
            QCPItemText::timerEvent(event);
        } else if (qcpitemtext_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpitemtext_timerevent_callback(this, cbval1);
        } else {
            QCPItemText::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpitemtext_childevent_isbase) {
            qcpitemtext_childevent_isbase = false;
            QCPItemText::childEvent(event);
        } else if (qcpitemtext_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpitemtext_childevent_callback(this, cbval1);
        } else {
            QCPItemText::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpitemtext_customevent_isbase) {
            qcpitemtext_customevent_isbase = false;
            QCPItemText::customEvent(event);
        } else if (qcpitemtext_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpitemtext_customevent_callback(this, cbval1);
        } else {
            QCPItemText::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpitemtext_connectnotify_isbase) {
            qcpitemtext_connectnotify_isbase = false;
            QCPItemText::connectNotify(signal);
        } else if (qcpitemtext_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpitemtext_connectnotify_callback(this, cbval1);
        } else {
            QCPItemText::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpitemtext_disconnectnotify_isbase) {
            qcpitemtext_disconnectnotify_isbase = false;
            QCPItemText::disconnectNotify(signal);
        } else if (qcpitemtext_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpitemtext_disconnectnotify_callback(this, cbval1);
        } else {
            QCPItemText::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    QPointF getTextDrawPoint(const QPointF& pos, const QRectF& rect, Qt::Alignment positionAlignment) const {
        if (qcpitemtext_gettextdrawpoint_isbase) {
            qcpitemtext_gettextdrawpoint_isbase = false;
            return QCPItemText::getTextDrawPoint(pos, rect, positionAlignment);
        } else if (qcpitemtext_gettextdrawpoint_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval2 = const_cast<QRectF*>(&rect_ret);
            int cbval3 = static_cast<int>(positionAlignment);

            QPointF* callback_ret = qcpitemtext_gettextdrawpoint_callback(this, cbval1, cbval2, cbval3);
            return *callback_ret;
        } else {
            return QCPItemText::getTextDrawPoint(pos, rect, positionAlignment);
        }
    }

    // Virtual method for C ABI access and custom callback
    QFont mainFont() const {
        if (qcpitemtext_mainfont_isbase) {
            qcpitemtext_mainfont_isbase = false;
            return QCPItemText::mainFont();
        } else if (qcpitemtext_mainfont_callback != nullptr) {
            QFont* callback_ret = qcpitemtext_mainfont_callback();
            return *callback_ret;
        } else {
            return QCPItemText::mainFont();
        }
    }

    // Virtual method for C ABI access and custom callback
    QColor mainColor() const {
        if (qcpitemtext_maincolor_isbase) {
            qcpitemtext_maincolor_isbase = false;
            return QCPItemText::mainColor();
        } else if (qcpitemtext_maincolor_callback != nullptr) {
            QColor* callback_ret = qcpitemtext_maincolor_callback();
            return *callback_ret;
        } else {
            return QCPItemText::mainColor();
        }
    }

    // Virtual method for C ABI access and custom callback
    QPen mainPen() const {
        if (qcpitemtext_mainpen_isbase) {
            qcpitemtext_mainpen_isbase = false;
            return QCPItemText::mainPen();
        } else if (qcpitemtext_mainpen_callback != nullptr) {
            QPen* callback_ret = qcpitemtext_mainpen_callback();
            return *callback_ret;
        } else {
            return QCPItemText::mainPen();
        }
    }

    // Virtual method for C ABI access and custom callback
    QBrush mainBrush() const {
        if (qcpitemtext_mainbrush_isbase) {
            qcpitemtext_mainbrush_isbase = false;
            return QCPItemText::mainBrush();
        } else if (qcpitemtext_mainbrush_callback != nullptr) {
            QBrush* callback_ret = qcpitemtext_mainbrush_callback();
            return *callback_ret;
        } else {
            return QCPItemText::mainBrush();
        }
    }

    // Virtual method for C ABI access and custom callback
    double rectDistance(const QRectF& rect, const QPointF& pos, bool filledRect) const {
        if (qcpitemtext_rectdistance_isbase) {
            qcpitemtext_rectdistance_isbase = false;
            return QCPItemText::rectDistance(rect, pos, filledRect);
        } else if (qcpitemtext_rectdistance_callback != nullptr) {
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval1 = const_cast<QRectF*>(&rect_ret);
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&pos_ret);
            bool cbval3 = filledRect;

            double callback_ret = qcpitemtext_rectdistance_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPItemText::rectDistance(rect, pos, filledRect);
        }
    }

    // Virtual method for C ABI access and custom callback
    QCPItemPosition* createPosition(const QString& name) {
        if (qcpitemtext_createposition_isbase) {
            qcpitemtext_createposition_isbase = false;
            return QCPItemText::createPosition(name);
        } else if (qcpitemtext_createposition_callback != nullptr) {
            const QString name_ret = name;
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray name_b = name_ret.toUtf8();
            libqt_string name_str;
            name_str.len = name_b.length();
            name_str.data = static_cast<const char*>(malloc(name_str.len + 1));
            memcpy((void*)name_str.data, name_b.data(), name_str.len);
            ((char*)name_str.data)[name_str.len] = '\0';
            libqt_string cbval1 = name_str;

            QCPItemPosition* callback_ret = qcpitemtext_createposition_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemText::createPosition(name);
        }
    }

    // Virtual method for C ABI access and custom callback
    QCPItemAnchor* createAnchor(const QString& name, int anchorId) {
        if (qcpitemtext_createanchor_isbase) {
            qcpitemtext_createanchor_isbase = false;
            return QCPItemText::createAnchor(name, anchorId);
        } else if (qcpitemtext_createanchor_callback != nullptr) {
            const QString name_ret = name;
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray name_b = name_ret.toUtf8();
            libqt_string name_str;
            name_str.len = name_b.length();
            name_str.data = static_cast<const char*>(malloc(name_str.len + 1));
            memcpy((void*)name_str.data, name_b.data(), name_str.len);
            ((char*)name_str.data)[name_str.len] = '\0';
            libqt_string cbval1 = name_str;
            int cbval2 = anchorId;

            QCPItemAnchor* callback_ret = qcpitemtext_createanchor_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemText::createAnchor(name, anchorId);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcpitemtext_initializeparentplot_isbase) {
            qcpitemtext_initializeparentplot_isbase = false;
            QCPItemText::initializeParentPlot(parentPlot);
        } else if (qcpitemtext_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpitemtext_initializeparentplot_callback(this, cbval1);
        } else {
            QCPItemText::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcpitemtext_setparentlayerable_isbase) {
            qcpitemtext_setparentlayerable_isbase = false;
            QCPItemText::setParentLayerable(parentLayerable);
        } else if (qcpitemtext_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcpitemtext_setparentlayerable_callback(this, cbval1);
        } else {
            QCPItemText::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcpitemtext_movetolayer_isbase) {
            qcpitemtext_movetolayer_isbase = false;
            return QCPItemText::moveToLayer(layer, prepend);
        } else if (qcpitemtext_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcpitemtext_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemText::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcpitemtext_applyantialiasinghint_isbase) {
            qcpitemtext_applyantialiasinghint_isbase = false;
            QCPItemText::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcpitemtext_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcpitemtext_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPItemText::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpitemtext_sender_isbase) {
            qcpitemtext_sender_isbase = false;
            return QCPItemText::sender();
        } else if (qcpitemtext_sender_callback != nullptr) {
            QObject* callback_ret = qcpitemtext_sender_callback();
            return callback_ret;
        } else {
            return QCPItemText::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpitemtext_sendersignalindex_isbase) {
            qcpitemtext_sendersignalindex_isbase = false;
            return QCPItemText::senderSignalIndex();
        } else if (qcpitemtext_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpitemtext_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemText::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpitemtext_receivers_isbase) {
            qcpitemtext_receivers_isbase = false;
            return QCPItemText::receivers(signal);
        } else if (qcpitemtext_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpitemtext_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemText::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpitemtext_issignalconnected_isbase) {
            qcpitemtext_issignalconnected_isbase = false;
            return QCPItemText::isSignalConnected(signal);
        } else if (qcpitemtext_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpitemtext_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemText::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPItemText_Draw(QCPItemText* self, QCPPainter* painter);
    friend void QCPItemText_QBaseDraw(QCPItemText* self, QCPPainter* painter);
    friend QPointF* QCPItemText_AnchorPixelPosition(const QCPItemText* self, int anchorId);
    friend QPointF* QCPItemText_QBaseAnchorPixelPosition(const QCPItemText* self, int anchorId);
    friend int QCPItemText_SelectionCategory(const QCPItemText* self);
    friend int QCPItemText_QBaseSelectionCategory(const QCPItemText* self);
    friend QRect* QCPItemText_ClipRect(const QCPItemText* self);
    friend QRect* QCPItemText_QBaseClipRect(const QCPItemText* self);
    friend void QCPItemText_ApplyDefaultAntialiasingHint(const QCPItemText* self, QCPPainter* painter);
    friend void QCPItemText_QBaseApplyDefaultAntialiasingHint(const QCPItemText* self, QCPPainter* painter);
    friend void QCPItemText_SelectEvent(QCPItemText* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPItemText_QBaseSelectEvent(QCPItemText* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPItemText_DeselectEvent(QCPItemText* self, bool* selectionStateChanged);
    friend void QCPItemText_QBaseDeselectEvent(QCPItemText* self, bool* selectionStateChanged);
    friend void QCPItemText_ParentPlotInitialized(QCPItemText* self, QCustomPlot* parentPlot);
    friend void QCPItemText_QBaseParentPlotInitialized(QCPItemText* self, QCustomPlot* parentPlot);
    friend void QCPItemText_MousePressEvent(QCPItemText* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemText_QBaseMousePressEvent(QCPItemText* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemText_MouseMoveEvent(QCPItemText* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemText_QBaseMouseMoveEvent(QCPItemText* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemText_MouseReleaseEvent(QCPItemText* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemText_QBaseMouseReleaseEvent(QCPItemText* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemText_MouseDoubleClickEvent(QCPItemText* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemText_QBaseMouseDoubleClickEvent(QCPItemText* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemText_WheelEvent(QCPItemText* self, QWheelEvent* event);
    friend void QCPItemText_QBaseWheelEvent(QCPItemText* self, QWheelEvent* event);
    friend void QCPItemText_TimerEvent(QCPItemText* self, QTimerEvent* event);
    friend void QCPItemText_QBaseTimerEvent(QCPItemText* self, QTimerEvent* event);
    friend void QCPItemText_ChildEvent(QCPItemText* self, QChildEvent* event);
    friend void QCPItemText_QBaseChildEvent(QCPItemText* self, QChildEvent* event);
    friend void QCPItemText_CustomEvent(QCPItemText* self, QEvent* event);
    friend void QCPItemText_QBaseCustomEvent(QCPItemText* self, QEvent* event);
    friend void QCPItemText_ConnectNotify(QCPItemText* self, const QMetaMethod* signal);
    friend void QCPItemText_QBaseConnectNotify(QCPItemText* self, const QMetaMethod* signal);
    friend void QCPItemText_DisconnectNotify(QCPItemText* self, const QMetaMethod* signal);
    friend void QCPItemText_QBaseDisconnectNotify(QCPItemText* self, const QMetaMethod* signal);
    friend QPointF* QCPItemText_GetTextDrawPoint(const QCPItemText* self, const QPointF* pos, const QRectF* rect, int positionAlignment);
    friend QPointF* QCPItemText_QBaseGetTextDrawPoint(const QCPItemText* self, const QPointF* pos, const QRectF* rect, int positionAlignment);
    friend QFont* QCPItemText_MainFont(const QCPItemText* self);
    friend QFont* QCPItemText_QBaseMainFont(const QCPItemText* self);
    friend QColor* QCPItemText_MainColor(const QCPItemText* self);
    friend QColor* QCPItemText_QBaseMainColor(const QCPItemText* self);
    friend QPen* QCPItemText_MainPen(const QCPItemText* self);
    friend QPen* QCPItemText_QBaseMainPen(const QCPItemText* self);
    friend QBrush* QCPItemText_MainBrush(const QCPItemText* self);
    friend QBrush* QCPItemText_QBaseMainBrush(const QCPItemText* self);
    friend double QCPItemText_RectDistance(const QCPItemText* self, const QRectF* rect, const QPointF* pos, bool filledRect);
    friend double QCPItemText_QBaseRectDistance(const QCPItemText* self, const QRectF* rect, const QPointF* pos, bool filledRect);
    friend QCPItemPosition* QCPItemText_CreatePosition(QCPItemText* self, const libqt_string name);
    friend QCPItemPosition* QCPItemText_QBaseCreatePosition(QCPItemText* self, const libqt_string name);
    friend QCPItemAnchor* QCPItemText_CreateAnchor(QCPItemText* self, const libqt_string name, int anchorId);
    friend QCPItemAnchor* QCPItemText_QBaseCreateAnchor(QCPItemText* self, const libqt_string name, int anchorId);
    friend void QCPItemText_InitializeParentPlot(QCPItemText* self, QCustomPlot* parentPlot);
    friend void QCPItemText_QBaseInitializeParentPlot(QCPItemText* self, QCustomPlot* parentPlot);
    friend void QCPItemText_SetParentLayerable(QCPItemText* self, QCPLayerable* parentLayerable);
    friend void QCPItemText_QBaseSetParentLayerable(QCPItemText* self, QCPLayerable* parentLayerable);
    friend bool QCPItemText_MoveToLayer(QCPItemText* self, QCPLayer* layer, bool prepend);
    friend bool QCPItemText_QBaseMoveToLayer(QCPItemText* self, QCPLayer* layer, bool prepend);
    friend void QCPItemText_ApplyAntialiasingHint(const QCPItemText* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPItemText_QBaseApplyAntialiasingHint(const QCPItemText* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPItemText_Sender(const QCPItemText* self);
    friend QObject* QCPItemText_QBaseSender(const QCPItemText* self);
    friend int QCPItemText_SenderSignalIndex(const QCPItemText* self);
    friend int QCPItemText_QBaseSenderSignalIndex(const QCPItemText* self);
    friend int QCPItemText_Receivers(const QCPItemText* self, const char* signal);
    friend int QCPItemText_QBaseReceivers(const QCPItemText* self, const char* signal);
    friend bool QCPItemText_IsSignalConnected(const QCPItemText* self, const QMetaMethod* signal);
    friend bool QCPItemText_QBaseIsSignalConnected(const QCPItemText* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPItemEllipse so that we can call protected methods
class VirtualQCPItemEllipse final : public QCPItemEllipse {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPItemEllipse = true;

    // Virtual class public types (including callbacks)
    using QCPItemEllipse::AnchorIndex;
    using QCPItemEllipse_Metacall_Callback = int (*)(QCPItemEllipse*, int, int, void**);
    using QCPItemEllipse_SelectTest_Callback = double (*)(const QCPItemEllipse*, QPointF*, bool, QVariant*);
    using QCPItemEllipse_Draw_Callback = void (*)(QCPItemEllipse*, QCPPainter*);
    using QCPItemEllipse_AnchorPixelPosition_Callback = QPointF* (*)(const QCPItemEllipse*, int);
    using QCPItemEllipse_SelectionCategory_Callback = int (*)();
    using QCPItemEllipse_ClipRect_Callback = QRect* (*)();
    using QCPItemEllipse_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPItemEllipse*, QCPPainter*);
    using QCPItemEllipse_SelectEvent_Callback = void (*)(QCPItemEllipse*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPItemEllipse_DeselectEvent_Callback = void (*)(QCPItemEllipse*, bool*);
    using QCPItemEllipse_ParentPlotInitialized_Callback = void (*)(QCPItemEllipse*, QCustomPlot*);
    using QCPItemEllipse_MousePressEvent_Callback = void (*)(QCPItemEllipse*, QMouseEvent*, QVariant*);
    using QCPItemEllipse_MouseMoveEvent_Callback = void (*)(QCPItemEllipse*, QMouseEvent*, QPointF*);
    using QCPItemEllipse_MouseReleaseEvent_Callback = void (*)(QCPItemEllipse*, QMouseEvent*, QPointF*);
    using QCPItemEllipse_MouseDoubleClickEvent_Callback = void (*)(QCPItemEllipse*, QMouseEvent*, QVariant*);
    using QCPItemEllipse_WheelEvent_Callback = void (*)(QCPItemEllipse*, QWheelEvent*);
    using QCPItemEllipse_Event_Callback = bool (*)(QCPItemEllipse*, QEvent*);
    using QCPItemEllipse_EventFilter_Callback = bool (*)(QCPItemEllipse*, QObject*, QEvent*);
    using QCPItemEllipse_TimerEvent_Callback = void (*)(QCPItemEllipse*, QTimerEvent*);
    using QCPItemEllipse_ChildEvent_Callback = void (*)(QCPItemEllipse*, QChildEvent*);
    using QCPItemEllipse_CustomEvent_Callback = void (*)(QCPItemEllipse*, QEvent*);
    using QCPItemEllipse_ConnectNotify_Callback = void (*)(QCPItemEllipse*, QMetaMethod*);
    using QCPItemEllipse_DisconnectNotify_Callback = void (*)(QCPItemEllipse*, QMetaMethod*);
    using QCPItemEllipse_MainPen_Callback = QPen* (*)();
    using QCPItemEllipse_MainBrush_Callback = QBrush* (*)();
    using QCPItemEllipse_RectDistance_Callback = double (*)(const QCPItemEllipse*, QRectF*, QPointF*, bool);
    using QCPItemEllipse_CreatePosition_Callback = QCPItemPosition* (*)(QCPItemEllipse*, libqt_string);
    using QCPItemEllipse_CreateAnchor_Callback = QCPItemAnchor* (*)(QCPItemEllipse*, libqt_string, int);
    using QCPItemEllipse_InitializeParentPlot_Callback = void (*)(QCPItemEllipse*, QCustomPlot*);
    using QCPItemEllipse_SetParentLayerable_Callback = void (*)(QCPItemEllipse*, QCPLayerable*);
    using QCPItemEllipse_MoveToLayer_Callback = bool (*)(QCPItemEllipse*, QCPLayer*, bool);
    using QCPItemEllipse_ApplyAntialiasingHint_Callback = void (*)(const QCPItemEllipse*, QCPPainter*, bool, int);
    using QCPItemEllipse_Sender_Callback = QObject* (*)();
    using QCPItemEllipse_SenderSignalIndex_Callback = int (*)();
    using QCPItemEllipse_Receivers_Callback = int (*)(const QCPItemEllipse*, const char*);
    using QCPItemEllipse_IsSignalConnected_Callback = bool (*)(const QCPItemEllipse*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPItemEllipse_Metacall_Callback qcpitemellipse_metacall_callback = nullptr;
    QCPItemEllipse_SelectTest_Callback qcpitemellipse_selecttest_callback = nullptr;
    QCPItemEllipse_Draw_Callback qcpitemellipse_draw_callback = nullptr;
    QCPItemEllipse_AnchorPixelPosition_Callback qcpitemellipse_anchorpixelposition_callback = nullptr;
    QCPItemEllipse_SelectionCategory_Callback qcpitemellipse_selectioncategory_callback = nullptr;
    QCPItemEllipse_ClipRect_Callback qcpitemellipse_cliprect_callback = nullptr;
    QCPItemEllipse_ApplyDefaultAntialiasingHint_Callback qcpitemellipse_applydefaultantialiasinghint_callback = nullptr;
    QCPItemEllipse_SelectEvent_Callback qcpitemellipse_selectevent_callback = nullptr;
    QCPItemEllipse_DeselectEvent_Callback qcpitemellipse_deselectevent_callback = nullptr;
    QCPItemEllipse_ParentPlotInitialized_Callback qcpitemellipse_parentplotinitialized_callback = nullptr;
    QCPItemEllipse_MousePressEvent_Callback qcpitemellipse_mousepressevent_callback = nullptr;
    QCPItemEllipse_MouseMoveEvent_Callback qcpitemellipse_mousemoveevent_callback = nullptr;
    QCPItemEllipse_MouseReleaseEvent_Callback qcpitemellipse_mousereleaseevent_callback = nullptr;
    QCPItemEllipse_MouseDoubleClickEvent_Callback qcpitemellipse_mousedoubleclickevent_callback = nullptr;
    QCPItemEllipse_WheelEvent_Callback qcpitemellipse_wheelevent_callback = nullptr;
    QCPItemEllipse_Event_Callback qcpitemellipse_event_callback = nullptr;
    QCPItemEllipse_EventFilter_Callback qcpitemellipse_eventfilter_callback = nullptr;
    QCPItemEllipse_TimerEvent_Callback qcpitemellipse_timerevent_callback = nullptr;
    QCPItemEllipse_ChildEvent_Callback qcpitemellipse_childevent_callback = nullptr;
    QCPItemEllipse_CustomEvent_Callback qcpitemellipse_customevent_callback = nullptr;
    QCPItemEllipse_ConnectNotify_Callback qcpitemellipse_connectnotify_callback = nullptr;
    QCPItemEllipse_DisconnectNotify_Callback qcpitemellipse_disconnectnotify_callback = nullptr;
    QCPItemEllipse_MainPen_Callback qcpitemellipse_mainpen_callback = nullptr;
    QCPItemEllipse_MainBrush_Callback qcpitemellipse_mainbrush_callback = nullptr;
    QCPItemEllipse_RectDistance_Callback qcpitemellipse_rectdistance_callback = nullptr;
    QCPItemEllipse_CreatePosition_Callback qcpitemellipse_createposition_callback = nullptr;
    QCPItemEllipse_CreateAnchor_Callback qcpitemellipse_createanchor_callback = nullptr;
    QCPItemEllipse_InitializeParentPlot_Callback qcpitemellipse_initializeparentplot_callback = nullptr;
    QCPItemEllipse_SetParentLayerable_Callback qcpitemellipse_setparentlayerable_callback = nullptr;
    QCPItemEllipse_MoveToLayer_Callback qcpitemellipse_movetolayer_callback = nullptr;
    QCPItemEllipse_ApplyAntialiasingHint_Callback qcpitemellipse_applyantialiasinghint_callback = nullptr;
    QCPItemEllipse_Sender_Callback qcpitemellipse_sender_callback = nullptr;
    QCPItemEllipse_SenderSignalIndex_Callback qcpitemellipse_sendersignalindex_callback = nullptr;
    QCPItemEllipse_Receivers_Callback qcpitemellipse_receivers_callback = nullptr;
    QCPItemEllipse_IsSignalConnected_Callback qcpitemellipse_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpitemellipse_metacall_isbase = false;
    mutable bool qcpitemellipse_selecttest_isbase = false;
    mutable bool qcpitemellipse_draw_isbase = false;
    mutable bool qcpitemellipse_anchorpixelposition_isbase = false;
    mutable bool qcpitemellipse_selectioncategory_isbase = false;
    mutable bool qcpitemellipse_cliprect_isbase = false;
    mutable bool qcpitemellipse_applydefaultantialiasinghint_isbase = false;
    mutable bool qcpitemellipse_selectevent_isbase = false;
    mutable bool qcpitemellipse_deselectevent_isbase = false;
    mutable bool qcpitemellipse_parentplotinitialized_isbase = false;
    mutable bool qcpitemellipse_mousepressevent_isbase = false;
    mutable bool qcpitemellipse_mousemoveevent_isbase = false;
    mutable bool qcpitemellipse_mousereleaseevent_isbase = false;
    mutable bool qcpitemellipse_mousedoubleclickevent_isbase = false;
    mutable bool qcpitemellipse_wheelevent_isbase = false;
    mutable bool qcpitemellipse_event_isbase = false;
    mutable bool qcpitemellipse_eventfilter_isbase = false;
    mutable bool qcpitemellipse_timerevent_isbase = false;
    mutable bool qcpitemellipse_childevent_isbase = false;
    mutable bool qcpitemellipse_customevent_isbase = false;
    mutable bool qcpitemellipse_connectnotify_isbase = false;
    mutable bool qcpitemellipse_disconnectnotify_isbase = false;
    mutable bool qcpitemellipse_mainpen_isbase = false;
    mutable bool qcpitemellipse_mainbrush_isbase = false;
    mutable bool qcpitemellipse_rectdistance_isbase = false;
    mutable bool qcpitemellipse_createposition_isbase = false;
    mutable bool qcpitemellipse_createanchor_isbase = false;
    mutable bool qcpitemellipse_initializeparentplot_isbase = false;
    mutable bool qcpitemellipse_setparentlayerable_isbase = false;
    mutable bool qcpitemellipse_movetolayer_isbase = false;
    mutable bool qcpitemellipse_applyantialiasinghint_isbase = false;
    mutable bool qcpitemellipse_sender_isbase = false;
    mutable bool qcpitemellipse_sendersignalindex_isbase = false;
    mutable bool qcpitemellipse_receivers_isbase = false;
    mutable bool qcpitemellipse_issignalconnected_isbase = false;

  public:
    VirtualQCPItemEllipse(QCustomPlot* parentPlot) : QCPItemEllipse(parentPlot) {};

    ~VirtualQCPItemEllipse() {
        qcpitemellipse_metacall_callback = nullptr;
        qcpitemellipse_selecttest_callback = nullptr;
        qcpitemellipse_draw_callback = nullptr;
        qcpitemellipse_anchorpixelposition_callback = nullptr;
        qcpitemellipse_selectioncategory_callback = nullptr;
        qcpitemellipse_cliprect_callback = nullptr;
        qcpitemellipse_applydefaultantialiasinghint_callback = nullptr;
        qcpitemellipse_selectevent_callback = nullptr;
        qcpitemellipse_deselectevent_callback = nullptr;
        qcpitemellipse_parentplotinitialized_callback = nullptr;
        qcpitemellipse_mousepressevent_callback = nullptr;
        qcpitemellipse_mousemoveevent_callback = nullptr;
        qcpitemellipse_mousereleaseevent_callback = nullptr;
        qcpitemellipse_mousedoubleclickevent_callback = nullptr;
        qcpitemellipse_wheelevent_callback = nullptr;
        qcpitemellipse_event_callback = nullptr;
        qcpitemellipse_eventfilter_callback = nullptr;
        qcpitemellipse_timerevent_callback = nullptr;
        qcpitemellipse_childevent_callback = nullptr;
        qcpitemellipse_customevent_callback = nullptr;
        qcpitemellipse_connectnotify_callback = nullptr;
        qcpitemellipse_disconnectnotify_callback = nullptr;
        qcpitemellipse_mainpen_callback = nullptr;
        qcpitemellipse_mainbrush_callback = nullptr;
        qcpitemellipse_rectdistance_callback = nullptr;
        qcpitemellipse_createposition_callback = nullptr;
        qcpitemellipse_createanchor_callback = nullptr;
        qcpitemellipse_initializeparentplot_callback = nullptr;
        qcpitemellipse_setparentlayerable_callback = nullptr;
        qcpitemellipse_movetolayer_callback = nullptr;
        qcpitemellipse_applyantialiasinghint_callback = nullptr;
        qcpitemellipse_sender_callback = nullptr;
        qcpitemellipse_sendersignalindex_callback = nullptr;
        qcpitemellipse_receivers_callback = nullptr;
        qcpitemellipse_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPItemEllipse_Metacall_Callback(QCPItemEllipse_Metacall_Callback cb) { qcpitemellipse_metacall_callback = cb; }
    inline void setQCPItemEllipse_SelectTest_Callback(QCPItemEllipse_SelectTest_Callback cb) { qcpitemellipse_selecttest_callback = cb; }
    inline void setQCPItemEllipse_Draw_Callback(QCPItemEllipse_Draw_Callback cb) { qcpitemellipse_draw_callback = cb; }
    inline void setQCPItemEllipse_AnchorPixelPosition_Callback(QCPItemEllipse_AnchorPixelPosition_Callback cb) { qcpitemellipse_anchorpixelposition_callback = cb; }
    inline void setQCPItemEllipse_SelectionCategory_Callback(QCPItemEllipse_SelectionCategory_Callback cb) { qcpitemellipse_selectioncategory_callback = cb; }
    inline void setQCPItemEllipse_ClipRect_Callback(QCPItemEllipse_ClipRect_Callback cb) { qcpitemellipse_cliprect_callback = cb; }
    inline void setQCPItemEllipse_ApplyDefaultAntialiasingHint_Callback(QCPItemEllipse_ApplyDefaultAntialiasingHint_Callback cb) { qcpitemellipse_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPItemEllipse_SelectEvent_Callback(QCPItemEllipse_SelectEvent_Callback cb) { qcpitemellipse_selectevent_callback = cb; }
    inline void setQCPItemEllipse_DeselectEvent_Callback(QCPItemEllipse_DeselectEvent_Callback cb) { qcpitemellipse_deselectevent_callback = cb; }
    inline void setQCPItemEllipse_ParentPlotInitialized_Callback(QCPItemEllipse_ParentPlotInitialized_Callback cb) { qcpitemellipse_parentplotinitialized_callback = cb; }
    inline void setQCPItemEllipse_MousePressEvent_Callback(QCPItemEllipse_MousePressEvent_Callback cb) { qcpitemellipse_mousepressevent_callback = cb; }
    inline void setQCPItemEllipse_MouseMoveEvent_Callback(QCPItemEllipse_MouseMoveEvent_Callback cb) { qcpitemellipse_mousemoveevent_callback = cb; }
    inline void setQCPItemEllipse_MouseReleaseEvent_Callback(QCPItemEllipse_MouseReleaseEvent_Callback cb) { qcpitemellipse_mousereleaseevent_callback = cb; }
    inline void setQCPItemEllipse_MouseDoubleClickEvent_Callback(QCPItemEllipse_MouseDoubleClickEvent_Callback cb) { qcpitemellipse_mousedoubleclickevent_callback = cb; }
    inline void setQCPItemEllipse_WheelEvent_Callback(QCPItemEllipse_WheelEvent_Callback cb) { qcpitemellipse_wheelevent_callback = cb; }
    inline void setQCPItemEllipse_Event_Callback(QCPItemEllipse_Event_Callback cb) { qcpitemellipse_event_callback = cb; }
    inline void setQCPItemEllipse_EventFilter_Callback(QCPItemEllipse_EventFilter_Callback cb) { qcpitemellipse_eventfilter_callback = cb; }
    inline void setQCPItemEllipse_TimerEvent_Callback(QCPItemEllipse_TimerEvent_Callback cb) { qcpitemellipse_timerevent_callback = cb; }
    inline void setQCPItemEllipse_ChildEvent_Callback(QCPItemEllipse_ChildEvent_Callback cb) { qcpitemellipse_childevent_callback = cb; }
    inline void setQCPItemEllipse_CustomEvent_Callback(QCPItemEllipse_CustomEvent_Callback cb) { qcpitemellipse_customevent_callback = cb; }
    inline void setQCPItemEllipse_ConnectNotify_Callback(QCPItemEllipse_ConnectNotify_Callback cb) { qcpitemellipse_connectnotify_callback = cb; }
    inline void setQCPItemEllipse_DisconnectNotify_Callback(QCPItemEllipse_DisconnectNotify_Callback cb) { qcpitemellipse_disconnectnotify_callback = cb; }
    inline void setQCPItemEllipse_MainPen_Callback(QCPItemEllipse_MainPen_Callback cb) { qcpitemellipse_mainpen_callback = cb; }
    inline void setQCPItemEllipse_MainBrush_Callback(QCPItemEllipse_MainBrush_Callback cb) { qcpitemellipse_mainbrush_callback = cb; }
    inline void setQCPItemEllipse_RectDistance_Callback(QCPItemEllipse_RectDistance_Callback cb) { qcpitemellipse_rectdistance_callback = cb; }
    inline void setQCPItemEllipse_CreatePosition_Callback(QCPItemEllipse_CreatePosition_Callback cb) { qcpitemellipse_createposition_callback = cb; }
    inline void setQCPItemEllipse_CreateAnchor_Callback(QCPItemEllipse_CreateAnchor_Callback cb) { qcpitemellipse_createanchor_callback = cb; }
    inline void setQCPItemEllipse_InitializeParentPlot_Callback(QCPItemEllipse_InitializeParentPlot_Callback cb) { qcpitemellipse_initializeparentplot_callback = cb; }
    inline void setQCPItemEllipse_SetParentLayerable_Callback(QCPItemEllipse_SetParentLayerable_Callback cb) { qcpitemellipse_setparentlayerable_callback = cb; }
    inline void setQCPItemEllipse_MoveToLayer_Callback(QCPItemEllipse_MoveToLayer_Callback cb) { qcpitemellipse_movetolayer_callback = cb; }
    inline void setQCPItemEllipse_ApplyAntialiasingHint_Callback(QCPItemEllipse_ApplyAntialiasingHint_Callback cb) { qcpitemellipse_applyantialiasinghint_callback = cb; }
    inline void setQCPItemEllipse_Sender_Callback(QCPItemEllipse_Sender_Callback cb) { qcpitemellipse_sender_callback = cb; }
    inline void setQCPItemEllipse_SenderSignalIndex_Callback(QCPItemEllipse_SenderSignalIndex_Callback cb) { qcpitemellipse_sendersignalindex_callback = cb; }
    inline void setQCPItemEllipse_Receivers_Callback(QCPItemEllipse_Receivers_Callback cb) { qcpitemellipse_receivers_callback = cb; }
    inline void setQCPItemEllipse_IsSignalConnected_Callback(QCPItemEllipse_IsSignalConnected_Callback cb) { qcpitemellipse_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPItemEllipse_Metacall_IsBase(bool value) const { qcpitemellipse_metacall_isbase = value; }
    inline void setQCPItemEllipse_SelectTest_IsBase(bool value) const { qcpitemellipse_selecttest_isbase = value; }
    inline void setQCPItemEllipse_Draw_IsBase(bool value) const { qcpitemellipse_draw_isbase = value; }
    inline void setQCPItemEllipse_AnchorPixelPosition_IsBase(bool value) const { qcpitemellipse_anchorpixelposition_isbase = value; }
    inline void setQCPItemEllipse_SelectionCategory_IsBase(bool value) const { qcpitemellipse_selectioncategory_isbase = value; }
    inline void setQCPItemEllipse_ClipRect_IsBase(bool value) const { qcpitemellipse_cliprect_isbase = value; }
    inline void setQCPItemEllipse_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcpitemellipse_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPItemEllipse_SelectEvent_IsBase(bool value) const { qcpitemellipse_selectevent_isbase = value; }
    inline void setQCPItemEllipse_DeselectEvent_IsBase(bool value) const { qcpitemellipse_deselectevent_isbase = value; }
    inline void setQCPItemEllipse_ParentPlotInitialized_IsBase(bool value) const { qcpitemellipse_parentplotinitialized_isbase = value; }
    inline void setQCPItemEllipse_MousePressEvent_IsBase(bool value) const { qcpitemellipse_mousepressevent_isbase = value; }
    inline void setQCPItemEllipse_MouseMoveEvent_IsBase(bool value) const { qcpitemellipse_mousemoveevent_isbase = value; }
    inline void setQCPItemEllipse_MouseReleaseEvent_IsBase(bool value) const { qcpitemellipse_mousereleaseevent_isbase = value; }
    inline void setQCPItemEllipse_MouseDoubleClickEvent_IsBase(bool value) const { qcpitemellipse_mousedoubleclickevent_isbase = value; }
    inline void setQCPItemEllipse_WheelEvent_IsBase(bool value) const { qcpitemellipse_wheelevent_isbase = value; }
    inline void setQCPItemEllipse_Event_IsBase(bool value) const { qcpitemellipse_event_isbase = value; }
    inline void setQCPItemEllipse_EventFilter_IsBase(bool value) const { qcpitemellipse_eventfilter_isbase = value; }
    inline void setQCPItemEllipse_TimerEvent_IsBase(bool value) const { qcpitemellipse_timerevent_isbase = value; }
    inline void setQCPItemEllipse_ChildEvent_IsBase(bool value) const { qcpitemellipse_childevent_isbase = value; }
    inline void setQCPItemEllipse_CustomEvent_IsBase(bool value) const { qcpitemellipse_customevent_isbase = value; }
    inline void setQCPItemEllipse_ConnectNotify_IsBase(bool value) const { qcpitemellipse_connectnotify_isbase = value; }
    inline void setQCPItemEllipse_DisconnectNotify_IsBase(bool value) const { qcpitemellipse_disconnectnotify_isbase = value; }
    inline void setQCPItemEllipse_MainPen_IsBase(bool value) const { qcpitemellipse_mainpen_isbase = value; }
    inline void setQCPItemEllipse_MainBrush_IsBase(bool value) const { qcpitemellipse_mainbrush_isbase = value; }
    inline void setQCPItemEllipse_RectDistance_IsBase(bool value) const { qcpitemellipse_rectdistance_isbase = value; }
    inline void setQCPItemEllipse_CreatePosition_IsBase(bool value) const { qcpitemellipse_createposition_isbase = value; }
    inline void setQCPItemEllipse_CreateAnchor_IsBase(bool value) const { qcpitemellipse_createanchor_isbase = value; }
    inline void setQCPItemEllipse_InitializeParentPlot_IsBase(bool value) const { qcpitemellipse_initializeparentplot_isbase = value; }
    inline void setQCPItemEllipse_SetParentLayerable_IsBase(bool value) const { qcpitemellipse_setparentlayerable_isbase = value; }
    inline void setQCPItemEllipse_MoveToLayer_IsBase(bool value) const { qcpitemellipse_movetolayer_isbase = value; }
    inline void setQCPItemEllipse_ApplyAntialiasingHint_IsBase(bool value) const { qcpitemellipse_applyantialiasinghint_isbase = value; }
    inline void setQCPItemEllipse_Sender_IsBase(bool value) const { qcpitemellipse_sender_isbase = value; }
    inline void setQCPItemEllipse_SenderSignalIndex_IsBase(bool value) const { qcpitemellipse_sendersignalindex_isbase = value; }
    inline void setQCPItemEllipse_Receivers_IsBase(bool value) const { qcpitemellipse_receivers_isbase = value; }
    inline void setQCPItemEllipse_IsSignalConnected_IsBase(bool value) const { qcpitemellipse_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpitemellipse_metacall_isbase) {
            qcpitemellipse_metacall_isbase = false;
            return QCPItemEllipse::qt_metacall(param1, param2, param3);
        } else if (qcpitemellipse_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpitemellipse_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemEllipse::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcpitemellipse_selecttest_isbase) {
            qcpitemellipse_selecttest_isbase = false;
            return QCPItemEllipse::selectTest(pos, onlySelectable, details);
        } else if (qcpitemellipse_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcpitemellipse_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPItemEllipse::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcpitemellipse_draw_isbase) {
            qcpitemellipse_draw_isbase = false;
            QCPItemEllipse::draw(painter);
        } else if (qcpitemellipse_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpitemellipse_draw_callback(this, cbval1);
        } else {
            QCPItemEllipse::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QPointF anchorPixelPosition(int anchorId) const override {
        if (qcpitemellipse_anchorpixelposition_isbase) {
            qcpitemellipse_anchorpixelposition_isbase = false;
            return QCPItemEllipse::anchorPixelPosition(anchorId);
        } else if (qcpitemellipse_anchorpixelposition_callback != nullptr) {
            int cbval1 = anchorId;

            QPointF* callback_ret = qcpitemellipse_anchorpixelposition_callback(this, cbval1);
            return *callback_ret;
        } else {
            return QCPItemEllipse::anchorPixelPosition(anchorId);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcpitemellipse_selectioncategory_isbase) {
            qcpitemellipse_selectioncategory_isbase = false;
            return QCPItemEllipse::selectionCategory();
        } else if (qcpitemellipse_selectioncategory_callback != nullptr) {
            int callback_ret = qcpitemellipse_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPItemEllipse::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcpitemellipse_cliprect_isbase) {
            qcpitemellipse_cliprect_isbase = false;
            return QCPItemEllipse::clipRect();
        } else if (qcpitemellipse_cliprect_callback != nullptr) {
            QRect* callback_ret = qcpitemellipse_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPItemEllipse::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcpitemellipse_applydefaultantialiasinghint_isbase) {
            qcpitemellipse_applydefaultantialiasinghint_isbase = false;
            QCPItemEllipse::applyDefaultAntialiasingHint(painter);
        } else if (qcpitemellipse_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpitemellipse_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPItemEllipse::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcpitemellipse_selectevent_isbase) {
            qcpitemellipse_selectevent_isbase = false;
            QCPItemEllipse::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcpitemellipse_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcpitemellipse_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPItemEllipse::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcpitemellipse_deselectevent_isbase) {
            qcpitemellipse_deselectevent_isbase = false;
            QCPItemEllipse::deselectEvent(selectionStateChanged);
        } else if (qcpitemellipse_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcpitemellipse_deselectevent_callback(this, cbval1);
        } else {
            QCPItemEllipse::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcpitemellipse_parentplotinitialized_isbase) {
            qcpitemellipse_parentplotinitialized_isbase = false;
            QCPItemEllipse::parentPlotInitialized(parentPlot);
        } else if (qcpitemellipse_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpitemellipse_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPItemEllipse::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpitemellipse_mousepressevent_isbase) {
            qcpitemellipse_mousepressevent_isbase = false;
            QCPItemEllipse::mousePressEvent(event, details);
        } else if (qcpitemellipse_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpitemellipse_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemEllipse::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpitemellipse_mousemoveevent_isbase) {
            qcpitemellipse_mousemoveevent_isbase = false;
            QCPItemEllipse::mouseMoveEvent(event, startPos);
        } else if (qcpitemellipse_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpitemellipse_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemEllipse::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpitemellipse_mousereleaseevent_isbase) {
            qcpitemellipse_mousereleaseevent_isbase = false;
            QCPItemEllipse::mouseReleaseEvent(event, startPos);
        } else if (qcpitemellipse_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpitemellipse_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemEllipse::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpitemellipse_mousedoubleclickevent_isbase) {
            qcpitemellipse_mousedoubleclickevent_isbase = false;
            QCPItemEllipse::mouseDoubleClickEvent(event, details);
        } else if (qcpitemellipse_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpitemellipse_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemEllipse::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcpitemellipse_wheelevent_isbase) {
            qcpitemellipse_wheelevent_isbase = false;
            QCPItemEllipse::wheelEvent(event);
        } else if (qcpitemellipse_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcpitemellipse_wheelevent_callback(this, cbval1);
        } else {
            QCPItemEllipse::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpitemellipse_event_isbase) {
            qcpitemellipse_event_isbase = false;
            return QCPItemEllipse::event(event);
        } else if (qcpitemellipse_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpitemellipse_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemEllipse::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpitemellipse_eventfilter_isbase) {
            qcpitemellipse_eventfilter_isbase = false;
            return QCPItemEllipse::eventFilter(watched, event);
        } else if (qcpitemellipse_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpitemellipse_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemEllipse::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpitemellipse_timerevent_isbase) {
            qcpitemellipse_timerevent_isbase = false;
            QCPItemEllipse::timerEvent(event);
        } else if (qcpitemellipse_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpitemellipse_timerevent_callback(this, cbval1);
        } else {
            QCPItemEllipse::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpitemellipse_childevent_isbase) {
            qcpitemellipse_childevent_isbase = false;
            QCPItemEllipse::childEvent(event);
        } else if (qcpitemellipse_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpitemellipse_childevent_callback(this, cbval1);
        } else {
            QCPItemEllipse::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpitemellipse_customevent_isbase) {
            qcpitemellipse_customevent_isbase = false;
            QCPItemEllipse::customEvent(event);
        } else if (qcpitemellipse_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpitemellipse_customevent_callback(this, cbval1);
        } else {
            QCPItemEllipse::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpitemellipse_connectnotify_isbase) {
            qcpitemellipse_connectnotify_isbase = false;
            QCPItemEllipse::connectNotify(signal);
        } else if (qcpitemellipse_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpitemellipse_connectnotify_callback(this, cbval1);
        } else {
            QCPItemEllipse::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpitemellipse_disconnectnotify_isbase) {
            qcpitemellipse_disconnectnotify_isbase = false;
            QCPItemEllipse::disconnectNotify(signal);
        } else if (qcpitemellipse_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpitemellipse_disconnectnotify_callback(this, cbval1);
        } else {
            QCPItemEllipse::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    QPen mainPen() const {
        if (qcpitemellipse_mainpen_isbase) {
            qcpitemellipse_mainpen_isbase = false;
            return QCPItemEllipse::mainPen();
        } else if (qcpitemellipse_mainpen_callback != nullptr) {
            QPen* callback_ret = qcpitemellipse_mainpen_callback();
            return *callback_ret;
        } else {
            return QCPItemEllipse::mainPen();
        }
    }

    // Virtual method for C ABI access and custom callback
    QBrush mainBrush() const {
        if (qcpitemellipse_mainbrush_isbase) {
            qcpitemellipse_mainbrush_isbase = false;
            return QCPItemEllipse::mainBrush();
        } else if (qcpitemellipse_mainbrush_callback != nullptr) {
            QBrush* callback_ret = qcpitemellipse_mainbrush_callback();
            return *callback_ret;
        } else {
            return QCPItemEllipse::mainBrush();
        }
    }

    // Virtual method for C ABI access and custom callback
    double rectDistance(const QRectF& rect, const QPointF& pos, bool filledRect) const {
        if (qcpitemellipse_rectdistance_isbase) {
            qcpitemellipse_rectdistance_isbase = false;
            return QCPItemEllipse::rectDistance(rect, pos, filledRect);
        } else if (qcpitemellipse_rectdistance_callback != nullptr) {
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval1 = const_cast<QRectF*>(&rect_ret);
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&pos_ret);
            bool cbval3 = filledRect;

            double callback_ret = qcpitemellipse_rectdistance_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPItemEllipse::rectDistance(rect, pos, filledRect);
        }
    }

    // Virtual method for C ABI access and custom callback
    QCPItemPosition* createPosition(const QString& name) {
        if (qcpitemellipse_createposition_isbase) {
            qcpitemellipse_createposition_isbase = false;
            return QCPItemEllipse::createPosition(name);
        } else if (qcpitemellipse_createposition_callback != nullptr) {
            const QString name_ret = name;
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray name_b = name_ret.toUtf8();
            libqt_string name_str;
            name_str.len = name_b.length();
            name_str.data = static_cast<const char*>(malloc(name_str.len + 1));
            memcpy((void*)name_str.data, name_b.data(), name_str.len);
            ((char*)name_str.data)[name_str.len] = '\0';
            libqt_string cbval1 = name_str;

            QCPItemPosition* callback_ret = qcpitemellipse_createposition_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemEllipse::createPosition(name);
        }
    }

    // Virtual method for C ABI access and custom callback
    QCPItemAnchor* createAnchor(const QString& name, int anchorId) {
        if (qcpitemellipse_createanchor_isbase) {
            qcpitemellipse_createanchor_isbase = false;
            return QCPItemEllipse::createAnchor(name, anchorId);
        } else if (qcpitemellipse_createanchor_callback != nullptr) {
            const QString name_ret = name;
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray name_b = name_ret.toUtf8();
            libqt_string name_str;
            name_str.len = name_b.length();
            name_str.data = static_cast<const char*>(malloc(name_str.len + 1));
            memcpy((void*)name_str.data, name_b.data(), name_str.len);
            ((char*)name_str.data)[name_str.len] = '\0';
            libqt_string cbval1 = name_str;
            int cbval2 = anchorId;

            QCPItemAnchor* callback_ret = qcpitemellipse_createanchor_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemEllipse::createAnchor(name, anchorId);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcpitemellipse_initializeparentplot_isbase) {
            qcpitemellipse_initializeparentplot_isbase = false;
            QCPItemEllipse::initializeParentPlot(parentPlot);
        } else if (qcpitemellipse_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpitemellipse_initializeparentplot_callback(this, cbval1);
        } else {
            QCPItemEllipse::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcpitemellipse_setparentlayerable_isbase) {
            qcpitemellipse_setparentlayerable_isbase = false;
            QCPItemEllipse::setParentLayerable(parentLayerable);
        } else if (qcpitemellipse_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcpitemellipse_setparentlayerable_callback(this, cbval1);
        } else {
            QCPItemEllipse::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcpitemellipse_movetolayer_isbase) {
            qcpitemellipse_movetolayer_isbase = false;
            return QCPItemEllipse::moveToLayer(layer, prepend);
        } else if (qcpitemellipse_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcpitemellipse_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemEllipse::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcpitemellipse_applyantialiasinghint_isbase) {
            qcpitemellipse_applyantialiasinghint_isbase = false;
            QCPItemEllipse::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcpitemellipse_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcpitemellipse_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPItemEllipse::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpitemellipse_sender_isbase) {
            qcpitemellipse_sender_isbase = false;
            return QCPItemEllipse::sender();
        } else if (qcpitemellipse_sender_callback != nullptr) {
            QObject* callback_ret = qcpitemellipse_sender_callback();
            return callback_ret;
        } else {
            return QCPItemEllipse::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpitemellipse_sendersignalindex_isbase) {
            qcpitemellipse_sendersignalindex_isbase = false;
            return QCPItemEllipse::senderSignalIndex();
        } else if (qcpitemellipse_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpitemellipse_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemEllipse::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpitemellipse_receivers_isbase) {
            qcpitemellipse_receivers_isbase = false;
            return QCPItemEllipse::receivers(signal);
        } else if (qcpitemellipse_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpitemellipse_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemEllipse::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpitemellipse_issignalconnected_isbase) {
            qcpitemellipse_issignalconnected_isbase = false;
            return QCPItemEllipse::isSignalConnected(signal);
        } else if (qcpitemellipse_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpitemellipse_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemEllipse::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPItemEllipse_Draw(QCPItemEllipse* self, QCPPainter* painter);
    friend void QCPItemEllipse_QBaseDraw(QCPItemEllipse* self, QCPPainter* painter);
    friend QPointF* QCPItemEllipse_AnchorPixelPosition(const QCPItemEllipse* self, int anchorId);
    friend QPointF* QCPItemEllipse_QBaseAnchorPixelPosition(const QCPItemEllipse* self, int anchorId);
    friend int QCPItemEllipse_SelectionCategory(const QCPItemEllipse* self);
    friend int QCPItemEllipse_QBaseSelectionCategory(const QCPItemEllipse* self);
    friend QRect* QCPItemEllipse_ClipRect(const QCPItemEllipse* self);
    friend QRect* QCPItemEllipse_QBaseClipRect(const QCPItemEllipse* self);
    friend void QCPItemEllipse_ApplyDefaultAntialiasingHint(const QCPItemEllipse* self, QCPPainter* painter);
    friend void QCPItemEllipse_QBaseApplyDefaultAntialiasingHint(const QCPItemEllipse* self, QCPPainter* painter);
    friend void QCPItemEllipse_SelectEvent(QCPItemEllipse* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPItemEllipse_QBaseSelectEvent(QCPItemEllipse* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPItemEllipse_DeselectEvent(QCPItemEllipse* self, bool* selectionStateChanged);
    friend void QCPItemEllipse_QBaseDeselectEvent(QCPItemEllipse* self, bool* selectionStateChanged);
    friend void QCPItemEllipse_ParentPlotInitialized(QCPItemEllipse* self, QCustomPlot* parentPlot);
    friend void QCPItemEllipse_QBaseParentPlotInitialized(QCPItemEllipse* self, QCustomPlot* parentPlot);
    friend void QCPItemEllipse_MousePressEvent(QCPItemEllipse* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemEllipse_QBaseMousePressEvent(QCPItemEllipse* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemEllipse_MouseMoveEvent(QCPItemEllipse* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemEllipse_QBaseMouseMoveEvent(QCPItemEllipse* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemEllipse_MouseReleaseEvent(QCPItemEllipse* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemEllipse_QBaseMouseReleaseEvent(QCPItemEllipse* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemEllipse_MouseDoubleClickEvent(QCPItemEllipse* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemEllipse_QBaseMouseDoubleClickEvent(QCPItemEllipse* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemEllipse_WheelEvent(QCPItemEllipse* self, QWheelEvent* event);
    friend void QCPItemEllipse_QBaseWheelEvent(QCPItemEllipse* self, QWheelEvent* event);
    friend void QCPItemEllipse_TimerEvent(QCPItemEllipse* self, QTimerEvent* event);
    friend void QCPItemEllipse_QBaseTimerEvent(QCPItemEllipse* self, QTimerEvent* event);
    friend void QCPItemEllipse_ChildEvent(QCPItemEllipse* self, QChildEvent* event);
    friend void QCPItemEllipse_QBaseChildEvent(QCPItemEllipse* self, QChildEvent* event);
    friend void QCPItemEllipse_CustomEvent(QCPItemEllipse* self, QEvent* event);
    friend void QCPItemEllipse_QBaseCustomEvent(QCPItemEllipse* self, QEvent* event);
    friend void QCPItemEllipse_ConnectNotify(QCPItemEllipse* self, const QMetaMethod* signal);
    friend void QCPItemEllipse_QBaseConnectNotify(QCPItemEllipse* self, const QMetaMethod* signal);
    friend void QCPItemEllipse_DisconnectNotify(QCPItemEllipse* self, const QMetaMethod* signal);
    friend void QCPItemEllipse_QBaseDisconnectNotify(QCPItemEllipse* self, const QMetaMethod* signal);
    friend QPen* QCPItemEllipse_MainPen(const QCPItemEllipse* self);
    friend QPen* QCPItemEllipse_QBaseMainPen(const QCPItemEllipse* self);
    friend QBrush* QCPItemEllipse_MainBrush(const QCPItemEllipse* self);
    friend QBrush* QCPItemEllipse_QBaseMainBrush(const QCPItemEllipse* self);
    friend double QCPItemEllipse_RectDistance(const QCPItemEllipse* self, const QRectF* rect, const QPointF* pos, bool filledRect);
    friend double QCPItemEllipse_QBaseRectDistance(const QCPItemEllipse* self, const QRectF* rect, const QPointF* pos, bool filledRect);
    friend QCPItemPosition* QCPItemEllipse_CreatePosition(QCPItemEllipse* self, const libqt_string name);
    friend QCPItemPosition* QCPItemEllipse_QBaseCreatePosition(QCPItemEllipse* self, const libqt_string name);
    friend QCPItemAnchor* QCPItemEllipse_CreateAnchor(QCPItemEllipse* self, const libqt_string name, int anchorId);
    friend QCPItemAnchor* QCPItemEllipse_QBaseCreateAnchor(QCPItemEllipse* self, const libqt_string name, int anchorId);
    friend void QCPItemEllipse_InitializeParentPlot(QCPItemEllipse* self, QCustomPlot* parentPlot);
    friend void QCPItemEllipse_QBaseInitializeParentPlot(QCPItemEllipse* self, QCustomPlot* parentPlot);
    friend void QCPItemEllipse_SetParentLayerable(QCPItemEllipse* self, QCPLayerable* parentLayerable);
    friend void QCPItemEllipse_QBaseSetParentLayerable(QCPItemEllipse* self, QCPLayerable* parentLayerable);
    friend bool QCPItemEllipse_MoveToLayer(QCPItemEllipse* self, QCPLayer* layer, bool prepend);
    friend bool QCPItemEllipse_QBaseMoveToLayer(QCPItemEllipse* self, QCPLayer* layer, bool prepend);
    friend void QCPItemEllipse_ApplyAntialiasingHint(const QCPItemEllipse* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPItemEllipse_QBaseApplyAntialiasingHint(const QCPItemEllipse* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPItemEllipse_Sender(const QCPItemEllipse* self);
    friend QObject* QCPItemEllipse_QBaseSender(const QCPItemEllipse* self);
    friend int QCPItemEllipse_SenderSignalIndex(const QCPItemEllipse* self);
    friend int QCPItemEllipse_QBaseSenderSignalIndex(const QCPItemEllipse* self);
    friend int QCPItemEllipse_Receivers(const QCPItemEllipse* self, const char* signal);
    friend int QCPItemEllipse_QBaseReceivers(const QCPItemEllipse* self, const char* signal);
    friend bool QCPItemEllipse_IsSignalConnected(const QCPItemEllipse* self, const QMetaMethod* signal);
    friend bool QCPItemEllipse_QBaseIsSignalConnected(const QCPItemEllipse* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPItemPixmap so that we can call protected methods
class VirtualQCPItemPixmap final : public QCPItemPixmap {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPItemPixmap = true;

    // Virtual class public types (including callbacks)
    using QCPItemPixmap::AnchorIndex;
    using QCPItemPixmap_Metacall_Callback = int (*)(QCPItemPixmap*, int, int, void**);
    using QCPItemPixmap_SelectTest_Callback = double (*)(const QCPItemPixmap*, QPointF*, bool, QVariant*);
    using QCPItemPixmap_Draw_Callback = void (*)(QCPItemPixmap*, QCPPainter*);
    using QCPItemPixmap_AnchorPixelPosition_Callback = QPointF* (*)(const QCPItemPixmap*, int);
    using QCPItemPixmap_SelectionCategory_Callback = int (*)();
    using QCPItemPixmap_ClipRect_Callback = QRect* (*)();
    using QCPItemPixmap_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPItemPixmap*, QCPPainter*);
    using QCPItemPixmap_SelectEvent_Callback = void (*)(QCPItemPixmap*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPItemPixmap_DeselectEvent_Callback = void (*)(QCPItemPixmap*, bool*);
    using QCPItemPixmap_ParentPlotInitialized_Callback = void (*)(QCPItemPixmap*, QCustomPlot*);
    using QCPItemPixmap_MousePressEvent_Callback = void (*)(QCPItemPixmap*, QMouseEvent*, QVariant*);
    using QCPItemPixmap_MouseMoveEvent_Callback = void (*)(QCPItemPixmap*, QMouseEvent*, QPointF*);
    using QCPItemPixmap_MouseReleaseEvent_Callback = void (*)(QCPItemPixmap*, QMouseEvent*, QPointF*);
    using QCPItemPixmap_MouseDoubleClickEvent_Callback = void (*)(QCPItemPixmap*, QMouseEvent*, QVariant*);
    using QCPItemPixmap_WheelEvent_Callback = void (*)(QCPItemPixmap*, QWheelEvent*);
    using QCPItemPixmap_Event_Callback = bool (*)(QCPItemPixmap*, QEvent*);
    using QCPItemPixmap_EventFilter_Callback = bool (*)(QCPItemPixmap*, QObject*, QEvent*);
    using QCPItemPixmap_TimerEvent_Callback = void (*)(QCPItemPixmap*, QTimerEvent*);
    using QCPItemPixmap_ChildEvent_Callback = void (*)(QCPItemPixmap*, QChildEvent*);
    using QCPItemPixmap_CustomEvent_Callback = void (*)(QCPItemPixmap*, QEvent*);
    using QCPItemPixmap_ConnectNotify_Callback = void (*)(QCPItemPixmap*, QMetaMethod*);
    using QCPItemPixmap_DisconnectNotify_Callback = void (*)(QCPItemPixmap*, QMetaMethod*);
    using QCPItemPixmap_UpdateScaledPixmap_Callback = void (*)();
    using QCPItemPixmap_GetFinalRect_Callback = QRect* (*)();
    using QCPItemPixmap_MainPen_Callback = QPen* (*)();
    using QCPItemPixmap_UpdateScaledPixmap1_Callback = void (*)(QCPItemPixmap*, QRect*);
    using QCPItemPixmap_UpdateScaledPixmap2_Callback = void (*)(QCPItemPixmap*, QRect*, bool);
    using QCPItemPixmap_UpdateScaledPixmap3_Callback = void (*)(QCPItemPixmap*, QRect*, bool, bool);
    using QCPItemPixmap_GetFinalRect1_Callback = QRect* (*)(const QCPItemPixmap*, bool*);
    using QCPItemPixmap_GetFinalRect2_Callback = QRect* (*)(const QCPItemPixmap*, bool*, bool*);
    using QCPItemPixmap_RectDistance_Callback = double (*)(const QCPItemPixmap*, QRectF*, QPointF*, bool);
    using QCPItemPixmap_CreatePosition_Callback = QCPItemPosition* (*)(QCPItemPixmap*, libqt_string);
    using QCPItemPixmap_CreateAnchor_Callback = QCPItemAnchor* (*)(QCPItemPixmap*, libqt_string, int);
    using QCPItemPixmap_InitializeParentPlot_Callback = void (*)(QCPItemPixmap*, QCustomPlot*);
    using QCPItemPixmap_SetParentLayerable_Callback = void (*)(QCPItemPixmap*, QCPLayerable*);
    using QCPItemPixmap_MoveToLayer_Callback = bool (*)(QCPItemPixmap*, QCPLayer*, bool);
    using QCPItemPixmap_ApplyAntialiasingHint_Callback = void (*)(const QCPItemPixmap*, QCPPainter*, bool, int);
    using QCPItemPixmap_Sender_Callback = QObject* (*)();
    using QCPItemPixmap_SenderSignalIndex_Callback = int (*)();
    using QCPItemPixmap_Receivers_Callback = int (*)(const QCPItemPixmap*, const char*);
    using QCPItemPixmap_IsSignalConnected_Callback = bool (*)(const QCPItemPixmap*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPItemPixmap_Metacall_Callback qcpitempixmap_metacall_callback = nullptr;
    QCPItemPixmap_SelectTest_Callback qcpitempixmap_selecttest_callback = nullptr;
    QCPItemPixmap_Draw_Callback qcpitempixmap_draw_callback = nullptr;
    QCPItemPixmap_AnchorPixelPosition_Callback qcpitempixmap_anchorpixelposition_callback = nullptr;
    QCPItemPixmap_SelectionCategory_Callback qcpitempixmap_selectioncategory_callback = nullptr;
    QCPItemPixmap_ClipRect_Callback qcpitempixmap_cliprect_callback = nullptr;
    QCPItemPixmap_ApplyDefaultAntialiasingHint_Callback qcpitempixmap_applydefaultantialiasinghint_callback = nullptr;
    QCPItemPixmap_SelectEvent_Callback qcpitempixmap_selectevent_callback = nullptr;
    QCPItemPixmap_DeselectEvent_Callback qcpitempixmap_deselectevent_callback = nullptr;
    QCPItemPixmap_ParentPlotInitialized_Callback qcpitempixmap_parentplotinitialized_callback = nullptr;
    QCPItemPixmap_MousePressEvent_Callback qcpitempixmap_mousepressevent_callback = nullptr;
    QCPItemPixmap_MouseMoveEvent_Callback qcpitempixmap_mousemoveevent_callback = nullptr;
    QCPItemPixmap_MouseReleaseEvent_Callback qcpitempixmap_mousereleaseevent_callback = nullptr;
    QCPItemPixmap_MouseDoubleClickEvent_Callback qcpitempixmap_mousedoubleclickevent_callback = nullptr;
    QCPItemPixmap_WheelEvent_Callback qcpitempixmap_wheelevent_callback = nullptr;
    QCPItemPixmap_Event_Callback qcpitempixmap_event_callback = nullptr;
    QCPItemPixmap_EventFilter_Callback qcpitempixmap_eventfilter_callback = nullptr;
    QCPItemPixmap_TimerEvent_Callback qcpitempixmap_timerevent_callback = nullptr;
    QCPItemPixmap_ChildEvent_Callback qcpitempixmap_childevent_callback = nullptr;
    QCPItemPixmap_CustomEvent_Callback qcpitempixmap_customevent_callback = nullptr;
    QCPItemPixmap_ConnectNotify_Callback qcpitempixmap_connectnotify_callback = nullptr;
    QCPItemPixmap_DisconnectNotify_Callback qcpitempixmap_disconnectnotify_callback = nullptr;
    QCPItemPixmap_UpdateScaledPixmap_Callback qcpitempixmap_updatescaledpixmap_callback = nullptr;
    QCPItemPixmap_GetFinalRect_Callback qcpitempixmap_getfinalrect_callback = nullptr;
    QCPItemPixmap_MainPen_Callback qcpitempixmap_mainpen_callback = nullptr;
    QCPItemPixmap_UpdateScaledPixmap1_Callback qcpitempixmap_updatescaledpixmap1_callback = nullptr;
    QCPItemPixmap_UpdateScaledPixmap2_Callback qcpitempixmap_updatescaledpixmap2_callback = nullptr;
    QCPItemPixmap_UpdateScaledPixmap3_Callback qcpitempixmap_updatescaledpixmap3_callback = nullptr;
    QCPItemPixmap_GetFinalRect1_Callback qcpitempixmap_getfinalrect1_callback = nullptr;
    QCPItemPixmap_GetFinalRect2_Callback qcpitempixmap_getfinalrect2_callback = nullptr;
    QCPItemPixmap_RectDistance_Callback qcpitempixmap_rectdistance_callback = nullptr;
    QCPItemPixmap_CreatePosition_Callback qcpitempixmap_createposition_callback = nullptr;
    QCPItemPixmap_CreateAnchor_Callback qcpitempixmap_createanchor_callback = nullptr;
    QCPItemPixmap_InitializeParentPlot_Callback qcpitempixmap_initializeparentplot_callback = nullptr;
    QCPItemPixmap_SetParentLayerable_Callback qcpitempixmap_setparentlayerable_callback = nullptr;
    QCPItemPixmap_MoveToLayer_Callback qcpitempixmap_movetolayer_callback = nullptr;
    QCPItemPixmap_ApplyAntialiasingHint_Callback qcpitempixmap_applyantialiasinghint_callback = nullptr;
    QCPItemPixmap_Sender_Callback qcpitempixmap_sender_callback = nullptr;
    QCPItemPixmap_SenderSignalIndex_Callback qcpitempixmap_sendersignalindex_callback = nullptr;
    QCPItemPixmap_Receivers_Callback qcpitempixmap_receivers_callback = nullptr;
    QCPItemPixmap_IsSignalConnected_Callback qcpitempixmap_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpitempixmap_metacall_isbase = false;
    mutable bool qcpitempixmap_selecttest_isbase = false;
    mutable bool qcpitempixmap_draw_isbase = false;
    mutable bool qcpitempixmap_anchorpixelposition_isbase = false;
    mutable bool qcpitempixmap_selectioncategory_isbase = false;
    mutable bool qcpitempixmap_cliprect_isbase = false;
    mutable bool qcpitempixmap_applydefaultantialiasinghint_isbase = false;
    mutable bool qcpitempixmap_selectevent_isbase = false;
    mutable bool qcpitempixmap_deselectevent_isbase = false;
    mutable bool qcpitempixmap_parentplotinitialized_isbase = false;
    mutable bool qcpitempixmap_mousepressevent_isbase = false;
    mutable bool qcpitempixmap_mousemoveevent_isbase = false;
    mutable bool qcpitempixmap_mousereleaseevent_isbase = false;
    mutable bool qcpitempixmap_mousedoubleclickevent_isbase = false;
    mutable bool qcpitempixmap_wheelevent_isbase = false;
    mutable bool qcpitempixmap_event_isbase = false;
    mutable bool qcpitempixmap_eventfilter_isbase = false;
    mutable bool qcpitempixmap_timerevent_isbase = false;
    mutable bool qcpitempixmap_childevent_isbase = false;
    mutable bool qcpitempixmap_customevent_isbase = false;
    mutable bool qcpitempixmap_connectnotify_isbase = false;
    mutable bool qcpitempixmap_disconnectnotify_isbase = false;
    mutable bool qcpitempixmap_updatescaledpixmap_isbase = false;
    mutable bool qcpitempixmap_getfinalrect_isbase = false;
    mutable bool qcpitempixmap_mainpen_isbase = false;
    mutable bool qcpitempixmap_updatescaledpixmap1_isbase = false;
    mutable bool qcpitempixmap_updatescaledpixmap2_isbase = false;
    mutable bool qcpitempixmap_updatescaledpixmap3_isbase = false;
    mutable bool qcpitempixmap_getfinalrect1_isbase = false;
    mutable bool qcpitempixmap_getfinalrect2_isbase = false;
    mutable bool qcpitempixmap_rectdistance_isbase = false;
    mutable bool qcpitempixmap_createposition_isbase = false;
    mutable bool qcpitempixmap_createanchor_isbase = false;
    mutable bool qcpitempixmap_initializeparentplot_isbase = false;
    mutable bool qcpitempixmap_setparentlayerable_isbase = false;
    mutable bool qcpitempixmap_movetolayer_isbase = false;
    mutable bool qcpitempixmap_applyantialiasinghint_isbase = false;
    mutable bool qcpitempixmap_sender_isbase = false;
    mutable bool qcpitempixmap_sendersignalindex_isbase = false;
    mutable bool qcpitempixmap_receivers_isbase = false;
    mutable bool qcpitempixmap_issignalconnected_isbase = false;

  public:
    VirtualQCPItemPixmap(QCustomPlot* parentPlot) : QCPItemPixmap(parentPlot) {};

    ~VirtualQCPItemPixmap() {
        qcpitempixmap_metacall_callback = nullptr;
        qcpitempixmap_selecttest_callback = nullptr;
        qcpitempixmap_draw_callback = nullptr;
        qcpitempixmap_anchorpixelposition_callback = nullptr;
        qcpitempixmap_selectioncategory_callback = nullptr;
        qcpitempixmap_cliprect_callback = nullptr;
        qcpitempixmap_applydefaultantialiasinghint_callback = nullptr;
        qcpitempixmap_selectevent_callback = nullptr;
        qcpitempixmap_deselectevent_callback = nullptr;
        qcpitempixmap_parentplotinitialized_callback = nullptr;
        qcpitempixmap_mousepressevent_callback = nullptr;
        qcpitempixmap_mousemoveevent_callback = nullptr;
        qcpitempixmap_mousereleaseevent_callback = nullptr;
        qcpitempixmap_mousedoubleclickevent_callback = nullptr;
        qcpitempixmap_wheelevent_callback = nullptr;
        qcpitempixmap_event_callback = nullptr;
        qcpitempixmap_eventfilter_callback = nullptr;
        qcpitempixmap_timerevent_callback = nullptr;
        qcpitempixmap_childevent_callback = nullptr;
        qcpitempixmap_customevent_callback = nullptr;
        qcpitempixmap_connectnotify_callback = nullptr;
        qcpitempixmap_disconnectnotify_callback = nullptr;
        qcpitempixmap_updatescaledpixmap_callback = nullptr;
        qcpitempixmap_getfinalrect_callback = nullptr;
        qcpitempixmap_mainpen_callback = nullptr;
        qcpitempixmap_updatescaledpixmap1_callback = nullptr;
        qcpitempixmap_updatescaledpixmap2_callback = nullptr;
        qcpitempixmap_updatescaledpixmap3_callback = nullptr;
        qcpitempixmap_getfinalrect1_callback = nullptr;
        qcpitempixmap_getfinalrect2_callback = nullptr;
        qcpitempixmap_rectdistance_callback = nullptr;
        qcpitempixmap_createposition_callback = nullptr;
        qcpitempixmap_createanchor_callback = nullptr;
        qcpitempixmap_initializeparentplot_callback = nullptr;
        qcpitempixmap_setparentlayerable_callback = nullptr;
        qcpitempixmap_movetolayer_callback = nullptr;
        qcpitempixmap_applyantialiasinghint_callback = nullptr;
        qcpitempixmap_sender_callback = nullptr;
        qcpitempixmap_sendersignalindex_callback = nullptr;
        qcpitempixmap_receivers_callback = nullptr;
        qcpitempixmap_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPItemPixmap_Metacall_Callback(QCPItemPixmap_Metacall_Callback cb) { qcpitempixmap_metacall_callback = cb; }
    inline void setQCPItemPixmap_SelectTest_Callback(QCPItemPixmap_SelectTest_Callback cb) { qcpitempixmap_selecttest_callback = cb; }
    inline void setQCPItemPixmap_Draw_Callback(QCPItemPixmap_Draw_Callback cb) { qcpitempixmap_draw_callback = cb; }
    inline void setQCPItemPixmap_AnchorPixelPosition_Callback(QCPItemPixmap_AnchorPixelPosition_Callback cb) { qcpitempixmap_anchorpixelposition_callback = cb; }
    inline void setQCPItemPixmap_SelectionCategory_Callback(QCPItemPixmap_SelectionCategory_Callback cb) { qcpitempixmap_selectioncategory_callback = cb; }
    inline void setQCPItemPixmap_ClipRect_Callback(QCPItemPixmap_ClipRect_Callback cb) { qcpitempixmap_cliprect_callback = cb; }
    inline void setQCPItemPixmap_ApplyDefaultAntialiasingHint_Callback(QCPItemPixmap_ApplyDefaultAntialiasingHint_Callback cb) { qcpitempixmap_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPItemPixmap_SelectEvent_Callback(QCPItemPixmap_SelectEvent_Callback cb) { qcpitempixmap_selectevent_callback = cb; }
    inline void setQCPItemPixmap_DeselectEvent_Callback(QCPItemPixmap_DeselectEvent_Callback cb) { qcpitempixmap_deselectevent_callback = cb; }
    inline void setQCPItemPixmap_ParentPlotInitialized_Callback(QCPItemPixmap_ParentPlotInitialized_Callback cb) { qcpitempixmap_parentplotinitialized_callback = cb; }
    inline void setQCPItemPixmap_MousePressEvent_Callback(QCPItemPixmap_MousePressEvent_Callback cb) { qcpitempixmap_mousepressevent_callback = cb; }
    inline void setQCPItemPixmap_MouseMoveEvent_Callback(QCPItemPixmap_MouseMoveEvent_Callback cb) { qcpitempixmap_mousemoveevent_callback = cb; }
    inline void setQCPItemPixmap_MouseReleaseEvent_Callback(QCPItemPixmap_MouseReleaseEvent_Callback cb) { qcpitempixmap_mousereleaseevent_callback = cb; }
    inline void setQCPItemPixmap_MouseDoubleClickEvent_Callback(QCPItemPixmap_MouseDoubleClickEvent_Callback cb) { qcpitempixmap_mousedoubleclickevent_callback = cb; }
    inline void setQCPItemPixmap_WheelEvent_Callback(QCPItemPixmap_WheelEvent_Callback cb) { qcpitempixmap_wheelevent_callback = cb; }
    inline void setQCPItemPixmap_Event_Callback(QCPItemPixmap_Event_Callback cb) { qcpitempixmap_event_callback = cb; }
    inline void setQCPItemPixmap_EventFilter_Callback(QCPItemPixmap_EventFilter_Callback cb) { qcpitempixmap_eventfilter_callback = cb; }
    inline void setQCPItemPixmap_TimerEvent_Callback(QCPItemPixmap_TimerEvent_Callback cb) { qcpitempixmap_timerevent_callback = cb; }
    inline void setQCPItemPixmap_ChildEvent_Callback(QCPItemPixmap_ChildEvent_Callback cb) { qcpitempixmap_childevent_callback = cb; }
    inline void setQCPItemPixmap_CustomEvent_Callback(QCPItemPixmap_CustomEvent_Callback cb) { qcpitempixmap_customevent_callback = cb; }
    inline void setQCPItemPixmap_ConnectNotify_Callback(QCPItemPixmap_ConnectNotify_Callback cb) { qcpitempixmap_connectnotify_callback = cb; }
    inline void setQCPItemPixmap_DisconnectNotify_Callback(QCPItemPixmap_DisconnectNotify_Callback cb) { qcpitempixmap_disconnectnotify_callback = cb; }
    inline void setQCPItemPixmap_UpdateScaledPixmap_Callback(QCPItemPixmap_UpdateScaledPixmap_Callback cb) { qcpitempixmap_updatescaledpixmap_callback = cb; }
    inline void setQCPItemPixmap_GetFinalRect_Callback(QCPItemPixmap_GetFinalRect_Callback cb) { qcpitempixmap_getfinalrect_callback = cb; }
    inline void setQCPItemPixmap_MainPen_Callback(QCPItemPixmap_MainPen_Callback cb) { qcpitempixmap_mainpen_callback = cb; }
    inline void setQCPItemPixmap_UpdateScaledPixmap1_Callback(QCPItemPixmap_UpdateScaledPixmap1_Callback cb) { qcpitempixmap_updatescaledpixmap1_callback = cb; }
    inline void setQCPItemPixmap_UpdateScaledPixmap2_Callback(QCPItemPixmap_UpdateScaledPixmap2_Callback cb) { qcpitempixmap_updatescaledpixmap2_callback = cb; }
    inline void setQCPItemPixmap_UpdateScaledPixmap3_Callback(QCPItemPixmap_UpdateScaledPixmap3_Callback cb) { qcpitempixmap_updatescaledpixmap3_callback = cb; }
    inline void setQCPItemPixmap_GetFinalRect1_Callback(QCPItemPixmap_GetFinalRect1_Callback cb) { qcpitempixmap_getfinalrect1_callback = cb; }
    inline void setQCPItemPixmap_GetFinalRect2_Callback(QCPItemPixmap_GetFinalRect2_Callback cb) { qcpitempixmap_getfinalrect2_callback = cb; }
    inline void setQCPItemPixmap_RectDistance_Callback(QCPItemPixmap_RectDistance_Callback cb) { qcpitempixmap_rectdistance_callback = cb; }
    inline void setQCPItemPixmap_CreatePosition_Callback(QCPItemPixmap_CreatePosition_Callback cb) { qcpitempixmap_createposition_callback = cb; }
    inline void setQCPItemPixmap_CreateAnchor_Callback(QCPItemPixmap_CreateAnchor_Callback cb) { qcpitempixmap_createanchor_callback = cb; }
    inline void setQCPItemPixmap_InitializeParentPlot_Callback(QCPItemPixmap_InitializeParentPlot_Callback cb) { qcpitempixmap_initializeparentplot_callback = cb; }
    inline void setQCPItemPixmap_SetParentLayerable_Callback(QCPItemPixmap_SetParentLayerable_Callback cb) { qcpitempixmap_setparentlayerable_callback = cb; }
    inline void setQCPItemPixmap_MoveToLayer_Callback(QCPItemPixmap_MoveToLayer_Callback cb) { qcpitempixmap_movetolayer_callback = cb; }
    inline void setQCPItemPixmap_ApplyAntialiasingHint_Callback(QCPItemPixmap_ApplyAntialiasingHint_Callback cb) { qcpitempixmap_applyantialiasinghint_callback = cb; }
    inline void setQCPItemPixmap_Sender_Callback(QCPItemPixmap_Sender_Callback cb) { qcpitempixmap_sender_callback = cb; }
    inline void setQCPItemPixmap_SenderSignalIndex_Callback(QCPItemPixmap_SenderSignalIndex_Callback cb) { qcpitempixmap_sendersignalindex_callback = cb; }
    inline void setQCPItemPixmap_Receivers_Callback(QCPItemPixmap_Receivers_Callback cb) { qcpitempixmap_receivers_callback = cb; }
    inline void setQCPItemPixmap_IsSignalConnected_Callback(QCPItemPixmap_IsSignalConnected_Callback cb) { qcpitempixmap_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPItemPixmap_Metacall_IsBase(bool value) const { qcpitempixmap_metacall_isbase = value; }
    inline void setQCPItemPixmap_SelectTest_IsBase(bool value) const { qcpitempixmap_selecttest_isbase = value; }
    inline void setQCPItemPixmap_Draw_IsBase(bool value) const { qcpitempixmap_draw_isbase = value; }
    inline void setQCPItemPixmap_AnchorPixelPosition_IsBase(bool value) const { qcpitempixmap_anchorpixelposition_isbase = value; }
    inline void setQCPItemPixmap_SelectionCategory_IsBase(bool value) const { qcpitempixmap_selectioncategory_isbase = value; }
    inline void setQCPItemPixmap_ClipRect_IsBase(bool value) const { qcpitempixmap_cliprect_isbase = value; }
    inline void setQCPItemPixmap_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcpitempixmap_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPItemPixmap_SelectEvent_IsBase(bool value) const { qcpitempixmap_selectevent_isbase = value; }
    inline void setQCPItemPixmap_DeselectEvent_IsBase(bool value) const { qcpitempixmap_deselectevent_isbase = value; }
    inline void setQCPItemPixmap_ParentPlotInitialized_IsBase(bool value) const { qcpitempixmap_parentplotinitialized_isbase = value; }
    inline void setQCPItemPixmap_MousePressEvent_IsBase(bool value) const { qcpitempixmap_mousepressevent_isbase = value; }
    inline void setQCPItemPixmap_MouseMoveEvent_IsBase(bool value) const { qcpitempixmap_mousemoveevent_isbase = value; }
    inline void setQCPItemPixmap_MouseReleaseEvent_IsBase(bool value) const { qcpitempixmap_mousereleaseevent_isbase = value; }
    inline void setQCPItemPixmap_MouseDoubleClickEvent_IsBase(bool value) const { qcpitempixmap_mousedoubleclickevent_isbase = value; }
    inline void setQCPItemPixmap_WheelEvent_IsBase(bool value) const { qcpitempixmap_wheelevent_isbase = value; }
    inline void setQCPItemPixmap_Event_IsBase(bool value) const { qcpitempixmap_event_isbase = value; }
    inline void setQCPItemPixmap_EventFilter_IsBase(bool value) const { qcpitempixmap_eventfilter_isbase = value; }
    inline void setQCPItemPixmap_TimerEvent_IsBase(bool value) const { qcpitempixmap_timerevent_isbase = value; }
    inline void setQCPItemPixmap_ChildEvent_IsBase(bool value) const { qcpitempixmap_childevent_isbase = value; }
    inline void setQCPItemPixmap_CustomEvent_IsBase(bool value) const { qcpitempixmap_customevent_isbase = value; }
    inline void setQCPItemPixmap_ConnectNotify_IsBase(bool value) const { qcpitempixmap_connectnotify_isbase = value; }
    inline void setQCPItemPixmap_DisconnectNotify_IsBase(bool value) const { qcpitempixmap_disconnectnotify_isbase = value; }
    inline void setQCPItemPixmap_UpdateScaledPixmap_IsBase(bool value) const { qcpitempixmap_updatescaledpixmap_isbase = value; }
    inline void setQCPItemPixmap_GetFinalRect_IsBase(bool value) const { qcpitempixmap_getfinalrect_isbase = value; }
    inline void setQCPItemPixmap_MainPen_IsBase(bool value) const { qcpitempixmap_mainpen_isbase = value; }
    inline void setQCPItemPixmap_UpdateScaledPixmap1_IsBase(bool value) const { qcpitempixmap_updatescaledpixmap1_isbase = value; }
    inline void setQCPItemPixmap_UpdateScaledPixmap2_IsBase(bool value) const { qcpitempixmap_updatescaledpixmap2_isbase = value; }
    inline void setQCPItemPixmap_UpdateScaledPixmap3_IsBase(bool value) const { qcpitempixmap_updatescaledpixmap3_isbase = value; }
    inline void setQCPItemPixmap_GetFinalRect1_IsBase(bool value) const { qcpitempixmap_getfinalrect1_isbase = value; }
    inline void setQCPItemPixmap_GetFinalRect2_IsBase(bool value) const { qcpitempixmap_getfinalrect2_isbase = value; }
    inline void setQCPItemPixmap_RectDistance_IsBase(bool value) const { qcpitempixmap_rectdistance_isbase = value; }
    inline void setQCPItemPixmap_CreatePosition_IsBase(bool value) const { qcpitempixmap_createposition_isbase = value; }
    inline void setQCPItemPixmap_CreateAnchor_IsBase(bool value) const { qcpitempixmap_createanchor_isbase = value; }
    inline void setQCPItemPixmap_InitializeParentPlot_IsBase(bool value) const { qcpitempixmap_initializeparentplot_isbase = value; }
    inline void setQCPItemPixmap_SetParentLayerable_IsBase(bool value) const { qcpitempixmap_setparentlayerable_isbase = value; }
    inline void setQCPItemPixmap_MoveToLayer_IsBase(bool value) const { qcpitempixmap_movetolayer_isbase = value; }
    inline void setQCPItemPixmap_ApplyAntialiasingHint_IsBase(bool value) const { qcpitempixmap_applyantialiasinghint_isbase = value; }
    inline void setQCPItemPixmap_Sender_IsBase(bool value) const { qcpitempixmap_sender_isbase = value; }
    inline void setQCPItemPixmap_SenderSignalIndex_IsBase(bool value) const { qcpitempixmap_sendersignalindex_isbase = value; }
    inline void setQCPItemPixmap_Receivers_IsBase(bool value) const { qcpitempixmap_receivers_isbase = value; }
    inline void setQCPItemPixmap_IsSignalConnected_IsBase(bool value) const { qcpitempixmap_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpitempixmap_metacall_isbase) {
            qcpitempixmap_metacall_isbase = false;
            return QCPItemPixmap::qt_metacall(param1, param2, param3);
        } else if (qcpitempixmap_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpitempixmap_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemPixmap::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcpitempixmap_selecttest_isbase) {
            qcpitempixmap_selecttest_isbase = false;
            return QCPItemPixmap::selectTest(pos, onlySelectable, details);
        } else if (qcpitempixmap_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcpitempixmap_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPItemPixmap::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcpitempixmap_draw_isbase) {
            qcpitempixmap_draw_isbase = false;
            QCPItemPixmap::draw(painter);
        } else if (qcpitempixmap_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpitempixmap_draw_callback(this, cbval1);
        } else {
            QCPItemPixmap::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QPointF anchorPixelPosition(int anchorId) const override {
        if (qcpitempixmap_anchorpixelposition_isbase) {
            qcpitempixmap_anchorpixelposition_isbase = false;
            return QCPItemPixmap::anchorPixelPosition(anchorId);
        } else if (qcpitempixmap_anchorpixelposition_callback != nullptr) {
            int cbval1 = anchorId;

            QPointF* callback_ret = qcpitempixmap_anchorpixelposition_callback(this, cbval1);
            return *callback_ret;
        } else {
            return QCPItemPixmap::anchorPixelPosition(anchorId);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcpitempixmap_selectioncategory_isbase) {
            qcpitempixmap_selectioncategory_isbase = false;
            return QCPItemPixmap::selectionCategory();
        } else if (qcpitempixmap_selectioncategory_callback != nullptr) {
            int callback_ret = qcpitempixmap_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPItemPixmap::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcpitempixmap_cliprect_isbase) {
            qcpitempixmap_cliprect_isbase = false;
            return QCPItemPixmap::clipRect();
        } else if (qcpitempixmap_cliprect_callback != nullptr) {
            QRect* callback_ret = qcpitempixmap_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPItemPixmap::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcpitempixmap_applydefaultantialiasinghint_isbase) {
            qcpitempixmap_applydefaultantialiasinghint_isbase = false;
            QCPItemPixmap::applyDefaultAntialiasingHint(painter);
        } else if (qcpitempixmap_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpitempixmap_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPItemPixmap::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcpitempixmap_selectevent_isbase) {
            qcpitempixmap_selectevent_isbase = false;
            QCPItemPixmap::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcpitempixmap_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcpitempixmap_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPItemPixmap::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcpitempixmap_deselectevent_isbase) {
            qcpitempixmap_deselectevent_isbase = false;
            QCPItemPixmap::deselectEvent(selectionStateChanged);
        } else if (qcpitempixmap_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcpitempixmap_deselectevent_callback(this, cbval1);
        } else {
            QCPItemPixmap::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcpitempixmap_parentplotinitialized_isbase) {
            qcpitempixmap_parentplotinitialized_isbase = false;
            QCPItemPixmap::parentPlotInitialized(parentPlot);
        } else if (qcpitempixmap_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpitempixmap_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPItemPixmap::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpitempixmap_mousepressevent_isbase) {
            qcpitempixmap_mousepressevent_isbase = false;
            QCPItemPixmap::mousePressEvent(event, details);
        } else if (qcpitempixmap_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpitempixmap_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemPixmap::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpitempixmap_mousemoveevent_isbase) {
            qcpitempixmap_mousemoveevent_isbase = false;
            QCPItemPixmap::mouseMoveEvent(event, startPos);
        } else if (qcpitempixmap_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpitempixmap_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemPixmap::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpitempixmap_mousereleaseevent_isbase) {
            qcpitempixmap_mousereleaseevent_isbase = false;
            QCPItemPixmap::mouseReleaseEvent(event, startPos);
        } else if (qcpitempixmap_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpitempixmap_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemPixmap::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpitempixmap_mousedoubleclickevent_isbase) {
            qcpitempixmap_mousedoubleclickevent_isbase = false;
            QCPItemPixmap::mouseDoubleClickEvent(event, details);
        } else if (qcpitempixmap_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpitempixmap_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemPixmap::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcpitempixmap_wheelevent_isbase) {
            qcpitempixmap_wheelevent_isbase = false;
            QCPItemPixmap::wheelEvent(event);
        } else if (qcpitempixmap_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcpitempixmap_wheelevent_callback(this, cbval1);
        } else {
            QCPItemPixmap::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpitempixmap_event_isbase) {
            qcpitempixmap_event_isbase = false;
            return QCPItemPixmap::event(event);
        } else if (qcpitempixmap_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpitempixmap_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemPixmap::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpitempixmap_eventfilter_isbase) {
            qcpitempixmap_eventfilter_isbase = false;
            return QCPItemPixmap::eventFilter(watched, event);
        } else if (qcpitempixmap_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpitempixmap_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemPixmap::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpitempixmap_timerevent_isbase) {
            qcpitempixmap_timerevent_isbase = false;
            QCPItemPixmap::timerEvent(event);
        } else if (qcpitempixmap_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpitempixmap_timerevent_callback(this, cbval1);
        } else {
            QCPItemPixmap::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpitempixmap_childevent_isbase) {
            qcpitempixmap_childevent_isbase = false;
            QCPItemPixmap::childEvent(event);
        } else if (qcpitempixmap_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpitempixmap_childevent_callback(this, cbval1);
        } else {
            QCPItemPixmap::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpitempixmap_customevent_isbase) {
            qcpitempixmap_customevent_isbase = false;
            QCPItemPixmap::customEvent(event);
        } else if (qcpitempixmap_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpitempixmap_customevent_callback(this, cbval1);
        } else {
            QCPItemPixmap::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpitempixmap_connectnotify_isbase) {
            qcpitempixmap_connectnotify_isbase = false;
            QCPItemPixmap::connectNotify(signal);
        } else if (qcpitempixmap_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpitempixmap_connectnotify_callback(this, cbval1);
        } else {
            QCPItemPixmap::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpitempixmap_disconnectnotify_isbase) {
            qcpitempixmap_disconnectnotify_isbase = false;
            QCPItemPixmap::disconnectNotify(signal);
        } else if (qcpitempixmap_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpitempixmap_disconnectnotify_callback(this, cbval1);
        } else {
            QCPItemPixmap::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    void updateScaledPixmap() {
        if (qcpitempixmap_updatescaledpixmap_isbase) {
            qcpitempixmap_updatescaledpixmap_isbase = false;
            QCPItemPixmap::updateScaledPixmap();
        } else if (qcpitempixmap_updatescaledpixmap_callback != nullptr) {
            qcpitempixmap_updatescaledpixmap_callback();
        } else {
            QCPItemPixmap::updateScaledPixmap();
        }
    }

    // Virtual method for C ABI access and custom callback
    QRect getFinalRect() const {
        if (qcpitempixmap_getfinalrect_isbase) {
            qcpitempixmap_getfinalrect_isbase = false;
            return QCPItemPixmap::getFinalRect();
        } else if (qcpitempixmap_getfinalrect_callback != nullptr) {
            QRect* callback_ret = qcpitempixmap_getfinalrect_callback();
            return *callback_ret;
        } else {
            return QCPItemPixmap::getFinalRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    QPen mainPen() const {
        if (qcpitempixmap_mainpen_isbase) {
            qcpitempixmap_mainpen_isbase = false;
            return QCPItemPixmap::mainPen();
        } else if (qcpitempixmap_mainpen_callback != nullptr) {
            QPen* callback_ret = qcpitempixmap_mainpen_callback();
            return *callback_ret;
        } else {
            return QCPItemPixmap::mainPen();
        }
    }

    // Virtual method for C ABI access and custom callback
    void updateScaledPixmap(QRect finalRect) {
        if (qcpitempixmap_updatescaledpixmap1_isbase) {
            qcpitempixmap_updatescaledpixmap1_isbase = false;
            QCPItemPixmap::updateScaledPixmap(finalRect);
        } else if (qcpitempixmap_updatescaledpixmap1_callback != nullptr) {
            QRect* cbval1 = new QRect(finalRect);

            qcpitempixmap_updatescaledpixmap1_callback(this, cbval1);
        } else {
            QCPItemPixmap::updateScaledPixmap(finalRect);
        }
    }

    // Virtual method for C ABI access and custom callback
    void updateScaledPixmap(QRect finalRect, bool flipHorz) {
        if (qcpitempixmap_updatescaledpixmap2_isbase) {
            qcpitempixmap_updatescaledpixmap2_isbase = false;
            QCPItemPixmap::updateScaledPixmap(finalRect, flipHorz);
        } else if (qcpitempixmap_updatescaledpixmap2_callback != nullptr) {
            QRect* cbval1 = new QRect(finalRect);
            bool cbval2 = flipHorz;

            qcpitempixmap_updatescaledpixmap2_callback(this, cbval1, cbval2);
        } else {
            QCPItemPixmap::updateScaledPixmap(finalRect, flipHorz);
        }
    }

    // Virtual method for C ABI access and custom callback
    void updateScaledPixmap(QRect finalRect, bool flipHorz, bool flipVert) {
        if (qcpitempixmap_updatescaledpixmap3_isbase) {
            qcpitempixmap_updatescaledpixmap3_isbase = false;
            QCPItemPixmap::updateScaledPixmap(finalRect, flipHorz, flipVert);
        } else if (qcpitempixmap_updatescaledpixmap3_callback != nullptr) {
            QRect* cbval1 = new QRect(finalRect);
            bool cbval2 = flipHorz;
            bool cbval3 = flipVert;

            qcpitempixmap_updatescaledpixmap3_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPItemPixmap::updateScaledPixmap(finalRect, flipHorz, flipVert);
        }
    }

    // Virtual method for C ABI access and custom callback
    QRect getFinalRect(bool* flippedHorz) const {
        if (qcpitempixmap_getfinalrect1_isbase) {
            qcpitempixmap_getfinalrect1_isbase = false;
            return QCPItemPixmap::getFinalRect(flippedHorz);
        } else if (qcpitempixmap_getfinalrect1_callback != nullptr) {
            bool* cbval1 = flippedHorz;

            QRect* callback_ret = qcpitempixmap_getfinalrect1_callback(this, cbval1);
            return *callback_ret;
        } else {
            return QCPItemPixmap::getFinalRect(flippedHorz);
        }
    }

    // Virtual method for C ABI access and custom callback
    QRect getFinalRect(bool* flippedHorz, bool* flippedVert) const {
        if (qcpitempixmap_getfinalrect2_isbase) {
            qcpitempixmap_getfinalrect2_isbase = false;
            return QCPItemPixmap::getFinalRect(flippedHorz, flippedVert);
        } else if (qcpitempixmap_getfinalrect2_callback != nullptr) {
            bool* cbval1 = flippedHorz;
            bool* cbval2 = flippedVert;

            QRect* callback_ret = qcpitempixmap_getfinalrect2_callback(this, cbval1, cbval2);
            return *callback_ret;
        } else {
            return QCPItemPixmap::getFinalRect(flippedHorz, flippedVert);
        }
    }

    // Virtual method for C ABI access and custom callback
    double rectDistance(const QRectF& rect, const QPointF& pos, bool filledRect) const {
        if (qcpitempixmap_rectdistance_isbase) {
            qcpitempixmap_rectdistance_isbase = false;
            return QCPItemPixmap::rectDistance(rect, pos, filledRect);
        } else if (qcpitempixmap_rectdistance_callback != nullptr) {
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval1 = const_cast<QRectF*>(&rect_ret);
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&pos_ret);
            bool cbval3 = filledRect;

            double callback_ret = qcpitempixmap_rectdistance_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPItemPixmap::rectDistance(rect, pos, filledRect);
        }
    }

    // Virtual method for C ABI access and custom callback
    QCPItemPosition* createPosition(const QString& name) {
        if (qcpitempixmap_createposition_isbase) {
            qcpitempixmap_createposition_isbase = false;
            return QCPItemPixmap::createPosition(name);
        } else if (qcpitempixmap_createposition_callback != nullptr) {
            const QString name_ret = name;
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray name_b = name_ret.toUtf8();
            libqt_string name_str;
            name_str.len = name_b.length();
            name_str.data = static_cast<const char*>(malloc(name_str.len + 1));
            memcpy((void*)name_str.data, name_b.data(), name_str.len);
            ((char*)name_str.data)[name_str.len] = '\0';
            libqt_string cbval1 = name_str;

            QCPItemPosition* callback_ret = qcpitempixmap_createposition_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemPixmap::createPosition(name);
        }
    }

    // Virtual method for C ABI access and custom callback
    QCPItemAnchor* createAnchor(const QString& name, int anchorId) {
        if (qcpitempixmap_createanchor_isbase) {
            qcpitempixmap_createanchor_isbase = false;
            return QCPItemPixmap::createAnchor(name, anchorId);
        } else if (qcpitempixmap_createanchor_callback != nullptr) {
            const QString name_ret = name;
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray name_b = name_ret.toUtf8();
            libqt_string name_str;
            name_str.len = name_b.length();
            name_str.data = static_cast<const char*>(malloc(name_str.len + 1));
            memcpy((void*)name_str.data, name_b.data(), name_str.len);
            ((char*)name_str.data)[name_str.len] = '\0';
            libqt_string cbval1 = name_str;
            int cbval2 = anchorId;

            QCPItemAnchor* callback_ret = qcpitempixmap_createanchor_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemPixmap::createAnchor(name, anchorId);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcpitempixmap_initializeparentplot_isbase) {
            qcpitempixmap_initializeparentplot_isbase = false;
            QCPItemPixmap::initializeParentPlot(parentPlot);
        } else if (qcpitempixmap_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpitempixmap_initializeparentplot_callback(this, cbval1);
        } else {
            QCPItemPixmap::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcpitempixmap_setparentlayerable_isbase) {
            qcpitempixmap_setparentlayerable_isbase = false;
            QCPItemPixmap::setParentLayerable(parentLayerable);
        } else if (qcpitempixmap_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcpitempixmap_setparentlayerable_callback(this, cbval1);
        } else {
            QCPItemPixmap::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcpitempixmap_movetolayer_isbase) {
            qcpitempixmap_movetolayer_isbase = false;
            return QCPItemPixmap::moveToLayer(layer, prepend);
        } else if (qcpitempixmap_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcpitempixmap_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemPixmap::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcpitempixmap_applyantialiasinghint_isbase) {
            qcpitempixmap_applyantialiasinghint_isbase = false;
            QCPItemPixmap::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcpitempixmap_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcpitempixmap_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPItemPixmap::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpitempixmap_sender_isbase) {
            qcpitempixmap_sender_isbase = false;
            return QCPItemPixmap::sender();
        } else if (qcpitempixmap_sender_callback != nullptr) {
            QObject* callback_ret = qcpitempixmap_sender_callback();
            return callback_ret;
        } else {
            return QCPItemPixmap::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpitempixmap_sendersignalindex_isbase) {
            qcpitempixmap_sendersignalindex_isbase = false;
            return QCPItemPixmap::senderSignalIndex();
        } else if (qcpitempixmap_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpitempixmap_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemPixmap::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpitempixmap_receivers_isbase) {
            qcpitempixmap_receivers_isbase = false;
            return QCPItemPixmap::receivers(signal);
        } else if (qcpitempixmap_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpitempixmap_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemPixmap::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpitempixmap_issignalconnected_isbase) {
            qcpitempixmap_issignalconnected_isbase = false;
            return QCPItemPixmap::isSignalConnected(signal);
        } else if (qcpitempixmap_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpitempixmap_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemPixmap::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPItemPixmap_Draw(QCPItemPixmap* self, QCPPainter* painter);
    friend void QCPItemPixmap_QBaseDraw(QCPItemPixmap* self, QCPPainter* painter);
    friend QPointF* QCPItemPixmap_AnchorPixelPosition(const QCPItemPixmap* self, int anchorId);
    friend QPointF* QCPItemPixmap_QBaseAnchorPixelPosition(const QCPItemPixmap* self, int anchorId);
    friend int QCPItemPixmap_SelectionCategory(const QCPItemPixmap* self);
    friend int QCPItemPixmap_QBaseSelectionCategory(const QCPItemPixmap* self);
    friend QRect* QCPItemPixmap_ClipRect(const QCPItemPixmap* self);
    friend QRect* QCPItemPixmap_QBaseClipRect(const QCPItemPixmap* self);
    friend void QCPItemPixmap_ApplyDefaultAntialiasingHint(const QCPItemPixmap* self, QCPPainter* painter);
    friend void QCPItemPixmap_QBaseApplyDefaultAntialiasingHint(const QCPItemPixmap* self, QCPPainter* painter);
    friend void QCPItemPixmap_SelectEvent(QCPItemPixmap* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPItemPixmap_QBaseSelectEvent(QCPItemPixmap* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPItemPixmap_DeselectEvent(QCPItemPixmap* self, bool* selectionStateChanged);
    friend void QCPItemPixmap_QBaseDeselectEvent(QCPItemPixmap* self, bool* selectionStateChanged);
    friend void QCPItemPixmap_ParentPlotInitialized(QCPItemPixmap* self, QCustomPlot* parentPlot);
    friend void QCPItemPixmap_QBaseParentPlotInitialized(QCPItemPixmap* self, QCustomPlot* parentPlot);
    friend void QCPItemPixmap_MousePressEvent(QCPItemPixmap* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemPixmap_QBaseMousePressEvent(QCPItemPixmap* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemPixmap_MouseMoveEvent(QCPItemPixmap* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemPixmap_QBaseMouseMoveEvent(QCPItemPixmap* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemPixmap_MouseReleaseEvent(QCPItemPixmap* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemPixmap_QBaseMouseReleaseEvent(QCPItemPixmap* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemPixmap_MouseDoubleClickEvent(QCPItemPixmap* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemPixmap_QBaseMouseDoubleClickEvent(QCPItemPixmap* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemPixmap_WheelEvent(QCPItemPixmap* self, QWheelEvent* event);
    friend void QCPItemPixmap_QBaseWheelEvent(QCPItemPixmap* self, QWheelEvent* event);
    friend void QCPItemPixmap_TimerEvent(QCPItemPixmap* self, QTimerEvent* event);
    friend void QCPItemPixmap_QBaseTimerEvent(QCPItemPixmap* self, QTimerEvent* event);
    friend void QCPItemPixmap_ChildEvent(QCPItemPixmap* self, QChildEvent* event);
    friend void QCPItemPixmap_QBaseChildEvent(QCPItemPixmap* self, QChildEvent* event);
    friend void QCPItemPixmap_CustomEvent(QCPItemPixmap* self, QEvent* event);
    friend void QCPItemPixmap_QBaseCustomEvent(QCPItemPixmap* self, QEvent* event);
    friend void QCPItemPixmap_ConnectNotify(QCPItemPixmap* self, const QMetaMethod* signal);
    friend void QCPItemPixmap_QBaseConnectNotify(QCPItemPixmap* self, const QMetaMethod* signal);
    friend void QCPItemPixmap_DisconnectNotify(QCPItemPixmap* self, const QMetaMethod* signal);
    friend void QCPItemPixmap_QBaseDisconnectNotify(QCPItemPixmap* self, const QMetaMethod* signal);
    friend void QCPItemPixmap_UpdateScaledPixmap(QCPItemPixmap* self);
    friend void QCPItemPixmap_QBaseUpdateScaledPixmap(QCPItemPixmap* self);
    friend QRect* QCPItemPixmap_GetFinalRect(const QCPItemPixmap* self);
    friend QRect* QCPItemPixmap_QBaseGetFinalRect(const QCPItemPixmap* self);
    friend QPen* QCPItemPixmap_MainPen(const QCPItemPixmap* self);
    friend QPen* QCPItemPixmap_QBaseMainPen(const QCPItemPixmap* self);
    friend void QCPItemPixmap_UpdateScaledPixmap1(QCPItemPixmap* self, QRect* finalRect);
    friend void QCPItemPixmap_QBaseUpdateScaledPixmap1(QCPItemPixmap* self, QRect* finalRect);
    friend void QCPItemPixmap_UpdateScaledPixmap2(QCPItemPixmap* self, QRect* finalRect, bool flipHorz);
    friend void QCPItemPixmap_QBaseUpdateScaledPixmap2(QCPItemPixmap* self, QRect* finalRect, bool flipHorz);
    friend void QCPItemPixmap_UpdateScaledPixmap3(QCPItemPixmap* self, QRect* finalRect, bool flipHorz, bool flipVert);
    friend void QCPItemPixmap_QBaseUpdateScaledPixmap3(QCPItemPixmap* self, QRect* finalRect, bool flipHorz, bool flipVert);
    friend QRect* QCPItemPixmap_GetFinalRect1(const QCPItemPixmap* self, bool* flippedHorz);
    friend QRect* QCPItemPixmap_QBaseGetFinalRect1(const QCPItemPixmap* self, bool* flippedHorz);
    friend QRect* QCPItemPixmap_GetFinalRect2(const QCPItemPixmap* self, bool* flippedHorz, bool* flippedVert);
    friend QRect* QCPItemPixmap_QBaseGetFinalRect2(const QCPItemPixmap* self, bool* flippedHorz, bool* flippedVert);
    friend double QCPItemPixmap_RectDistance(const QCPItemPixmap* self, const QRectF* rect, const QPointF* pos, bool filledRect);
    friend double QCPItemPixmap_QBaseRectDistance(const QCPItemPixmap* self, const QRectF* rect, const QPointF* pos, bool filledRect);
    friend QCPItemPosition* QCPItemPixmap_CreatePosition(QCPItemPixmap* self, const libqt_string name);
    friend QCPItemPosition* QCPItemPixmap_QBaseCreatePosition(QCPItemPixmap* self, const libqt_string name);
    friend QCPItemAnchor* QCPItemPixmap_CreateAnchor(QCPItemPixmap* self, const libqt_string name, int anchorId);
    friend QCPItemAnchor* QCPItemPixmap_QBaseCreateAnchor(QCPItemPixmap* self, const libqt_string name, int anchorId);
    friend void QCPItemPixmap_InitializeParentPlot(QCPItemPixmap* self, QCustomPlot* parentPlot);
    friend void QCPItemPixmap_QBaseInitializeParentPlot(QCPItemPixmap* self, QCustomPlot* parentPlot);
    friend void QCPItemPixmap_SetParentLayerable(QCPItemPixmap* self, QCPLayerable* parentLayerable);
    friend void QCPItemPixmap_QBaseSetParentLayerable(QCPItemPixmap* self, QCPLayerable* parentLayerable);
    friend bool QCPItemPixmap_MoveToLayer(QCPItemPixmap* self, QCPLayer* layer, bool prepend);
    friend bool QCPItemPixmap_QBaseMoveToLayer(QCPItemPixmap* self, QCPLayer* layer, bool prepend);
    friend void QCPItemPixmap_ApplyAntialiasingHint(const QCPItemPixmap* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPItemPixmap_QBaseApplyAntialiasingHint(const QCPItemPixmap* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPItemPixmap_Sender(const QCPItemPixmap* self);
    friend QObject* QCPItemPixmap_QBaseSender(const QCPItemPixmap* self);
    friend int QCPItemPixmap_SenderSignalIndex(const QCPItemPixmap* self);
    friend int QCPItemPixmap_QBaseSenderSignalIndex(const QCPItemPixmap* self);
    friend int QCPItemPixmap_Receivers(const QCPItemPixmap* self, const char* signal);
    friend int QCPItemPixmap_QBaseReceivers(const QCPItemPixmap* self, const char* signal);
    friend bool QCPItemPixmap_IsSignalConnected(const QCPItemPixmap* self, const QMetaMethod* signal);
    friend bool QCPItemPixmap_QBaseIsSignalConnected(const QCPItemPixmap* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPItemTracer so that we can call protected methods
class VirtualQCPItemTracer final : public QCPItemTracer {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPItemTracer = true;

    // Virtual class public types (including callbacks)
    using QCPItemTracer_Metacall_Callback = int (*)(QCPItemTracer*, int, int, void**);
    using QCPItemTracer_SelectTest_Callback = double (*)(const QCPItemTracer*, QPointF*, bool, QVariant*);
    using QCPItemTracer_Draw_Callback = void (*)(QCPItemTracer*, QCPPainter*);
    using QCPItemTracer_SelectionCategory_Callback = int (*)();
    using QCPItemTracer_ClipRect_Callback = QRect* (*)();
    using QCPItemTracer_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPItemTracer*, QCPPainter*);
    using QCPItemTracer_SelectEvent_Callback = void (*)(QCPItemTracer*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPItemTracer_DeselectEvent_Callback = void (*)(QCPItemTracer*, bool*);
    using QCPItemTracer_AnchorPixelPosition_Callback = QPointF* (*)(const QCPItemTracer*, int);
    using QCPItemTracer_ParentPlotInitialized_Callback = void (*)(QCPItemTracer*, QCustomPlot*);
    using QCPItemTracer_MousePressEvent_Callback = void (*)(QCPItemTracer*, QMouseEvent*, QVariant*);
    using QCPItemTracer_MouseMoveEvent_Callback = void (*)(QCPItemTracer*, QMouseEvent*, QPointF*);
    using QCPItemTracer_MouseReleaseEvent_Callback = void (*)(QCPItemTracer*, QMouseEvent*, QPointF*);
    using QCPItemTracer_MouseDoubleClickEvent_Callback = void (*)(QCPItemTracer*, QMouseEvent*, QVariant*);
    using QCPItemTracer_WheelEvent_Callback = void (*)(QCPItemTracer*, QWheelEvent*);
    using QCPItemTracer_Event_Callback = bool (*)(QCPItemTracer*, QEvent*);
    using QCPItemTracer_EventFilter_Callback = bool (*)(QCPItemTracer*, QObject*, QEvent*);
    using QCPItemTracer_TimerEvent_Callback = void (*)(QCPItemTracer*, QTimerEvent*);
    using QCPItemTracer_ChildEvent_Callback = void (*)(QCPItemTracer*, QChildEvent*);
    using QCPItemTracer_CustomEvent_Callback = void (*)(QCPItemTracer*, QEvent*);
    using QCPItemTracer_ConnectNotify_Callback = void (*)(QCPItemTracer*, QMetaMethod*);
    using QCPItemTracer_DisconnectNotify_Callback = void (*)(QCPItemTracer*, QMetaMethod*);
    using QCPItemTracer_MainPen_Callback = QPen* (*)();
    using QCPItemTracer_MainBrush_Callback = QBrush* (*)();
    using QCPItemTracer_RectDistance_Callback = double (*)(const QCPItemTracer*, QRectF*, QPointF*, bool);
    using QCPItemTracer_CreatePosition_Callback = QCPItemPosition* (*)(QCPItemTracer*, libqt_string);
    using QCPItemTracer_CreateAnchor_Callback = QCPItemAnchor* (*)(QCPItemTracer*, libqt_string, int);
    using QCPItemTracer_InitializeParentPlot_Callback = void (*)(QCPItemTracer*, QCustomPlot*);
    using QCPItemTracer_SetParentLayerable_Callback = void (*)(QCPItemTracer*, QCPLayerable*);
    using QCPItemTracer_MoveToLayer_Callback = bool (*)(QCPItemTracer*, QCPLayer*, bool);
    using QCPItemTracer_ApplyAntialiasingHint_Callback = void (*)(const QCPItemTracer*, QCPPainter*, bool, int);
    using QCPItemTracer_Sender_Callback = QObject* (*)();
    using QCPItemTracer_SenderSignalIndex_Callback = int (*)();
    using QCPItemTracer_Receivers_Callback = int (*)(const QCPItemTracer*, const char*);
    using QCPItemTracer_IsSignalConnected_Callback = bool (*)(const QCPItemTracer*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPItemTracer_Metacall_Callback qcpitemtracer_metacall_callback = nullptr;
    QCPItemTracer_SelectTest_Callback qcpitemtracer_selecttest_callback = nullptr;
    QCPItemTracer_Draw_Callback qcpitemtracer_draw_callback = nullptr;
    QCPItemTracer_SelectionCategory_Callback qcpitemtracer_selectioncategory_callback = nullptr;
    QCPItemTracer_ClipRect_Callback qcpitemtracer_cliprect_callback = nullptr;
    QCPItemTracer_ApplyDefaultAntialiasingHint_Callback qcpitemtracer_applydefaultantialiasinghint_callback = nullptr;
    QCPItemTracer_SelectEvent_Callback qcpitemtracer_selectevent_callback = nullptr;
    QCPItemTracer_DeselectEvent_Callback qcpitemtracer_deselectevent_callback = nullptr;
    QCPItemTracer_AnchorPixelPosition_Callback qcpitemtracer_anchorpixelposition_callback = nullptr;
    QCPItemTracer_ParentPlotInitialized_Callback qcpitemtracer_parentplotinitialized_callback = nullptr;
    QCPItemTracer_MousePressEvent_Callback qcpitemtracer_mousepressevent_callback = nullptr;
    QCPItemTracer_MouseMoveEvent_Callback qcpitemtracer_mousemoveevent_callback = nullptr;
    QCPItemTracer_MouseReleaseEvent_Callback qcpitemtracer_mousereleaseevent_callback = nullptr;
    QCPItemTracer_MouseDoubleClickEvent_Callback qcpitemtracer_mousedoubleclickevent_callback = nullptr;
    QCPItemTracer_WheelEvent_Callback qcpitemtracer_wheelevent_callback = nullptr;
    QCPItemTracer_Event_Callback qcpitemtracer_event_callback = nullptr;
    QCPItemTracer_EventFilter_Callback qcpitemtracer_eventfilter_callback = nullptr;
    QCPItemTracer_TimerEvent_Callback qcpitemtracer_timerevent_callback = nullptr;
    QCPItemTracer_ChildEvent_Callback qcpitemtracer_childevent_callback = nullptr;
    QCPItemTracer_CustomEvent_Callback qcpitemtracer_customevent_callback = nullptr;
    QCPItemTracer_ConnectNotify_Callback qcpitemtracer_connectnotify_callback = nullptr;
    QCPItemTracer_DisconnectNotify_Callback qcpitemtracer_disconnectnotify_callback = nullptr;
    QCPItemTracer_MainPen_Callback qcpitemtracer_mainpen_callback = nullptr;
    QCPItemTracer_MainBrush_Callback qcpitemtracer_mainbrush_callback = nullptr;
    QCPItemTracer_RectDistance_Callback qcpitemtracer_rectdistance_callback = nullptr;
    QCPItemTracer_CreatePosition_Callback qcpitemtracer_createposition_callback = nullptr;
    QCPItemTracer_CreateAnchor_Callback qcpitemtracer_createanchor_callback = nullptr;
    QCPItemTracer_InitializeParentPlot_Callback qcpitemtracer_initializeparentplot_callback = nullptr;
    QCPItemTracer_SetParentLayerable_Callback qcpitemtracer_setparentlayerable_callback = nullptr;
    QCPItemTracer_MoveToLayer_Callback qcpitemtracer_movetolayer_callback = nullptr;
    QCPItemTracer_ApplyAntialiasingHint_Callback qcpitemtracer_applyantialiasinghint_callback = nullptr;
    QCPItemTracer_Sender_Callback qcpitemtracer_sender_callback = nullptr;
    QCPItemTracer_SenderSignalIndex_Callback qcpitemtracer_sendersignalindex_callback = nullptr;
    QCPItemTracer_Receivers_Callback qcpitemtracer_receivers_callback = nullptr;
    QCPItemTracer_IsSignalConnected_Callback qcpitemtracer_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpitemtracer_metacall_isbase = false;
    mutable bool qcpitemtracer_selecttest_isbase = false;
    mutable bool qcpitemtracer_draw_isbase = false;
    mutable bool qcpitemtracer_selectioncategory_isbase = false;
    mutable bool qcpitemtracer_cliprect_isbase = false;
    mutable bool qcpitemtracer_applydefaultantialiasinghint_isbase = false;
    mutable bool qcpitemtracer_selectevent_isbase = false;
    mutable bool qcpitemtracer_deselectevent_isbase = false;
    mutable bool qcpitemtracer_anchorpixelposition_isbase = false;
    mutable bool qcpitemtracer_parentplotinitialized_isbase = false;
    mutable bool qcpitemtracer_mousepressevent_isbase = false;
    mutable bool qcpitemtracer_mousemoveevent_isbase = false;
    mutable bool qcpitemtracer_mousereleaseevent_isbase = false;
    mutable bool qcpitemtracer_mousedoubleclickevent_isbase = false;
    mutable bool qcpitemtracer_wheelevent_isbase = false;
    mutable bool qcpitemtracer_event_isbase = false;
    mutable bool qcpitemtracer_eventfilter_isbase = false;
    mutable bool qcpitemtracer_timerevent_isbase = false;
    mutable bool qcpitemtracer_childevent_isbase = false;
    mutable bool qcpitemtracer_customevent_isbase = false;
    mutable bool qcpitemtracer_connectnotify_isbase = false;
    mutable bool qcpitemtracer_disconnectnotify_isbase = false;
    mutable bool qcpitemtracer_mainpen_isbase = false;
    mutable bool qcpitemtracer_mainbrush_isbase = false;
    mutable bool qcpitemtracer_rectdistance_isbase = false;
    mutable bool qcpitemtracer_createposition_isbase = false;
    mutable bool qcpitemtracer_createanchor_isbase = false;
    mutable bool qcpitemtracer_initializeparentplot_isbase = false;
    mutable bool qcpitemtracer_setparentlayerable_isbase = false;
    mutable bool qcpitemtracer_movetolayer_isbase = false;
    mutable bool qcpitemtracer_applyantialiasinghint_isbase = false;
    mutable bool qcpitemtracer_sender_isbase = false;
    mutable bool qcpitemtracer_sendersignalindex_isbase = false;
    mutable bool qcpitemtracer_receivers_isbase = false;
    mutable bool qcpitemtracer_issignalconnected_isbase = false;

  public:
    VirtualQCPItemTracer(QCustomPlot* parentPlot) : QCPItemTracer(parentPlot) {};

    ~VirtualQCPItemTracer() {
        qcpitemtracer_metacall_callback = nullptr;
        qcpitemtracer_selecttest_callback = nullptr;
        qcpitemtracer_draw_callback = nullptr;
        qcpitemtracer_selectioncategory_callback = nullptr;
        qcpitemtracer_cliprect_callback = nullptr;
        qcpitemtracer_applydefaultantialiasinghint_callback = nullptr;
        qcpitemtracer_selectevent_callback = nullptr;
        qcpitemtracer_deselectevent_callback = nullptr;
        qcpitemtracer_anchorpixelposition_callback = nullptr;
        qcpitemtracer_parentplotinitialized_callback = nullptr;
        qcpitemtracer_mousepressevent_callback = nullptr;
        qcpitemtracer_mousemoveevent_callback = nullptr;
        qcpitemtracer_mousereleaseevent_callback = nullptr;
        qcpitemtracer_mousedoubleclickevent_callback = nullptr;
        qcpitemtracer_wheelevent_callback = nullptr;
        qcpitemtracer_event_callback = nullptr;
        qcpitemtracer_eventfilter_callback = nullptr;
        qcpitemtracer_timerevent_callback = nullptr;
        qcpitemtracer_childevent_callback = nullptr;
        qcpitemtracer_customevent_callback = nullptr;
        qcpitemtracer_connectnotify_callback = nullptr;
        qcpitemtracer_disconnectnotify_callback = nullptr;
        qcpitemtracer_mainpen_callback = nullptr;
        qcpitemtracer_mainbrush_callback = nullptr;
        qcpitemtracer_rectdistance_callback = nullptr;
        qcpitemtracer_createposition_callback = nullptr;
        qcpitemtracer_createanchor_callback = nullptr;
        qcpitemtracer_initializeparentplot_callback = nullptr;
        qcpitemtracer_setparentlayerable_callback = nullptr;
        qcpitemtracer_movetolayer_callback = nullptr;
        qcpitemtracer_applyantialiasinghint_callback = nullptr;
        qcpitemtracer_sender_callback = nullptr;
        qcpitemtracer_sendersignalindex_callback = nullptr;
        qcpitemtracer_receivers_callback = nullptr;
        qcpitemtracer_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPItemTracer_Metacall_Callback(QCPItemTracer_Metacall_Callback cb) { qcpitemtracer_metacall_callback = cb; }
    inline void setQCPItemTracer_SelectTest_Callback(QCPItemTracer_SelectTest_Callback cb) { qcpitemtracer_selecttest_callback = cb; }
    inline void setQCPItemTracer_Draw_Callback(QCPItemTracer_Draw_Callback cb) { qcpitemtracer_draw_callback = cb; }
    inline void setQCPItemTracer_SelectionCategory_Callback(QCPItemTracer_SelectionCategory_Callback cb) { qcpitemtracer_selectioncategory_callback = cb; }
    inline void setQCPItemTracer_ClipRect_Callback(QCPItemTracer_ClipRect_Callback cb) { qcpitemtracer_cliprect_callback = cb; }
    inline void setQCPItemTracer_ApplyDefaultAntialiasingHint_Callback(QCPItemTracer_ApplyDefaultAntialiasingHint_Callback cb) { qcpitemtracer_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPItemTracer_SelectEvent_Callback(QCPItemTracer_SelectEvent_Callback cb) { qcpitemtracer_selectevent_callback = cb; }
    inline void setQCPItemTracer_DeselectEvent_Callback(QCPItemTracer_DeselectEvent_Callback cb) { qcpitemtracer_deselectevent_callback = cb; }
    inline void setQCPItemTracer_AnchorPixelPosition_Callback(QCPItemTracer_AnchorPixelPosition_Callback cb) { qcpitemtracer_anchorpixelposition_callback = cb; }
    inline void setQCPItemTracer_ParentPlotInitialized_Callback(QCPItemTracer_ParentPlotInitialized_Callback cb) { qcpitemtracer_parentplotinitialized_callback = cb; }
    inline void setQCPItemTracer_MousePressEvent_Callback(QCPItemTracer_MousePressEvent_Callback cb) { qcpitemtracer_mousepressevent_callback = cb; }
    inline void setQCPItemTracer_MouseMoveEvent_Callback(QCPItemTracer_MouseMoveEvent_Callback cb) { qcpitemtracer_mousemoveevent_callback = cb; }
    inline void setQCPItemTracer_MouseReleaseEvent_Callback(QCPItemTracer_MouseReleaseEvent_Callback cb) { qcpitemtracer_mousereleaseevent_callback = cb; }
    inline void setQCPItemTracer_MouseDoubleClickEvent_Callback(QCPItemTracer_MouseDoubleClickEvent_Callback cb) { qcpitemtracer_mousedoubleclickevent_callback = cb; }
    inline void setQCPItemTracer_WheelEvent_Callback(QCPItemTracer_WheelEvent_Callback cb) { qcpitemtracer_wheelevent_callback = cb; }
    inline void setQCPItemTracer_Event_Callback(QCPItemTracer_Event_Callback cb) { qcpitemtracer_event_callback = cb; }
    inline void setQCPItemTracer_EventFilter_Callback(QCPItemTracer_EventFilter_Callback cb) { qcpitemtracer_eventfilter_callback = cb; }
    inline void setQCPItemTracer_TimerEvent_Callback(QCPItemTracer_TimerEvent_Callback cb) { qcpitemtracer_timerevent_callback = cb; }
    inline void setQCPItemTracer_ChildEvent_Callback(QCPItemTracer_ChildEvent_Callback cb) { qcpitemtracer_childevent_callback = cb; }
    inline void setQCPItemTracer_CustomEvent_Callback(QCPItemTracer_CustomEvent_Callback cb) { qcpitemtracer_customevent_callback = cb; }
    inline void setQCPItemTracer_ConnectNotify_Callback(QCPItemTracer_ConnectNotify_Callback cb) { qcpitemtracer_connectnotify_callback = cb; }
    inline void setQCPItemTracer_DisconnectNotify_Callback(QCPItemTracer_DisconnectNotify_Callback cb) { qcpitemtracer_disconnectnotify_callback = cb; }
    inline void setQCPItemTracer_MainPen_Callback(QCPItemTracer_MainPen_Callback cb) { qcpitemtracer_mainpen_callback = cb; }
    inline void setQCPItemTracer_MainBrush_Callback(QCPItemTracer_MainBrush_Callback cb) { qcpitemtracer_mainbrush_callback = cb; }
    inline void setQCPItemTracer_RectDistance_Callback(QCPItemTracer_RectDistance_Callback cb) { qcpitemtracer_rectdistance_callback = cb; }
    inline void setQCPItemTracer_CreatePosition_Callback(QCPItemTracer_CreatePosition_Callback cb) { qcpitemtracer_createposition_callback = cb; }
    inline void setQCPItemTracer_CreateAnchor_Callback(QCPItemTracer_CreateAnchor_Callback cb) { qcpitemtracer_createanchor_callback = cb; }
    inline void setQCPItemTracer_InitializeParentPlot_Callback(QCPItemTracer_InitializeParentPlot_Callback cb) { qcpitemtracer_initializeparentplot_callback = cb; }
    inline void setQCPItemTracer_SetParentLayerable_Callback(QCPItemTracer_SetParentLayerable_Callback cb) { qcpitemtracer_setparentlayerable_callback = cb; }
    inline void setQCPItemTracer_MoveToLayer_Callback(QCPItemTracer_MoveToLayer_Callback cb) { qcpitemtracer_movetolayer_callback = cb; }
    inline void setQCPItemTracer_ApplyAntialiasingHint_Callback(QCPItemTracer_ApplyAntialiasingHint_Callback cb) { qcpitemtracer_applyantialiasinghint_callback = cb; }
    inline void setQCPItemTracer_Sender_Callback(QCPItemTracer_Sender_Callback cb) { qcpitemtracer_sender_callback = cb; }
    inline void setQCPItemTracer_SenderSignalIndex_Callback(QCPItemTracer_SenderSignalIndex_Callback cb) { qcpitemtracer_sendersignalindex_callback = cb; }
    inline void setQCPItemTracer_Receivers_Callback(QCPItemTracer_Receivers_Callback cb) { qcpitemtracer_receivers_callback = cb; }
    inline void setQCPItemTracer_IsSignalConnected_Callback(QCPItemTracer_IsSignalConnected_Callback cb) { qcpitemtracer_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPItemTracer_Metacall_IsBase(bool value) const { qcpitemtracer_metacall_isbase = value; }
    inline void setQCPItemTracer_SelectTest_IsBase(bool value) const { qcpitemtracer_selecttest_isbase = value; }
    inline void setQCPItemTracer_Draw_IsBase(bool value) const { qcpitemtracer_draw_isbase = value; }
    inline void setQCPItemTracer_SelectionCategory_IsBase(bool value) const { qcpitemtracer_selectioncategory_isbase = value; }
    inline void setQCPItemTracer_ClipRect_IsBase(bool value) const { qcpitemtracer_cliprect_isbase = value; }
    inline void setQCPItemTracer_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcpitemtracer_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPItemTracer_SelectEvent_IsBase(bool value) const { qcpitemtracer_selectevent_isbase = value; }
    inline void setQCPItemTracer_DeselectEvent_IsBase(bool value) const { qcpitemtracer_deselectevent_isbase = value; }
    inline void setQCPItemTracer_AnchorPixelPosition_IsBase(bool value) const { qcpitemtracer_anchorpixelposition_isbase = value; }
    inline void setQCPItemTracer_ParentPlotInitialized_IsBase(bool value) const { qcpitemtracer_parentplotinitialized_isbase = value; }
    inline void setQCPItemTracer_MousePressEvent_IsBase(bool value) const { qcpitemtracer_mousepressevent_isbase = value; }
    inline void setQCPItemTracer_MouseMoveEvent_IsBase(bool value) const { qcpitemtracer_mousemoveevent_isbase = value; }
    inline void setQCPItemTracer_MouseReleaseEvent_IsBase(bool value) const { qcpitemtracer_mousereleaseevent_isbase = value; }
    inline void setQCPItemTracer_MouseDoubleClickEvent_IsBase(bool value) const { qcpitemtracer_mousedoubleclickevent_isbase = value; }
    inline void setQCPItemTracer_WheelEvent_IsBase(bool value) const { qcpitemtracer_wheelevent_isbase = value; }
    inline void setQCPItemTracer_Event_IsBase(bool value) const { qcpitemtracer_event_isbase = value; }
    inline void setQCPItemTracer_EventFilter_IsBase(bool value) const { qcpitemtracer_eventfilter_isbase = value; }
    inline void setQCPItemTracer_TimerEvent_IsBase(bool value) const { qcpitemtracer_timerevent_isbase = value; }
    inline void setQCPItemTracer_ChildEvent_IsBase(bool value) const { qcpitemtracer_childevent_isbase = value; }
    inline void setQCPItemTracer_CustomEvent_IsBase(bool value) const { qcpitemtracer_customevent_isbase = value; }
    inline void setQCPItemTracer_ConnectNotify_IsBase(bool value) const { qcpitemtracer_connectnotify_isbase = value; }
    inline void setQCPItemTracer_DisconnectNotify_IsBase(bool value) const { qcpitemtracer_disconnectnotify_isbase = value; }
    inline void setQCPItemTracer_MainPen_IsBase(bool value) const { qcpitemtracer_mainpen_isbase = value; }
    inline void setQCPItemTracer_MainBrush_IsBase(bool value) const { qcpitemtracer_mainbrush_isbase = value; }
    inline void setQCPItemTracer_RectDistance_IsBase(bool value) const { qcpitemtracer_rectdistance_isbase = value; }
    inline void setQCPItemTracer_CreatePosition_IsBase(bool value) const { qcpitemtracer_createposition_isbase = value; }
    inline void setQCPItemTracer_CreateAnchor_IsBase(bool value) const { qcpitemtracer_createanchor_isbase = value; }
    inline void setQCPItemTracer_InitializeParentPlot_IsBase(bool value) const { qcpitemtracer_initializeparentplot_isbase = value; }
    inline void setQCPItemTracer_SetParentLayerable_IsBase(bool value) const { qcpitemtracer_setparentlayerable_isbase = value; }
    inline void setQCPItemTracer_MoveToLayer_IsBase(bool value) const { qcpitemtracer_movetolayer_isbase = value; }
    inline void setQCPItemTracer_ApplyAntialiasingHint_IsBase(bool value) const { qcpitemtracer_applyantialiasinghint_isbase = value; }
    inline void setQCPItemTracer_Sender_IsBase(bool value) const { qcpitemtracer_sender_isbase = value; }
    inline void setQCPItemTracer_SenderSignalIndex_IsBase(bool value) const { qcpitemtracer_sendersignalindex_isbase = value; }
    inline void setQCPItemTracer_Receivers_IsBase(bool value) const { qcpitemtracer_receivers_isbase = value; }
    inline void setQCPItemTracer_IsSignalConnected_IsBase(bool value) const { qcpitemtracer_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpitemtracer_metacall_isbase) {
            qcpitemtracer_metacall_isbase = false;
            return QCPItemTracer::qt_metacall(param1, param2, param3);
        } else if (qcpitemtracer_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpitemtracer_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemTracer::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcpitemtracer_selecttest_isbase) {
            qcpitemtracer_selecttest_isbase = false;
            return QCPItemTracer::selectTest(pos, onlySelectable, details);
        } else if (qcpitemtracer_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcpitemtracer_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPItemTracer::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcpitemtracer_draw_isbase) {
            qcpitemtracer_draw_isbase = false;
            QCPItemTracer::draw(painter);
        } else if (qcpitemtracer_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpitemtracer_draw_callback(this, cbval1);
        } else {
            QCPItemTracer::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcpitemtracer_selectioncategory_isbase) {
            qcpitemtracer_selectioncategory_isbase = false;
            return QCPItemTracer::selectionCategory();
        } else if (qcpitemtracer_selectioncategory_callback != nullptr) {
            int callback_ret = qcpitemtracer_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPItemTracer::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcpitemtracer_cliprect_isbase) {
            qcpitemtracer_cliprect_isbase = false;
            return QCPItemTracer::clipRect();
        } else if (qcpitemtracer_cliprect_callback != nullptr) {
            QRect* callback_ret = qcpitemtracer_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPItemTracer::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcpitemtracer_applydefaultantialiasinghint_isbase) {
            qcpitemtracer_applydefaultantialiasinghint_isbase = false;
            QCPItemTracer::applyDefaultAntialiasingHint(painter);
        } else if (qcpitemtracer_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpitemtracer_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPItemTracer::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcpitemtracer_selectevent_isbase) {
            qcpitemtracer_selectevent_isbase = false;
            QCPItemTracer::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcpitemtracer_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcpitemtracer_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPItemTracer::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcpitemtracer_deselectevent_isbase) {
            qcpitemtracer_deselectevent_isbase = false;
            QCPItemTracer::deselectEvent(selectionStateChanged);
        } else if (qcpitemtracer_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcpitemtracer_deselectevent_callback(this, cbval1);
        } else {
            QCPItemTracer::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QPointF anchorPixelPosition(int anchorId) const override {
        if (qcpitemtracer_anchorpixelposition_isbase) {
            qcpitemtracer_anchorpixelposition_isbase = false;
            return QCPItemTracer::anchorPixelPosition(anchorId);
        } else if (qcpitemtracer_anchorpixelposition_callback != nullptr) {
            int cbval1 = anchorId;

            QPointF* callback_ret = qcpitemtracer_anchorpixelposition_callback(this, cbval1);
            return *callback_ret;
        } else {
            return QCPItemTracer::anchorPixelPosition(anchorId);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcpitemtracer_parentplotinitialized_isbase) {
            qcpitemtracer_parentplotinitialized_isbase = false;
            QCPItemTracer::parentPlotInitialized(parentPlot);
        } else if (qcpitemtracer_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpitemtracer_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPItemTracer::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpitemtracer_mousepressevent_isbase) {
            qcpitemtracer_mousepressevent_isbase = false;
            QCPItemTracer::mousePressEvent(event, details);
        } else if (qcpitemtracer_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpitemtracer_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemTracer::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpitemtracer_mousemoveevent_isbase) {
            qcpitemtracer_mousemoveevent_isbase = false;
            QCPItemTracer::mouseMoveEvent(event, startPos);
        } else if (qcpitemtracer_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpitemtracer_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemTracer::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpitemtracer_mousereleaseevent_isbase) {
            qcpitemtracer_mousereleaseevent_isbase = false;
            QCPItemTracer::mouseReleaseEvent(event, startPos);
        } else if (qcpitemtracer_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpitemtracer_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemTracer::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpitemtracer_mousedoubleclickevent_isbase) {
            qcpitemtracer_mousedoubleclickevent_isbase = false;
            QCPItemTracer::mouseDoubleClickEvent(event, details);
        } else if (qcpitemtracer_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpitemtracer_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemTracer::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcpitemtracer_wheelevent_isbase) {
            qcpitemtracer_wheelevent_isbase = false;
            QCPItemTracer::wheelEvent(event);
        } else if (qcpitemtracer_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcpitemtracer_wheelevent_callback(this, cbval1);
        } else {
            QCPItemTracer::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpitemtracer_event_isbase) {
            qcpitemtracer_event_isbase = false;
            return QCPItemTracer::event(event);
        } else if (qcpitemtracer_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpitemtracer_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemTracer::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpitemtracer_eventfilter_isbase) {
            qcpitemtracer_eventfilter_isbase = false;
            return QCPItemTracer::eventFilter(watched, event);
        } else if (qcpitemtracer_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpitemtracer_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemTracer::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpitemtracer_timerevent_isbase) {
            qcpitemtracer_timerevent_isbase = false;
            QCPItemTracer::timerEvent(event);
        } else if (qcpitemtracer_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpitemtracer_timerevent_callback(this, cbval1);
        } else {
            QCPItemTracer::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpitemtracer_childevent_isbase) {
            qcpitemtracer_childevent_isbase = false;
            QCPItemTracer::childEvent(event);
        } else if (qcpitemtracer_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpitemtracer_childevent_callback(this, cbval1);
        } else {
            QCPItemTracer::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpitemtracer_customevent_isbase) {
            qcpitemtracer_customevent_isbase = false;
            QCPItemTracer::customEvent(event);
        } else if (qcpitemtracer_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpitemtracer_customevent_callback(this, cbval1);
        } else {
            QCPItemTracer::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpitemtracer_connectnotify_isbase) {
            qcpitemtracer_connectnotify_isbase = false;
            QCPItemTracer::connectNotify(signal);
        } else if (qcpitemtracer_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpitemtracer_connectnotify_callback(this, cbval1);
        } else {
            QCPItemTracer::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpitemtracer_disconnectnotify_isbase) {
            qcpitemtracer_disconnectnotify_isbase = false;
            QCPItemTracer::disconnectNotify(signal);
        } else if (qcpitemtracer_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpitemtracer_disconnectnotify_callback(this, cbval1);
        } else {
            QCPItemTracer::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    QPen mainPen() const {
        if (qcpitemtracer_mainpen_isbase) {
            qcpitemtracer_mainpen_isbase = false;
            return QCPItemTracer::mainPen();
        } else if (qcpitemtracer_mainpen_callback != nullptr) {
            QPen* callback_ret = qcpitemtracer_mainpen_callback();
            return *callback_ret;
        } else {
            return QCPItemTracer::mainPen();
        }
    }

    // Virtual method for C ABI access and custom callback
    QBrush mainBrush() const {
        if (qcpitemtracer_mainbrush_isbase) {
            qcpitemtracer_mainbrush_isbase = false;
            return QCPItemTracer::mainBrush();
        } else if (qcpitemtracer_mainbrush_callback != nullptr) {
            QBrush* callback_ret = qcpitemtracer_mainbrush_callback();
            return *callback_ret;
        } else {
            return QCPItemTracer::mainBrush();
        }
    }

    // Virtual method for C ABI access and custom callback
    double rectDistance(const QRectF& rect, const QPointF& pos, bool filledRect) const {
        if (qcpitemtracer_rectdistance_isbase) {
            qcpitemtracer_rectdistance_isbase = false;
            return QCPItemTracer::rectDistance(rect, pos, filledRect);
        } else if (qcpitemtracer_rectdistance_callback != nullptr) {
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval1 = const_cast<QRectF*>(&rect_ret);
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&pos_ret);
            bool cbval3 = filledRect;

            double callback_ret = qcpitemtracer_rectdistance_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPItemTracer::rectDistance(rect, pos, filledRect);
        }
    }

    // Virtual method for C ABI access and custom callback
    QCPItemPosition* createPosition(const QString& name) {
        if (qcpitemtracer_createposition_isbase) {
            qcpitemtracer_createposition_isbase = false;
            return QCPItemTracer::createPosition(name);
        } else if (qcpitemtracer_createposition_callback != nullptr) {
            const QString name_ret = name;
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray name_b = name_ret.toUtf8();
            libqt_string name_str;
            name_str.len = name_b.length();
            name_str.data = static_cast<const char*>(malloc(name_str.len + 1));
            memcpy((void*)name_str.data, name_b.data(), name_str.len);
            ((char*)name_str.data)[name_str.len] = '\0';
            libqt_string cbval1 = name_str;

            QCPItemPosition* callback_ret = qcpitemtracer_createposition_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemTracer::createPosition(name);
        }
    }

    // Virtual method for C ABI access and custom callback
    QCPItemAnchor* createAnchor(const QString& name, int anchorId) {
        if (qcpitemtracer_createanchor_isbase) {
            qcpitemtracer_createanchor_isbase = false;
            return QCPItemTracer::createAnchor(name, anchorId);
        } else if (qcpitemtracer_createanchor_callback != nullptr) {
            const QString name_ret = name;
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray name_b = name_ret.toUtf8();
            libqt_string name_str;
            name_str.len = name_b.length();
            name_str.data = static_cast<const char*>(malloc(name_str.len + 1));
            memcpy((void*)name_str.data, name_b.data(), name_str.len);
            ((char*)name_str.data)[name_str.len] = '\0';
            libqt_string cbval1 = name_str;
            int cbval2 = anchorId;

            QCPItemAnchor* callback_ret = qcpitemtracer_createanchor_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemTracer::createAnchor(name, anchorId);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcpitemtracer_initializeparentplot_isbase) {
            qcpitemtracer_initializeparentplot_isbase = false;
            QCPItemTracer::initializeParentPlot(parentPlot);
        } else if (qcpitemtracer_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpitemtracer_initializeparentplot_callback(this, cbval1);
        } else {
            QCPItemTracer::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcpitemtracer_setparentlayerable_isbase) {
            qcpitemtracer_setparentlayerable_isbase = false;
            QCPItemTracer::setParentLayerable(parentLayerable);
        } else if (qcpitemtracer_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcpitemtracer_setparentlayerable_callback(this, cbval1);
        } else {
            QCPItemTracer::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcpitemtracer_movetolayer_isbase) {
            qcpitemtracer_movetolayer_isbase = false;
            return QCPItemTracer::moveToLayer(layer, prepend);
        } else if (qcpitemtracer_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcpitemtracer_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemTracer::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcpitemtracer_applyantialiasinghint_isbase) {
            qcpitemtracer_applyantialiasinghint_isbase = false;
            QCPItemTracer::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcpitemtracer_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcpitemtracer_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPItemTracer::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpitemtracer_sender_isbase) {
            qcpitemtracer_sender_isbase = false;
            return QCPItemTracer::sender();
        } else if (qcpitemtracer_sender_callback != nullptr) {
            QObject* callback_ret = qcpitemtracer_sender_callback();
            return callback_ret;
        } else {
            return QCPItemTracer::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpitemtracer_sendersignalindex_isbase) {
            qcpitemtracer_sendersignalindex_isbase = false;
            return QCPItemTracer::senderSignalIndex();
        } else if (qcpitemtracer_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpitemtracer_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemTracer::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpitemtracer_receivers_isbase) {
            qcpitemtracer_receivers_isbase = false;
            return QCPItemTracer::receivers(signal);
        } else if (qcpitemtracer_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpitemtracer_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemTracer::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpitemtracer_issignalconnected_isbase) {
            qcpitemtracer_issignalconnected_isbase = false;
            return QCPItemTracer::isSignalConnected(signal);
        } else if (qcpitemtracer_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpitemtracer_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemTracer::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPItemTracer_Draw(QCPItemTracer* self, QCPPainter* painter);
    friend void QCPItemTracer_QBaseDraw(QCPItemTracer* self, QCPPainter* painter);
    friend int QCPItemTracer_SelectionCategory(const QCPItemTracer* self);
    friend int QCPItemTracer_QBaseSelectionCategory(const QCPItemTracer* self);
    friend QRect* QCPItemTracer_ClipRect(const QCPItemTracer* self);
    friend QRect* QCPItemTracer_QBaseClipRect(const QCPItemTracer* self);
    friend void QCPItemTracer_ApplyDefaultAntialiasingHint(const QCPItemTracer* self, QCPPainter* painter);
    friend void QCPItemTracer_QBaseApplyDefaultAntialiasingHint(const QCPItemTracer* self, QCPPainter* painter);
    friend void QCPItemTracer_SelectEvent(QCPItemTracer* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPItemTracer_QBaseSelectEvent(QCPItemTracer* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPItemTracer_DeselectEvent(QCPItemTracer* self, bool* selectionStateChanged);
    friend void QCPItemTracer_QBaseDeselectEvent(QCPItemTracer* self, bool* selectionStateChanged);
    friend QPointF* QCPItemTracer_AnchorPixelPosition(const QCPItemTracer* self, int anchorId);
    friend QPointF* QCPItemTracer_QBaseAnchorPixelPosition(const QCPItemTracer* self, int anchorId);
    friend void QCPItemTracer_ParentPlotInitialized(QCPItemTracer* self, QCustomPlot* parentPlot);
    friend void QCPItemTracer_QBaseParentPlotInitialized(QCPItemTracer* self, QCustomPlot* parentPlot);
    friend void QCPItemTracer_MousePressEvent(QCPItemTracer* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemTracer_QBaseMousePressEvent(QCPItemTracer* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemTracer_MouseMoveEvent(QCPItemTracer* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemTracer_QBaseMouseMoveEvent(QCPItemTracer* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemTracer_MouseReleaseEvent(QCPItemTracer* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemTracer_QBaseMouseReleaseEvent(QCPItemTracer* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemTracer_MouseDoubleClickEvent(QCPItemTracer* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemTracer_QBaseMouseDoubleClickEvent(QCPItemTracer* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemTracer_WheelEvent(QCPItemTracer* self, QWheelEvent* event);
    friend void QCPItemTracer_QBaseWheelEvent(QCPItemTracer* self, QWheelEvent* event);
    friend void QCPItemTracer_TimerEvent(QCPItemTracer* self, QTimerEvent* event);
    friend void QCPItemTracer_QBaseTimerEvent(QCPItemTracer* self, QTimerEvent* event);
    friend void QCPItemTracer_ChildEvent(QCPItemTracer* self, QChildEvent* event);
    friend void QCPItemTracer_QBaseChildEvent(QCPItemTracer* self, QChildEvent* event);
    friend void QCPItemTracer_CustomEvent(QCPItemTracer* self, QEvent* event);
    friend void QCPItemTracer_QBaseCustomEvent(QCPItemTracer* self, QEvent* event);
    friend void QCPItemTracer_ConnectNotify(QCPItemTracer* self, const QMetaMethod* signal);
    friend void QCPItemTracer_QBaseConnectNotify(QCPItemTracer* self, const QMetaMethod* signal);
    friend void QCPItemTracer_DisconnectNotify(QCPItemTracer* self, const QMetaMethod* signal);
    friend void QCPItemTracer_QBaseDisconnectNotify(QCPItemTracer* self, const QMetaMethod* signal);
    friend QPen* QCPItemTracer_MainPen(const QCPItemTracer* self);
    friend QPen* QCPItemTracer_QBaseMainPen(const QCPItemTracer* self);
    friend QBrush* QCPItemTracer_MainBrush(const QCPItemTracer* self);
    friend QBrush* QCPItemTracer_QBaseMainBrush(const QCPItemTracer* self);
    friend double QCPItemTracer_RectDistance(const QCPItemTracer* self, const QRectF* rect, const QPointF* pos, bool filledRect);
    friend double QCPItemTracer_QBaseRectDistance(const QCPItemTracer* self, const QRectF* rect, const QPointF* pos, bool filledRect);
    friend QCPItemPosition* QCPItemTracer_CreatePosition(QCPItemTracer* self, const libqt_string name);
    friend QCPItemPosition* QCPItemTracer_QBaseCreatePosition(QCPItemTracer* self, const libqt_string name);
    friend QCPItemAnchor* QCPItemTracer_CreateAnchor(QCPItemTracer* self, const libqt_string name, int anchorId);
    friend QCPItemAnchor* QCPItemTracer_QBaseCreateAnchor(QCPItemTracer* self, const libqt_string name, int anchorId);
    friend void QCPItemTracer_InitializeParentPlot(QCPItemTracer* self, QCustomPlot* parentPlot);
    friend void QCPItemTracer_QBaseInitializeParentPlot(QCPItemTracer* self, QCustomPlot* parentPlot);
    friend void QCPItemTracer_SetParentLayerable(QCPItemTracer* self, QCPLayerable* parentLayerable);
    friend void QCPItemTracer_QBaseSetParentLayerable(QCPItemTracer* self, QCPLayerable* parentLayerable);
    friend bool QCPItemTracer_MoveToLayer(QCPItemTracer* self, QCPLayer* layer, bool prepend);
    friend bool QCPItemTracer_QBaseMoveToLayer(QCPItemTracer* self, QCPLayer* layer, bool prepend);
    friend void QCPItemTracer_ApplyAntialiasingHint(const QCPItemTracer* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPItemTracer_QBaseApplyAntialiasingHint(const QCPItemTracer* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPItemTracer_Sender(const QCPItemTracer* self);
    friend QObject* QCPItemTracer_QBaseSender(const QCPItemTracer* self);
    friend int QCPItemTracer_SenderSignalIndex(const QCPItemTracer* self);
    friend int QCPItemTracer_QBaseSenderSignalIndex(const QCPItemTracer* self);
    friend int QCPItemTracer_Receivers(const QCPItemTracer* self, const char* signal);
    friend int QCPItemTracer_QBaseReceivers(const QCPItemTracer* self, const char* signal);
    friend bool QCPItemTracer_IsSignalConnected(const QCPItemTracer* self, const QMetaMethod* signal);
    friend bool QCPItemTracer_QBaseIsSignalConnected(const QCPItemTracer* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPItemBracket so that we can call protected methods
class VirtualQCPItemBracket final : public QCPItemBracket {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPItemBracket = true;

    // Virtual class public types (including callbacks)
    using QCPItemBracket::AnchorIndex;
    using QCPItemBracket_Metacall_Callback = int (*)(QCPItemBracket*, int, int, void**);
    using QCPItemBracket_SelectTest_Callback = double (*)(const QCPItemBracket*, QPointF*, bool, QVariant*);
    using QCPItemBracket_Draw_Callback = void (*)(QCPItemBracket*, QCPPainter*);
    using QCPItemBracket_AnchorPixelPosition_Callback = QPointF* (*)(const QCPItemBracket*, int);
    using QCPItemBracket_SelectionCategory_Callback = int (*)();
    using QCPItemBracket_ClipRect_Callback = QRect* (*)();
    using QCPItemBracket_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPItemBracket*, QCPPainter*);
    using QCPItemBracket_SelectEvent_Callback = void (*)(QCPItemBracket*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPItemBracket_DeselectEvent_Callback = void (*)(QCPItemBracket*, bool*);
    using QCPItemBracket_ParentPlotInitialized_Callback = void (*)(QCPItemBracket*, QCustomPlot*);
    using QCPItemBracket_MousePressEvent_Callback = void (*)(QCPItemBracket*, QMouseEvent*, QVariant*);
    using QCPItemBracket_MouseMoveEvent_Callback = void (*)(QCPItemBracket*, QMouseEvent*, QPointF*);
    using QCPItemBracket_MouseReleaseEvent_Callback = void (*)(QCPItemBracket*, QMouseEvent*, QPointF*);
    using QCPItemBracket_MouseDoubleClickEvent_Callback = void (*)(QCPItemBracket*, QMouseEvent*, QVariant*);
    using QCPItemBracket_WheelEvent_Callback = void (*)(QCPItemBracket*, QWheelEvent*);
    using QCPItemBracket_Event_Callback = bool (*)(QCPItemBracket*, QEvent*);
    using QCPItemBracket_EventFilter_Callback = bool (*)(QCPItemBracket*, QObject*, QEvent*);
    using QCPItemBracket_TimerEvent_Callback = void (*)(QCPItemBracket*, QTimerEvent*);
    using QCPItemBracket_ChildEvent_Callback = void (*)(QCPItemBracket*, QChildEvent*);
    using QCPItemBracket_CustomEvent_Callback = void (*)(QCPItemBracket*, QEvent*);
    using QCPItemBracket_ConnectNotify_Callback = void (*)(QCPItemBracket*, QMetaMethod*);
    using QCPItemBracket_DisconnectNotify_Callback = void (*)(QCPItemBracket*, QMetaMethod*);
    using QCPItemBracket_MainPen_Callback = QPen* (*)();
    using QCPItemBracket_RectDistance_Callback = double (*)(const QCPItemBracket*, QRectF*, QPointF*, bool);
    using QCPItemBracket_CreatePosition_Callback = QCPItemPosition* (*)(QCPItemBracket*, libqt_string);
    using QCPItemBracket_CreateAnchor_Callback = QCPItemAnchor* (*)(QCPItemBracket*, libqt_string, int);
    using QCPItemBracket_InitializeParentPlot_Callback = void (*)(QCPItemBracket*, QCustomPlot*);
    using QCPItemBracket_SetParentLayerable_Callback = void (*)(QCPItemBracket*, QCPLayerable*);
    using QCPItemBracket_MoveToLayer_Callback = bool (*)(QCPItemBracket*, QCPLayer*, bool);
    using QCPItemBracket_ApplyAntialiasingHint_Callback = void (*)(const QCPItemBracket*, QCPPainter*, bool, int);
    using QCPItemBracket_Sender_Callback = QObject* (*)();
    using QCPItemBracket_SenderSignalIndex_Callback = int (*)();
    using QCPItemBracket_Receivers_Callback = int (*)(const QCPItemBracket*, const char*);
    using QCPItemBracket_IsSignalConnected_Callback = bool (*)(const QCPItemBracket*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPItemBracket_Metacall_Callback qcpitembracket_metacall_callback = nullptr;
    QCPItemBracket_SelectTest_Callback qcpitembracket_selecttest_callback = nullptr;
    QCPItemBracket_Draw_Callback qcpitembracket_draw_callback = nullptr;
    QCPItemBracket_AnchorPixelPosition_Callback qcpitembracket_anchorpixelposition_callback = nullptr;
    QCPItemBracket_SelectionCategory_Callback qcpitembracket_selectioncategory_callback = nullptr;
    QCPItemBracket_ClipRect_Callback qcpitembracket_cliprect_callback = nullptr;
    QCPItemBracket_ApplyDefaultAntialiasingHint_Callback qcpitembracket_applydefaultantialiasinghint_callback = nullptr;
    QCPItemBracket_SelectEvent_Callback qcpitembracket_selectevent_callback = nullptr;
    QCPItemBracket_DeselectEvent_Callback qcpitembracket_deselectevent_callback = nullptr;
    QCPItemBracket_ParentPlotInitialized_Callback qcpitembracket_parentplotinitialized_callback = nullptr;
    QCPItemBracket_MousePressEvent_Callback qcpitembracket_mousepressevent_callback = nullptr;
    QCPItemBracket_MouseMoveEvent_Callback qcpitembracket_mousemoveevent_callback = nullptr;
    QCPItemBracket_MouseReleaseEvent_Callback qcpitembracket_mousereleaseevent_callback = nullptr;
    QCPItemBracket_MouseDoubleClickEvent_Callback qcpitembracket_mousedoubleclickevent_callback = nullptr;
    QCPItemBracket_WheelEvent_Callback qcpitembracket_wheelevent_callback = nullptr;
    QCPItemBracket_Event_Callback qcpitembracket_event_callback = nullptr;
    QCPItemBracket_EventFilter_Callback qcpitembracket_eventfilter_callback = nullptr;
    QCPItemBracket_TimerEvent_Callback qcpitembracket_timerevent_callback = nullptr;
    QCPItemBracket_ChildEvent_Callback qcpitembracket_childevent_callback = nullptr;
    QCPItemBracket_CustomEvent_Callback qcpitembracket_customevent_callback = nullptr;
    QCPItemBracket_ConnectNotify_Callback qcpitembracket_connectnotify_callback = nullptr;
    QCPItemBracket_DisconnectNotify_Callback qcpitembracket_disconnectnotify_callback = nullptr;
    QCPItemBracket_MainPen_Callback qcpitembracket_mainpen_callback = nullptr;
    QCPItemBracket_RectDistance_Callback qcpitembracket_rectdistance_callback = nullptr;
    QCPItemBracket_CreatePosition_Callback qcpitembracket_createposition_callback = nullptr;
    QCPItemBracket_CreateAnchor_Callback qcpitembracket_createanchor_callback = nullptr;
    QCPItemBracket_InitializeParentPlot_Callback qcpitembracket_initializeparentplot_callback = nullptr;
    QCPItemBracket_SetParentLayerable_Callback qcpitembracket_setparentlayerable_callback = nullptr;
    QCPItemBracket_MoveToLayer_Callback qcpitembracket_movetolayer_callback = nullptr;
    QCPItemBracket_ApplyAntialiasingHint_Callback qcpitembracket_applyantialiasinghint_callback = nullptr;
    QCPItemBracket_Sender_Callback qcpitembracket_sender_callback = nullptr;
    QCPItemBracket_SenderSignalIndex_Callback qcpitembracket_sendersignalindex_callback = nullptr;
    QCPItemBracket_Receivers_Callback qcpitembracket_receivers_callback = nullptr;
    QCPItemBracket_IsSignalConnected_Callback qcpitembracket_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcpitembracket_metacall_isbase = false;
    mutable bool qcpitembracket_selecttest_isbase = false;
    mutable bool qcpitembracket_draw_isbase = false;
    mutable bool qcpitembracket_anchorpixelposition_isbase = false;
    mutable bool qcpitembracket_selectioncategory_isbase = false;
    mutable bool qcpitembracket_cliprect_isbase = false;
    mutable bool qcpitembracket_applydefaultantialiasinghint_isbase = false;
    mutable bool qcpitembracket_selectevent_isbase = false;
    mutable bool qcpitembracket_deselectevent_isbase = false;
    mutable bool qcpitembracket_parentplotinitialized_isbase = false;
    mutable bool qcpitembracket_mousepressevent_isbase = false;
    mutable bool qcpitembracket_mousemoveevent_isbase = false;
    mutable bool qcpitembracket_mousereleaseevent_isbase = false;
    mutable bool qcpitembracket_mousedoubleclickevent_isbase = false;
    mutable bool qcpitembracket_wheelevent_isbase = false;
    mutable bool qcpitembracket_event_isbase = false;
    mutable bool qcpitembracket_eventfilter_isbase = false;
    mutable bool qcpitembracket_timerevent_isbase = false;
    mutable bool qcpitembracket_childevent_isbase = false;
    mutable bool qcpitembracket_customevent_isbase = false;
    mutable bool qcpitembracket_connectnotify_isbase = false;
    mutable bool qcpitembracket_disconnectnotify_isbase = false;
    mutable bool qcpitembracket_mainpen_isbase = false;
    mutable bool qcpitembracket_rectdistance_isbase = false;
    mutable bool qcpitembracket_createposition_isbase = false;
    mutable bool qcpitembracket_createanchor_isbase = false;
    mutable bool qcpitembracket_initializeparentplot_isbase = false;
    mutable bool qcpitembracket_setparentlayerable_isbase = false;
    mutable bool qcpitembracket_movetolayer_isbase = false;
    mutable bool qcpitembracket_applyantialiasinghint_isbase = false;
    mutable bool qcpitembracket_sender_isbase = false;
    mutable bool qcpitembracket_sendersignalindex_isbase = false;
    mutable bool qcpitembracket_receivers_isbase = false;
    mutable bool qcpitembracket_issignalconnected_isbase = false;

  public:
    VirtualQCPItemBracket(QCustomPlot* parentPlot) : QCPItemBracket(parentPlot) {};

    ~VirtualQCPItemBracket() {
        qcpitembracket_metacall_callback = nullptr;
        qcpitembracket_selecttest_callback = nullptr;
        qcpitembracket_draw_callback = nullptr;
        qcpitembracket_anchorpixelposition_callback = nullptr;
        qcpitembracket_selectioncategory_callback = nullptr;
        qcpitembracket_cliprect_callback = nullptr;
        qcpitembracket_applydefaultantialiasinghint_callback = nullptr;
        qcpitembracket_selectevent_callback = nullptr;
        qcpitembracket_deselectevent_callback = nullptr;
        qcpitembracket_parentplotinitialized_callback = nullptr;
        qcpitembracket_mousepressevent_callback = nullptr;
        qcpitembracket_mousemoveevent_callback = nullptr;
        qcpitembracket_mousereleaseevent_callback = nullptr;
        qcpitembracket_mousedoubleclickevent_callback = nullptr;
        qcpitembracket_wheelevent_callback = nullptr;
        qcpitembracket_event_callback = nullptr;
        qcpitembracket_eventfilter_callback = nullptr;
        qcpitembracket_timerevent_callback = nullptr;
        qcpitembracket_childevent_callback = nullptr;
        qcpitembracket_customevent_callback = nullptr;
        qcpitembracket_connectnotify_callback = nullptr;
        qcpitembracket_disconnectnotify_callback = nullptr;
        qcpitembracket_mainpen_callback = nullptr;
        qcpitembracket_rectdistance_callback = nullptr;
        qcpitembracket_createposition_callback = nullptr;
        qcpitembracket_createanchor_callback = nullptr;
        qcpitembracket_initializeparentplot_callback = nullptr;
        qcpitembracket_setparentlayerable_callback = nullptr;
        qcpitembracket_movetolayer_callback = nullptr;
        qcpitembracket_applyantialiasinghint_callback = nullptr;
        qcpitembracket_sender_callback = nullptr;
        qcpitembracket_sendersignalindex_callback = nullptr;
        qcpitembracket_receivers_callback = nullptr;
        qcpitembracket_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPItemBracket_Metacall_Callback(QCPItemBracket_Metacall_Callback cb) { qcpitembracket_metacall_callback = cb; }
    inline void setQCPItemBracket_SelectTest_Callback(QCPItemBracket_SelectTest_Callback cb) { qcpitembracket_selecttest_callback = cb; }
    inline void setQCPItemBracket_Draw_Callback(QCPItemBracket_Draw_Callback cb) { qcpitembracket_draw_callback = cb; }
    inline void setQCPItemBracket_AnchorPixelPosition_Callback(QCPItemBracket_AnchorPixelPosition_Callback cb) { qcpitembracket_anchorpixelposition_callback = cb; }
    inline void setQCPItemBracket_SelectionCategory_Callback(QCPItemBracket_SelectionCategory_Callback cb) { qcpitembracket_selectioncategory_callback = cb; }
    inline void setQCPItemBracket_ClipRect_Callback(QCPItemBracket_ClipRect_Callback cb) { qcpitembracket_cliprect_callback = cb; }
    inline void setQCPItemBracket_ApplyDefaultAntialiasingHint_Callback(QCPItemBracket_ApplyDefaultAntialiasingHint_Callback cb) { qcpitembracket_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPItemBracket_SelectEvent_Callback(QCPItemBracket_SelectEvent_Callback cb) { qcpitembracket_selectevent_callback = cb; }
    inline void setQCPItemBracket_DeselectEvent_Callback(QCPItemBracket_DeselectEvent_Callback cb) { qcpitembracket_deselectevent_callback = cb; }
    inline void setQCPItemBracket_ParentPlotInitialized_Callback(QCPItemBracket_ParentPlotInitialized_Callback cb) { qcpitembracket_parentplotinitialized_callback = cb; }
    inline void setQCPItemBracket_MousePressEvent_Callback(QCPItemBracket_MousePressEvent_Callback cb) { qcpitembracket_mousepressevent_callback = cb; }
    inline void setQCPItemBracket_MouseMoveEvent_Callback(QCPItemBracket_MouseMoveEvent_Callback cb) { qcpitembracket_mousemoveevent_callback = cb; }
    inline void setQCPItemBracket_MouseReleaseEvent_Callback(QCPItemBracket_MouseReleaseEvent_Callback cb) { qcpitembracket_mousereleaseevent_callback = cb; }
    inline void setQCPItemBracket_MouseDoubleClickEvent_Callback(QCPItemBracket_MouseDoubleClickEvent_Callback cb) { qcpitembracket_mousedoubleclickevent_callback = cb; }
    inline void setQCPItemBracket_WheelEvent_Callback(QCPItemBracket_WheelEvent_Callback cb) { qcpitembracket_wheelevent_callback = cb; }
    inline void setQCPItemBracket_Event_Callback(QCPItemBracket_Event_Callback cb) { qcpitembracket_event_callback = cb; }
    inline void setQCPItemBracket_EventFilter_Callback(QCPItemBracket_EventFilter_Callback cb) { qcpitembracket_eventfilter_callback = cb; }
    inline void setQCPItemBracket_TimerEvent_Callback(QCPItemBracket_TimerEvent_Callback cb) { qcpitembracket_timerevent_callback = cb; }
    inline void setQCPItemBracket_ChildEvent_Callback(QCPItemBracket_ChildEvent_Callback cb) { qcpitembracket_childevent_callback = cb; }
    inline void setQCPItemBracket_CustomEvent_Callback(QCPItemBracket_CustomEvent_Callback cb) { qcpitembracket_customevent_callback = cb; }
    inline void setQCPItemBracket_ConnectNotify_Callback(QCPItemBracket_ConnectNotify_Callback cb) { qcpitembracket_connectnotify_callback = cb; }
    inline void setQCPItemBracket_DisconnectNotify_Callback(QCPItemBracket_DisconnectNotify_Callback cb) { qcpitembracket_disconnectnotify_callback = cb; }
    inline void setQCPItemBracket_MainPen_Callback(QCPItemBracket_MainPen_Callback cb) { qcpitembracket_mainpen_callback = cb; }
    inline void setQCPItemBracket_RectDistance_Callback(QCPItemBracket_RectDistance_Callback cb) { qcpitembracket_rectdistance_callback = cb; }
    inline void setQCPItemBracket_CreatePosition_Callback(QCPItemBracket_CreatePosition_Callback cb) { qcpitembracket_createposition_callback = cb; }
    inline void setQCPItemBracket_CreateAnchor_Callback(QCPItemBracket_CreateAnchor_Callback cb) { qcpitembracket_createanchor_callback = cb; }
    inline void setQCPItemBracket_InitializeParentPlot_Callback(QCPItemBracket_InitializeParentPlot_Callback cb) { qcpitembracket_initializeparentplot_callback = cb; }
    inline void setQCPItemBracket_SetParentLayerable_Callback(QCPItemBracket_SetParentLayerable_Callback cb) { qcpitembracket_setparentlayerable_callback = cb; }
    inline void setQCPItemBracket_MoveToLayer_Callback(QCPItemBracket_MoveToLayer_Callback cb) { qcpitembracket_movetolayer_callback = cb; }
    inline void setQCPItemBracket_ApplyAntialiasingHint_Callback(QCPItemBracket_ApplyAntialiasingHint_Callback cb) { qcpitembracket_applyantialiasinghint_callback = cb; }
    inline void setQCPItemBracket_Sender_Callback(QCPItemBracket_Sender_Callback cb) { qcpitembracket_sender_callback = cb; }
    inline void setQCPItemBracket_SenderSignalIndex_Callback(QCPItemBracket_SenderSignalIndex_Callback cb) { qcpitembracket_sendersignalindex_callback = cb; }
    inline void setQCPItemBracket_Receivers_Callback(QCPItemBracket_Receivers_Callback cb) { qcpitembracket_receivers_callback = cb; }
    inline void setQCPItemBracket_IsSignalConnected_Callback(QCPItemBracket_IsSignalConnected_Callback cb) { qcpitembracket_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPItemBracket_Metacall_IsBase(bool value) const { qcpitembracket_metacall_isbase = value; }
    inline void setQCPItemBracket_SelectTest_IsBase(bool value) const { qcpitembracket_selecttest_isbase = value; }
    inline void setQCPItemBracket_Draw_IsBase(bool value) const { qcpitembracket_draw_isbase = value; }
    inline void setQCPItemBracket_AnchorPixelPosition_IsBase(bool value) const { qcpitembracket_anchorpixelposition_isbase = value; }
    inline void setQCPItemBracket_SelectionCategory_IsBase(bool value) const { qcpitembracket_selectioncategory_isbase = value; }
    inline void setQCPItemBracket_ClipRect_IsBase(bool value) const { qcpitembracket_cliprect_isbase = value; }
    inline void setQCPItemBracket_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcpitembracket_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPItemBracket_SelectEvent_IsBase(bool value) const { qcpitembracket_selectevent_isbase = value; }
    inline void setQCPItemBracket_DeselectEvent_IsBase(bool value) const { qcpitembracket_deselectevent_isbase = value; }
    inline void setQCPItemBracket_ParentPlotInitialized_IsBase(bool value) const { qcpitembracket_parentplotinitialized_isbase = value; }
    inline void setQCPItemBracket_MousePressEvent_IsBase(bool value) const { qcpitembracket_mousepressevent_isbase = value; }
    inline void setQCPItemBracket_MouseMoveEvent_IsBase(bool value) const { qcpitembracket_mousemoveevent_isbase = value; }
    inline void setQCPItemBracket_MouseReleaseEvent_IsBase(bool value) const { qcpitembracket_mousereleaseevent_isbase = value; }
    inline void setQCPItemBracket_MouseDoubleClickEvent_IsBase(bool value) const { qcpitembracket_mousedoubleclickevent_isbase = value; }
    inline void setQCPItemBracket_WheelEvent_IsBase(bool value) const { qcpitembracket_wheelevent_isbase = value; }
    inline void setQCPItemBracket_Event_IsBase(bool value) const { qcpitembracket_event_isbase = value; }
    inline void setQCPItemBracket_EventFilter_IsBase(bool value) const { qcpitembracket_eventfilter_isbase = value; }
    inline void setQCPItemBracket_TimerEvent_IsBase(bool value) const { qcpitembracket_timerevent_isbase = value; }
    inline void setQCPItemBracket_ChildEvent_IsBase(bool value) const { qcpitembracket_childevent_isbase = value; }
    inline void setQCPItemBracket_CustomEvent_IsBase(bool value) const { qcpitembracket_customevent_isbase = value; }
    inline void setQCPItemBracket_ConnectNotify_IsBase(bool value) const { qcpitembracket_connectnotify_isbase = value; }
    inline void setQCPItemBracket_DisconnectNotify_IsBase(bool value) const { qcpitembracket_disconnectnotify_isbase = value; }
    inline void setQCPItemBracket_MainPen_IsBase(bool value) const { qcpitembracket_mainpen_isbase = value; }
    inline void setQCPItemBracket_RectDistance_IsBase(bool value) const { qcpitembracket_rectdistance_isbase = value; }
    inline void setQCPItemBracket_CreatePosition_IsBase(bool value) const { qcpitembracket_createposition_isbase = value; }
    inline void setQCPItemBracket_CreateAnchor_IsBase(bool value) const { qcpitembracket_createanchor_isbase = value; }
    inline void setQCPItemBracket_InitializeParentPlot_IsBase(bool value) const { qcpitembracket_initializeparentplot_isbase = value; }
    inline void setQCPItemBracket_SetParentLayerable_IsBase(bool value) const { qcpitembracket_setparentlayerable_isbase = value; }
    inline void setQCPItemBracket_MoveToLayer_IsBase(bool value) const { qcpitembracket_movetolayer_isbase = value; }
    inline void setQCPItemBracket_ApplyAntialiasingHint_IsBase(bool value) const { qcpitembracket_applyantialiasinghint_isbase = value; }
    inline void setQCPItemBracket_Sender_IsBase(bool value) const { qcpitembracket_sender_isbase = value; }
    inline void setQCPItemBracket_SenderSignalIndex_IsBase(bool value) const { qcpitembracket_sendersignalindex_isbase = value; }
    inline void setQCPItemBracket_Receivers_IsBase(bool value) const { qcpitembracket_receivers_isbase = value; }
    inline void setQCPItemBracket_IsSignalConnected_IsBase(bool value) const { qcpitembracket_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcpitembracket_metacall_isbase) {
            qcpitembracket_metacall_isbase = false;
            return QCPItemBracket::qt_metacall(param1, param2, param3);
        } else if (qcpitembracket_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcpitembracket_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemBracket::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcpitembracket_selecttest_isbase) {
            qcpitembracket_selecttest_isbase = false;
            return QCPItemBracket::selectTest(pos, onlySelectable, details);
        } else if (qcpitembracket_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcpitembracket_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPItemBracket::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcpitembracket_draw_isbase) {
            qcpitembracket_draw_isbase = false;
            QCPItemBracket::draw(painter);
        } else if (qcpitembracket_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpitembracket_draw_callback(this, cbval1);
        } else {
            QCPItemBracket::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QPointF anchorPixelPosition(int anchorId) const override {
        if (qcpitembracket_anchorpixelposition_isbase) {
            qcpitembracket_anchorpixelposition_isbase = false;
            return QCPItemBracket::anchorPixelPosition(anchorId);
        } else if (qcpitembracket_anchorpixelposition_callback != nullptr) {
            int cbval1 = anchorId;

            QPointF* callback_ret = qcpitembracket_anchorpixelposition_callback(this, cbval1);
            return *callback_ret;
        } else {
            return QCPItemBracket::anchorPixelPosition(anchorId);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcpitembracket_selectioncategory_isbase) {
            qcpitembracket_selectioncategory_isbase = false;
            return QCPItemBracket::selectionCategory();
        } else if (qcpitembracket_selectioncategory_callback != nullptr) {
            int callback_ret = qcpitembracket_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPItemBracket::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcpitembracket_cliprect_isbase) {
            qcpitembracket_cliprect_isbase = false;
            return QCPItemBracket::clipRect();
        } else if (qcpitembracket_cliprect_callback != nullptr) {
            QRect* callback_ret = qcpitembracket_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPItemBracket::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcpitembracket_applydefaultantialiasinghint_isbase) {
            qcpitembracket_applydefaultantialiasinghint_isbase = false;
            QCPItemBracket::applyDefaultAntialiasingHint(painter);
        } else if (qcpitembracket_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcpitembracket_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPItemBracket::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcpitembracket_selectevent_isbase) {
            qcpitembracket_selectevent_isbase = false;
            QCPItemBracket::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcpitembracket_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcpitembracket_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPItemBracket::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcpitembracket_deselectevent_isbase) {
            qcpitembracket_deselectevent_isbase = false;
            QCPItemBracket::deselectEvent(selectionStateChanged);
        } else if (qcpitembracket_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcpitembracket_deselectevent_callback(this, cbval1);
        } else {
            QCPItemBracket::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcpitembracket_parentplotinitialized_isbase) {
            qcpitembracket_parentplotinitialized_isbase = false;
            QCPItemBracket::parentPlotInitialized(parentPlot);
        } else if (qcpitembracket_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpitembracket_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPItemBracket::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpitembracket_mousepressevent_isbase) {
            qcpitembracket_mousepressevent_isbase = false;
            QCPItemBracket::mousePressEvent(event, details);
        } else if (qcpitembracket_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpitembracket_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemBracket::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpitembracket_mousemoveevent_isbase) {
            qcpitembracket_mousemoveevent_isbase = false;
            QCPItemBracket::mouseMoveEvent(event, startPos);
        } else if (qcpitembracket_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpitembracket_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemBracket::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcpitembracket_mousereleaseevent_isbase) {
            qcpitembracket_mousereleaseevent_isbase = false;
            QCPItemBracket::mouseReleaseEvent(event, startPos);
        } else if (qcpitembracket_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcpitembracket_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemBracket::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcpitembracket_mousedoubleclickevent_isbase) {
            qcpitembracket_mousedoubleclickevent_isbase = false;
            QCPItemBracket::mouseDoubleClickEvent(event, details);
        } else if (qcpitembracket_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcpitembracket_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPItemBracket::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcpitembracket_wheelevent_isbase) {
            qcpitembracket_wheelevent_isbase = false;
            QCPItemBracket::wheelEvent(event);
        } else if (qcpitembracket_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcpitembracket_wheelevent_callback(this, cbval1);
        } else {
            QCPItemBracket::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcpitembracket_event_isbase) {
            qcpitembracket_event_isbase = false;
            return QCPItemBracket::event(event);
        } else if (qcpitembracket_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcpitembracket_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemBracket::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcpitembracket_eventfilter_isbase) {
            qcpitembracket_eventfilter_isbase = false;
            return QCPItemBracket::eventFilter(watched, event);
        } else if (qcpitembracket_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcpitembracket_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemBracket::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcpitembracket_timerevent_isbase) {
            qcpitembracket_timerevent_isbase = false;
            QCPItemBracket::timerEvent(event);
        } else if (qcpitembracket_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcpitembracket_timerevent_callback(this, cbval1);
        } else {
            QCPItemBracket::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcpitembracket_childevent_isbase) {
            qcpitembracket_childevent_isbase = false;
            QCPItemBracket::childEvent(event);
        } else if (qcpitembracket_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcpitembracket_childevent_callback(this, cbval1);
        } else {
            QCPItemBracket::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcpitembracket_customevent_isbase) {
            qcpitembracket_customevent_isbase = false;
            QCPItemBracket::customEvent(event);
        } else if (qcpitembracket_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcpitembracket_customevent_callback(this, cbval1);
        } else {
            QCPItemBracket::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcpitembracket_connectnotify_isbase) {
            qcpitembracket_connectnotify_isbase = false;
            QCPItemBracket::connectNotify(signal);
        } else if (qcpitembracket_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpitembracket_connectnotify_callback(this, cbval1);
        } else {
            QCPItemBracket::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcpitembracket_disconnectnotify_isbase) {
            qcpitembracket_disconnectnotify_isbase = false;
            QCPItemBracket::disconnectNotify(signal);
        } else if (qcpitembracket_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcpitembracket_disconnectnotify_callback(this, cbval1);
        } else {
            QCPItemBracket::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    QPen mainPen() const {
        if (qcpitembracket_mainpen_isbase) {
            qcpitembracket_mainpen_isbase = false;
            return QCPItemBracket::mainPen();
        } else if (qcpitembracket_mainpen_callback != nullptr) {
            QPen* callback_ret = qcpitembracket_mainpen_callback();
            return *callback_ret;
        } else {
            return QCPItemBracket::mainPen();
        }
    }

    // Virtual method for C ABI access and custom callback
    double rectDistance(const QRectF& rect, const QPointF& pos, bool filledRect) const {
        if (qcpitembracket_rectdistance_isbase) {
            qcpitembracket_rectdistance_isbase = false;
            return QCPItemBracket::rectDistance(rect, pos, filledRect);
        } else if (qcpitembracket_rectdistance_callback != nullptr) {
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval1 = const_cast<QRectF*>(&rect_ret);
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&pos_ret);
            bool cbval3 = filledRect;

            double callback_ret = qcpitembracket_rectdistance_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPItemBracket::rectDistance(rect, pos, filledRect);
        }
    }

    // Virtual method for C ABI access and custom callback
    QCPItemPosition* createPosition(const QString& name) {
        if (qcpitembracket_createposition_isbase) {
            qcpitembracket_createposition_isbase = false;
            return QCPItemBracket::createPosition(name);
        } else if (qcpitembracket_createposition_callback != nullptr) {
            const QString name_ret = name;
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray name_b = name_ret.toUtf8();
            libqt_string name_str;
            name_str.len = name_b.length();
            name_str.data = static_cast<const char*>(malloc(name_str.len + 1));
            memcpy((void*)name_str.data, name_b.data(), name_str.len);
            ((char*)name_str.data)[name_str.len] = '\0';
            libqt_string cbval1 = name_str;

            QCPItemPosition* callback_ret = qcpitembracket_createposition_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemBracket::createPosition(name);
        }
    }

    // Virtual method for C ABI access and custom callback
    QCPItemAnchor* createAnchor(const QString& name, int anchorId) {
        if (qcpitembracket_createanchor_isbase) {
            qcpitembracket_createanchor_isbase = false;
            return QCPItemBracket::createAnchor(name, anchorId);
        } else if (qcpitembracket_createanchor_callback != nullptr) {
            const QString name_ret = name;
            // Convert QString from UTF-16 in C++ RAII memory to UTF-8 in manually-managed C memory
            QByteArray name_b = name_ret.toUtf8();
            libqt_string name_str;
            name_str.len = name_b.length();
            name_str.data = static_cast<const char*>(malloc(name_str.len + 1));
            memcpy((void*)name_str.data, name_b.data(), name_str.len);
            ((char*)name_str.data)[name_str.len] = '\0';
            libqt_string cbval1 = name_str;
            int cbval2 = anchorId;

            QCPItemAnchor* callback_ret = qcpitembracket_createanchor_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemBracket::createAnchor(name, anchorId);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcpitembracket_initializeparentplot_isbase) {
            qcpitembracket_initializeparentplot_isbase = false;
            QCPItemBracket::initializeParentPlot(parentPlot);
        } else if (qcpitembracket_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcpitembracket_initializeparentplot_callback(this, cbval1);
        } else {
            QCPItemBracket::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcpitembracket_setparentlayerable_isbase) {
            qcpitembracket_setparentlayerable_isbase = false;
            QCPItemBracket::setParentLayerable(parentLayerable);
        } else if (qcpitembracket_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcpitembracket_setparentlayerable_callback(this, cbval1);
        } else {
            QCPItemBracket::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcpitembracket_movetolayer_isbase) {
            qcpitembracket_movetolayer_isbase = false;
            return QCPItemBracket::moveToLayer(layer, prepend);
        } else if (qcpitembracket_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcpitembracket_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPItemBracket::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcpitembracket_applyantialiasinghint_isbase) {
            qcpitembracket_applyantialiasinghint_isbase = false;
            QCPItemBracket::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcpitembracket_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcpitembracket_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPItemBracket::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcpitembracket_sender_isbase) {
            qcpitembracket_sender_isbase = false;
            return QCPItemBracket::sender();
        } else if (qcpitembracket_sender_callback != nullptr) {
            QObject* callback_ret = qcpitembracket_sender_callback();
            return callback_ret;
        } else {
            return QCPItemBracket::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcpitembracket_sendersignalindex_isbase) {
            qcpitembracket_sendersignalindex_isbase = false;
            return QCPItemBracket::senderSignalIndex();
        } else if (qcpitembracket_sendersignalindex_callback != nullptr) {
            int callback_ret = qcpitembracket_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemBracket::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcpitembracket_receivers_isbase) {
            qcpitembracket_receivers_isbase = false;
            return QCPItemBracket::receivers(signal);
        } else if (qcpitembracket_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcpitembracket_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPItemBracket::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcpitembracket_issignalconnected_isbase) {
            qcpitembracket_issignalconnected_isbase = false;
            return QCPItemBracket::isSignalConnected(signal);
        } else if (qcpitembracket_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcpitembracket_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPItemBracket::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPItemBracket_Draw(QCPItemBracket* self, QCPPainter* painter);
    friend void QCPItemBracket_QBaseDraw(QCPItemBracket* self, QCPPainter* painter);
    friend QPointF* QCPItemBracket_AnchorPixelPosition(const QCPItemBracket* self, int anchorId);
    friend QPointF* QCPItemBracket_QBaseAnchorPixelPosition(const QCPItemBracket* self, int anchorId);
    friend int QCPItemBracket_SelectionCategory(const QCPItemBracket* self);
    friend int QCPItemBracket_QBaseSelectionCategory(const QCPItemBracket* self);
    friend QRect* QCPItemBracket_ClipRect(const QCPItemBracket* self);
    friend QRect* QCPItemBracket_QBaseClipRect(const QCPItemBracket* self);
    friend void QCPItemBracket_ApplyDefaultAntialiasingHint(const QCPItemBracket* self, QCPPainter* painter);
    friend void QCPItemBracket_QBaseApplyDefaultAntialiasingHint(const QCPItemBracket* self, QCPPainter* painter);
    friend void QCPItemBracket_SelectEvent(QCPItemBracket* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPItemBracket_QBaseSelectEvent(QCPItemBracket* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPItemBracket_DeselectEvent(QCPItemBracket* self, bool* selectionStateChanged);
    friend void QCPItemBracket_QBaseDeselectEvent(QCPItemBracket* self, bool* selectionStateChanged);
    friend void QCPItemBracket_ParentPlotInitialized(QCPItemBracket* self, QCustomPlot* parentPlot);
    friend void QCPItemBracket_QBaseParentPlotInitialized(QCPItemBracket* self, QCustomPlot* parentPlot);
    friend void QCPItemBracket_MousePressEvent(QCPItemBracket* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemBracket_QBaseMousePressEvent(QCPItemBracket* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemBracket_MouseMoveEvent(QCPItemBracket* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemBracket_QBaseMouseMoveEvent(QCPItemBracket* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemBracket_MouseReleaseEvent(QCPItemBracket* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemBracket_QBaseMouseReleaseEvent(QCPItemBracket* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPItemBracket_MouseDoubleClickEvent(QCPItemBracket* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemBracket_QBaseMouseDoubleClickEvent(QCPItemBracket* self, QMouseEvent* event, const QVariant* details);
    friend void QCPItemBracket_WheelEvent(QCPItemBracket* self, QWheelEvent* event);
    friend void QCPItemBracket_QBaseWheelEvent(QCPItemBracket* self, QWheelEvent* event);
    friend void QCPItemBracket_TimerEvent(QCPItemBracket* self, QTimerEvent* event);
    friend void QCPItemBracket_QBaseTimerEvent(QCPItemBracket* self, QTimerEvent* event);
    friend void QCPItemBracket_ChildEvent(QCPItemBracket* self, QChildEvent* event);
    friend void QCPItemBracket_QBaseChildEvent(QCPItemBracket* self, QChildEvent* event);
    friend void QCPItemBracket_CustomEvent(QCPItemBracket* self, QEvent* event);
    friend void QCPItemBracket_QBaseCustomEvent(QCPItemBracket* self, QEvent* event);
    friend void QCPItemBracket_ConnectNotify(QCPItemBracket* self, const QMetaMethod* signal);
    friend void QCPItemBracket_QBaseConnectNotify(QCPItemBracket* self, const QMetaMethod* signal);
    friend void QCPItemBracket_DisconnectNotify(QCPItemBracket* self, const QMetaMethod* signal);
    friend void QCPItemBracket_QBaseDisconnectNotify(QCPItemBracket* self, const QMetaMethod* signal);
    friend QPen* QCPItemBracket_MainPen(const QCPItemBracket* self);
    friend QPen* QCPItemBracket_QBaseMainPen(const QCPItemBracket* self);
    friend double QCPItemBracket_RectDistance(const QCPItemBracket* self, const QRectF* rect, const QPointF* pos, bool filledRect);
    friend double QCPItemBracket_QBaseRectDistance(const QCPItemBracket* self, const QRectF* rect, const QPointF* pos, bool filledRect);
    friend QCPItemPosition* QCPItemBracket_CreatePosition(QCPItemBracket* self, const libqt_string name);
    friend QCPItemPosition* QCPItemBracket_QBaseCreatePosition(QCPItemBracket* self, const libqt_string name);
    friend QCPItemAnchor* QCPItemBracket_CreateAnchor(QCPItemBracket* self, const libqt_string name, int anchorId);
    friend QCPItemAnchor* QCPItemBracket_QBaseCreateAnchor(QCPItemBracket* self, const libqt_string name, int anchorId);
    friend void QCPItemBracket_InitializeParentPlot(QCPItemBracket* self, QCustomPlot* parentPlot);
    friend void QCPItemBracket_QBaseInitializeParentPlot(QCPItemBracket* self, QCustomPlot* parentPlot);
    friend void QCPItemBracket_SetParentLayerable(QCPItemBracket* self, QCPLayerable* parentLayerable);
    friend void QCPItemBracket_QBaseSetParentLayerable(QCPItemBracket* self, QCPLayerable* parentLayerable);
    friend bool QCPItemBracket_MoveToLayer(QCPItemBracket* self, QCPLayer* layer, bool prepend);
    friend bool QCPItemBracket_QBaseMoveToLayer(QCPItemBracket* self, QCPLayer* layer, bool prepend);
    friend void QCPItemBracket_ApplyAntialiasingHint(const QCPItemBracket* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPItemBracket_QBaseApplyAntialiasingHint(const QCPItemBracket* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPItemBracket_Sender(const QCPItemBracket* self);
    friend QObject* QCPItemBracket_QBaseSender(const QCPItemBracket* self);
    friend int QCPItemBracket_SenderSignalIndex(const QCPItemBracket* self);
    friend int QCPItemBracket_QBaseSenderSignalIndex(const QCPItemBracket* self);
    friend int QCPItemBracket_Receivers(const QCPItemBracket* self, const char* signal);
    friend int QCPItemBracket_QBaseReceivers(const QCPItemBracket* self, const char* signal);
    friend bool QCPItemBracket_IsSignalConnected(const QCPItemBracket* self, const QMetaMethod* signal);
    friend bool QCPItemBracket_QBaseIsSignalConnected(const QCPItemBracket* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPPolarAxisRadial so that we can call protected methods
class VirtualQCPPolarAxisRadial final : public QCPPolarAxisRadial {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPPolarAxisRadial = true;

    // Virtual class public types (including callbacks)
    using QCPPolarAxisRadial_Metacall_Callback = int (*)(QCPPolarAxisRadial*, int, int, void**);
    using QCPPolarAxisRadial_SelectTest_Callback = double (*)(const QCPPolarAxisRadial*, QPointF*, bool, QVariant*);
    using QCPPolarAxisRadial_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPPolarAxisRadial*, QCPPainter*);
    using QCPPolarAxisRadial_Draw_Callback = void (*)(QCPPolarAxisRadial*, QCPPainter*);
    using QCPPolarAxisRadial_SelectionCategory_Callback = int (*)();
    using QCPPolarAxisRadial_SelectEvent_Callback = void (*)(QCPPolarAxisRadial*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPPolarAxisRadial_DeselectEvent_Callback = void (*)(QCPPolarAxisRadial*, bool*);
    using QCPPolarAxisRadial_MousePressEvent_Callback = void (*)(QCPPolarAxisRadial*, QMouseEvent*, QVariant*);
    using QCPPolarAxisRadial_MouseMoveEvent_Callback = void (*)(QCPPolarAxisRadial*, QMouseEvent*, QPointF*);
    using QCPPolarAxisRadial_MouseReleaseEvent_Callback = void (*)(QCPPolarAxisRadial*, QMouseEvent*, QPointF*);
    using QCPPolarAxisRadial_WheelEvent_Callback = void (*)(QCPPolarAxisRadial*, QWheelEvent*);
    using QCPPolarAxisRadial_ParentPlotInitialized_Callback = void (*)(QCPPolarAxisRadial*, QCustomPlot*);
    using QCPPolarAxisRadial_ClipRect_Callback = QRect* (*)();
    using QCPPolarAxisRadial_MouseDoubleClickEvent_Callback = void (*)(QCPPolarAxisRadial*, QMouseEvent*, QVariant*);
    using QCPPolarAxisRadial_Event_Callback = bool (*)(QCPPolarAxisRadial*, QEvent*);
    using QCPPolarAxisRadial_EventFilter_Callback = bool (*)(QCPPolarAxisRadial*, QObject*, QEvent*);
    using QCPPolarAxisRadial_TimerEvent_Callback = void (*)(QCPPolarAxisRadial*, QTimerEvent*);
    using QCPPolarAxisRadial_ChildEvent_Callback = void (*)(QCPPolarAxisRadial*, QChildEvent*);
    using QCPPolarAxisRadial_CustomEvent_Callback = void (*)(QCPPolarAxisRadial*, QEvent*);
    using QCPPolarAxisRadial_ConnectNotify_Callback = void (*)(QCPPolarAxisRadial*, QMetaMethod*);
    using QCPPolarAxisRadial_DisconnectNotify_Callback = void (*)(QCPPolarAxisRadial*, QMetaMethod*);
    using QCPPolarAxisRadial_UpdateGeometry_Callback = void (*)(QCPPolarAxisRadial*, QPointF*, double);
    using QCPPolarAxisRadial_SetupTickVectors_Callback = void (*)();
    using QCPPolarAxisRadial_GetBasePen_Callback = QPen* (*)();
    using QCPPolarAxisRadial_GetTickPen_Callback = QPen* (*)();
    using QCPPolarAxisRadial_GetSubTickPen_Callback = QPen* (*)();
    using QCPPolarAxisRadial_GetTickLabelFont_Callback = QFont* (*)();
    using QCPPolarAxisRadial_GetLabelFont_Callback = QFont* (*)();
    using QCPPolarAxisRadial_GetTickLabelColor_Callback = QColor* (*)();
    using QCPPolarAxisRadial_GetLabelColor_Callback = QColor* (*)();
    using QCPPolarAxisRadial_InitializeParentPlot_Callback = void (*)(QCPPolarAxisRadial*, QCustomPlot*);
    using QCPPolarAxisRadial_SetParentLayerable_Callback = void (*)(QCPPolarAxisRadial*, QCPLayerable*);
    using QCPPolarAxisRadial_MoveToLayer_Callback = bool (*)(QCPPolarAxisRadial*, QCPLayer*, bool);
    using QCPPolarAxisRadial_ApplyAntialiasingHint_Callback = void (*)(const QCPPolarAxisRadial*, QCPPainter*, bool, int);
    using QCPPolarAxisRadial_Sender_Callback = QObject* (*)();
    using QCPPolarAxisRadial_SenderSignalIndex_Callback = int (*)();
    using QCPPolarAxisRadial_Receivers_Callback = int (*)(const QCPPolarAxisRadial*, const char*);
    using QCPPolarAxisRadial_IsSignalConnected_Callback = bool (*)(const QCPPolarAxisRadial*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPPolarAxisRadial_Metacall_Callback qcppolaraxisradial_metacall_callback = nullptr;
    QCPPolarAxisRadial_SelectTest_Callback qcppolaraxisradial_selecttest_callback = nullptr;
    QCPPolarAxisRadial_ApplyDefaultAntialiasingHint_Callback qcppolaraxisradial_applydefaultantialiasinghint_callback = nullptr;
    QCPPolarAxisRadial_Draw_Callback qcppolaraxisradial_draw_callback = nullptr;
    QCPPolarAxisRadial_SelectionCategory_Callback qcppolaraxisradial_selectioncategory_callback = nullptr;
    QCPPolarAxisRadial_SelectEvent_Callback qcppolaraxisradial_selectevent_callback = nullptr;
    QCPPolarAxisRadial_DeselectEvent_Callback qcppolaraxisradial_deselectevent_callback = nullptr;
    QCPPolarAxisRadial_MousePressEvent_Callback qcppolaraxisradial_mousepressevent_callback = nullptr;
    QCPPolarAxisRadial_MouseMoveEvent_Callback qcppolaraxisradial_mousemoveevent_callback = nullptr;
    QCPPolarAxisRadial_MouseReleaseEvent_Callback qcppolaraxisradial_mousereleaseevent_callback = nullptr;
    QCPPolarAxisRadial_WheelEvent_Callback qcppolaraxisradial_wheelevent_callback = nullptr;
    QCPPolarAxisRadial_ParentPlotInitialized_Callback qcppolaraxisradial_parentplotinitialized_callback = nullptr;
    QCPPolarAxisRadial_ClipRect_Callback qcppolaraxisradial_cliprect_callback = nullptr;
    QCPPolarAxisRadial_MouseDoubleClickEvent_Callback qcppolaraxisradial_mousedoubleclickevent_callback = nullptr;
    QCPPolarAxisRadial_Event_Callback qcppolaraxisradial_event_callback = nullptr;
    QCPPolarAxisRadial_EventFilter_Callback qcppolaraxisradial_eventfilter_callback = nullptr;
    QCPPolarAxisRadial_TimerEvent_Callback qcppolaraxisradial_timerevent_callback = nullptr;
    QCPPolarAxisRadial_ChildEvent_Callback qcppolaraxisradial_childevent_callback = nullptr;
    QCPPolarAxisRadial_CustomEvent_Callback qcppolaraxisradial_customevent_callback = nullptr;
    QCPPolarAxisRadial_ConnectNotify_Callback qcppolaraxisradial_connectnotify_callback = nullptr;
    QCPPolarAxisRadial_DisconnectNotify_Callback qcppolaraxisradial_disconnectnotify_callback = nullptr;
    QCPPolarAxisRadial_UpdateGeometry_Callback qcppolaraxisradial_updategeometry_callback = nullptr;
    QCPPolarAxisRadial_SetupTickVectors_Callback qcppolaraxisradial_setuptickvectors_callback = nullptr;
    QCPPolarAxisRadial_GetBasePen_Callback qcppolaraxisradial_getbasepen_callback = nullptr;
    QCPPolarAxisRadial_GetTickPen_Callback qcppolaraxisradial_gettickpen_callback = nullptr;
    QCPPolarAxisRadial_GetSubTickPen_Callback qcppolaraxisradial_getsubtickpen_callback = nullptr;
    QCPPolarAxisRadial_GetTickLabelFont_Callback qcppolaraxisradial_getticklabelfont_callback = nullptr;
    QCPPolarAxisRadial_GetLabelFont_Callback qcppolaraxisradial_getlabelfont_callback = nullptr;
    QCPPolarAxisRadial_GetTickLabelColor_Callback qcppolaraxisradial_getticklabelcolor_callback = nullptr;
    QCPPolarAxisRadial_GetLabelColor_Callback qcppolaraxisradial_getlabelcolor_callback = nullptr;
    QCPPolarAxisRadial_InitializeParentPlot_Callback qcppolaraxisradial_initializeparentplot_callback = nullptr;
    QCPPolarAxisRadial_SetParentLayerable_Callback qcppolaraxisradial_setparentlayerable_callback = nullptr;
    QCPPolarAxisRadial_MoveToLayer_Callback qcppolaraxisradial_movetolayer_callback = nullptr;
    QCPPolarAxisRadial_ApplyAntialiasingHint_Callback qcppolaraxisradial_applyantialiasinghint_callback = nullptr;
    QCPPolarAxisRadial_Sender_Callback qcppolaraxisradial_sender_callback = nullptr;
    QCPPolarAxisRadial_SenderSignalIndex_Callback qcppolaraxisradial_sendersignalindex_callback = nullptr;
    QCPPolarAxisRadial_Receivers_Callback qcppolaraxisradial_receivers_callback = nullptr;
    QCPPolarAxisRadial_IsSignalConnected_Callback qcppolaraxisradial_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcppolaraxisradial_metacall_isbase = false;
    mutable bool qcppolaraxisradial_selecttest_isbase = false;
    mutable bool qcppolaraxisradial_applydefaultantialiasinghint_isbase = false;
    mutable bool qcppolaraxisradial_draw_isbase = false;
    mutable bool qcppolaraxisradial_selectioncategory_isbase = false;
    mutable bool qcppolaraxisradial_selectevent_isbase = false;
    mutable bool qcppolaraxisradial_deselectevent_isbase = false;
    mutable bool qcppolaraxisradial_mousepressevent_isbase = false;
    mutable bool qcppolaraxisradial_mousemoveevent_isbase = false;
    mutable bool qcppolaraxisradial_mousereleaseevent_isbase = false;
    mutable bool qcppolaraxisradial_wheelevent_isbase = false;
    mutable bool qcppolaraxisradial_parentplotinitialized_isbase = false;
    mutable bool qcppolaraxisradial_cliprect_isbase = false;
    mutable bool qcppolaraxisradial_mousedoubleclickevent_isbase = false;
    mutable bool qcppolaraxisradial_event_isbase = false;
    mutable bool qcppolaraxisradial_eventfilter_isbase = false;
    mutable bool qcppolaraxisradial_timerevent_isbase = false;
    mutable bool qcppolaraxisradial_childevent_isbase = false;
    mutable bool qcppolaraxisradial_customevent_isbase = false;
    mutable bool qcppolaraxisradial_connectnotify_isbase = false;
    mutable bool qcppolaraxisradial_disconnectnotify_isbase = false;
    mutable bool qcppolaraxisradial_updategeometry_isbase = false;
    mutable bool qcppolaraxisradial_setuptickvectors_isbase = false;
    mutable bool qcppolaraxisradial_getbasepen_isbase = false;
    mutable bool qcppolaraxisradial_gettickpen_isbase = false;
    mutable bool qcppolaraxisradial_getsubtickpen_isbase = false;
    mutable bool qcppolaraxisradial_getticklabelfont_isbase = false;
    mutable bool qcppolaraxisradial_getlabelfont_isbase = false;
    mutable bool qcppolaraxisradial_getticklabelcolor_isbase = false;
    mutable bool qcppolaraxisradial_getlabelcolor_isbase = false;
    mutable bool qcppolaraxisradial_initializeparentplot_isbase = false;
    mutable bool qcppolaraxisradial_setparentlayerable_isbase = false;
    mutable bool qcppolaraxisradial_movetolayer_isbase = false;
    mutable bool qcppolaraxisradial_applyantialiasinghint_isbase = false;
    mutable bool qcppolaraxisradial_sender_isbase = false;
    mutable bool qcppolaraxisradial_sendersignalindex_isbase = false;
    mutable bool qcppolaraxisradial_receivers_isbase = false;
    mutable bool qcppolaraxisradial_issignalconnected_isbase = false;

  public:
    VirtualQCPPolarAxisRadial(QCPPolarAxisAngular* parent) : QCPPolarAxisRadial(parent) {};

    ~VirtualQCPPolarAxisRadial() {
        qcppolaraxisradial_metacall_callback = nullptr;
        qcppolaraxisradial_selecttest_callback = nullptr;
        qcppolaraxisradial_applydefaultantialiasinghint_callback = nullptr;
        qcppolaraxisradial_draw_callback = nullptr;
        qcppolaraxisradial_selectioncategory_callback = nullptr;
        qcppolaraxisradial_selectevent_callback = nullptr;
        qcppolaraxisradial_deselectevent_callback = nullptr;
        qcppolaraxisradial_mousepressevent_callback = nullptr;
        qcppolaraxisradial_mousemoveevent_callback = nullptr;
        qcppolaraxisradial_mousereleaseevent_callback = nullptr;
        qcppolaraxisradial_wheelevent_callback = nullptr;
        qcppolaraxisradial_parentplotinitialized_callback = nullptr;
        qcppolaraxisradial_cliprect_callback = nullptr;
        qcppolaraxisradial_mousedoubleclickevent_callback = nullptr;
        qcppolaraxisradial_event_callback = nullptr;
        qcppolaraxisradial_eventfilter_callback = nullptr;
        qcppolaraxisradial_timerevent_callback = nullptr;
        qcppolaraxisradial_childevent_callback = nullptr;
        qcppolaraxisradial_customevent_callback = nullptr;
        qcppolaraxisradial_connectnotify_callback = nullptr;
        qcppolaraxisradial_disconnectnotify_callback = nullptr;
        qcppolaraxisradial_updategeometry_callback = nullptr;
        qcppolaraxisradial_setuptickvectors_callback = nullptr;
        qcppolaraxisradial_getbasepen_callback = nullptr;
        qcppolaraxisradial_gettickpen_callback = nullptr;
        qcppolaraxisradial_getsubtickpen_callback = nullptr;
        qcppolaraxisradial_getticklabelfont_callback = nullptr;
        qcppolaraxisradial_getlabelfont_callback = nullptr;
        qcppolaraxisradial_getticklabelcolor_callback = nullptr;
        qcppolaraxisradial_getlabelcolor_callback = nullptr;
        qcppolaraxisradial_initializeparentplot_callback = nullptr;
        qcppolaraxisradial_setparentlayerable_callback = nullptr;
        qcppolaraxisradial_movetolayer_callback = nullptr;
        qcppolaraxisradial_applyantialiasinghint_callback = nullptr;
        qcppolaraxisradial_sender_callback = nullptr;
        qcppolaraxisradial_sendersignalindex_callback = nullptr;
        qcppolaraxisradial_receivers_callback = nullptr;
        qcppolaraxisradial_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPPolarAxisRadial_Metacall_Callback(QCPPolarAxisRadial_Metacall_Callback cb) { qcppolaraxisradial_metacall_callback = cb; }
    inline void setQCPPolarAxisRadial_SelectTest_Callback(QCPPolarAxisRadial_SelectTest_Callback cb) { qcppolaraxisradial_selecttest_callback = cb; }
    inline void setQCPPolarAxisRadial_ApplyDefaultAntialiasingHint_Callback(QCPPolarAxisRadial_ApplyDefaultAntialiasingHint_Callback cb) { qcppolaraxisradial_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPPolarAxisRadial_Draw_Callback(QCPPolarAxisRadial_Draw_Callback cb) { qcppolaraxisradial_draw_callback = cb; }
    inline void setQCPPolarAxisRadial_SelectionCategory_Callback(QCPPolarAxisRadial_SelectionCategory_Callback cb) { qcppolaraxisradial_selectioncategory_callback = cb; }
    inline void setQCPPolarAxisRadial_SelectEvent_Callback(QCPPolarAxisRadial_SelectEvent_Callback cb) { qcppolaraxisradial_selectevent_callback = cb; }
    inline void setQCPPolarAxisRadial_DeselectEvent_Callback(QCPPolarAxisRadial_DeselectEvent_Callback cb) { qcppolaraxisradial_deselectevent_callback = cb; }
    inline void setQCPPolarAxisRadial_MousePressEvent_Callback(QCPPolarAxisRadial_MousePressEvent_Callback cb) { qcppolaraxisradial_mousepressevent_callback = cb; }
    inline void setQCPPolarAxisRadial_MouseMoveEvent_Callback(QCPPolarAxisRadial_MouseMoveEvent_Callback cb) { qcppolaraxisradial_mousemoveevent_callback = cb; }
    inline void setQCPPolarAxisRadial_MouseReleaseEvent_Callback(QCPPolarAxisRadial_MouseReleaseEvent_Callback cb) { qcppolaraxisradial_mousereleaseevent_callback = cb; }
    inline void setQCPPolarAxisRadial_WheelEvent_Callback(QCPPolarAxisRadial_WheelEvent_Callback cb) { qcppolaraxisradial_wheelevent_callback = cb; }
    inline void setQCPPolarAxisRadial_ParentPlotInitialized_Callback(QCPPolarAxisRadial_ParentPlotInitialized_Callback cb) { qcppolaraxisradial_parentplotinitialized_callback = cb; }
    inline void setQCPPolarAxisRadial_ClipRect_Callback(QCPPolarAxisRadial_ClipRect_Callback cb) { qcppolaraxisradial_cliprect_callback = cb; }
    inline void setQCPPolarAxisRadial_MouseDoubleClickEvent_Callback(QCPPolarAxisRadial_MouseDoubleClickEvent_Callback cb) { qcppolaraxisradial_mousedoubleclickevent_callback = cb; }
    inline void setQCPPolarAxisRadial_Event_Callback(QCPPolarAxisRadial_Event_Callback cb) { qcppolaraxisradial_event_callback = cb; }
    inline void setQCPPolarAxisRadial_EventFilter_Callback(QCPPolarAxisRadial_EventFilter_Callback cb) { qcppolaraxisradial_eventfilter_callback = cb; }
    inline void setQCPPolarAxisRadial_TimerEvent_Callback(QCPPolarAxisRadial_TimerEvent_Callback cb) { qcppolaraxisradial_timerevent_callback = cb; }
    inline void setQCPPolarAxisRadial_ChildEvent_Callback(QCPPolarAxisRadial_ChildEvent_Callback cb) { qcppolaraxisradial_childevent_callback = cb; }
    inline void setQCPPolarAxisRadial_CustomEvent_Callback(QCPPolarAxisRadial_CustomEvent_Callback cb) { qcppolaraxisradial_customevent_callback = cb; }
    inline void setQCPPolarAxisRadial_ConnectNotify_Callback(QCPPolarAxisRadial_ConnectNotify_Callback cb) { qcppolaraxisradial_connectnotify_callback = cb; }
    inline void setQCPPolarAxisRadial_DisconnectNotify_Callback(QCPPolarAxisRadial_DisconnectNotify_Callback cb) { qcppolaraxisradial_disconnectnotify_callback = cb; }
    inline void setQCPPolarAxisRadial_UpdateGeometry_Callback(QCPPolarAxisRadial_UpdateGeometry_Callback cb) { qcppolaraxisradial_updategeometry_callback = cb; }
    inline void setQCPPolarAxisRadial_SetupTickVectors_Callback(QCPPolarAxisRadial_SetupTickVectors_Callback cb) { qcppolaraxisradial_setuptickvectors_callback = cb; }
    inline void setQCPPolarAxisRadial_GetBasePen_Callback(QCPPolarAxisRadial_GetBasePen_Callback cb) { qcppolaraxisradial_getbasepen_callback = cb; }
    inline void setQCPPolarAxisRadial_GetTickPen_Callback(QCPPolarAxisRadial_GetTickPen_Callback cb) { qcppolaraxisradial_gettickpen_callback = cb; }
    inline void setQCPPolarAxisRadial_GetSubTickPen_Callback(QCPPolarAxisRadial_GetSubTickPen_Callback cb) { qcppolaraxisradial_getsubtickpen_callback = cb; }
    inline void setQCPPolarAxisRadial_GetTickLabelFont_Callback(QCPPolarAxisRadial_GetTickLabelFont_Callback cb) { qcppolaraxisradial_getticklabelfont_callback = cb; }
    inline void setQCPPolarAxisRadial_GetLabelFont_Callback(QCPPolarAxisRadial_GetLabelFont_Callback cb) { qcppolaraxisradial_getlabelfont_callback = cb; }
    inline void setQCPPolarAxisRadial_GetTickLabelColor_Callback(QCPPolarAxisRadial_GetTickLabelColor_Callback cb) { qcppolaraxisradial_getticklabelcolor_callback = cb; }
    inline void setQCPPolarAxisRadial_GetLabelColor_Callback(QCPPolarAxisRadial_GetLabelColor_Callback cb) { qcppolaraxisradial_getlabelcolor_callback = cb; }
    inline void setQCPPolarAxisRadial_InitializeParentPlot_Callback(QCPPolarAxisRadial_InitializeParentPlot_Callback cb) { qcppolaraxisradial_initializeparentplot_callback = cb; }
    inline void setQCPPolarAxisRadial_SetParentLayerable_Callback(QCPPolarAxisRadial_SetParentLayerable_Callback cb) { qcppolaraxisradial_setparentlayerable_callback = cb; }
    inline void setQCPPolarAxisRadial_MoveToLayer_Callback(QCPPolarAxisRadial_MoveToLayer_Callback cb) { qcppolaraxisradial_movetolayer_callback = cb; }
    inline void setQCPPolarAxisRadial_ApplyAntialiasingHint_Callback(QCPPolarAxisRadial_ApplyAntialiasingHint_Callback cb) { qcppolaraxisradial_applyantialiasinghint_callback = cb; }
    inline void setQCPPolarAxisRadial_Sender_Callback(QCPPolarAxisRadial_Sender_Callback cb) { qcppolaraxisradial_sender_callback = cb; }
    inline void setQCPPolarAxisRadial_SenderSignalIndex_Callback(QCPPolarAxisRadial_SenderSignalIndex_Callback cb) { qcppolaraxisradial_sendersignalindex_callback = cb; }
    inline void setQCPPolarAxisRadial_Receivers_Callback(QCPPolarAxisRadial_Receivers_Callback cb) { qcppolaraxisradial_receivers_callback = cb; }
    inline void setQCPPolarAxisRadial_IsSignalConnected_Callback(QCPPolarAxisRadial_IsSignalConnected_Callback cb) { qcppolaraxisradial_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPPolarAxisRadial_Metacall_IsBase(bool value) const { qcppolaraxisradial_metacall_isbase = value; }
    inline void setQCPPolarAxisRadial_SelectTest_IsBase(bool value) const { qcppolaraxisradial_selecttest_isbase = value; }
    inline void setQCPPolarAxisRadial_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcppolaraxisradial_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPPolarAxisRadial_Draw_IsBase(bool value) const { qcppolaraxisradial_draw_isbase = value; }
    inline void setQCPPolarAxisRadial_SelectionCategory_IsBase(bool value) const { qcppolaraxisradial_selectioncategory_isbase = value; }
    inline void setQCPPolarAxisRadial_SelectEvent_IsBase(bool value) const { qcppolaraxisradial_selectevent_isbase = value; }
    inline void setQCPPolarAxisRadial_DeselectEvent_IsBase(bool value) const { qcppolaraxisradial_deselectevent_isbase = value; }
    inline void setQCPPolarAxisRadial_MousePressEvent_IsBase(bool value) const { qcppolaraxisradial_mousepressevent_isbase = value; }
    inline void setQCPPolarAxisRadial_MouseMoveEvent_IsBase(bool value) const { qcppolaraxisradial_mousemoveevent_isbase = value; }
    inline void setQCPPolarAxisRadial_MouseReleaseEvent_IsBase(bool value) const { qcppolaraxisradial_mousereleaseevent_isbase = value; }
    inline void setQCPPolarAxisRadial_WheelEvent_IsBase(bool value) const { qcppolaraxisradial_wheelevent_isbase = value; }
    inline void setQCPPolarAxisRadial_ParentPlotInitialized_IsBase(bool value) const { qcppolaraxisradial_parentplotinitialized_isbase = value; }
    inline void setQCPPolarAxisRadial_ClipRect_IsBase(bool value) const { qcppolaraxisradial_cliprect_isbase = value; }
    inline void setQCPPolarAxisRadial_MouseDoubleClickEvent_IsBase(bool value) const { qcppolaraxisradial_mousedoubleclickevent_isbase = value; }
    inline void setQCPPolarAxisRadial_Event_IsBase(bool value) const { qcppolaraxisradial_event_isbase = value; }
    inline void setQCPPolarAxisRadial_EventFilter_IsBase(bool value) const { qcppolaraxisradial_eventfilter_isbase = value; }
    inline void setQCPPolarAxisRadial_TimerEvent_IsBase(bool value) const { qcppolaraxisradial_timerevent_isbase = value; }
    inline void setQCPPolarAxisRadial_ChildEvent_IsBase(bool value) const { qcppolaraxisradial_childevent_isbase = value; }
    inline void setQCPPolarAxisRadial_CustomEvent_IsBase(bool value) const { qcppolaraxisradial_customevent_isbase = value; }
    inline void setQCPPolarAxisRadial_ConnectNotify_IsBase(bool value) const { qcppolaraxisradial_connectnotify_isbase = value; }
    inline void setQCPPolarAxisRadial_DisconnectNotify_IsBase(bool value) const { qcppolaraxisradial_disconnectnotify_isbase = value; }
    inline void setQCPPolarAxisRadial_UpdateGeometry_IsBase(bool value) const { qcppolaraxisradial_updategeometry_isbase = value; }
    inline void setQCPPolarAxisRadial_SetupTickVectors_IsBase(bool value) const { qcppolaraxisradial_setuptickvectors_isbase = value; }
    inline void setQCPPolarAxisRadial_GetBasePen_IsBase(bool value) const { qcppolaraxisradial_getbasepen_isbase = value; }
    inline void setQCPPolarAxisRadial_GetTickPen_IsBase(bool value) const { qcppolaraxisradial_gettickpen_isbase = value; }
    inline void setQCPPolarAxisRadial_GetSubTickPen_IsBase(bool value) const { qcppolaraxisradial_getsubtickpen_isbase = value; }
    inline void setQCPPolarAxisRadial_GetTickLabelFont_IsBase(bool value) const { qcppolaraxisradial_getticklabelfont_isbase = value; }
    inline void setQCPPolarAxisRadial_GetLabelFont_IsBase(bool value) const { qcppolaraxisradial_getlabelfont_isbase = value; }
    inline void setQCPPolarAxisRadial_GetTickLabelColor_IsBase(bool value) const { qcppolaraxisradial_getticklabelcolor_isbase = value; }
    inline void setQCPPolarAxisRadial_GetLabelColor_IsBase(bool value) const { qcppolaraxisradial_getlabelcolor_isbase = value; }
    inline void setQCPPolarAxisRadial_InitializeParentPlot_IsBase(bool value) const { qcppolaraxisradial_initializeparentplot_isbase = value; }
    inline void setQCPPolarAxisRadial_SetParentLayerable_IsBase(bool value) const { qcppolaraxisradial_setparentlayerable_isbase = value; }
    inline void setQCPPolarAxisRadial_MoveToLayer_IsBase(bool value) const { qcppolaraxisradial_movetolayer_isbase = value; }
    inline void setQCPPolarAxisRadial_ApplyAntialiasingHint_IsBase(bool value) const { qcppolaraxisradial_applyantialiasinghint_isbase = value; }
    inline void setQCPPolarAxisRadial_Sender_IsBase(bool value) const { qcppolaraxisradial_sender_isbase = value; }
    inline void setQCPPolarAxisRadial_SenderSignalIndex_IsBase(bool value) const { qcppolaraxisradial_sendersignalindex_isbase = value; }
    inline void setQCPPolarAxisRadial_Receivers_IsBase(bool value) const { qcppolaraxisradial_receivers_isbase = value; }
    inline void setQCPPolarAxisRadial_IsSignalConnected_IsBase(bool value) const { qcppolaraxisradial_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcppolaraxisradial_metacall_isbase) {
            qcppolaraxisradial_metacall_isbase = false;
            return QCPPolarAxisRadial::qt_metacall(param1, param2, param3);
        } else if (qcppolaraxisradial_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcppolaraxisradial_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPPolarAxisRadial::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcppolaraxisradial_selecttest_isbase) {
            qcppolaraxisradial_selecttest_isbase = false;
            return QCPPolarAxisRadial::selectTest(pos, onlySelectable, details);
        } else if (qcppolaraxisradial_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcppolaraxisradial_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPPolarAxisRadial::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcppolaraxisradial_applydefaultantialiasinghint_isbase) {
            qcppolaraxisradial_applydefaultantialiasinghint_isbase = false;
            QCPPolarAxisRadial::applyDefaultAntialiasingHint(painter);
        } else if (qcppolaraxisradial_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcppolaraxisradial_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPPolarAxisRadial::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcppolaraxisradial_draw_isbase) {
            qcppolaraxisradial_draw_isbase = false;
            QCPPolarAxisRadial::draw(painter);
        } else if (qcppolaraxisradial_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcppolaraxisradial_draw_callback(this, cbval1);
        } else {
            QCPPolarAxisRadial::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcppolaraxisradial_selectioncategory_isbase) {
            qcppolaraxisradial_selectioncategory_isbase = false;
            return QCPPolarAxisRadial::selectionCategory();
        } else if (qcppolaraxisradial_selectioncategory_callback != nullptr) {
            int callback_ret = qcppolaraxisradial_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPPolarAxisRadial::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcppolaraxisradial_selectevent_isbase) {
            qcppolaraxisradial_selectevent_isbase = false;
            QCPPolarAxisRadial::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcppolaraxisradial_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcppolaraxisradial_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPPolarAxisRadial::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcppolaraxisradial_deselectevent_isbase) {
            qcppolaraxisradial_deselectevent_isbase = false;
            QCPPolarAxisRadial::deselectEvent(selectionStateChanged);
        } else if (qcppolaraxisradial_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcppolaraxisradial_deselectevent_callback(this, cbval1);
        } else {
            QCPPolarAxisRadial::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcppolaraxisradial_mousepressevent_isbase) {
            qcppolaraxisradial_mousepressevent_isbase = false;
            QCPPolarAxisRadial::mousePressEvent(event, details);
        } else if (qcppolaraxisradial_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcppolaraxisradial_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPPolarAxisRadial::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcppolaraxisradial_mousemoveevent_isbase) {
            qcppolaraxisradial_mousemoveevent_isbase = false;
            QCPPolarAxisRadial::mouseMoveEvent(event, startPos);
        } else if (qcppolaraxisradial_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcppolaraxisradial_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPPolarAxisRadial::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcppolaraxisradial_mousereleaseevent_isbase) {
            qcppolaraxisradial_mousereleaseevent_isbase = false;
            QCPPolarAxisRadial::mouseReleaseEvent(event, startPos);
        } else if (qcppolaraxisradial_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcppolaraxisradial_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPPolarAxisRadial::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcppolaraxisradial_wheelevent_isbase) {
            qcppolaraxisradial_wheelevent_isbase = false;
            QCPPolarAxisRadial::wheelEvent(event);
        } else if (qcppolaraxisradial_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcppolaraxisradial_wheelevent_callback(this, cbval1);
        } else {
            QCPPolarAxisRadial::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcppolaraxisradial_parentplotinitialized_isbase) {
            qcppolaraxisradial_parentplotinitialized_isbase = false;
            QCPPolarAxisRadial::parentPlotInitialized(parentPlot);
        } else if (qcppolaraxisradial_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcppolaraxisradial_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPPolarAxisRadial::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcppolaraxisradial_cliprect_isbase) {
            qcppolaraxisradial_cliprect_isbase = false;
            return QCPPolarAxisRadial::clipRect();
        } else if (qcppolaraxisradial_cliprect_callback != nullptr) {
            QRect* callback_ret = qcppolaraxisradial_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPPolarAxisRadial::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcppolaraxisradial_mousedoubleclickevent_isbase) {
            qcppolaraxisradial_mousedoubleclickevent_isbase = false;
            QCPPolarAxisRadial::mouseDoubleClickEvent(event, details);
        } else if (qcppolaraxisradial_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcppolaraxisradial_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPPolarAxisRadial::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcppolaraxisradial_event_isbase) {
            qcppolaraxisradial_event_isbase = false;
            return QCPPolarAxisRadial::event(event);
        } else if (qcppolaraxisradial_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcppolaraxisradial_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPPolarAxisRadial::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcppolaraxisradial_eventfilter_isbase) {
            qcppolaraxisradial_eventfilter_isbase = false;
            return QCPPolarAxisRadial::eventFilter(watched, event);
        } else if (qcppolaraxisradial_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcppolaraxisradial_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPPolarAxisRadial::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcppolaraxisradial_timerevent_isbase) {
            qcppolaraxisradial_timerevent_isbase = false;
            QCPPolarAxisRadial::timerEvent(event);
        } else if (qcppolaraxisradial_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcppolaraxisradial_timerevent_callback(this, cbval1);
        } else {
            QCPPolarAxisRadial::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcppolaraxisradial_childevent_isbase) {
            qcppolaraxisradial_childevent_isbase = false;
            QCPPolarAxisRadial::childEvent(event);
        } else if (qcppolaraxisradial_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcppolaraxisradial_childevent_callback(this, cbval1);
        } else {
            QCPPolarAxisRadial::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcppolaraxisradial_customevent_isbase) {
            qcppolaraxisradial_customevent_isbase = false;
            QCPPolarAxisRadial::customEvent(event);
        } else if (qcppolaraxisradial_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcppolaraxisradial_customevent_callback(this, cbval1);
        } else {
            QCPPolarAxisRadial::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcppolaraxisradial_connectnotify_isbase) {
            qcppolaraxisradial_connectnotify_isbase = false;
            QCPPolarAxisRadial::connectNotify(signal);
        } else if (qcppolaraxisradial_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcppolaraxisradial_connectnotify_callback(this, cbval1);
        } else {
            QCPPolarAxisRadial::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcppolaraxisradial_disconnectnotify_isbase) {
            qcppolaraxisradial_disconnectnotify_isbase = false;
            QCPPolarAxisRadial::disconnectNotify(signal);
        } else if (qcppolaraxisradial_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcppolaraxisradial_disconnectnotify_callback(this, cbval1);
        } else {
            QCPPolarAxisRadial::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    void updateGeometry(const QPointF& center, double radius) {
        if (qcppolaraxisradial_updategeometry_isbase) {
            qcppolaraxisradial_updategeometry_isbase = false;
            QCPPolarAxisRadial::updateGeometry(center, radius);
        } else if (qcppolaraxisradial_updategeometry_callback != nullptr) {
            const QPointF& center_ret = center;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&center_ret);
            double cbval2 = radius;

            qcppolaraxisradial_updategeometry_callback(this, cbval1, cbval2);
        } else {
            QCPPolarAxisRadial::updateGeometry(center, radius);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setupTickVectors() {
        if (qcppolaraxisradial_setuptickvectors_isbase) {
            qcppolaraxisradial_setuptickvectors_isbase = false;
            QCPPolarAxisRadial::setupTickVectors();
        } else if (qcppolaraxisradial_setuptickvectors_callback != nullptr) {
            qcppolaraxisradial_setuptickvectors_callback();
        } else {
            QCPPolarAxisRadial::setupTickVectors();
        }
    }

    // Virtual method for C ABI access and custom callback
    QPen getBasePen() const {
        if (qcppolaraxisradial_getbasepen_isbase) {
            qcppolaraxisradial_getbasepen_isbase = false;
            return QCPPolarAxisRadial::getBasePen();
        } else if (qcppolaraxisradial_getbasepen_callback != nullptr) {
            QPen* callback_ret = qcppolaraxisradial_getbasepen_callback();
            return *callback_ret;
        } else {
            return QCPPolarAxisRadial::getBasePen();
        }
    }

    // Virtual method for C ABI access and custom callback
    QPen getTickPen() const {
        if (qcppolaraxisradial_gettickpen_isbase) {
            qcppolaraxisradial_gettickpen_isbase = false;
            return QCPPolarAxisRadial::getTickPen();
        } else if (qcppolaraxisradial_gettickpen_callback != nullptr) {
            QPen* callback_ret = qcppolaraxisradial_gettickpen_callback();
            return *callback_ret;
        } else {
            return QCPPolarAxisRadial::getTickPen();
        }
    }

    // Virtual method for C ABI access and custom callback
    QPen getSubTickPen() const {
        if (qcppolaraxisradial_getsubtickpen_isbase) {
            qcppolaraxisradial_getsubtickpen_isbase = false;
            return QCPPolarAxisRadial::getSubTickPen();
        } else if (qcppolaraxisradial_getsubtickpen_callback != nullptr) {
            QPen* callback_ret = qcppolaraxisradial_getsubtickpen_callback();
            return *callback_ret;
        } else {
            return QCPPolarAxisRadial::getSubTickPen();
        }
    }

    // Virtual method for C ABI access and custom callback
    QFont getTickLabelFont() const {
        if (qcppolaraxisradial_getticklabelfont_isbase) {
            qcppolaraxisradial_getticklabelfont_isbase = false;
            return QCPPolarAxisRadial::getTickLabelFont();
        } else if (qcppolaraxisradial_getticklabelfont_callback != nullptr) {
            QFont* callback_ret = qcppolaraxisradial_getticklabelfont_callback();
            return *callback_ret;
        } else {
            return QCPPolarAxisRadial::getTickLabelFont();
        }
    }

    // Virtual method for C ABI access and custom callback
    QFont getLabelFont() const {
        if (qcppolaraxisradial_getlabelfont_isbase) {
            qcppolaraxisradial_getlabelfont_isbase = false;
            return QCPPolarAxisRadial::getLabelFont();
        } else if (qcppolaraxisradial_getlabelfont_callback != nullptr) {
            QFont* callback_ret = qcppolaraxisradial_getlabelfont_callback();
            return *callback_ret;
        } else {
            return QCPPolarAxisRadial::getLabelFont();
        }
    }

    // Virtual method for C ABI access and custom callback
    QColor getTickLabelColor() const {
        if (qcppolaraxisradial_getticklabelcolor_isbase) {
            qcppolaraxisradial_getticklabelcolor_isbase = false;
            return QCPPolarAxisRadial::getTickLabelColor();
        } else if (qcppolaraxisradial_getticklabelcolor_callback != nullptr) {
            QColor* callback_ret = qcppolaraxisradial_getticklabelcolor_callback();
            return *callback_ret;
        } else {
            return QCPPolarAxisRadial::getTickLabelColor();
        }
    }

    // Virtual method for C ABI access and custom callback
    QColor getLabelColor() const {
        if (qcppolaraxisradial_getlabelcolor_isbase) {
            qcppolaraxisradial_getlabelcolor_isbase = false;
            return QCPPolarAxisRadial::getLabelColor();
        } else if (qcppolaraxisradial_getlabelcolor_callback != nullptr) {
            QColor* callback_ret = qcppolaraxisradial_getlabelcolor_callback();
            return *callback_ret;
        } else {
            return QCPPolarAxisRadial::getLabelColor();
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcppolaraxisradial_initializeparentplot_isbase) {
            qcppolaraxisradial_initializeparentplot_isbase = false;
            QCPPolarAxisRadial::initializeParentPlot(parentPlot);
        } else if (qcppolaraxisradial_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcppolaraxisradial_initializeparentplot_callback(this, cbval1);
        } else {
            QCPPolarAxisRadial::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcppolaraxisradial_setparentlayerable_isbase) {
            qcppolaraxisradial_setparentlayerable_isbase = false;
            QCPPolarAxisRadial::setParentLayerable(parentLayerable);
        } else if (qcppolaraxisradial_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcppolaraxisradial_setparentlayerable_callback(this, cbval1);
        } else {
            QCPPolarAxisRadial::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcppolaraxisradial_movetolayer_isbase) {
            qcppolaraxisradial_movetolayer_isbase = false;
            return QCPPolarAxisRadial::moveToLayer(layer, prepend);
        } else if (qcppolaraxisradial_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcppolaraxisradial_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPPolarAxisRadial::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcppolaraxisradial_applyantialiasinghint_isbase) {
            qcppolaraxisradial_applyantialiasinghint_isbase = false;
            QCPPolarAxisRadial::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcppolaraxisradial_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcppolaraxisradial_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPPolarAxisRadial::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcppolaraxisradial_sender_isbase) {
            qcppolaraxisradial_sender_isbase = false;
            return QCPPolarAxisRadial::sender();
        } else if (qcppolaraxisradial_sender_callback != nullptr) {
            QObject* callback_ret = qcppolaraxisradial_sender_callback();
            return callback_ret;
        } else {
            return QCPPolarAxisRadial::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcppolaraxisradial_sendersignalindex_isbase) {
            qcppolaraxisradial_sendersignalindex_isbase = false;
            return QCPPolarAxisRadial::senderSignalIndex();
        } else if (qcppolaraxisradial_sendersignalindex_callback != nullptr) {
            int callback_ret = qcppolaraxisradial_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPPolarAxisRadial::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcppolaraxisradial_receivers_isbase) {
            qcppolaraxisradial_receivers_isbase = false;
            return QCPPolarAxisRadial::receivers(signal);
        } else if (qcppolaraxisradial_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcppolaraxisradial_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPPolarAxisRadial::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcppolaraxisradial_issignalconnected_isbase) {
            qcppolaraxisradial_issignalconnected_isbase = false;
            return QCPPolarAxisRadial::isSignalConnected(signal);
        } else if (qcppolaraxisradial_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcppolaraxisradial_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPPolarAxisRadial::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPPolarAxisRadial_ApplyDefaultAntialiasingHint(const QCPPolarAxisRadial* self, QCPPainter* painter);
    friend void QCPPolarAxisRadial_QBaseApplyDefaultAntialiasingHint(const QCPPolarAxisRadial* self, QCPPainter* painter);
    friend void QCPPolarAxisRadial_Draw(QCPPolarAxisRadial* self, QCPPainter* painter);
    friend void QCPPolarAxisRadial_QBaseDraw(QCPPolarAxisRadial* self, QCPPainter* painter);
    friend int QCPPolarAxisRadial_SelectionCategory(const QCPPolarAxisRadial* self);
    friend int QCPPolarAxisRadial_QBaseSelectionCategory(const QCPPolarAxisRadial* self);
    friend void QCPPolarAxisRadial_SelectEvent(QCPPolarAxisRadial* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPPolarAxisRadial_QBaseSelectEvent(QCPPolarAxisRadial* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPPolarAxisRadial_DeselectEvent(QCPPolarAxisRadial* self, bool* selectionStateChanged);
    friend void QCPPolarAxisRadial_QBaseDeselectEvent(QCPPolarAxisRadial* self, bool* selectionStateChanged);
    friend void QCPPolarAxisRadial_MousePressEvent(QCPPolarAxisRadial* self, QMouseEvent* event, const QVariant* details);
    friend void QCPPolarAxisRadial_QBaseMousePressEvent(QCPPolarAxisRadial* self, QMouseEvent* event, const QVariant* details);
    friend void QCPPolarAxisRadial_MouseMoveEvent(QCPPolarAxisRadial* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPPolarAxisRadial_QBaseMouseMoveEvent(QCPPolarAxisRadial* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPPolarAxisRadial_MouseReleaseEvent(QCPPolarAxisRadial* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPPolarAxisRadial_QBaseMouseReleaseEvent(QCPPolarAxisRadial* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPPolarAxisRadial_WheelEvent(QCPPolarAxisRadial* self, QWheelEvent* event);
    friend void QCPPolarAxisRadial_QBaseWheelEvent(QCPPolarAxisRadial* self, QWheelEvent* event);
    friend void QCPPolarAxisRadial_ParentPlotInitialized(QCPPolarAxisRadial* self, QCustomPlot* parentPlot);
    friend void QCPPolarAxisRadial_QBaseParentPlotInitialized(QCPPolarAxisRadial* self, QCustomPlot* parentPlot);
    friend QRect* QCPPolarAxisRadial_ClipRect(const QCPPolarAxisRadial* self);
    friend QRect* QCPPolarAxisRadial_QBaseClipRect(const QCPPolarAxisRadial* self);
    friend void QCPPolarAxisRadial_MouseDoubleClickEvent(QCPPolarAxisRadial* self, QMouseEvent* event, const QVariant* details);
    friend void QCPPolarAxisRadial_QBaseMouseDoubleClickEvent(QCPPolarAxisRadial* self, QMouseEvent* event, const QVariant* details);
    friend void QCPPolarAxisRadial_TimerEvent(QCPPolarAxisRadial* self, QTimerEvent* event);
    friend void QCPPolarAxisRadial_QBaseTimerEvent(QCPPolarAxisRadial* self, QTimerEvent* event);
    friend void QCPPolarAxisRadial_ChildEvent(QCPPolarAxisRadial* self, QChildEvent* event);
    friend void QCPPolarAxisRadial_QBaseChildEvent(QCPPolarAxisRadial* self, QChildEvent* event);
    friend void QCPPolarAxisRadial_CustomEvent(QCPPolarAxisRadial* self, QEvent* event);
    friend void QCPPolarAxisRadial_QBaseCustomEvent(QCPPolarAxisRadial* self, QEvent* event);
    friend void QCPPolarAxisRadial_ConnectNotify(QCPPolarAxisRadial* self, const QMetaMethod* signal);
    friend void QCPPolarAxisRadial_QBaseConnectNotify(QCPPolarAxisRadial* self, const QMetaMethod* signal);
    friend void QCPPolarAxisRadial_DisconnectNotify(QCPPolarAxisRadial* self, const QMetaMethod* signal);
    friend void QCPPolarAxisRadial_QBaseDisconnectNotify(QCPPolarAxisRadial* self, const QMetaMethod* signal);
    friend void QCPPolarAxisRadial_UpdateGeometry(QCPPolarAxisRadial* self, const QPointF* center, double radius);
    friend void QCPPolarAxisRadial_QBaseUpdateGeometry(QCPPolarAxisRadial* self, const QPointF* center, double radius);
    friend void QCPPolarAxisRadial_SetupTickVectors(QCPPolarAxisRadial* self);
    friend void QCPPolarAxisRadial_QBaseSetupTickVectors(QCPPolarAxisRadial* self);
    friend QPen* QCPPolarAxisRadial_GetBasePen(const QCPPolarAxisRadial* self);
    friend QPen* QCPPolarAxisRadial_QBaseGetBasePen(const QCPPolarAxisRadial* self);
    friend QPen* QCPPolarAxisRadial_GetTickPen(const QCPPolarAxisRadial* self);
    friend QPen* QCPPolarAxisRadial_QBaseGetTickPen(const QCPPolarAxisRadial* self);
    friend QPen* QCPPolarAxisRadial_GetSubTickPen(const QCPPolarAxisRadial* self);
    friend QPen* QCPPolarAxisRadial_QBaseGetSubTickPen(const QCPPolarAxisRadial* self);
    friend QFont* QCPPolarAxisRadial_GetTickLabelFont(const QCPPolarAxisRadial* self);
    friend QFont* QCPPolarAxisRadial_QBaseGetTickLabelFont(const QCPPolarAxisRadial* self);
    friend QFont* QCPPolarAxisRadial_GetLabelFont(const QCPPolarAxisRadial* self);
    friend QFont* QCPPolarAxisRadial_QBaseGetLabelFont(const QCPPolarAxisRadial* self);
    friend QColor* QCPPolarAxisRadial_GetTickLabelColor(const QCPPolarAxisRadial* self);
    friend QColor* QCPPolarAxisRadial_QBaseGetTickLabelColor(const QCPPolarAxisRadial* self);
    friend QColor* QCPPolarAxisRadial_GetLabelColor(const QCPPolarAxisRadial* self);
    friend QColor* QCPPolarAxisRadial_QBaseGetLabelColor(const QCPPolarAxisRadial* self);
    friend void QCPPolarAxisRadial_InitializeParentPlot(QCPPolarAxisRadial* self, QCustomPlot* parentPlot);
    friend void QCPPolarAxisRadial_QBaseInitializeParentPlot(QCPPolarAxisRadial* self, QCustomPlot* parentPlot);
    friend void QCPPolarAxisRadial_SetParentLayerable(QCPPolarAxisRadial* self, QCPLayerable* parentLayerable);
    friend void QCPPolarAxisRadial_QBaseSetParentLayerable(QCPPolarAxisRadial* self, QCPLayerable* parentLayerable);
    friend bool QCPPolarAxisRadial_MoveToLayer(QCPPolarAxisRadial* self, QCPLayer* layer, bool prepend);
    friend bool QCPPolarAxisRadial_QBaseMoveToLayer(QCPPolarAxisRadial* self, QCPLayer* layer, bool prepend);
    friend void QCPPolarAxisRadial_ApplyAntialiasingHint(const QCPPolarAxisRadial* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPPolarAxisRadial_QBaseApplyAntialiasingHint(const QCPPolarAxisRadial* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPPolarAxisRadial_Sender(const QCPPolarAxisRadial* self);
    friend QObject* QCPPolarAxisRadial_QBaseSender(const QCPPolarAxisRadial* self);
    friend int QCPPolarAxisRadial_SenderSignalIndex(const QCPPolarAxisRadial* self);
    friend int QCPPolarAxisRadial_QBaseSenderSignalIndex(const QCPPolarAxisRadial* self);
    friend int QCPPolarAxisRadial_Receivers(const QCPPolarAxisRadial* self, const char* signal);
    friend int QCPPolarAxisRadial_QBaseReceivers(const QCPPolarAxisRadial* self, const char* signal);
    friend bool QCPPolarAxisRadial_IsSignalConnected(const QCPPolarAxisRadial* self, const QMetaMethod* signal);
    friend bool QCPPolarAxisRadial_QBaseIsSignalConnected(const QCPPolarAxisRadial* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPPolarAxisAngular so that we can call protected methods
class VirtualQCPPolarAxisAngular final : public QCPPolarAxisAngular {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPPolarAxisAngular = true;

    // Virtual class public types (including callbacks)
    using QCPPolarAxisAngular_Metacall_Callback = int (*)(QCPPolarAxisAngular*, int, int, void**);
    using QCPPolarAxisAngular_SelectTest_Callback = double (*)(const QCPPolarAxisAngular*, QPointF*, bool, QVariant*);
    using QCPPolarAxisAngular_Update_Callback = void (*)(QCPPolarAxisAngular*, int);
    using QCPPolarAxisAngular_Elements_Callback = QCPLayoutElement** (*)(const QCPPolarAxisAngular*, bool);
    using QCPPolarAxisAngular_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPPolarAxisAngular*, QCPPainter*);
    using QCPPolarAxisAngular_Draw_Callback = void (*)(QCPPolarAxisAngular*, QCPPainter*);
    using QCPPolarAxisAngular_SelectionCategory_Callback = int (*)();
    using QCPPolarAxisAngular_MousePressEvent_Callback = void (*)(QCPPolarAxisAngular*, QMouseEvent*, QVariant*);
    using QCPPolarAxisAngular_MouseMoveEvent_Callback = void (*)(QCPPolarAxisAngular*, QMouseEvent*, QPointF*);
    using QCPPolarAxisAngular_MouseReleaseEvent_Callback = void (*)(QCPPolarAxisAngular*, QMouseEvent*, QPointF*);
    using QCPPolarAxisAngular_WheelEvent_Callback = void (*)(QCPPolarAxisAngular*, QWheelEvent*);
    using QCPPolarAxisAngular_MinimumOuterSizeHint_Callback = QSize* (*)();
    using QCPPolarAxisAngular_MaximumOuterSizeHint_Callback = QSize* (*)();
    using QCPPolarAxisAngular_CalculateAutoMargin_Callback = int (*)(QCPPolarAxisAngular*, int);
    using QCPPolarAxisAngular_LayoutChanged_Callback = void (*)();
    using QCPPolarAxisAngular_ParentPlotInitialized_Callback = void (*)(QCPPolarAxisAngular*, QCustomPlot*);
    using QCPPolarAxisAngular_ClipRect_Callback = QRect* (*)();
    using QCPPolarAxisAngular_SelectEvent_Callback = void (*)(QCPPolarAxisAngular*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPPolarAxisAngular_DeselectEvent_Callback = void (*)(QCPPolarAxisAngular*, bool*);
    using QCPPolarAxisAngular_MouseDoubleClickEvent_Callback = void (*)(QCPPolarAxisAngular*, QMouseEvent*, QVariant*);
    using QCPPolarAxisAngular_Event_Callback = bool (*)(QCPPolarAxisAngular*, QEvent*);
    using QCPPolarAxisAngular_EventFilter_Callback = bool (*)(QCPPolarAxisAngular*, QObject*, QEvent*);
    using QCPPolarAxisAngular_TimerEvent_Callback = void (*)(QCPPolarAxisAngular*, QTimerEvent*);
    using QCPPolarAxisAngular_ChildEvent_Callback = void (*)(QCPPolarAxisAngular*, QChildEvent*);
    using QCPPolarAxisAngular_CustomEvent_Callback = void (*)(QCPPolarAxisAngular*, QEvent*);
    using QCPPolarAxisAngular_ConnectNotify_Callback = void (*)(QCPPolarAxisAngular*, QMetaMethod*);
    using QCPPolarAxisAngular_DisconnectNotify_Callback = void (*)(QCPPolarAxisAngular*, QMetaMethod*);
    using QCPPolarAxisAngular_RegisterPolarGraph_Callback = bool (*)(QCPPolarAxisAngular*, QCPPolarGraph*);
    using QCPPolarAxisAngular_DrawBackground_Callback = void (*)(QCPPolarAxisAngular*, QCPPainter*, QPointF*, double);
    using QCPPolarAxisAngular_SetupTickVectors_Callback = void (*)();
    using QCPPolarAxisAngular_GetBasePen_Callback = QPen* (*)();
    using QCPPolarAxisAngular_GetTickPen_Callback = QPen* (*)();
    using QCPPolarAxisAngular_GetSubTickPen_Callback = QPen* (*)();
    using QCPPolarAxisAngular_GetTickLabelFont_Callback = QFont* (*)();
    using QCPPolarAxisAngular_GetLabelFont_Callback = QFont* (*)();
    using QCPPolarAxisAngular_GetTickLabelColor_Callback = QColor* (*)();
    using QCPPolarAxisAngular_GetLabelColor_Callback = QColor* (*)();
    using QCPPolarAxisAngular_InitializeParentPlot_Callback = void (*)(QCPPolarAxisAngular*, QCustomPlot*);
    using QCPPolarAxisAngular_SetParentLayerable_Callback = void (*)(QCPPolarAxisAngular*, QCPLayerable*);
    using QCPPolarAxisAngular_MoveToLayer_Callback = bool (*)(QCPPolarAxisAngular*, QCPLayer*, bool);
    using QCPPolarAxisAngular_ApplyAntialiasingHint_Callback = void (*)(const QCPPolarAxisAngular*, QCPPainter*, bool, int);
    using QCPPolarAxisAngular_Sender_Callback = QObject* (*)();
    using QCPPolarAxisAngular_SenderSignalIndex_Callback = int (*)();
    using QCPPolarAxisAngular_Receivers_Callback = int (*)(const QCPPolarAxisAngular*, const char*);
    using QCPPolarAxisAngular_IsSignalConnected_Callback = bool (*)(const QCPPolarAxisAngular*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPPolarAxisAngular_Metacall_Callback qcppolaraxisangular_metacall_callback = nullptr;
    QCPPolarAxisAngular_SelectTest_Callback qcppolaraxisangular_selecttest_callback = nullptr;
    QCPPolarAxisAngular_Update_Callback qcppolaraxisangular_update_callback = nullptr;
    QCPPolarAxisAngular_Elements_Callback qcppolaraxisangular_elements_callback = nullptr;
    QCPPolarAxisAngular_ApplyDefaultAntialiasingHint_Callback qcppolaraxisangular_applydefaultantialiasinghint_callback = nullptr;
    QCPPolarAxisAngular_Draw_Callback qcppolaraxisangular_draw_callback = nullptr;
    QCPPolarAxisAngular_SelectionCategory_Callback qcppolaraxisangular_selectioncategory_callback = nullptr;
    QCPPolarAxisAngular_MousePressEvent_Callback qcppolaraxisangular_mousepressevent_callback = nullptr;
    QCPPolarAxisAngular_MouseMoveEvent_Callback qcppolaraxisangular_mousemoveevent_callback = nullptr;
    QCPPolarAxisAngular_MouseReleaseEvent_Callback qcppolaraxisangular_mousereleaseevent_callback = nullptr;
    QCPPolarAxisAngular_WheelEvent_Callback qcppolaraxisangular_wheelevent_callback = nullptr;
    QCPPolarAxisAngular_MinimumOuterSizeHint_Callback qcppolaraxisangular_minimumoutersizehint_callback = nullptr;
    QCPPolarAxisAngular_MaximumOuterSizeHint_Callback qcppolaraxisangular_maximumoutersizehint_callback = nullptr;
    QCPPolarAxisAngular_CalculateAutoMargin_Callback qcppolaraxisangular_calculateautomargin_callback = nullptr;
    QCPPolarAxisAngular_LayoutChanged_Callback qcppolaraxisangular_layoutchanged_callback = nullptr;
    QCPPolarAxisAngular_ParentPlotInitialized_Callback qcppolaraxisangular_parentplotinitialized_callback = nullptr;
    QCPPolarAxisAngular_ClipRect_Callback qcppolaraxisangular_cliprect_callback = nullptr;
    QCPPolarAxisAngular_SelectEvent_Callback qcppolaraxisangular_selectevent_callback = nullptr;
    QCPPolarAxisAngular_DeselectEvent_Callback qcppolaraxisangular_deselectevent_callback = nullptr;
    QCPPolarAxisAngular_MouseDoubleClickEvent_Callback qcppolaraxisangular_mousedoubleclickevent_callback = nullptr;
    QCPPolarAxisAngular_Event_Callback qcppolaraxisangular_event_callback = nullptr;
    QCPPolarAxisAngular_EventFilter_Callback qcppolaraxisangular_eventfilter_callback = nullptr;
    QCPPolarAxisAngular_TimerEvent_Callback qcppolaraxisangular_timerevent_callback = nullptr;
    QCPPolarAxisAngular_ChildEvent_Callback qcppolaraxisangular_childevent_callback = nullptr;
    QCPPolarAxisAngular_CustomEvent_Callback qcppolaraxisangular_customevent_callback = nullptr;
    QCPPolarAxisAngular_ConnectNotify_Callback qcppolaraxisangular_connectnotify_callback = nullptr;
    QCPPolarAxisAngular_DisconnectNotify_Callback qcppolaraxisangular_disconnectnotify_callback = nullptr;
    QCPPolarAxisAngular_RegisterPolarGraph_Callback qcppolaraxisangular_registerpolargraph_callback = nullptr;
    QCPPolarAxisAngular_DrawBackground_Callback qcppolaraxisangular_drawbackground_callback = nullptr;
    QCPPolarAxisAngular_SetupTickVectors_Callback qcppolaraxisangular_setuptickvectors_callback = nullptr;
    QCPPolarAxisAngular_GetBasePen_Callback qcppolaraxisangular_getbasepen_callback = nullptr;
    QCPPolarAxisAngular_GetTickPen_Callback qcppolaraxisangular_gettickpen_callback = nullptr;
    QCPPolarAxisAngular_GetSubTickPen_Callback qcppolaraxisangular_getsubtickpen_callback = nullptr;
    QCPPolarAxisAngular_GetTickLabelFont_Callback qcppolaraxisangular_getticklabelfont_callback = nullptr;
    QCPPolarAxisAngular_GetLabelFont_Callback qcppolaraxisangular_getlabelfont_callback = nullptr;
    QCPPolarAxisAngular_GetTickLabelColor_Callback qcppolaraxisangular_getticklabelcolor_callback = nullptr;
    QCPPolarAxisAngular_GetLabelColor_Callback qcppolaraxisangular_getlabelcolor_callback = nullptr;
    QCPPolarAxisAngular_InitializeParentPlot_Callback qcppolaraxisangular_initializeparentplot_callback = nullptr;
    QCPPolarAxisAngular_SetParentLayerable_Callback qcppolaraxisangular_setparentlayerable_callback = nullptr;
    QCPPolarAxisAngular_MoveToLayer_Callback qcppolaraxisangular_movetolayer_callback = nullptr;
    QCPPolarAxisAngular_ApplyAntialiasingHint_Callback qcppolaraxisangular_applyantialiasinghint_callback = nullptr;
    QCPPolarAxisAngular_Sender_Callback qcppolaraxisangular_sender_callback = nullptr;
    QCPPolarAxisAngular_SenderSignalIndex_Callback qcppolaraxisangular_sendersignalindex_callback = nullptr;
    QCPPolarAxisAngular_Receivers_Callback qcppolaraxisangular_receivers_callback = nullptr;
    QCPPolarAxisAngular_IsSignalConnected_Callback qcppolaraxisangular_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcppolaraxisangular_metacall_isbase = false;
    mutable bool qcppolaraxisangular_selecttest_isbase = false;
    mutable bool qcppolaraxisangular_update_isbase = false;
    mutable bool qcppolaraxisangular_elements_isbase = false;
    mutable bool qcppolaraxisangular_applydefaultantialiasinghint_isbase = false;
    mutable bool qcppolaraxisangular_draw_isbase = false;
    mutable bool qcppolaraxisangular_selectioncategory_isbase = false;
    mutable bool qcppolaraxisangular_mousepressevent_isbase = false;
    mutable bool qcppolaraxisangular_mousemoveevent_isbase = false;
    mutable bool qcppolaraxisangular_mousereleaseevent_isbase = false;
    mutable bool qcppolaraxisangular_wheelevent_isbase = false;
    mutable bool qcppolaraxisangular_minimumoutersizehint_isbase = false;
    mutable bool qcppolaraxisangular_maximumoutersizehint_isbase = false;
    mutable bool qcppolaraxisangular_calculateautomargin_isbase = false;
    mutable bool qcppolaraxisangular_layoutchanged_isbase = false;
    mutable bool qcppolaraxisangular_parentplotinitialized_isbase = false;
    mutable bool qcppolaraxisangular_cliprect_isbase = false;
    mutable bool qcppolaraxisangular_selectevent_isbase = false;
    mutable bool qcppolaraxisangular_deselectevent_isbase = false;
    mutable bool qcppolaraxisangular_mousedoubleclickevent_isbase = false;
    mutable bool qcppolaraxisangular_event_isbase = false;
    mutable bool qcppolaraxisangular_eventfilter_isbase = false;
    mutable bool qcppolaraxisangular_timerevent_isbase = false;
    mutable bool qcppolaraxisangular_childevent_isbase = false;
    mutable bool qcppolaraxisangular_customevent_isbase = false;
    mutable bool qcppolaraxisangular_connectnotify_isbase = false;
    mutable bool qcppolaraxisangular_disconnectnotify_isbase = false;
    mutable bool qcppolaraxisangular_registerpolargraph_isbase = false;
    mutable bool qcppolaraxisangular_drawbackground_isbase = false;
    mutable bool qcppolaraxisangular_setuptickvectors_isbase = false;
    mutable bool qcppolaraxisangular_getbasepen_isbase = false;
    mutable bool qcppolaraxisangular_gettickpen_isbase = false;
    mutable bool qcppolaraxisangular_getsubtickpen_isbase = false;
    mutable bool qcppolaraxisangular_getticklabelfont_isbase = false;
    mutable bool qcppolaraxisangular_getlabelfont_isbase = false;
    mutable bool qcppolaraxisangular_getticklabelcolor_isbase = false;
    mutable bool qcppolaraxisangular_getlabelcolor_isbase = false;
    mutable bool qcppolaraxisangular_initializeparentplot_isbase = false;
    mutable bool qcppolaraxisangular_setparentlayerable_isbase = false;
    mutable bool qcppolaraxisangular_movetolayer_isbase = false;
    mutable bool qcppolaraxisangular_applyantialiasinghint_isbase = false;
    mutable bool qcppolaraxisangular_sender_isbase = false;
    mutable bool qcppolaraxisangular_sendersignalindex_isbase = false;
    mutable bool qcppolaraxisangular_receivers_isbase = false;
    mutable bool qcppolaraxisangular_issignalconnected_isbase = false;

  public:
    VirtualQCPPolarAxisAngular(QCustomPlot* parentPlot) : QCPPolarAxisAngular(parentPlot) {};

    ~VirtualQCPPolarAxisAngular() {
        qcppolaraxisangular_metacall_callback = nullptr;
        qcppolaraxisangular_selecttest_callback = nullptr;
        qcppolaraxisangular_update_callback = nullptr;
        qcppolaraxisangular_elements_callback = nullptr;
        qcppolaraxisangular_applydefaultantialiasinghint_callback = nullptr;
        qcppolaraxisangular_draw_callback = nullptr;
        qcppolaraxisangular_selectioncategory_callback = nullptr;
        qcppolaraxisangular_mousepressevent_callback = nullptr;
        qcppolaraxisangular_mousemoveevent_callback = nullptr;
        qcppolaraxisangular_mousereleaseevent_callback = nullptr;
        qcppolaraxisangular_wheelevent_callback = nullptr;
        qcppolaraxisangular_minimumoutersizehint_callback = nullptr;
        qcppolaraxisangular_maximumoutersizehint_callback = nullptr;
        qcppolaraxisangular_calculateautomargin_callback = nullptr;
        qcppolaraxisangular_layoutchanged_callback = nullptr;
        qcppolaraxisangular_parentplotinitialized_callback = nullptr;
        qcppolaraxisangular_cliprect_callback = nullptr;
        qcppolaraxisangular_selectevent_callback = nullptr;
        qcppolaraxisangular_deselectevent_callback = nullptr;
        qcppolaraxisangular_mousedoubleclickevent_callback = nullptr;
        qcppolaraxisangular_event_callback = nullptr;
        qcppolaraxisangular_eventfilter_callback = nullptr;
        qcppolaraxisangular_timerevent_callback = nullptr;
        qcppolaraxisangular_childevent_callback = nullptr;
        qcppolaraxisangular_customevent_callback = nullptr;
        qcppolaraxisangular_connectnotify_callback = nullptr;
        qcppolaraxisangular_disconnectnotify_callback = nullptr;
        qcppolaraxisangular_registerpolargraph_callback = nullptr;
        qcppolaraxisangular_drawbackground_callback = nullptr;
        qcppolaraxisangular_setuptickvectors_callback = nullptr;
        qcppolaraxisangular_getbasepen_callback = nullptr;
        qcppolaraxisangular_gettickpen_callback = nullptr;
        qcppolaraxisangular_getsubtickpen_callback = nullptr;
        qcppolaraxisangular_getticklabelfont_callback = nullptr;
        qcppolaraxisangular_getlabelfont_callback = nullptr;
        qcppolaraxisangular_getticklabelcolor_callback = nullptr;
        qcppolaraxisangular_getlabelcolor_callback = nullptr;
        qcppolaraxisangular_initializeparentplot_callback = nullptr;
        qcppolaraxisangular_setparentlayerable_callback = nullptr;
        qcppolaraxisangular_movetolayer_callback = nullptr;
        qcppolaraxisangular_applyantialiasinghint_callback = nullptr;
        qcppolaraxisangular_sender_callback = nullptr;
        qcppolaraxisangular_sendersignalindex_callback = nullptr;
        qcppolaraxisangular_receivers_callback = nullptr;
        qcppolaraxisangular_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPPolarAxisAngular_Metacall_Callback(QCPPolarAxisAngular_Metacall_Callback cb) { qcppolaraxisangular_metacall_callback = cb; }
    inline void setQCPPolarAxisAngular_SelectTest_Callback(QCPPolarAxisAngular_SelectTest_Callback cb) { qcppolaraxisangular_selecttest_callback = cb; }
    inline void setQCPPolarAxisAngular_Update_Callback(QCPPolarAxisAngular_Update_Callback cb) { qcppolaraxisangular_update_callback = cb; }
    inline void setQCPPolarAxisAngular_Elements_Callback(QCPPolarAxisAngular_Elements_Callback cb) { qcppolaraxisangular_elements_callback = cb; }
    inline void setQCPPolarAxisAngular_ApplyDefaultAntialiasingHint_Callback(QCPPolarAxisAngular_ApplyDefaultAntialiasingHint_Callback cb) { qcppolaraxisangular_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPPolarAxisAngular_Draw_Callback(QCPPolarAxisAngular_Draw_Callback cb) { qcppolaraxisangular_draw_callback = cb; }
    inline void setQCPPolarAxisAngular_SelectionCategory_Callback(QCPPolarAxisAngular_SelectionCategory_Callback cb) { qcppolaraxisangular_selectioncategory_callback = cb; }
    inline void setQCPPolarAxisAngular_MousePressEvent_Callback(QCPPolarAxisAngular_MousePressEvent_Callback cb) { qcppolaraxisangular_mousepressevent_callback = cb; }
    inline void setQCPPolarAxisAngular_MouseMoveEvent_Callback(QCPPolarAxisAngular_MouseMoveEvent_Callback cb) { qcppolaraxisangular_mousemoveevent_callback = cb; }
    inline void setQCPPolarAxisAngular_MouseReleaseEvent_Callback(QCPPolarAxisAngular_MouseReleaseEvent_Callback cb) { qcppolaraxisangular_mousereleaseevent_callback = cb; }
    inline void setQCPPolarAxisAngular_WheelEvent_Callback(QCPPolarAxisAngular_WheelEvent_Callback cb) { qcppolaraxisangular_wheelevent_callback = cb; }
    inline void setQCPPolarAxisAngular_MinimumOuterSizeHint_Callback(QCPPolarAxisAngular_MinimumOuterSizeHint_Callback cb) { qcppolaraxisangular_minimumoutersizehint_callback = cb; }
    inline void setQCPPolarAxisAngular_MaximumOuterSizeHint_Callback(QCPPolarAxisAngular_MaximumOuterSizeHint_Callback cb) { qcppolaraxisangular_maximumoutersizehint_callback = cb; }
    inline void setQCPPolarAxisAngular_CalculateAutoMargin_Callback(QCPPolarAxisAngular_CalculateAutoMargin_Callback cb) { qcppolaraxisangular_calculateautomargin_callback = cb; }
    inline void setQCPPolarAxisAngular_LayoutChanged_Callback(QCPPolarAxisAngular_LayoutChanged_Callback cb) { qcppolaraxisangular_layoutchanged_callback = cb; }
    inline void setQCPPolarAxisAngular_ParentPlotInitialized_Callback(QCPPolarAxisAngular_ParentPlotInitialized_Callback cb) { qcppolaraxisangular_parentplotinitialized_callback = cb; }
    inline void setQCPPolarAxisAngular_ClipRect_Callback(QCPPolarAxisAngular_ClipRect_Callback cb) { qcppolaraxisangular_cliprect_callback = cb; }
    inline void setQCPPolarAxisAngular_SelectEvent_Callback(QCPPolarAxisAngular_SelectEvent_Callback cb) { qcppolaraxisangular_selectevent_callback = cb; }
    inline void setQCPPolarAxisAngular_DeselectEvent_Callback(QCPPolarAxisAngular_DeselectEvent_Callback cb) { qcppolaraxisangular_deselectevent_callback = cb; }
    inline void setQCPPolarAxisAngular_MouseDoubleClickEvent_Callback(QCPPolarAxisAngular_MouseDoubleClickEvent_Callback cb) { qcppolaraxisangular_mousedoubleclickevent_callback = cb; }
    inline void setQCPPolarAxisAngular_Event_Callback(QCPPolarAxisAngular_Event_Callback cb) { qcppolaraxisangular_event_callback = cb; }
    inline void setQCPPolarAxisAngular_EventFilter_Callback(QCPPolarAxisAngular_EventFilter_Callback cb) { qcppolaraxisangular_eventfilter_callback = cb; }
    inline void setQCPPolarAxisAngular_TimerEvent_Callback(QCPPolarAxisAngular_TimerEvent_Callback cb) { qcppolaraxisangular_timerevent_callback = cb; }
    inline void setQCPPolarAxisAngular_ChildEvent_Callback(QCPPolarAxisAngular_ChildEvent_Callback cb) { qcppolaraxisangular_childevent_callback = cb; }
    inline void setQCPPolarAxisAngular_CustomEvent_Callback(QCPPolarAxisAngular_CustomEvent_Callback cb) { qcppolaraxisangular_customevent_callback = cb; }
    inline void setQCPPolarAxisAngular_ConnectNotify_Callback(QCPPolarAxisAngular_ConnectNotify_Callback cb) { qcppolaraxisangular_connectnotify_callback = cb; }
    inline void setQCPPolarAxisAngular_DisconnectNotify_Callback(QCPPolarAxisAngular_DisconnectNotify_Callback cb) { qcppolaraxisangular_disconnectnotify_callback = cb; }
    inline void setQCPPolarAxisAngular_RegisterPolarGraph_Callback(QCPPolarAxisAngular_RegisterPolarGraph_Callback cb) { qcppolaraxisangular_registerpolargraph_callback = cb; }
    inline void setQCPPolarAxisAngular_DrawBackground_Callback(QCPPolarAxisAngular_DrawBackground_Callback cb) { qcppolaraxisangular_drawbackground_callback = cb; }
    inline void setQCPPolarAxisAngular_SetupTickVectors_Callback(QCPPolarAxisAngular_SetupTickVectors_Callback cb) { qcppolaraxisangular_setuptickvectors_callback = cb; }
    inline void setQCPPolarAxisAngular_GetBasePen_Callback(QCPPolarAxisAngular_GetBasePen_Callback cb) { qcppolaraxisangular_getbasepen_callback = cb; }
    inline void setQCPPolarAxisAngular_GetTickPen_Callback(QCPPolarAxisAngular_GetTickPen_Callback cb) { qcppolaraxisangular_gettickpen_callback = cb; }
    inline void setQCPPolarAxisAngular_GetSubTickPen_Callback(QCPPolarAxisAngular_GetSubTickPen_Callback cb) { qcppolaraxisangular_getsubtickpen_callback = cb; }
    inline void setQCPPolarAxisAngular_GetTickLabelFont_Callback(QCPPolarAxisAngular_GetTickLabelFont_Callback cb) { qcppolaraxisangular_getticklabelfont_callback = cb; }
    inline void setQCPPolarAxisAngular_GetLabelFont_Callback(QCPPolarAxisAngular_GetLabelFont_Callback cb) { qcppolaraxisangular_getlabelfont_callback = cb; }
    inline void setQCPPolarAxisAngular_GetTickLabelColor_Callback(QCPPolarAxisAngular_GetTickLabelColor_Callback cb) { qcppolaraxisangular_getticklabelcolor_callback = cb; }
    inline void setQCPPolarAxisAngular_GetLabelColor_Callback(QCPPolarAxisAngular_GetLabelColor_Callback cb) { qcppolaraxisangular_getlabelcolor_callback = cb; }
    inline void setQCPPolarAxisAngular_InitializeParentPlot_Callback(QCPPolarAxisAngular_InitializeParentPlot_Callback cb) { qcppolaraxisangular_initializeparentplot_callback = cb; }
    inline void setQCPPolarAxisAngular_SetParentLayerable_Callback(QCPPolarAxisAngular_SetParentLayerable_Callback cb) { qcppolaraxisangular_setparentlayerable_callback = cb; }
    inline void setQCPPolarAxisAngular_MoveToLayer_Callback(QCPPolarAxisAngular_MoveToLayer_Callback cb) { qcppolaraxisangular_movetolayer_callback = cb; }
    inline void setQCPPolarAxisAngular_ApplyAntialiasingHint_Callback(QCPPolarAxisAngular_ApplyAntialiasingHint_Callback cb) { qcppolaraxisangular_applyantialiasinghint_callback = cb; }
    inline void setQCPPolarAxisAngular_Sender_Callback(QCPPolarAxisAngular_Sender_Callback cb) { qcppolaraxisangular_sender_callback = cb; }
    inline void setQCPPolarAxisAngular_SenderSignalIndex_Callback(QCPPolarAxisAngular_SenderSignalIndex_Callback cb) { qcppolaraxisangular_sendersignalindex_callback = cb; }
    inline void setQCPPolarAxisAngular_Receivers_Callback(QCPPolarAxisAngular_Receivers_Callback cb) { qcppolaraxisangular_receivers_callback = cb; }
    inline void setQCPPolarAxisAngular_IsSignalConnected_Callback(QCPPolarAxisAngular_IsSignalConnected_Callback cb) { qcppolaraxisangular_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPPolarAxisAngular_Metacall_IsBase(bool value) const { qcppolaraxisangular_metacall_isbase = value; }
    inline void setQCPPolarAxisAngular_SelectTest_IsBase(bool value) const { qcppolaraxisangular_selecttest_isbase = value; }
    inline void setQCPPolarAxisAngular_Update_IsBase(bool value) const { qcppolaraxisangular_update_isbase = value; }
    inline void setQCPPolarAxisAngular_Elements_IsBase(bool value) const { qcppolaraxisangular_elements_isbase = value; }
    inline void setQCPPolarAxisAngular_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcppolaraxisangular_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPPolarAxisAngular_Draw_IsBase(bool value) const { qcppolaraxisangular_draw_isbase = value; }
    inline void setQCPPolarAxisAngular_SelectionCategory_IsBase(bool value) const { qcppolaraxisangular_selectioncategory_isbase = value; }
    inline void setQCPPolarAxisAngular_MousePressEvent_IsBase(bool value) const { qcppolaraxisangular_mousepressevent_isbase = value; }
    inline void setQCPPolarAxisAngular_MouseMoveEvent_IsBase(bool value) const { qcppolaraxisangular_mousemoveevent_isbase = value; }
    inline void setQCPPolarAxisAngular_MouseReleaseEvent_IsBase(bool value) const { qcppolaraxisangular_mousereleaseevent_isbase = value; }
    inline void setQCPPolarAxisAngular_WheelEvent_IsBase(bool value) const { qcppolaraxisangular_wheelevent_isbase = value; }
    inline void setQCPPolarAxisAngular_MinimumOuterSizeHint_IsBase(bool value) const { qcppolaraxisangular_minimumoutersizehint_isbase = value; }
    inline void setQCPPolarAxisAngular_MaximumOuterSizeHint_IsBase(bool value) const { qcppolaraxisangular_maximumoutersizehint_isbase = value; }
    inline void setQCPPolarAxisAngular_CalculateAutoMargin_IsBase(bool value) const { qcppolaraxisangular_calculateautomargin_isbase = value; }
    inline void setQCPPolarAxisAngular_LayoutChanged_IsBase(bool value) const { qcppolaraxisangular_layoutchanged_isbase = value; }
    inline void setQCPPolarAxisAngular_ParentPlotInitialized_IsBase(bool value) const { qcppolaraxisangular_parentplotinitialized_isbase = value; }
    inline void setQCPPolarAxisAngular_ClipRect_IsBase(bool value) const { qcppolaraxisangular_cliprect_isbase = value; }
    inline void setQCPPolarAxisAngular_SelectEvent_IsBase(bool value) const { qcppolaraxisangular_selectevent_isbase = value; }
    inline void setQCPPolarAxisAngular_DeselectEvent_IsBase(bool value) const { qcppolaraxisangular_deselectevent_isbase = value; }
    inline void setQCPPolarAxisAngular_MouseDoubleClickEvent_IsBase(bool value) const { qcppolaraxisangular_mousedoubleclickevent_isbase = value; }
    inline void setQCPPolarAxisAngular_Event_IsBase(bool value) const { qcppolaraxisangular_event_isbase = value; }
    inline void setQCPPolarAxisAngular_EventFilter_IsBase(bool value) const { qcppolaraxisangular_eventfilter_isbase = value; }
    inline void setQCPPolarAxisAngular_TimerEvent_IsBase(bool value) const { qcppolaraxisangular_timerevent_isbase = value; }
    inline void setQCPPolarAxisAngular_ChildEvent_IsBase(bool value) const { qcppolaraxisangular_childevent_isbase = value; }
    inline void setQCPPolarAxisAngular_CustomEvent_IsBase(bool value) const { qcppolaraxisangular_customevent_isbase = value; }
    inline void setQCPPolarAxisAngular_ConnectNotify_IsBase(bool value) const { qcppolaraxisangular_connectnotify_isbase = value; }
    inline void setQCPPolarAxisAngular_DisconnectNotify_IsBase(bool value) const { qcppolaraxisangular_disconnectnotify_isbase = value; }
    inline void setQCPPolarAxisAngular_RegisterPolarGraph_IsBase(bool value) const { qcppolaraxisangular_registerpolargraph_isbase = value; }
    inline void setQCPPolarAxisAngular_DrawBackground_IsBase(bool value) const { qcppolaraxisangular_drawbackground_isbase = value; }
    inline void setQCPPolarAxisAngular_SetupTickVectors_IsBase(bool value) const { qcppolaraxisangular_setuptickvectors_isbase = value; }
    inline void setQCPPolarAxisAngular_GetBasePen_IsBase(bool value) const { qcppolaraxisangular_getbasepen_isbase = value; }
    inline void setQCPPolarAxisAngular_GetTickPen_IsBase(bool value) const { qcppolaraxisangular_gettickpen_isbase = value; }
    inline void setQCPPolarAxisAngular_GetSubTickPen_IsBase(bool value) const { qcppolaraxisangular_getsubtickpen_isbase = value; }
    inline void setQCPPolarAxisAngular_GetTickLabelFont_IsBase(bool value) const { qcppolaraxisangular_getticklabelfont_isbase = value; }
    inline void setQCPPolarAxisAngular_GetLabelFont_IsBase(bool value) const { qcppolaraxisangular_getlabelfont_isbase = value; }
    inline void setQCPPolarAxisAngular_GetTickLabelColor_IsBase(bool value) const { qcppolaraxisangular_getticklabelcolor_isbase = value; }
    inline void setQCPPolarAxisAngular_GetLabelColor_IsBase(bool value) const { qcppolaraxisangular_getlabelcolor_isbase = value; }
    inline void setQCPPolarAxisAngular_InitializeParentPlot_IsBase(bool value) const { qcppolaraxisangular_initializeparentplot_isbase = value; }
    inline void setQCPPolarAxisAngular_SetParentLayerable_IsBase(bool value) const { qcppolaraxisangular_setparentlayerable_isbase = value; }
    inline void setQCPPolarAxisAngular_MoveToLayer_IsBase(bool value) const { qcppolaraxisangular_movetolayer_isbase = value; }
    inline void setQCPPolarAxisAngular_ApplyAntialiasingHint_IsBase(bool value) const { qcppolaraxisangular_applyantialiasinghint_isbase = value; }
    inline void setQCPPolarAxisAngular_Sender_IsBase(bool value) const { qcppolaraxisangular_sender_isbase = value; }
    inline void setQCPPolarAxisAngular_SenderSignalIndex_IsBase(bool value) const { qcppolaraxisangular_sendersignalindex_isbase = value; }
    inline void setQCPPolarAxisAngular_Receivers_IsBase(bool value) const { qcppolaraxisangular_receivers_isbase = value; }
    inline void setQCPPolarAxisAngular_IsSignalConnected_IsBase(bool value) const { qcppolaraxisangular_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcppolaraxisangular_metacall_isbase) {
            qcppolaraxisangular_metacall_isbase = false;
            return QCPPolarAxisAngular::qt_metacall(param1, param2, param3);
        } else if (qcppolaraxisangular_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcppolaraxisangular_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPPolarAxisAngular::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcppolaraxisangular_selecttest_isbase) {
            qcppolaraxisangular_selecttest_isbase = false;
            return QCPPolarAxisAngular::selectTest(pos, onlySelectable, details);
        } else if (qcppolaraxisangular_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcppolaraxisangular_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPPolarAxisAngular::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void update(QCPLayoutElement::UpdatePhase phase) override {
        if (qcppolaraxisangular_update_isbase) {
            qcppolaraxisangular_update_isbase = false;
            QCPPolarAxisAngular::update(phase);
        } else if (qcppolaraxisangular_update_callback != nullptr) {
            int cbval1 = static_cast<int>(phase);

            qcppolaraxisangular_update_callback(this, cbval1);
        } else {
            QCPPolarAxisAngular::update(phase);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QList<QCPLayoutElement*> elements(bool recursive) const override {
        if (qcppolaraxisangular_elements_isbase) {
            qcppolaraxisangular_elements_isbase = false;
            return QCPPolarAxisAngular::elements(recursive);
        } else if (qcppolaraxisangular_elements_callback != nullptr) {
            bool cbval1 = recursive;

            QCPLayoutElement** callback_ret = qcppolaraxisangular_elements_callback(this, cbval1);
            QList<QCPLayoutElement*> callback_ret_QList;
            // Iterate until null pointer sentinel
            for (QCPLayoutElement** ptridx = callback_ret; *ptridx != nullptr; ptridx++) {
                callback_ret_QList.push_back(*ptridx);
            }
            free(callback_ret);
            return callback_ret_QList;
        } else {
            return QCPPolarAxisAngular::elements(recursive);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcppolaraxisangular_applydefaultantialiasinghint_isbase) {
            qcppolaraxisangular_applydefaultantialiasinghint_isbase = false;
            QCPPolarAxisAngular::applyDefaultAntialiasingHint(painter);
        } else if (qcppolaraxisangular_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcppolaraxisangular_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPPolarAxisAngular::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcppolaraxisangular_draw_isbase) {
            qcppolaraxisangular_draw_isbase = false;
            QCPPolarAxisAngular::draw(painter);
        } else if (qcppolaraxisangular_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcppolaraxisangular_draw_callback(this, cbval1);
        } else {
            QCPPolarAxisAngular::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcppolaraxisangular_selectioncategory_isbase) {
            qcppolaraxisangular_selectioncategory_isbase = false;
            return QCPPolarAxisAngular::selectionCategory();
        } else if (qcppolaraxisangular_selectioncategory_callback != nullptr) {
            int callback_ret = qcppolaraxisangular_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPPolarAxisAngular::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcppolaraxisangular_mousepressevent_isbase) {
            qcppolaraxisangular_mousepressevent_isbase = false;
            QCPPolarAxisAngular::mousePressEvent(event, details);
        } else if (qcppolaraxisangular_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcppolaraxisangular_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPPolarAxisAngular::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcppolaraxisangular_mousemoveevent_isbase) {
            qcppolaraxisangular_mousemoveevent_isbase = false;
            QCPPolarAxisAngular::mouseMoveEvent(event, startPos);
        } else if (qcppolaraxisangular_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcppolaraxisangular_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPPolarAxisAngular::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcppolaraxisangular_mousereleaseevent_isbase) {
            qcppolaraxisangular_mousereleaseevent_isbase = false;
            QCPPolarAxisAngular::mouseReleaseEvent(event, startPos);
        } else if (qcppolaraxisangular_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcppolaraxisangular_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPPolarAxisAngular::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcppolaraxisangular_wheelevent_isbase) {
            qcppolaraxisangular_wheelevent_isbase = false;
            QCPPolarAxisAngular::wheelEvent(event);
        } else if (qcppolaraxisangular_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcppolaraxisangular_wheelevent_callback(this, cbval1);
        } else {
            QCPPolarAxisAngular::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize minimumOuterSizeHint() const override {
        if (qcppolaraxisangular_minimumoutersizehint_isbase) {
            qcppolaraxisangular_minimumoutersizehint_isbase = false;
            return QCPPolarAxisAngular::minimumOuterSizeHint();
        } else if (qcppolaraxisangular_minimumoutersizehint_callback != nullptr) {
            QSize* callback_ret = qcppolaraxisangular_minimumoutersizehint_callback();
            return *callback_ret;
        } else {
            return QCPPolarAxisAngular::minimumOuterSizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize maximumOuterSizeHint() const override {
        if (qcppolaraxisangular_maximumoutersizehint_isbase) {
            qcppolaraxisangular_maximumoutersizehint_isbase = false;
            return QCPPolarAxisAngular::maximumOuterSizeHint();
        } else if (qcppolaraxisangular_maximumoutersizehint_callback != nullptr) {
            QSize* callback_ret = qcppolaraxisangular_maximumoutersizehint_callback();
            return *callback_ret;
        } else {
            return QCPPolarAxisAngular::maximumOuterSizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int calculateAutoMargin(QCP::MarginSide side) override {
        if (qcppolaraxisangular_calculateautomargin_isbase) {
            qcppolaraxisangular_calculateautomargin_isbase = false;
            return QCPPolarAxisAngular::calculateAutoMargin(side);
        } else if (qcppolaraxisangular_calculateautomargin_callback != nullptr) {
            int cbval1 = static_cast<int>(side);

            int callback_ret = qcppolaraxisangular_calculateautomargin_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPPolarAxisAngular::calculateAutoMargin(side);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void layoutChanged() override {
        if (qcppolaraxisangular_layoutchanged_isbase) {
            qcppolaraxisangular_layoutchanged_isbase = false;
            QCPPolarAxisAngular::layoutChanged();
        } else if (qcppolaraxisangular_layoutchanged_callback != nullptr) {
            qcppolaraxisangular_layoutchanged_callback();
        } else {
            QCPPolarAxisAngular::layoutChanged();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcppolaraxisangular_parentplotinitialized_isbase) {
            qcppolaraxisangular_parentplotinitialized_isbase = false;
            QCPPolarAxisAngular::parentPlotInitialized(parentPlot);
        } else if (qcppolaraxisangular_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcppolaraxisangular_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPPolarAxisAngular::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcppolaraxisangular_cliprect_isbase) {
            qcppolaraxisangular_cliprect_isbase = false;
            return QCPPolarAxisAngular::clipRect();
        } else if (qcppolaraxisangular_cliprect_callback != nullptr) {
            QRect* callback_ret = qcppolaraxisangular_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPPolarAxisAngular::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcppolaraxisangular_selectevent_isbase) {
            qcppolaraxisangular_selectevent_isbase = false;
            QCPPolarAxisAngular::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcppolaraxisangular_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcppolaraxisangular_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPPolarAxisAngular::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcppolaraxisangular_deselectevent_isbase) {
            qcppolaraxisangular_deselectevent_isbase = false;
            QCPPolarAxisAngular::deselectEvent(selectionStateChanged);
        } else if (qcppolaraxisangular_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcppolaraxisangular_deselectevent_callback(this, cbval1);
        } else {
            QCPPolarAxisAngular::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcppolaraxisangular_mousedoubleclickevent_isbase) {
            qcppolaraxisangular_mousedoubleclickevent_isbase = false;
            QCPPolarAxisAngular::mouseDoubleClickEvent(event, details);
        } else if (qcppolaraxisangular_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcppolaraxisangular_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPPolarAxisAngular::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcppolaraxisangular_event_isbase) {
            qcppolaraxisangular_event_isbase = false;
            return QCPPolarAxisAngular::event(event);
        } else if (qcppolaraxisangular_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcppolaraxisangular_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPPolarAxisAngular::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcppolaraxisangular_eventfilter_isbase) {
            qcppolaraxisangular_eventfilter_isbase = false;
            return QCPPolarAxisAngular::eventFilter(watched, event);
        } else if (qcppolaraxisangular_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcppolaraxisangular_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPPolarAxisAngular::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcppolaraxisangular_timerevent_isbase) {
            qcppolaraxisangular_timerevent_isbase = false;
            QCPPolarAxisAngular::timerEvent(event);
        } else if (qcppolaraxisangular_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcppolaraxisangular_timerevent_callback(this, cbval1);
        } else {
            QCPPolarAxisAngular::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcppolaraxisangular_childevent_isbase) {
            qcppolaraxisangular_childevent_isbase = false;
            QCPPolarAxisAngular::childEvent(event);
        } else if (qcppolaraxisangular_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcppolaraxisangular_childevent_callback(this, cbval1);
        } else {
            QCPPolarAxisAngular::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcppolaraxisangular_customevent_isbase) {
            qcppolaraxisangular_customevent_isbase = false;
            QCPPolarAxisAngular::customEvent(event);
        } else if (qcppolaraxisangular_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcppolaraxisangular_customevent_callback(this, cbval1);
        } else {
            QCPPolarAxisAngular::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcppolaraxisangular_connectnotify_isbase) {
            qcppolaraxisangular_connectnotify_isbase = false;
            QCPPolarAxisAngular::connectNotify(signal);
        } else if (qcppolaraxisangular_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcppolaraxisangular_connectnotify_callback(this, cbval1);
        } else {
            QCPPolarAxisAngular::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcppolaraxisangular_disconnectnotify_isbase) {
            qcppolaraxisangular_disconnectnotify_isbase = false;
            QCPPolarAxisAngular::disconnectNotify(signal);
        } else if (qcppolaraxisangular_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcppolaraxisangular_disconnectnotify_callback(this, cbval1);
        } else {
            QCPPolarAxisAngular::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool registerPolarGraph(QCPPolarGraph* graph) {
        if (qcppolaraxisangular_registerpolargraph_isbase) {
            qcppolaraxisangular_registerpolargraph_isbase = false;
            return QCPPolarAxisAngular::registerPolarGraph(graph);
        } else if (qcppolaraxisangular_registerpolargraph_callback != nullptr) {
            QCPPolarGraph* cbval1 = graph;

            bool callback_ret = qcppolaraxisangular_registerpolargraph_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPPolarAxisAngular::registerPolarGraph(graph);
        }
    }

    // Virtual method for C ABI access and custom callback
    void drawBackground(QCPPainter* painter, const QPointF& center, double radius) {
        if (qcppolaraxisangular_drawbackground_isbase) {
            qcppolaraxisangular_drawbackground_isbase = false;
            QCPPolarAxisAngular::drawBackground(painter, center, radius);
        } else if (qcppolaraxisangular_drawbackground_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            const QPointF& center_ret = center;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&center_ret);
            double cbval3 = radius;

            qcppolaraxisangular_drawbackground_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPPolarAxisAngular::drawBackground(painter, center, radius);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setupTickVectors() {
        if (qcppolaraxisangular_setuptickvectors_isbase) {
            qcppolaraxisangular_setuptickvectors_isbase = false;
            QCPPolarAxisAngular::setupTickVectors();
        } else if (qcppolaraxisangular_setuptickvectors_callback != nullptr) {
            qcppolaraxisangular_setuptickvectors_callback();
        } else {
            QCPPolarAxisAngular::setupTickVectors();
        }
    }

    // Virtual method for C ABI access and custom callback
    QPen getBasePen() const {
        if (qcppolaraxisangular_getbasepen_isbase) {
            qcppolaraxisangular_getbasepen_isbase = false;
            return QCPPolarAxisAngular::getBasePen();
        } else if (qcppolaraxisangular_getbasepen_callback != nullptr) {
            QPen* callback_ret = qcppolaraxisangular_getbasepen_callback();
            return *callback_ret;
        } else {
            return QCPPolarAxisAngular::getBasePen();
        }
    }

    // Virtual method for C ABI access and custom callback
    QPen getTickPen() const {
        if (qcppolaraxisangular_gettickpen_isbase) {
            qcppolaraxisangular_gettickpen_isbase = false;
            return QCPPolarAxisAngular::getTickPen();
        } else if (qcppolaraxisangular_gettickpen_callback != nullptr) {
            QPen* callback_ret = qcppolaraxisangular_gettickpen_callback();
            return *callback_ret;
        } else {
            return QCPPolarAxisAngular::getTickPen();
        }
    }

    // Virtual method for C ABI access and custom callback
    QPen getSubTickPen() const {
        if (qcppolaraxisangular_getsubtickpen_isbase) {
            qcppolaraxisangular_getsubtickpen_isbase = false;
            return QCPPolarAxisAngular::getSubTickPen();
        } else if (qcppolaraxisangular_getsubtickpen_callback != nullptr) {
            QPen* callback_ret = qcppolaraxisangular_getsubtickpen_callback();
            return *callback_ret;
        } else {
            return QCPPolarAxisAngular::getSubTickPen();
        }
    }

    // Virtual method for C ABI access and custom callback
    QFont getTickLabelFont() const {
        if (qcppolaraxisangular_getticklabelfont_isbase) {
            qcppolaraxisangular_getticklabelfont_isbase = false;
            return QCPPolarAxisAngular::getTickLabelFont();
        } else if (qcppolaraxisangular_getticklabelfont_callback != nullptr) {
            QFont* callback_ret = qcppolaraxisangular_getticklabelfont_callback();
            return *callback_ret;
        } else {
            return QCPPolarAxisAngular::getTickLabelFont();
        }
    }

    // Virtual method for C ABI access and custom callback
    QFont getLabelFont() const {
        if (qcppolaraxisangular_getlabelfont_isbase) {
            qcppolaraxisangular_getlabelfont_isbase = false;
            return QCPPolarAxisAngular::getLabelFont();
        } else if (qcppolaraxisangular_getlabelfont_callback != nullptr) {
            QFont* callback_ret = qcppolaraxisangular_getlabelfont_callback();
            return *callback_ret;
        } else {
            return QCPPolarAxisAngular::getLabelFont();
        }
    }

    // Virtual method for C ABI access and custom callback
    QColor getTickLabelColor() const {
        if (qcppolaraxisangular_getticklabelcolor_isbase) {
            qcppolaraxisangular_getticklabelcolor_isbase = false;
            return QCPPolarAxisAngular::getTickLabelColor();
        } else if (qcppolaraxisangular_getticklabelcolor_callback != nullptr) {
            QColor* callback_ret = qcppolaraxisangular_getticklabelcolor_callback();
            return *callback_ret;
        } else {
            return QCPPolarAxisAngular::getTickLabelColor();
        }
    }

    // Virtual method for C ABI access and custom callback
    QColor getLabelColor() const {
        if (qcppolaraxisangular_getlabelcolor_isbase) {
            qcppolaraxisangular_getlabelcolor_isbase = false;
            return QCPPolarAxisAngular::getLabelColor();
        } else if (qcppolaraxisangular_getlabelcolor_callback != nullptr) {
            QColor* callback_ret = qcppolaraxisangular_getlabelcolor_callback();
            return *callback_ret;
        } else {
            return QCPPolarAxisAngular::getLabelColor();
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcppolaraxisangular_initializeparentplot_isbase) {
            qcppolaraxisangular_initializeparentplot_isbase = false;
            QCPPolarAxisAngular::initializeParentPlot(parentPlot);
        } else if (qcppolaraxisangular_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcppolaraxisangular_initializeparentplot_callback(this, cbval1);
        } else {
            QCPPolarAxisAngular::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcppolaraxisangular_setparentlayerable_isbase) {
            qcppolaraxisangular_setparentlayerable_isbase = false;
            QCPPolarAxisAngular::setParentLayerable(parentLayerable);
        } else if (qcppolaraxisangular_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcppolaraxisangular_setparentlayerable_callback(this, cbval1);
        } else {
            QCPPolarAxisAngular::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcppolaraxisangular_movetolayer_isbase) {
            qcppolaraxisangular_movetolayer_isbase = false;
            return QCPPolarAxisAngular::moveToLayer(layer, prepend);
        } else if (qcppolaraxisangular_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcppolaraxisangular_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPPolarAxisAngular::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcppolaraxisangular_applyantialiasinghint_isbase) {
            qcppolaraxisangular_applyantialiasinghint_isbase = false;
            QCPPolarAxisAngular::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcppolaraxisangular_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcppolaraxisangular_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPPolarAxisAngular::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcppolaraxisangular_sender_isbase) {
            qcppolaraxisangular_sender_isbase = false;
            return QCPPolarAxisAngular::sender();
        } else if (qcppolaraxisangular_sender_callback != nullptr) {
            QObject* callback_ret = qcppolaraxisangular_sender_callback();
            return callback_ret;
        } else {
            return QCPPolarAxisAngular::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcppolaraxisangular_sendersignalindex_isbase) {
            qcppolaraxisangular_sendersignalindex_isbase = false;
            return QCPPolarAxisAngular::senderSignalIndex();
        } else if (qcppolaraxisangular_sendersignalindex_callback != nullptr) {
            int callback_ret = qcppolaraxisangular_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPPolarAxisAngular::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcppolaraxisangular_receivers_isbase) {
            qcppolaraxisangular_receivers_isbase = false;
            return QCPPolarAxisAngular::receivers(signal);
        } else if (qcppolaraxisangular_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcppolaraxisangular_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPPolarAxisAngular::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcppolaraxisangular_issignalconnected_isbase) {
            qcppolaraxisangular_issignalconnected_isbase = false;
            return QCPPolarAxisAngular::isSignalConnected(signal);
        } else if (qcppolaraxisangular_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcppolaraxisangular_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPPolarAxisAngular::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPPolarAxisAngular_ApplyDefaultAntialiasingHint(const QCPPolarAxisAngular* self, QCPPainter* painter);
    friend void QCPPolarAxisAngular_QBaseApplyDefaultAntialiasingHint(const QCPPolarAxisAngular* self, QCPPainter* painter);
    friend void QCPPolarAxisAngular_Draw(QCPPolarAxisAngular* self, QCPPainter* painter);
    friend void QCPPolarAxisAngular_QBaseDraw(QCPPolarAxisAngular* self, QCPPainter* painter);
    friend int QCPPolarAxisAngular_SelectionCategory(const QCPPolarAxisAngular* self);
    friend int QCPPolarAxisAngular_QBaseSelectionCategory(const QCPPolarAxisAngular* self);
    friend void QCPPolarAxisAngular_MousePressEvent(QCPPolarAxisAngular* self, QMouseEvent* event, const QVariant* details);
    friend void QCPPolarAxisAngular_QBaseMousePressEvent(QCPPolarAxisAngular* self, QMouseEvent* event, const QVariant* details);
    friend void QCPPolarAxisAngular_MouseMoveEvent(QCPPolarAxisAngular* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPPolarAxisAngular_QBaseMouseMoveEvent(QCPPolarAxisAngular* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPPolarAxisAngular_MouseReleaseEvent(QCPPolarAxisAngular* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPPolarAxisAngular_QBaseMouseReleaseEvent(QCPPolarAxisAngular* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPPolarAxisAngular_WheelEvent(QCPPolarAxisAngular* self, QWheelEvent* event);
    friend void QCPPolarAxisAngular_QBaseWheelEvent(QCPPolarAxisAngular* self, QWheelEvent* event);
    friend int QCPPolarAxisAngular_CalculateAutoMargin(QCPPolarAxisAngular* self, int side);
    friend int QCPPolarAxisAngular_QBaseCalculateAutoMargin(QCPPolarAxisAngular* self, int side);
    friend void QCPPolarAxisAngular_LayoutChanged(QCPPolarAxisAngular* self);
    friend void QCPPolarAxisAngular_QBaseLayoutChanged(QCPPolarAxisAngular* self);
    friend void QCPPolarAxisAngular_ParentPlotInitialized(QCPPolarAxisAngular* self, QCustomPlot* parentPlot);
    friend void QCPPolarAxisAngular_QBaseParentPlotInitialized(QCPPolarAxisAngular* self, QCustomPlot* parentPlot);
    friend QRect* QCPPolarAxisAngular_ClipRect(const QCPPolarAxisAngular* self);
    friend QRect* QCPPolarAxisAngular_QBaseClipRect(const QCPPolarAxisAngular* self);
    friend void QCPPolarAxisAngular_SelectEvent(QCPPolarAxisAngular* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPPolarAxisAngular_QBaseSelectEvent(QCPPolarAxisAngular* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPPolarAxisAngular_DeselectEvent(QCPPolarAxisAngular* self, bool* selectionStateChanged);
    friend void QCPPolarAxisAngular_QBaseDeselectEvent(QCPPolarAxisAngular* self, bool* selectionStateChanged);
    friend void QCPPolarAxisAngular_MouseDoubleClickEvent(QCPPolarAxisAngular* self, QMouseEvent* event, const QVariant* details);
    friend void QCPPolarAxisAngular_QBaseMouseDoubleClickEvent(QCPPolarAxisAngular* self, QMouseEvent* event, const QVariant* details);
    friend void QCPPolarAxisAngular_TimerEvent(QCPPolarAxisAngular* self, QTimerEvent* event);
    friend void QCPPolarAxisAngular_QBaseTimerEvent(QCPPolarAxisAngular* self, QTimerEvent* event);
    friend void QCPPolarAxisAngular_ChildEvent(QCPPolarAxisAngular* self, QChildEvent* event);
    friend void QCPPolarAxisAngular_QBaseChildEvent(QCPPolarAxisAngular* self, QChildEvent* event);
    friend void QCPPolarAxisAngular_CustomEvent(QCPPolarAxisAngular* self, QEvent* event);
    friend void QCPPolarAxisAngular_QBaseCustomEvent(QCPPolarAxisAngular* self, QEvent* event);
    friend void QCPPolarAxisAngular_ConnectNotify(QCPPolarAxisAngular* self, const QMetaMethod* signal);
    friend void QCPPolarAxisAngular_QBaseConnectNotify(QCPPolarAxisAngular* self, const QMetaMethod* signal);
    friend void QCPPolarAxisAngular_DisconnectNotify(QCPPolarAxisAngular* self, const QMetaMethod* signal);
    friend void QCPPolarAxisAngular_QBaseDisconnectNotify(QCPPolarAxisAngular* self, const QMetaMethod* signal);
    friend bool QCPPolarAxisAngular_RegisterPolarGraph(QCPPolarAxisAngular* self, QCPPolarGraph* graph);
    friend bool QCPPolarAxisAngular_QBaseRegisterPolarGraph(QCPPolarAxisAngular* self, QCPPolarGraph* graph);
    friend void QCPPolarAxisAngular_DrawBackground(QCPPolarAxisAngular* self, QCPPainter* painter, const QPointF* center, double radius);
    friend void QCPPolarAxisAngular_QBaseDrawBackground(QCPPolarAxisAngular* self, QCPPainter* painter, const QPointF* center, double radius);
    friend void QCPPolarAxisAngular_SetupTickVectors(QCPPolarAxisAngular* self);
    friend void QCPPolarAxisAngular_QBaseSetupTickVectors(QCPPolarAxisAngular* self);
    friend QPen* QCPPolarAxisAngular_GetBasePen(const QCPPolarAxisAngular* self);
    friend QPen* QCPPolarAxisAngular_QBaseGetBasePen(const QCPPolarAxisAngular* self);
    friend QPen* QCPPolarAxisAngular_GetTickPen(const QCPPolarAxisAngular* self);
    friend QPen* QCPPolarAxisAngular_QBaseGetTickPen(const QCPPolarAxisAngular* self);
    friend QPen* QCPPolarAxisAngular_GetSubTickPen(const QCPPolarAxisAngular* self);
    friend QPen* QCPPolarAxisAngular_QBaseGetSubTickPen(const QCPPolarAxisAngular* self);
    friend QFont* QCPPolarAxisAngular_GetTickLabelFont(const QCPPolarAxisAngular* self);
    friend QFont* QCPPolarAxisAngular_QBaseGetTickLabelFont(const QCPPolarAxisAngular* self);
    friend QFont* QCPPolarAxisAngular_GetLabelFont(const QCPPolarAxisAngular* self);
    friend QFont* QCPPolarAxisAngular_QBaseGetLabelFont(const QCPPolarAxisAngular* self);
    friend QColor* QCPPolarAxisAngular_GetTickLabelColor(const QCPPolarAxisAngular* self);
    friend QColor* QCPPolarAxisAngular_QBaseGetTickLabelColor(const QCPPolarAxisAngular* self);
    friend QColor* QCPPolarAxisAngular_GetLabelColor(const QCPPolarAxisAngular* self);
    friend QColor* QCPPolarAxisAngular_QBaseGetLabelColor(const QCPPolarAxisAngular* self);
    friend void QCPPolarAxisAngular_InitializeParentPlot(QCPPolarAxisAngular* self, QCustomPlot* parentPlot);
    friend void QCPPolarAxisAngular_QBaseInitializeParentPlot(QCPPolarAxisAngular* self, QCustomPlot* parentPlot);
    friend void QCPPolarAxisAngular_SetParentLayerable(QCPPolarAxisAngular* self, QCPLayerable* parentLayerable);
    friend void QCPPolarAxisAngular_QBaseSetParentLayerable(QCPPolarAxisAngular* self, QCPLayerable* parentLayerable);
    friend bool QCPPolarAxisAngular_MoveToLayer(QCPPolarAxisAngular* self, QCPLayer* layer, bool prepend);
    friend bool QCPPolarAxisAngular_QBaseMoveToLayer(QCPPolarAxisAngular* self, QCPLayer* layer, bool prepend);
    friend void QCPPolarAxisAngular_ApplyAntialiasingHint(const QCPPolarAxisAngular* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPPolarAxisAngular_QBaseApplyAntialiasingHint(const QCPPolarAxisAngular* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPPolarAxisAngular_Sender(const QCPPolarAxisAngular* self);
    friend QObject* QCPPolarAxisAngular_QBaseSender(const QCPPolarAxisAngular* self);
    friend int QCPPolarAxisAngular_SenderSignalIndex(const QCPPolarAxisAngular* self);
    friend int QCPPolarAxisAngular_QBaseSenderSignalIndex(const QCPPolarAxisAngular* self);
    friend int QCPPolarAxisAngular_Receivers(const QCPPolarAxisAngular* self, const char* signal);
    friend int QCPPolarAxisAngular_QBaseReceivers(const QCPPolarAxisAngular* self, const char* signal);
    friend bool QCPPolarAxisAngular_IsSignalConnected(const QCPPolarAxisAngular* self, const QMetaMethod* signal);
    friend bool QCPPolarAxisAngular_QBaseIsSignalConnected(const QCPPolarAxisAngular* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPPolarGrid so that we can call protected methods
class VirtualQCPPolarGrid final : public QCPPolarGrid {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPPolarGrid = true;

    // Virtual class public types (including callbacks)
    using QCPPolarGrid_Metacall_Callback = int (*)(QCPPolarGrid*, int, int, void**);
    using QCPPolarGrid_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPPolarGrid*, QCPPainter*);
    using QCPPolarGrid_Draw_Callback = void (*)(QCPPolarGrid*, QCPPainter*);
    using QCPPolarGrid_SelectTest_Callback = double (*)(const QCPPolarGrid*, QPointF*, bool, QVariant*);
    using QCPPolarGrid_ParentPlotInitialized_Callback = void (*)(QCPPolarGrid*, QCustomPlot*);
    using QCPPolarGrid_SelectionCategory_Callback = int (*)();
    using QCPPolarGrid_ClipRect_Callback = QRect* (*)();
    using QCPPolarGrid_SelectEvent_Callback = void (*)(QCPPolarGrid*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPPolarGrid_DeselectEvent_Callback = void (*)(QCPPolarGrid*, bool*);
    using QCPPolarGrid_MousePressEvent_Callback = void (*)(QCPPolarGrid*, QMouseEvent*, QVariant*);
    using QCPPolarGrid_MouseMoveEvent_Callback = void (*)(QCPPolarGrid*, QMouseEvent*, QPointF*);
    using QCPPolarGrid_MouseReleaseEvent_Callback = void (*)(QCPPolarGrid*, QMouseEvent*, QPointF*);
    using QCPPolarGrid_MouseDoubleClickEvent_Callback = void (*)(QCPPolarGrid*, QMouseEvent*, QVariant*);
    using QCPPolarGrid_WheelEvent_Callback = void (*)(QCPPolarGrid*, QWheelEvent*);
    using QCPPolarGrid_Event_Callback = bool (*)(QCPPolarGrid*, QEvent*);
    using QCPPolarGrid_EventFilter_Callback = bool (*)(QCPPolarGrid*, QObject*, QEvent*);
    using QCPPolarGrid_TimerEvent_Callback = void (*)(QCPPolarGrid*, QTimerEvent*);
    using QCPPolarGrid_ChildEvent_Callback = void (*)(QCPPolarGrid*, QChildEvent*);
    using QCPPolarGrid_CustomEvent_Callback = void (*)(QCPPolarGrid*, QEvent*);
    using QCPPolarGrid_ConnectNotify_Callback = void (*)(QCPPolarGrid*, QMetaMethod*);
    using QCPPolarGrid_DisconnectNotify_Callback = void (*)(QCPPolarGrid*, QMetaMethod*);
    using QCPPolarGrid_DrawRadialGrid_Callback = void (*)(QCPPolarGrid*, QCPPainter*, QPointF*, libqt_list /* of double */, QPen*);
    using QCPPolarGrid_DrawAngularGrid_Callback = void (*)(QCPPolarGrid*, QCPPainter*, QPointF*, double, libqt_list /* of QPointF* */, QPen*);
    using QCPPolarGrid_DrawRadialGrid5_Callback = void (*)(QCPPolarGrid*, QCPPainter*, QPointF*, libqt_list /* of double */, QPen*, QPen*);
    using QCPPolarGrid_InitializeParentPlot_Callback = void (*)(QCPPolarGrid*, QCustomPlot*);
    using QCPPolarGrid_SetParentLayerable_Callback = void (*)(QCPPolarGrid*, QCPLayerable*);
    using QCPPolarGrid_MoveToLayer_Callback = bool (*)(QCPPolarGrid*, QCPLayer*, bool);
    using QCPPolarGrid_ApplyAntialiasingHint_Callback = void (*)(const QCPPolarGrid*, QCPPainter*, bool, int);
    using QCPPolarGrid_Sender_Callback = QObject* (*)();
    using QCPPolarGrid_SenderSignalIndex_Callback = int (*)();
    using QCPPolarGrid_Receivers_Callback = int (*)(const QCPPolarGrid*, const char*);
    using QCPPolarGrid_IsSignalConnected_Callback = bool (*)(const QCPPolarGrid*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPPolarGrid_Metacall_Callback qcppolargrid_metacall_callback = nullptr;
    QCPPolarGrid_ApplyDefaultAntialiasingHint_Callback qcppolargrid_applydefaultantialiasinghint_callback = nullptr;
    QCPPolarGrid_Draw_Callback qcppolargrid_draw_callback = nullptr;
    QCPPolarGrid_SelectTest_Callback qcppolargrid_selecttest_callback = nullptr;
    QCPPolarGrid_ParentPlotInitialized_Callback qcppolargrid_parentplotinitialized_callback = nullptr;
    QCPPolarGrid_SelectionCategory_Callback qcppolargrid_selectioncategory_callback = nullptr;
    QCPPolarGrid_ClipRect_Callback qcppolargrid_cliprect_callback = nullptr;
    QCPPolarGrid_SelectEvent_Callback qcppolargrid_selectevent_callback = nullptr;
    QCPPolarGrid_DeselectEvent_Callback qcppolargrid_deselectevent_callback = nullptr;
    QCPPolarGrid_MousePressEvent_Callback qcppolargrid_mousepressevent_callback = nullptr;
    QCPPolarGrid_MouseMoveEvent_Callback qcppolargrid_mousemoveevent_callback = nullptr;
    QCPPolarGrid_MouseReleaseEvent_Callback qcppolargrid_mousereleaseevent_callback = nullptr;
    QCPPolarGrid_MouseDoubleClickEvent_Callback qcppolargrid_mousedoubleclickevent_callback = nullptr;
    QCPPolarGrid_WheelEvent_Callback qcppolargrid_wheelevent_callback = nullptr;
    QCPPolarGrid_Event_Callback qcppolargrid_event_callback = nullptr;
    QCPPolarGrid_EventFilter_Callback qcppolargrid_eventfilter_callback = nullptr;
    QCPPolarGrid_TimerEvent_Callback qcppolargrid_timerevent_callback = nullptr;
    QCPPolarGrid_ChildEvent_Callback qcppolargrid_childevent_callback = nullptr;
    QCPPolarGrid_CustomEvent_Callback qcppolargrid_customevent_callback = nullptr;
    QCPPolarGrid_ConnectNotify_Callback qcppolargrid_connectnotify_callback = nullptr;
    QCPPolarGrid_DisconnectNotify_Callback qcppolargrid_disconnectnotify_callback = nullptr;
    QCPPolarGrid_DrawRadialGrid_Callback qcppolargrid_drawradialgrid_callback = nullptr;
    QCPPolarGrid_DrawAngularGrid_Callback qcppolargrid_drawangulargrid_callback = nullptr;
    QCPPolarGrid_DrawRadialGrid5_Callback qcppolargrid_drawradialgrid5_callback = nullptr;
    QCPPolarGrid_InitializeParentPlot_Callback qcppolargrid_initializeparentplot_callback = nullptr;
    QCPPolarGrid_SetParentLayerable_Callback qcppolargrid_setparentlayerable_callback = nullptr;
    QCPPolarGrid_MoveToLayer_Callback qcppolargrid_movetolayer_callback = nullptr;
    QCPPolarGrid_ApplyAntialiasingHint_Callback qcppolargrid_applyantialiasinghint_callback = nullptr;
    QCPPolarGrid_Sender_Callback qcppolargrid_sender_callback = nullptr;
    QCPPolarGrid_SenderSignalIndex_Callback qcppolargrid_sendersignalindex_callback = nullptr;
    QCPPolarGrid_Receivers_Callback qcppolargrid_receivers_callback = nullptr;
    QCPPolarGrid_IsSignalConnected_Callback qcppolargrid_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcppolargrid_metacall_isbase = false;
    mutable bool qcppolargrid_applydefaultantialiasinghint_isbase = false;
    mutable bool qcppolargrid_draw_isbase = false;
    mutable bool qcppolargrid_selecttest_isbase = false;
    mutable bool qcppolargrid_parentplotinitialized_isbase = false;
    mutable bool qcppolargrid_selectioncategory_isbase = false;
    mutable bool qcppolargrid_cliprect_isbase = false;
    mutable bool qcppolargrid_selectevent_isbase = false;
    mutable bool qcppolargrid_deselectevent_isbase = false;
    mutable bool qcppolargrid_mousepressevent_isbase = false;
    mutable bool qcppolargrid_mousemoveevent_isbase = false;
    mutable bool qcppolargrid_mousereleaseevent_isbase = false;
    mutable bool qcppolargrid_mousedoubleclickevent_isbase = false;
    mutable bool qcppolargrid_wheelevent_isbase = false;
    mutable bool qcppolargrid_event_isbase = false;
    mutable bool qcppolargrid_eventfilter_isbase = false;
    mutable bool qcppolargrid_timerevent_isbase = false;
    mutable bool qcppolargrid_childevent_isbase = false;
    mutable bool qcppolargrid_customevent_isbase = false;
    mutable bool qcppolargrid_connectnotify_isbase = false;
    mutable bool qcppolargrid_disconnectnotify_isbase = false;
    mutable bool qcppolargrid_drawradialgrid_isbase = false;
    mutable bool qcppolargrid_drawangulargrid_isbase = false;
    mutable bool qcppolargrid_drawradialgrid5_isbase = false;
    mutable bool qcppolargrid_initializeparentplot_isbase = false;
    mutable bool qcppolargrid_setparentlayerable_isbase = false;
    mutable bool qcppolargrid_movetolayer_isbase = false;
    mutable bool qcppolargrid_applyantialiasinghint_isbase = false;
    mutable bool qcppolargrid_sender_isbase = false;
    mutable bool qcppolargrid_sendersignalindex_isbase = false;
    mutable bool qcppolargrid_receivers_isbase = false;
    mutable bool qcppolargrid_issignalconnected_isbase = false;

  public:
    VirtualQCPPolarGrid(QCPPolarAxisAngular* parentAxis) : QCPPolarGrid(parentAxis) {};

    ~VirtualQCPPolarGrid() {
        qcppolargrid_metacall_callback = nullptr;
        qcppolargrid_applydefaultantialiasinghint_callback = nullptr;
        qcppolargrid_draw_callback = nullptr;
        qcppolargrid_selecttest_callback = nullptr;
        qcppolargrid_parentplotinitialized_callback = nullptr;
        qcppolargrid_selectioncategory_callback = nullptr;
        qcppolargrid_cliprect_callback = nullptr;
        qcppolargrid_selectevent_callback = nullptr;
        qcppolargrid_deselectevent_callback = nullptr;
        qcppolargrid_mousepressevent_callback = nullptr;
        qcppolargrid_mousemoveevent_callback = nullptr;
        qcppolargrid_mousereleaseevent_callback = nullptr;
        qcppolargrid_mousedoubleclickevent_callback = nullptr;
        qcppolargrid_wheelevent_callback = nullptr;
        qcppolargrid_event_callback = nullptr;
        qcppolargrid_eventfilter_callback = nullptr;
        qcppolargrid_timerevent_callback = nullptr;
        qcppolargrid_childevent_callback = nullptr;
        qcppolargrid_customevent_callback = nullptr;
        qcppolargrid_connectnotify_callback = nullptr;
        qcppolargrid_disconnectnotify_callback = nullptr;
        qcppolargrid_drawradialgrid_callback = nullptr;
        qcppolargrid_drawangulargrid_callback = nullptr;
        qcppolargrid_drawradialgrid5_callback = nullptr;
        qcppolargrid_initializeparentplot_callback = nullptr;
        qcppolargrid_setparentlayerable_callback = nullptr;
        qcppolargrid_movetolayer_callback = nullptr;
        qcppolargrid_applyantialiasinghint_callback = nullptr;
        qcppolargrid_sender_callback = nullptr;
        qcppolargrid_sendersignalindex_callback = nullptr;
        qcppolargrid_receivers_callback = nullptr;
        qcppolargrid_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPPolarGrid_Metacall_Callback(QCPPolarGrid_Metacall_Callback cb) { qcppolargrid_metacall_callback = cb; }
    inline void setQCPPolarGrid_ApplyDefaultAntialiasingHint_Callback(QCPPolarGrid_ApplyDefaultAntialiasingHint_Callback cb) { qcppolargrid_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPPolarGrid_Draw_Callback(QCPPolarGrid_Draw_Callback cb) { qcppolargrid_draw_callback = cb; }
    inline void setQCPPolarGrid_SelectTest_Callback(QCPPolarGrid_SelectTest_Callback cb) { qcppolargrid_selecttest_callback = cb; }
    inline void setQCPPolarGrid_ParentPlotInitialized_Callback(QCPPolarGrid_ParentPlotInitialized_Callback cb) { qcppolargrid_parentplotinitialized_callback = cb; }
    inline void setQCPPolarGrid_SelectionCategory_Callback(QCPPolarGrid_SelectionCategory_Callback cb) { qcppolargrid_selectioncategory_callback = cb; }
    inline void setQCPPolarGrid_ClipRect_Callback(QCPPolarGrid_ClipRect_Callback cb) { qcppolargrid_cliprect_callback = cb; }
    inline void setQCPPolarGrid_SelectEvent_Callback(QCPPolarGrid_SelectEvent_Callback cb) { qcppolargrid_selectevent_callback = cb; }
    inline void setQCPPolarGrid_DeselectEvent_Callback(QCPPolarGrid_DeselectEvent_Callback cb) { qcppolargrid_deselectevent_callback = cb; }
    inline void setQCPPolarGrid_MousePressEvent_Callback(QCPPolarGrid_MousePressEvent_Callback cb) { qcppolargrid_mousepressevent_callback = cb; }
    inline void setQCPPolarGrid_MouseMoveEvent_Callback(QCPPolarGrid_MouseMoveEvent_Callback cb) { qcppolargrid_mousemoveevent_callback = cb; }
    inline void setQCPPolarGrid_MouseReleaseEvent_Callback(QCPPolarGrid_MouseReleaseEvent_Callback cb) { qcppolargrid_mousereleaseevent_callback = cb; }
    inline void setQCPPolarGrid_MouseDoubleClickEvent_Callback(QCPPolarGrid_MouseDoubleClickEvent_Callback cb) { qcppolargrid_mousedoubleclickevent_callback = cb; }
    inline void setQCPPolarGrid_WheelEvent_Callback(QCPPolarGrid_WheelEvent_Callback cb) { qcppolargrid_wheelevent_callback = cb; }
    inline void setQCPPolarGrid_Event_Callback(QCPPolarGrid_Event_Callback cb) { qcppolargrid_event_callback = cb; }
    inline void setQCPPolarGrid_EventFilter_Callback(QCPPolarGrid_EventFilter_Callback cb) { qcppolargrid_eventfilter_callback = cb; }
    inline void setQCPPolarGrid_TimerEvent_Callback(QCPPolarGrid_TimerEvent_Callback cb) { qcppolargrid_timerevent_callback = cb; }
    inline void setQCPPolarGrid_ChildEvent_Callback(QCPPolarGrid_ChildEvent_Callback cb) { qcppolargrid_childevent_callback = cb; }
    inline void setQCPPolarGrid_CustomEvent_Callback(QCPPolarGrid_CustomEvent_Callback cb) { qcppolargrid_customevent_callback = cb; }
    inline void setQCPPolarGrid_ConnectNotify_Callback(QCPPolarGrid_ConnectNotify_Callback cb) { qcppolargrid_connectnotify_callback = cb; }
    inline void setQCPPolarGrid_DisconnectNotify_Callback(QCPPolarGrid_DisconnectNotify_Callback cb) { qcppolargrid_disconnectnotify_callback = cb; }
    inline void setQCPPolarGrid_DrawRadialGrid_Callback(QCPPolarGrid_DrawRadialGrid_Callback cb) { qcppolargrid_drawradialgrid_callback = cb; }
    inline void setQCPPolarGrid_DrawAngularGrid_Callback(QCPPolarGrid_DrawAngularGrid_Callback cb) { qcppolargrid_drawangulargrid_callback = cb; }
    inline void setQCPPolarGrid_DrawRadialGrid5_Callback(QCPPolarGrid_DrawRadialGrid5_Callback cb) { qcppolargrid_drawradialgrid5_callback = cb; }
    inline void setQCPPolarGrid_InitializeParentPlot_Callback(QCPPolarGrid_InitializeParentPlot_Callback cb) { qcppolargrid_initializeparentplot_callback = cb; }
    inline void setQCPPolarGrid_SetParentLayerable_Callback(QCPPolarGrid_SetParentLayerable_Callback cb) { qcppolargrid_setparentlayerable_callback = cb; }
    inline void setQCPPolarGrid_MoveToLayer_Callback(QCPPolarGrid_MoveToLayer_Callback cb) { qcppolargrid_movetolayer_callback = cb; }
    inline void setQCPPolarGrid_ApplyAntialiasingHint_Callback(QCPPolarGrid_ApplyAntialiasingHint_Callback cb) { qcppolargrid_applyantialiasinghint_callback = cb; }
    inline void setQCPPolarGrid_Sender_Callback(QCPPolarGrid_Sender_Callback cb) { qcppolargrid_sender_callback = cb; }
    inline void setQCPPolarGrid_SenderSignalIndex_Callback(QCPPolarGrid_SenderSignalIndex_Callback cb) { qcppolargrid_sendersignalindex_callback = cb; }
    inline void setQCPPolarGrid_Receivers_Callback(QCPPolarGrid_Receivers_Callback cb) { qcppolargrid_receivers_callback = cb; }
    inline void setQCPPolarGrid_IsSignalConnected_Callback(QCPPolarGrid_IsSignalConnected_Callback cb) { qcppolargrid_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPPolarGrid_Metacall_IsBase(bool value) const { qcppolargrid_metacall_isbase = value; }
    inline void setQCPPolarGrid_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcppolargrid_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPPolarGrid_Draw_IsBase(bool value) const { qcppolargrid_draw_isbase = value; }
    inline void setQCPPolarGrid_SelectTest_IsBase(bool value) const { qcppolargrid_selecttest_isbase = value; }
    inline void setQCPPolarGrid_ParentPlotInitialized_IsBase(bool value) const { qcppolargrid_parentplotinitialized_isbase = value; }
    inline void setQCPPolarGrid_SelectionCategory_IsBase(bool value) const { qcppolargrid_selectioncategory_isbase = value; }
    inline void setQCPPolarGrid_ClipRect_IsBase(bool value) const { qcppolargrid_cliprect_isbase = value; }
    inline void setQCPPolarGrid_SelectEvent_IsBase(bool value) const { qcppolargrid_selectevent_isbase = value; }
    inline void setQCPPolarGrid_DeselectEvent_IsBase(bool value) const { qcppolargrid_deselectevent_isbase = value; }
    inline void setQCPPolarGrid_MousePressEvent_IsBase(bool value) const { qcppolargrid_mousepressevent_isbase = value; }
    inline void setQCPPolarGrid_MouseMoveEvent_IsBase(bool value) const { qcppolargrid_mousemoveevent_isbase = value; }
    inline void setQCPPolarGrid_MouseReleaseEvent_IsBase(bool value) const { qcppolargrid_mousereleaseevent_isbase = value; }
    inline void setQCPPolarGrid_MouseDoubleClickEvent_IsBase(bool value) const { qcppolargrid_mousedoubleclickevent_isbase = value; }
    inline void setQCPPolarGrid_WheelEvent_IsBase(bool value) const { qcppolargrid_wheelevent_isbase = value; }
    inline void setQCPPolarGrid_Event_IsBase(bool value) const { qcppolargrid_event_isbase = value; }
    inline void setQCPPolarGrid_EventFilter_IsBase(bool value) const { qcppolargrid_eventfilter_isbase = value; }
    inline void setQCPPolarGrid_TimerEvent_IsBase(bool value) const { qcppolargrid_timerevent_isbase = value; }
    inline void setQCPPolarGrid_ChildEvent_IsBase(bool value) const { qcppolargrid_childevent_isbase = value; }
    inline void setQCPPolarGrid_CustomEvent_IsBase(bool value) const { qcppolargrid_customevent_isbase = value; }
    inline void setQCPPolarGrid_ConnectNotify_IsBase(bool value) const { qcppolargrid_connectnotify_isbase = value; }
    inline void setQCPPolarGrid_DisconnectNotify_IsBase(bool value) const { qcppolargrid_disconnectnotify_isbase = value; }
    inline void setQCPPolarGrid_DrawRadialGrid_IsBase(bool value) const { qcppolargrid_drawradialgrid_isbase = value; }
    inline void setQCPPolarGrid_DrawAngularGrid_IsBase(bool value) const { qcppolargrid_drawangulargrid_isbase = value; }
    inline void setQCPPolarGrid_DrawRadialGrid5_IsBase(bool value) const { qcppolargrid_drawradialgrid5_isbase = value; }
    inline void setQCPPolarGrid_InitializeParentPlot_IsBase(bool value) const { qcppolargrid_initializeparentplot_isbase = value; }
    inline void setQCPPolarGrid_SetParentLayerable_IsBase(bool value) const { qcppolargrid_setparentlayerable_isbase = value; }
    inline void setQCPPolarGrid_MoveToLayer_IsBase(bool value) const { qcppolargrid_movetolayer_isbase = value; }
    inline void setQCPPolarGrid_ApplyAntialiasingHint_IsBase(bool value) const { qcppolargrid_applyantialiasinghint_isbase = value; }
    inline void setQCPPolarGrid_Sender_IsBase(bool value) const { qcppolargrid_sender_isbase = value; }
    inline void setQCPPolarGrid_SenderSignalIndex_IsBase(bool value) const { qcppolargrid_sendersignalindex_isbase = value; }
    inline void setQCPPolarGrid_Receivers_IsBase(bool value) const { qcppolargrid_receivers_isbase = value; }
    inline void setQCPPolarGrid_IsSignalConnected_IsBase(bool value) const { qcppolargrid_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcppolargrid_metacall_isbase) {
            qcppolargrid_metacall_isbase = false;
            return QCPPolarGrid::qt_metacall(param1, param2, param3);
        } else if (qcppolargrid_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcppolargrid_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPPolarGrid::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcppolargrid_applydefaultantialiasinghint_isbase) {
            qcppolargrid_applydefaultantialiasinghint_isbase = false;
            QCPPolarGrid::applyDefaultAntialiasingHint(painter);
        } else if (qcppolargrid_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcppolargrid_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPPolarGrid::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcppolargrid_draw_isbase) {
            qcppolargrid_draw_isbase = false;
            QCPPolarGrid::draw(painter);
        } else if (qcppolargrid_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcppolargrid_draw_callback(this, cbval1);
        } else {
            QCPPolarGrid::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcppolargrid_selecttest_isbase) {
            qcppolargrid_selecttest_isbase = false;
            return QCPPolarGrid::selectTest(pos, onlySelectable, details);
        } else if (qcppolargrid_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcppolargrid_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPPolarGrid::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcppolargrid_parentplotinitialized_isbase) {
            qcppolargrid_parentplotinitialized_isbase = false;
            QCPPolarGrid::parentPlotInitialized(parentPlot);
        } else if (qcppolargrid_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcppolargrid_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPPolarGrid::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcppolargrid_selectioncategory_isbase) {
            qcppolargrid_selectioncategory_isbase = false;
            return QCPPolarGrid::selectionCategory();
        } else if (qcppolargrid_selectioncategory_callback != nullptr) {
            int callback_ret = qcppolargrid_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPPolarGrid::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcppolargrid_cliprect_isbase) {
            qcppolargrid_cliprect_isbase = false;
            return QCPPolarGrid::clipRect();
        } else if (qcppolargrid_cliprect_callback != nullptr) {
            QRect* callback_ret = qcppolargrid_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPPolarGrid::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcppolargrid_selectevent_isbase) {
            qcppolargrid_selectevent_isbase = false;
            QCPPolarGrid::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcppolargrid_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcppolargrid_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPPolarGrid::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcppolargrid_deselectevent_isbase) {
            qcppolargrid_deselectevent_isbase = false;
            QCPPolarGrid::deselectEvent(selectionStateChanged);
        } else if (qcppolargrid_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcppolargrid_deselectevent_callback(this, cbval1);
        } else {
            QCPPolarGrid::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcppolargrid_mousepressevent_isbase) {
            qcppolargrid_mousepressevent_isbase = false;
            QCPPolarGrid::mousePressEvent(event, details);
        } else if (qcppolargrid_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcppolargrid_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPPolarGrid::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcppolargrid_mousemoveevent_isbase) {
            qcppolargrid_mousemoveevent_isbase = false;
            QCPPolarGrid::mouseMoveEvent(event, startPos);
        } else if (qcppolargrid_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcppolargrid_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPPolarGrid::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcppolargrid_mousereleaseevent_isbase) {
            qcppolargrid_mousereleaseevent_isbase = false;
            QCPPolarGrid::mouseReleaseEvent(event, startPos);
        } else if (qcppolargrid_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcppolargrid_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPPolarGrid::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcppolargrid_mousedoubleclickevent_isbase) {
            qcppolargrid_mousedoubleclickevent_isbase = false;
            QCPPolarGrid::mouseDoubleClickEvent(event, details);
        } else if (qcppolargrid_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcppolargrid_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPPolarGrid::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcppolargrid_wheelevent_isbase) {
            qcppolargrid_wheelevent_isbase = false;
            QCPPolarGrid::wheelEvent(event);
        } else if (qcppolargrid_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcppolargrid_wheelevent_callback(this, cbval1);
        } else {
            QCPPolarGrid::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcppolargrid_event_isbase) {
            qcppolargrid_event_isbase = false;
            return QCPPolarGrid::event(event);
        } else if (qcppolargrid_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcppolargrid_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPPolarGrid::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcppolargrid_eventfilter_isbase) {
            qcppolargrid_eventfilter_isbase = false;
            return QCPPolarGrid::eventFilter(watched, event);
        } else if (qcppolargrid_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcppolargrid_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPPolarGrid::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcppolargrid_timerevent_isbase) {
            qcppolargrid_timerevent_isbase = false;
            QCPPolarGrid::timerEvent(event);
        } else if (qcppolargrid_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcppolargrid_timerevent_callback(this, cbval1);
        } else {
            QCPPolarGrid::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcppolargrid_childevent_isbase) {
            qcppolargrid_childevent_isbase = false;
            QCPPolarGrid::childEvent(event);
        } else if (qcppolargrid_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcppolargrid_childevent_callback(this, cbval1);
        } else {
            QCPPolarGrid::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcppolargrid_customevent_isbase) {
            qcppolargrid_customevent_isbase = false;
            QCPPolarGrid::customEvent(event);
        } else if (qcppolargrid_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcppolargrid_customevent_callback(this, cbval1);
        } else {
            QCPPolarGrid::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcppolargrid_connectnotify_isbase) {
            qcppolargrid_connectnotify_isbase = false;
            QCPPolarGrid::connectNotify(signal);
        } else if (qcppolargrid_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcppolargrid_connectnotify_callback(this, cbval1);
        } else {
            QCPPolarGrid::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcppolargrid_disconnectnotify_isbase) {
            qcppolargrid_disconnectnotify_isbase = false;
            QCPPolarGrid::disconnectNotify(signal);
        } else if (qcppolargrid_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcppolargrid_disconnectnotify_callback(this, cbval1);
        } else {
            QCPPolarGrid::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    void drawRadialGrid(QCPPainter* painter, const QPointF& center, const QVector<double>& coords, const QPen& pen) {
        if (qcppolargrid_drawradialgrid_isbase) {
            qcppolargrid_drawradialgrid_isbase = false;
            QCPPolarGrid::drawRadialGrid(painter, center, coords, pen);
        } else if (qcppolargrid_drawradialgrid_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            const QPointF& center_ret = center;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&center_ret);
            const QVector<double>& coords_ret = coords;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* coords_arr = static_cast<double*>(malloc(sizeof(double) * (coords_ret.size() + 1)));
            for (qsizetype i = 0; i < coords_ret.size(); ++i) {
                coords_arr[i] = coords_ret[i];
            }
            libqt_list coords_out;
            coords_out.len = coords_ret.size();
            coords_out.data = static_cast<void*>(coords_arr);
            libqt_list /* of double */ cbval3 = coords_out;
            const QPen& pen_ret = pen;
            // Cast returned reference into pointer
            QPen* cbval4 = const_cast<QPen*>(&pen_ret);

            qcppolargrid_drawradialgrid_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPPolarGrid::drawRadialGrid(painter, center, coords, pen);
        }
    }

    // Virtual method for C ABI access and custom callback
    void drawAngularGrid(QCPPainter* painter, const QPointF& center, double radius, const QVector<QPointF>& ticksCosSin, const QPen& pen) {
        if (qcppolargrid_drawangulargrid_isbase) {
            qcppolargrid_drawangulargrid_isbase = false;
            QCPPolarGrid::drawAngularGrid(painter, center, radius, ticksCosSin, pen);
        } else if (qcppolargrid_drawangulargrid_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            const QPointF& center_ret = center;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&center_ret);
            double cbval3 = radius;
            const QVector<QPointF>& ticksCosSin_ret = ticksCosSin;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** ticksCosSin_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (ticksCosSin_ret.size() + 1)));
            for (qsizetype i = 0; i < ticksCosSin_ret.size(); ++i) {
                ticksCosSin_arr[i] = new QPointF(ticksCosSin_ret[i]);
            }
            libqt_list ticksCosSin_out;
            ticksCosSin_out.len = ticksCosSin_ret.size();
            ticksCosSin_out.data = static_cast<void*>(ticksCosSin_arr);
            libqt_list /* of QPointF* */ cbval4 = ticksCosSin_out;
            const QPen& pen_ret = pen;
            // Cast returned reference into pointer
            QPen* cbval5 = const_cast<QPen*>(&pen_ret);

            qcppolargrid_drawangulargrid_callback(this, cbval1, cbval2, cbval3, cbval4, cbval5);
        } else {
            QCPPolarGrid::drawAngularGrid(painter, center, radius, ticksCosSin, pen);
        }
    }

    // Virtual method for C ABI access and custom callback
    void drawRadialGrid(QCPPainter* painter, const QPointF& center, const QVector<double>& coords, const QPen& pen, const QPen& zeroPen) {
        if (qcppolargrid_drawradialgrid5_isbase) {
            qcppolargrid_drawradialgrid5_isbase = false;
            QCPPolarGrid::drawRadialGrid(painter, center, coords, pen, zeroPen);
        } else if (qcppolargrid_drawradialgrid5_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            const QPointF& center_ret = center;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&center_ret);
            const QVector<double>& coords_ret = coords;
            // Convert QVector<> from C++ memory to manually-managed C memory
            double* coords_arr = static_cast<double*>(malloc(sizeof(double) * (coords_ret.size() + 1)));
            for (qsizetype i = 0; i < coords_ret.size(); ++i) {
                coords_arr[i] = coords_ret[i];
            }
            libqt_list coords_out;
            coords_out.len = coords_ret.size();
            coords_out.data = static_cast<void*>(coords_arr);
            libqt_list /* of double */ cbval3 = coords_out;
            const QPen& pen_ret = pen;
            // Cast returned reference into pointer
            QPen* cbval4 = const_cast<QPen*>(&pen_ret);
            const QPen& zeroPen_ret = zeroPen;
            // Cast returned reference into pointer
            QPen* cbval5 = const_cast<QPen*>(&zeroPen_ret);

            qcppolargrid_drawradialgrid5_callback(this, cbval1, cbval2, cbval3, cbval4, cbval5);
        } else {
            QCPPolarGrid::drawRadialGrid(painter, center, coords, pen, zeroPen);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcppolargrid_initializeparentplot_isbase) {
            qcppolargrid_initializeparentplot_isbase = false;
            QCPPolarGrid::initializeParentPlot(parentPlot);
        } else if (qcppolargrid_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcppolargrid_initializeparentplot_callback(this, cbval1);
        } else {
            QCPPolarGrid::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcppolargrid_setparentlayerable_isbase) {
            qcppolargrid_setparentlayerable_isbase = false;
            QCPPolarGrid::setParentLayerable(parentLayerable);
        } else if (qcppolargrid_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcppolargrid_setparentlayerable_callback(this, cbval1);
        } else {
            QCPPolarGrid::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcppolargrid_movetolayer_isbase) {
            qcppolargrid_movetolayer_isbase = false;
            return QCPPolarGrid::moveToLayer(layer, prepend);
        } else if (qcppolargrid_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcppolargrid_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPPolarGrid::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcppolargrid_applyantialiasinghint_isbase) {
            qcppolargrid_applyantialiasinghint_isbase = false;
            QCPPolarGrid::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcppolargrid_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcppolargrid_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPPolarGrid::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcppolargrid_sender_isbase) {
            qcppolargrid_sender_isbase = false;
            return QCPPolarGrid::sender();
        } else if (qcppolargrid_sender_callback != nullptr) {
            QObject* callback_ret = qcppolargrid_sender_callback();
            return callback_ret;
        } else {
            return QCPPolarGrid::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcppolargrid_sendersignalindex_isbase) {
            qcppolargrid_sendersignalindex_isbase = false;
            return QCPPolarGrid::senderSignalIndex();
        } else if (qcppolargrid_sendersignalindex_callback != nullptr) {
            int callback_ret = qcppolargrid_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPPolarGrid::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcppolargrid_receivers_isbase) {
            qcppolargrid_receivers_isbase = false;
            return QCPPolarGrid::receivers(signal);
        } else if (qcppolargrid_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcppolargrid_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPPolarGrid::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcppolargrid_issignalconnected_isbase) {
            qcppolargrid_issignalconnected_isbase = false;
            return QCPPolarGrid::isSignalConnected(signal);
        } else if (qcppolargrid_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcppolargrid_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPPolarGrid::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPPolarGrid_ApplyDefaultAntialiasingHint(const QCPPolarGrid* self, QCPPainter* painter);
    friend void QCPPolarGrid_QBaseApplyDefaultAntialiasingHint(const QCPPolarGrid* self, QCPPainter* painter);
    friend void QCPPolarGrid_Draw(QCPPolarGrid* self, QCPPainter* painter);
    friend void QCPPolarGrid_QBaseDraw(QCPPolarGrid* self, QCPPainter* painter);
    friend void QCPPolarGrid_ParentPlotInitialized(QCPPolarGrid* self, QCustomPlot* parentPlot);
    friend void QCPPolarGrid_QBaseParentPlotInitialized(QCPPolarGrid* self, QCustomPlot* parentPlot);
    friend int QCPPolarGrid_SelectionCategory(const QCPPolarGrid* self);
    friend int QCPPolarGrid_QBaseSelectionCategory(const QCPPolarGrid* self);
    friend QRect* QCPPolarGrid_ClipRect(const QCPPolarGrid* self);
    friend QRect* QCPPolarGrid_QBaseClipRect(const QCPPolarGrid* self);
    friend void QCPPolarGrid_SelectEvent(QCPPolarGrid* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPPolarGrid_QBaseSelectEvent(QCPPolarGrid* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPPolarGrid_DeselectEvent(QCPPolarGrid* self, bool* selectionStateChanged);
    friend void QCPPolarGrid_QBaseDeselectEvent(QCPPolarGrid* self, bool* selectionStateChanged);
    friend void QCPPolarGrid_MousePressEvent(QCPPolarGrid* self, QMouseEvent* event, const QVariant* details);
    friend void QCPPolarGrid_QBaseMousePressEvent(QCPPolarGrid* self, QMouseEvent* event, const QVariant* details);
    friend void QCPPolarGrid_MouseMoveEvent(QCPPolarGrid* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPPolarGrid_QBaseMouseMoveEvent(QCPPolarGrid* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPPolarGrid_MouseReleaseEvent(QCPPolarGrid* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPPolarGrid_QBaseMouseReleaseEvent(QCPPolarGrid* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPPolarGrid_MouseDoubleClickEvent(QCPPolarGrid* self, QMouseEvent* event, const QVariant* details);
    friend void QCPPolarGrid_QBaseMouseDoubleClickEvent(QCPPolarGrid* self, QMouseEvent* event, const QVariant* details);
    friend void QCPPolarGrid_WheelEvent(QCPPolarGrid* self, QWheelEvent* event);
    friend void QCPPolarGrid_QBaseWheelEvent(QCPPolarGrid* self, QWheelEvent* event);
    friend void QCPPolarGrid_TimerEvent(QCPPolarGrid* self, QTimerEvent* event);
    friend void QCPPolarGrid_QBaseTimerEvent(QCPPolarGrid* self, QTimerEvent* event);
    friend void QCPPolarGrid_ChildEvent(QCPPolarGrid* self, QChildEvent* event);
    friend void QCPPolarGrid_QBaseChildEvent(QCPPolarGrid* self, QChildEvent* event);
    friend void QCPPolarGrid_CustomEvent(QCPPolarGrid* self, QEvent* event);
    friend void QCPPolarGrid_QBaseCustomEvent(QCPPolarGrid* self, QEvent* event);
    friend void QCPPolarGrid_ConnectNotify(QCPPolarGrid* self, const QMetaMethod* signal);
    friend void QCPPolarGrid_QBaseConnectNotify(QCPPolarGrid* self, const QMetaMethod* signal);
    friend void QCPPolarGrid_DisconnectNotify(QCPPolarGrid* self, const QMetaMethod* signal);
    friend void QCPPolarGrid_QBaseDisconnectNotify(QCPPolarGrid* self, const QMetaMethod* signal);
    friend void QCPPolarGrid_DrawRadialGrid(QCPPolarGrid* self, QCPPainter* painter, const QPointF* center, const libqt_list /* of double */ coords, const QPen* pen);
    friend void QCPPolarGrid_QBaseDrawRadialGrid(QCPPolarGrid* self, QCPPainter* painter, const QPointF* center, const libqt_list /* of double */ coords, const QPen* pen);
    friend void QCPPolarGrid_DrawAngularGrid(QCPPolarGrid* self, QCPPainter* painter, const QPointF* center, double radius, const libqt_list /* of QPointF* */ ticksCosSin, const QPen* pen);
    friend void QCPPolarGrid_QBaseDrawAngularGrid(QCPPolarGrid* self, QCPPainter* painter, const QPointF* center, double radius, const libqt_list /* of QPointF* */ ticksCosSin, const QPen* pen);
    friend void QCPPolarGrid_DrawRadialGrid5(QCPPolarGrid* self, QCPPainter* painter, const QPointF* center, const libqt_list /* of double */ coords, const QPen* pen, const QPen* zeroPen);
    friend void QCPPolarGrid_QBaseDrawRadialGrid5(QCPPolarGrid* self, QCPPainter* painter, const QPointF* center, const libqt_list /* of double */ coords, const QPen* pen, const QPen* zeroPen);
    friend void QCPPolarGrid_InitializeParentPlot(QCPPolarGrid* self, QCustomPlot* parentPlot);
    friend void QCPPolarGrid_QBaseInitializeParentPlot(QCPPolarGrid* self, QCustomPlot* parentPlot);
    friend void QCPPolarGrid_SetParentLayerable(QCPPolarGrid* self, QCPLayerable* parentLayerable);
    friend void QCPPolarGrid_QBaseSetParentLayerable(QCPPolarGrid* self, QCPLayerable* parentLayerable);
    friend bool QCPPolarGrid_MoveToLayer(QCPPolarGrid* self, QCPLayer* layer, bool prepend);
    friend bool QCPPolarGrid_QBaseMoveToLayer(QCPPolarGrid* self, QCPLayer* layer, bool prepend);
    friend void QCPPolarGrid_ApplyAntialiasingHint(const QCPPolarGrid* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPPolarGrid_QBaseApplyAntialiasingHint(const QCPPolarGrid* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPPolarGrid_Sender(const QCPPolarGrid* self);
    friend QObject* QCPPolarGrid_QBaseSender(const QCPPolarGrid* self);
    friend int QCPPolarGrid_SenderSignalIndex(const QCPPolarGrid* self);
    friend int QCPPolarGrid_QBaseSenderSignalIndex(const QCPPolarGrid* self);
    friend int QCPPolarGrid_Receivers(const QCPPolarGrid* self, const char* signal);
    friend int QCPPolarGrid_QBaseReceivers(const QCPPolarGrid* self, const char* signal);
    friend bool QCPPolarGrid_IsSignalConnected(const QCPPolarGrid* self, const QMetaMethod* signal);
    friend bool QCPPolarGrid_QBaseIsSignalConnected(const QCPPolarGrid* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPPolarLegendItem so that we can call protected methods
class VirtualQCPPolarLegendItem final : public QCPPolarLegendItem {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPPolarLegendItem = true;

    // Virtual class public types (including callbacks)
    using QCPPolarLegendItem_Metacall_Callback = int (*)(QCPPolarLegendItem*, int, int, void**);
    using QCPPolarLegendItem_Draw_Callback = void (*)(QCPPolarLegendItem*, QCPPainter*);
    using QCPPolarLegendItem_MinimumOuterSizeHint_Callback = QSize* (*)();
    using QCPPolarLegendItem_SelectTest_Callback = double (*)(const QCPPolarLegendItem*, QPointF*, bool, QVariant*);
    using QCPPolarLegendItem_SelectionCategory_Callback = int (*)();
    using QCPPolarLegendItem_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPPolarLegendItem*, QCPPainter*);
    using QCPPolarLegendItem_ClipRect_Callback = QRect* (*)();
    using QCPPolarLegendItem_SelectEvent_Callback = void (*)(QCPPolarLegendItem*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPPolarLegendItem_DeselectEvent_Callback = void (*)(QCPPolarLegendItem*, bool*);
    using QCPPolarLegendItem_Update_Callback = void (*)(QCPPolarLegendItem*, int);
    using QCPPolarLegendItem_MaximumOuterSizeHint_Callback = QSize* (*)();
    using QCPPolarLegendItem_Elements_Callback = QCPLayoutElement** (*)(const QCPPolarLegendItem*, bool);
    using QCPPolarLegendItem_CalculateAutoMargin_Callback = int (*)(QCPPolarLegendItem*, int);
    using QCPPolarLegendItem_LayoutChanged_Callback = void (*)();
    using QCPPolarLegendItem_ParentPlotInitialized_Callback = void (*)(QCPPolarLegendItem*, QCustomPlot*);
    using QCPPolarLegendItem_MousePressEvent_Callback = void (*)(QCPPolarLegendItem*, QMouseEvent*, QVariant*);
    using QCPPolarLegendItem_MouseMoveEvent_Callback = void (*)(QCPPolarLegendItem*, QMouseEvent*, QPointF*);
    using QCPPolarLegendItem_MouseReleaseEvent_Callback = void (*)(QCPPolarLegendItem*, QMouseEvent*, QPointF*);
    using QCPPolarLegendItem_MouseDoubleClickEvent_Callback = void (*)(QCPPolarLegendItem*, QMouseEvent*, QVariant*);
    using QCPPolarLegendItem_WheelEvent_Callback = void (*)(QCPPolarLegendItem*, QWheelEvent*);
    using QCPPolarLegendItem_Event_Callback = bool (*)(QCPPolarLegendItem*, QEvent*);
    using QCPPolarLegendItem_EventFilter_Callback = bool (*)(QCPPolarLegendItem*, QObject*, QEvent*);
    using QCPPolarLegendItem_TimerEvent_Callback = void (*)(QCPPolarLegendItem*, QTimerEvent*);
    using QCPPolarLegendItem_ChildEvent_Callback = void (*)(QCPPolarLegendItem*, QChildEvent*);
    using QCPPolarLegendItem_CustomEvent_Callback = void (*)(QCPPolarLegendItem*, QEvent*);
    using QCPPolarLegendItem_ConnectNotify_Callback = void (*)(QCPPolarLegendItem*, QMetaMethod*);
    using QCPPolarLegendItem_DisconnectNotify_Callback = void (*)(QCPPolarLegendItem*, QMetaMethod*);
    using QCPPolarLegendItem_GetIconBorderPen_Callback = QPen* (*)();
    using QCPPolarLegendItem_GetTextColor_Callback = QColor* (*)();
    using QCPPolarLegendItem_GetFont_Callback = QFont* (*)();
    using QCPPolarLegendItem_InitializeParentPlot_Callback = void (*)(QCPPolarLegendItem*, QCustomPlot*);
    using QCPPolarLegendItem_SetParentLayerable_Callback = void (*)(QCPPolarLegendItem*, QCPLayerable*);
    using QCPPolarLegendItem_MoveToLayer_Callback = bool (*)(QCPPolarLegendItem*, QCPLayer*, bool);
    using QCPPolarLegendItem_ApplyAntialiasingHint_Callback = void (*)(const QCPPolarLegendItem*, QCPPainter*, bool, int);
    using QCPPolarLegendItem_Sender_Callback = QObject* (*)();
    using QCPPolarLegendItem_SenderSignalIndex_Callback = int (*)();
    using QCPPolarLegendItem_Receivers_Callback = int (*)(const QCPPolarLegendItem*, const char*);
    using QCPPolarLegendItem_IsSignalConnected_Callback = bool (*)(const QCPPolarLegendItem*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPPolarLegendItem_Metacall_Callback qcppolarlegenditem_metacall_callback = nullptr;
    QCPPolarLegendItem_Draw_Callback qcppolarlegenditem_draw_callback = nullptr;
    QCPPolarLegendItem_MinimumOuterSizeHint_Callback qcppolarlegenditem_minimumoutersizehint_callback = nullptr;
    QCPPolarLegendItem_SelectTest_Callback qcppolarlegenditem_selecttest_callback = nullptr;
    QCPPolarLegendItem_SelectionCategory_Callback qcppolarlegenditem_selectioncategory_callback = nullptr;
    QCPPolarLegendItem_ApplyDefaultAntialiasingHint_Callback qcppolarlegenditem_applydefaultantialiasinghint_callback = nullptr;
    QCPPolarLegendItem_ClipRect_Callback qcppolarlegenditem_cliprect_callback = nullptr;
    QCPPolarLegendItem_SelectEvent_Callback qcppolarlegenditem_selectevent_callback = nullptr;
    QCPPolarLegendItem_DeselectEvent_Callback qcppolarlegenditem_deselectevent_callback = nullptr;
    QCPPolarLegendItem_Update_Callback qcppolarlegenditem_update_callback = nullptr;
    QCPPolarLegendItem_MaximumOuterSizeHint_Callback qcppolarlegenditem_maximumoutersizehint_callback = nullptr;
    QCPPolarLegendItem_Elements_Callback qcppolarlegenditem_elements_callback = nullptr;
    QCPPolarLegendItem_CalculateAutoMargin_Callback qcppolarlegenditem_calculateautomargin_callback = nullptr;
    QCPPolarLegendItem_LayoutChanged_Callback qcppolarlegenditem_layoutchanged_callback = nullptr;
    QCPPolarLegendItem_ParentPlotInitialized_Callback qcppolarlegenditem_parentplotinitialized_callback = nullptr;
    QCPPolarLegendItem_MousePressEvent_Callback qcppolarlegenditem_mousepressevent_callback = nullptr;
    QCPPolarLegendItem_MouseMoveEvent_Callback qcppolarlegenditem_mousemoveevent_callback = nullptr;
    QCPPolarLegendItem_MouseReleaseEvent_Callback qcppolarlegenditem_mousereleaseevent_callback = nullptr;
    QCPPolarLegendItem_MouseDoubleClickEvent_Callback qcppolarlegenditem_mousedoubleclickevent_callback = nullptr;
    QCPPolarLegendItem_WheelEvent_Callback qcppolarlegenditem_wheelevent_callback = nullptr;
    QCPPolarLegendItem_Event_Callback qcppolarlegenditem_event_callback = nullptr;
    QCPPolarLegendItem_EventFilter_Callback qcppolarlegenditem_eventfilter_callback = nullptr;
    QCPPolarLegendItem_TimerEvent_Callback qcppolarlegenditem_timerevent_callback = nullptr;
    QCPPolarLegendItem_ChildEvent_Callback qcppolarlegenditem_childevent_callback = nullptr;
    QCPPolarLegendItem_CustomEvent_Callback qcppolarlegenditem_customevent_callback = nullptr;
    QCPPolarLegendItem_ConnectNotify_Callback qcppolarlegenditem_connectnotify_callback = nullptr;
    QCPPolarLegendItem_DisconnectNotify_Callback qcppolarlegenditem_disconnectnotify_callback = nullptr;
    QCPPolarLegendItem_GetIconBorderPen_Callback qcppolarlegenditem_geticonborderpen_callback = nullptr;
    QCPPolarLegendItem_GetTextColor_Callback qcppolarlegenditem_gettextcolor_callback = nullptr;
    QCPPolarLegendItem_GetFont_Callback qcppolarlegenditem_getfont_callback = nullptr;
    QCPPolarLegendItem_InitializeParentPlot_Callback qcppolarlegenditem_initializeparentplot_callback = nullptr;
    QCPPolarLegendItem_SetParentLayerable_Callback qcppolarlegenditem_setparentlayerable_callback = nullptr;
    QCPPolarLegendItem_MoveToLayer_Callback qcppolarlegenditem_movetolayer_callback = nullptr;
    QCPPolarLegendItem_ApplyAntialiasingHint_Callback qcppolarlegenditem_applyantialiasinghint_callback = nullptr;
    QCPPolarLegendItem_Sender_Callback qcppolarlegenditem_sender_callback = nullptr;
    QCPPolarLegendItem_SenderSignalIndex_Callback qcppolarlegenditem_sendersignalindex_callback = nullptr;
    QCPPolarLegendItem_Receivers_Callback qcppolarlegenditem_receivers_callback = nullptr;
    QCPPolarLegendItem_IsSignalConnected_Callback qcppolarlegenditem_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcppolarlegenditem_metacall_isbase = false;
    mutable bool qcppolarlegenditem_draw_isbase = false;
    mutable bool qcppolarlegenditem_minimumoutersizehint_isbase = false;
    mutable bool qcppolarlegenditem_selecttest_isbase = false;
    mutable bool qcppolarlegenditem_selectioncategory_isbase = false;
    mutable bool qcppolarlegenditem_applydefaultantialiasinghint_isbase = false;
    mutable bool qcppolarlegenditem_cliprect_isbase = false;
    mutable bool qcppolarlegenditem_selectevent_isbase = false;
    mutable bool qcppolarlegenditem_deselectevent_isbase = false;
    mutable bool qcppolarlegenditem_update_isbase = false;
    mutable bool qcppolarlegenditem_maximumoutersizehint_isbase = false;
    mutable bool qcppolarlegenditem_elements_isbase = false;
    mutable bool qcppolarlegenditem_calculateautomargin_isbase = false;
    mutable bool qcppolarlegenditem_layoutchanged_isbase = false;
    mutable bool qcppolarlegenditem_parentplotinitialized_isbase = false;
    mutable bool qcppolarlegenditem_mousepressevent_isbase = false;
    mutable bool qcppolarlegenditem_mousemoveevent_isbase = false;
    mutable bool qcppolarlegenditem_mousereleaseevent_isbase = false;
    mutable bool qcppolarlegenditem_mousedoubleclickevent_isbase = false;
    mutable bool qcppolarlegenditem_wheelevent_isbase = false;
    mutable bool qcppolarlegenditem_event_isbase = false;
    mutable bool qcppolarlegenditem_eventfilter_isbase = false;
    mutable bool qcppolarlegenditem_timerevent_isbase = false;
    mutable bool qcppolarlegenditem_childevent_isbase = false;
    mutable bool qcppolarlegenditem_customevent_isbase = false;
    mutable bool qcppolarlegenditem_connectnotify_isbase = false;
    mutable bool qcppolarlegenditem_disconnectnotify_isbase = false;
    mutable bool qcppolarlegenditem_geticonborderpen_isbase = false;
    mutable bool qcppolarlegenditem_gettextcolor_isbase = false;
    mutable bool qcppolarlegenditem_getfont_isbase = false;
    mutable bool qcppolarlegenditem_initializeparentplot_isbase = false;
    mutable bool qcppolarlegenditem_setparentlayerable_isbase = false;
    mutable bool qcppolarlegenditem_movetolayer_isbase = false;
    mutable bool qcppolarlegenditem_applyantialiasinghint_isbase = false;
    mutable bool qcppolarlegenditem_sender_isbase = false;
    mutable bool qcppolarlegenditem_sendersignalindex_isbase = false;
    mutable bool qcppolarlegenditem_receivers_isbase = false;
    mutable bool qcppolarlegenditem_issignalconnected_isbase = false;

  public:
    VirtualQCPPolarLegendItem(QCPLegend* parent, QCPPolarGraph* graph) : QCPPolarLegendItem(parent, graph) {};

    ~VirtualQCPPolarLegendItem() {
        qcppolarlegenditem_metacall_callback = nullptr;
        qcppolarlegenditem_draw_callback = nullptr;
        qcppolarlegenditem_minimumoutersizehint_callback = nullptr;
        qcppolarlegenditem_selecttest_callback = nullptr;
        qcppolarlegenditem_selectioncategory_callback = nullptr;
        qcppolarlegenditem_applydefaultantialiasinghint_callback = nullptr;
        qcppolarlegenditem_cliprect_callback = nullptr;
        qcppolarlegenditem_selectevent_callback = nullptr;
        qcppolarlegenditem_deselectevent_callback = nullptr;
        qcppolarlegenditem_update_callback = nullptr;
        qcppolarlegenditem_maximumoutersizehint_callback = nullptr;
        qcppolarlegenditem_elements_callback = nullptr;
        qcppolarlegenditem_calculateautomargin_callback = nullptr;
        qcppolarlegenditem_layoutchanged_callback = nullptr;
        qcppolarlegenditem_parentplotinitialized_callback = nullptr;
        qcppolarlegenditem_mousepressevent_callback = nullptr;
        qcppolarlegenditem_mousemoveevent_callback = nullptr;
        qcppolarlegenditem_mousereleaseevent_callback = nullptr;
        qcppolarlegenditem_mousedoubleclickevent_callback = nullptr;
        qcppolarlegenditem_wheelevent_callback = nullptr;
        qcppolarlegenditem_event_callback = nullptr;
        qcppolarlegenditem_eventfilter_callback = nullptr;
        qcppolarlegenditem_timerevent_callback = nullptr;
        qcppolarlegenditem_childevent_callback = nullptr;
        qcppolarlegenditem_customevent_callback = nullptr;
        qcppolarlegenditem_connectnotify_callback = nullptr;
        qcppolarlegenditem_disconnectnotify_callback = nullptr;
        qcppolarlegenditem_geticonborderpen_callback = nullptr;
        qcppolarlegenditem_gettextcolor_callback = nullptr;
        qcppolarlegenditem_getfont_callback = nullptr;
        qcppolarlegenditem_initializeparentplot_callback = nullptr;
        qcppolarlegenditem_setparentlayerable_callback = nullptr;
        qcppolarlegenditem_movetolayer_callback = nullptr;
        qcppolarlegenditem_applyantialiasinghint_callback = nullptr;
        qcppolarlegenditem_sender_callback = nullptr;
        qcppolarlegenditem_sendersignalindex_callback = nullptr;
        qcppolarlegenditem_receivers_callback = nullptr;
        qcppolarlegenditem_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPPolarLegendItem_Metacall_Callback(QCPPolarLegendItem_Metacall_Callback cb) { qcppolarlegenditem_metacall_callback = cb; }
    inline void setQCPPolarLegendItem_Draw_Callback(QCPPolarLegendItem_Draw_Callback cb) { qcppolarlegenditem_draw_callback = cb; }
    inline void setQCPPolarLegendItem_MinimumOuterSizeHint_Callback(QCPPolarLegendItem_MinimumOuterSizeHint_Callback cb) { qcppolarlegenditem_minimumoutersizehint_callback = cb; }
    inline void setQCPPolarLegendItem_SelectTest_Callback(QCPPolarLegendItem_SelectTest_Callback cb) { qcppolarlegenditem_selecttest_callback = cb; }
    inline void setQCPPolarLegendItem_SelectionCategory_Callback(QCPPolarLegendItem_SelectionCategory_Callback cb) { qcppolarlegenditem_selectioncategory_callback = cb; }
    inline void setQCPPolarLegendItem_ApplyDefaultAntialiasingHint_Callback(QCPPolarLegendItem_ApplyDefaultAntialiasingHint_Callback cb) { qcppolarlegenditem_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPPolarLegendItem_ClipRect_Callback(QCPPolarLegendItem_ClipRect_Callback cb) { qcppolarlegenditem_cliprect_callback = cb; }
    inline void setQCPPolarLegendItem_SelectEvent_Callback(QCPPolarLegendItem_SelectEvent_Callback cb) { qcppolarlegenditem_selectevent_callback = cb; }
    inline void setQCPPolarLegendItem_DeselectEvent_Callback(QCPPolarLegendItem_DeselectEvent_Callback cb) { qcppolarlegenditem_deselectevent_callback = cb; }
    inline void setQCPPolarLegendItem_Update_Callback(QCPPolarLegendItem_Update_Callback cb) { qcppolarlegenditem_update_callback = cb; }
    inline void setQCPPolarLegendItem_MaximumOuterSizeHint_Callback(QCPPolarLegendItem_MaximumOuterSizeHint_Callback cb) { qcppolarlegenditem_maximumoutersizehint_callback = cb; }
    inline void setQCPPolarLegendItem_Elements_Callback(QCPPolarLegendItem_Elements_Callback cb) { qcppolarlegenditem_elements_callback = cb; }
    inline void setQCPPolarLegendItem_CalculateAutoMargin_Callback(QCPPolarLegendItem_CalculateAutoMargin_Callback cb) { qcppolarlegenditem_calculateautomargin_callback = cb; }
    inline void setQCPPolarLegendItem_LayoutChanged_Callback(QCPPolarLegendItem_LayoutChanged_Callback cb) { qcppolarlegenditem_layoutchanged_callback = cb; }
    inline void setQCPPolarLegendItem_ParentPlotInitialized_Callback(QCPPolarLegendItem_ParentPlotInitialized_Callback cb) { qcppolarlegenditem_parentplotinitialized_callback = cb; }
    inline void setQCPPolarLegendItem_MousePressEvent_Callback(QCPPolarLegendItem_MousePressEvent_Callback cb) { qcppolarlegenditem_mousepressevent_callback = cb; }
    inline void setQCPPolarLegendItem_MouseMoveEvent_Callback(QCPPolarLegendItem_MouseMoveEvent_Callback cb) { qcppolarlegenditem_mousemoveevent_callback = cb; }
    inline void setQCPPolarLegendItem_MouseReleaseEvent_Callback(QCPPolarLegendItem_MouseReleaseEvent_Callback cb) { qcppolarlegenditem_mousereleaseevent_callback = cb; }
    inline void setQCPPolarLegendItem_MouseDoubleClickEvent_Callback(QCPPolarLegendItem_MouseDoubleClickEvent_Callback cb) { qcppolarlegenditem_mousedoubleclickevent_callback = cb; }
    inline void setQCPPolarLegendItem_WheelEvent_Callback(QCPPolarLegendItem_WheelEvent_Callback cb) { qcppolarlegenditem_wheelevent_callback = cb; }
    inline void setQCPPolarLegendItem_Event_Callback(QCPPolarLegendItem_Event_Callback cb) { qcppolarlegenditem_event_callback = cb; }
    inline void setQCPPolarLegendItem_EventFilter_Callback(QCPPolarLegendItem_EventFilter_Callback cb) { qcppolarlegenditem_eventfilter_callback = cb; }
    inline void setQCPPolarLegendItem_TimerEvent_Callback(QCPPolarLegendItem_TimerEvent_Callback cb) { qcppolarlegenditem_timerevent_callback = cb; }
    inline void setQCPPolarLegendItem_ChildEvent_Callback(QCPPolarLegendItem_ChildEvent_Callback cb) { qcppolarlegenditem_childevent_callback = cb; }
    inline void setQCPPolarLegendItem_CustomEvent_Callback(QCPPolarLegendItem_CustomEvent_Callback cb) { qcppolarlegenditem_customevent_callback = cb; }
    inline void setQCPPolarLegendItem_ConnectNotify_Callback(QCPPolarLegendItem_ConnectNotify_Callback cb) { qcppolarlegenditem_connectnotify_callback = cb; }
    inline void setQCPPolarLegendItem_DisconnectNotify_Callback(QCPPolarLegendItem_DisconnectNotify_Callback cb) { qcppolarlegenditem_disconnectnotify_callback = cb; }
    inline void setQCPPolarLegendItem_GetIconBorderPen_Callback(QCPPolarLegendItem_GetIconBorderPen_Callback cb) { qcppolarlegenditem_geticonborderpen_callback = cb; }
    inline void setQCPPolarLegendItem_GetTextColor_Callback(QCPPolarLegendItem_GetTextColor_Callback cb) { qcppolarlegenditem_gettextcolor_callback = cb; }
    inline void setQCPPolarLegendItem_GetFont_Callback(QCPPolarLegendItem_GetFont_Callback cb) { qcppolarlegenditem_getfont_callback = cb; }
    inline void setQCPPolarLegendItem_InitializeParentPlot_Callback(QCPPolarLegendItem_InitializeParentPlot_Callback cb) { qcppolarlegenditem_initializeparentplot_callback = cb; }
    inline void setQCPPolarLegendItem_SetParentLayerable_Callback(QCPPolarLegendItem_SetParentLayerable_Callback cb) { qcppolarlegenditem_setparentlayerable_callback = cb; }
    inline void setQCPPolarLegendItem_MoveToLayer_Callback(QCPPolarLegendItem_MoveToLayer_Callback cb) { qcppolarlegenditem_movetolayer_callback = cb; }
    inline void setQCPPolarLegendItem_ApplyAntialiasingHint_Callback(QCPPolarLegendItem_ApplyAntialiasingHint_Callback cb) { qcppolarlegenditem_applyantialiasinghint_callback = cb; }
    inline void setQCPPolarLegendItem_Sender_Callback(QCPPolarLegendItem_Sender_Callback cb) { qcppolarlegenditem_sender_callback = cb; }
    inline void setQCPPolarLegendItem_SenderSignalIndex_Callback(QCPPolarLegendItem_SenderSignalIndex_Callback cb) { qcppolarlegenditem_sendersignalindex_callback = cb; }
    inline void setQCPPolarLegendItem_Receivers_Callback(QCPPolarLegendItem_Receivers_Callback cb) { qcppolarlegenditem_receivers_callback = cb; }
    inline void setQCPPolarLegendItem_IsSignalConnected_Callback(QCPPolarLegendItem_IsSignalConnected_Callback cb) { qcppolarlegenditem_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPPolarLegendItem_Metacall_IsBase(bool value) const { qcppolarlegenditem_metacall_isbase = value; }
    inline void setQCPPolarLegendItem_Draw_IsBase(bool value) const { qcppolarlegenditem_draw_isbase = value; }
    inline void setQCPPolarLegendItem_MinimumOuterSizeHint_IsBase(bool value) const { qcppolarlegenditem_minimumoutersizehint_isbase = value; }
    inline void setQCPPolarLegendItem_SelectTest_IsBase(bool value) const { qcppolarlegenditem_selecttest_isbase = value; }
    inline void setQCPPolarLegendItem_SelectionCategory_IsBase(bool value) const { qcppolarlegenditem_selectioncategory_isbase = value; }
    inline void setQCPPolarLegendItem_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcppolarlegenditem_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPPolarLegendItem_ClipRect_IsBase(bool value) const { qcppolarlegenditem_cliprect_isbase = value; }
    inline void setQCPPolarLegendItem_SelectEvent_IsBase(bool value) const { qcppolarlegenditem_selectevent_isbase = value; }
    inline void setQCPPolarLegendItem_DeselectEvent_IsBase(bool value) const { qcppolarlegenditem_deselectevent_isbase = value; }
    inline void setQCPPolarLegendItem_Update_IsBase(bool value) const { qcppolarlegenditem_update_isbase = value; }
    inline void setQCPPolarLegendItem_MaximumOuterSizeHint_IsBase(bool value) const { qcppolarlegenditem_maximumoutersizehint_isbase = value; }
    inline void setQCPPolarLegendItem_Elements_IsBase(bool value) const { qcppolarlegenditem_elements_isbase = value; }
    inline void setQCPPolarLegendItem_CalculateAutoMargin_IsBase(bool value) const { qcppolarlegenditem_calculateautomargin_isbase = value; }
    inline void setQCPPolarLegendItem_LayoutChanged_IsBase(bool value) const { qcppolarlegenditem_layoutchanged_isbase = value; }
    inline void setQCPPolarLegendItem_ParentPlotInitialized_IsBase(bool value) const { qcppolarlegenditem_parentplotinitialized_isbase = value; }
    inline void setQCPPolarLegendItem_MousePressEvent_IsBase(bool value) const { qcppolarlegenditem_mousepressevent_isbase = value; }
    inline void setQCPPolarLegendItem_MouseMoveEvent_IsBase(bool value) const { qcppolarlegenditem_mousemoveevent_isbase = value; }
    inline void setQCPPolarLegendItem_MouseReleaseEvent_IsBase(bool value) const { qcppolarlegenditem_mousereleaseevent_isbase = value; }
    inline void setQCPPolarLegendItem_MouseDoubleClickEvent_IsBase(bool value) const { qcppolarlegenditem_mousedoubleclickevent_isbase = value; }
    inline void setQCPPolarLegendItem_WheelEvent_IsBase(bool value) const { qcppolarlegenditem_wheelevent_isbase = value; }
    inline void setQCPPolarLegendItem_Event_IsBase(bool value) const { qcppolarlegenditem_event_isbase = value; }
    inline void setQCPPolarLegendItem_EventFilter_IsBase(bool value) const { qcppolarlegenditem_eventfilter_isbase = value; }
    inline void setQCPPolarLegendItem_TimerEvent_IsBase(bool value) const { qcppolarlegenditem_timerevent_isbase = value; }
    inline void setQCPPolarLegendItem_ChildEvent_IsBase(bool value) const { qcppolarlegenditem_childevent_isbase = value; }
    inline void setQCPPolarLegendItem_CustomEvent_IsBase(bool value) const { qcppolarlegenditem_customevent_isbase = value; }
    inline void setQCPPolarLegendItem_ConnectNotify_IsBase(bool value) const { qcppolarlegenditem_connectnotify_isbase = value; }
    inline void setQCPPolarLegendItem_DisconnectNotify_IsBase(bool value) const { qcppolarlegenditem_disconnectnotify_isbase = value; }
    inline void setQCPPolarLegendItem_GetIconBorderPen_IsBase(bool value) const { qcppolarlegenditem_geticonborderpen_isbase = value; }
    inline void setQCPPolarLegendItem_GetTextColor_IsBase(bool value) const { qcppolarlegenditem_gettextcolor_isbase = value; }
    inline void setQCPPolarLegendItem_GetFont_IsBase(bool value) const { qcppolarlegenditem_getfont_isbase = value; }
    inline void setQCPPolarLegendItem_InitializeParentPlot_IsBase(bool value) const { qcppolarlegenditem_initializeparentplot_isbase = value; }
    inline void setQCPPolarLegendItem_SetParentLayerable_IsBase(bool value) const { qcppolarlegenditem_setparentlayerable_isbase = value; }
    inline void setQCPPolarLegendItem_MoveToLayer_IsBase(bool value) const { qcppolarlegenditem_movetolayer_isbase = value; }
    inline void setQCPPolarLegendItem_ApplyAntialiasingHint_IsBase(bool value) const { qcppolarlegenditem_applyantialiasinghint_isbase = value; }
    inline void setQCPPolarLegendItem_Sender_IsBase(bool value) const { qcppolarlegenditem_sender_isbase = value; }
    inline void setQCPPolarLegendItem_SenderSignalIndex_IsBase(bool value) const { qcppolarlegenditem_sendersignalindex_isbase = value; }
    inline void setQCPPolarLegendItem_Receivers_IsBase(bool value) const { qcppolarlegenditem_receivers_isbase = value; }
    inline void setQCPPolarLegendItem_IsSignalConnected_IsBase(bool value) const { qcppolarlegenditem_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcppolarlegenditem_metacall_isbase) {
            qcppolarlegenditem_metacall_isbase = false;
            return QCPPolarLegendItem::qt_metacall(param1, param2, param3);
        } else if (qcppolarlegenditem_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcppolarlegenditem_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPPolarLegendItem::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcppolarlegenditem_draw_isbase) {
            qcppolarlegenditem_draw_isbase = false;
            QCPPolarLegendItem::draw(painter);
        } else if (qcppolarlegenditem_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcppolarlegenditem_draw_callback(this, cbval1);
        } else {
            QCPPolarLegendItem::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize minimumOuterSizeHint() const override {
        if (qcppolarlegenditem_minimumoutersizehint_isbase) {
            qcppolarlegenditem_minimumoutersizehint_isbase = false;
            return QCPPolarLegendItem::minimumOuterSizeHint();
        } else if (qcppolarlegenditem_minimumoutersizehint_callback != nullptr) {
            QSize* callback_ret = qcppolarlegenditem_minimumoutersizehint_callback();
            return *callback_ret;
        } else {
            return QCPPolarLegendItem::minimumOuterSizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcppolarlegenditem_selecttest_isbase) {
            qcppolarlegenditem_selecttest_isbase = false;
            return QCPPolarLegendItem::selectTest(pos, onlySelectable, details);
        } else if (qcppolarlegenditem_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcppolarlegenditem_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPPolarLegendItem::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcppolarlegenditem_selectioncategory_isbase) {
            qcppolarlegenditem_selectioncategory_isbase = false;
            return QCPPolarLegendItem::selectionCategory();
        } else if (qcppolarlegenditem_selectioncategory_callback != nullptr) {
            int callback_ret = qcppolarlegenditem_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPPolarLegendItem::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcppolarlegenditem_applydefaultantialiasinghint_isbase) {
            qcppolarlegenditem_applydefaultantialiasinghint_isbase = false;
            QCPPolarLegendItem::applyDefaultAntialiasingHint(painter);
        } else if (qcppolarlegenditem_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcppolarlegenditem_applydefaultantialiasinghint_callback(this, cbval1);
        } else {
            QCPPolarLegendItem::applyDefaultAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcppolarlegenditem_cliprect_isbase) {
            qcppolarlegenditem_cliprect_isbase = false;
            return QCPPolarLegendItem::clipRect();
        } else if (qcppolarlegenditem_cliprect_callback != nullptr) {
            QRect* callback_ret = qcppolarlegenditem_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPPolarLegendItem::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcppolarlegenditem_selectevent_isbase) {
            qcppolarlegenditem_selectevent_isbase = false;
            QCPPolarLegendItem::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcppolarlegenditem_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcppolarlegenditem_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPPolarLegendItem::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcppolarlegenditem_deselectevent_isbase) {
            qcppolarlegenditem_deselectevent_isbase = false;
            QCPPolarLegendItem::deselectEvent(selectionStateChanged);
        } else if (qcppolarlegenditem_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcppolarlegenditem_deselectevent_callback(this, cbval1);
        } else {
            QCPPolarLegendItem::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void update(QCPLayoutElement::UpdatePhase phase) override {
        if (qcppolarlegenditem_update_isbase) {
            qcppolarlegenditem_update_isbase = false;
            QCPPolarLegendItem::update(phase);
        } else if (qcppolarlegenditem_update_callback != nullptr) {
            int cbval1 = static_cast<int>(phase);

            qcppolarlegenditem_update_callback(this, cbval1);
        } else {
            QCPPolarLegendItem::update(phase);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QSize maximumOuterSizeHint() const override {
        if (qcppolarlegenditem_maximumoutersizehint_isbase) {
            qcppolarlegenditem_maximumoutersizehint_isbase = false;
            return QCPPolarLegendItem::maximumOuterSizeHint();
        } else if (qcppolarlegenditem_maximumoutersizehint_callback != nullptr) {
            QSize* callback_ret = qcppolarlegenditem_maximumoutersizehint_callback();
            return *callback_ret;
        } else {
            return QCPPolarLegendItem::maximumOuterSizeHint();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QList<QCPLayoutElement*> elements(bool recursive) const override {
        if (qcppolarlegenditem_elements_isbase) {
            qcppolarlegenditem_elements_isbase = false;
            return QCPPolarLegendItem::elements(recursive);
        } else if (qcppolarlegenditem_elements_callback != nullptr) {
            bool cbval1 = recursive;

            QCPLayoutElement** callback_ret = qcppolarlegenditem_elements_callback(this, cbval1);
            QList<QCPLayoutElement*> callback_ret_QList;
            // Iterate until null pointer sentinel
            for (QCPLayoutElement** ptridx = callback_ret; *ptridx != nullptr; ptridx++) {
                callback_ret_QList.push_back(*ptridx);
            }
            free(callback_ret);
            return callback_ret_QList;
        } else {
            return QCPPolarLegendItem::elements(recursive);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int calculateAutoMargin(QCP::MarginSide side) override {
        if (qcppolarlegenditem_calculateautomargin_isbase) {
            qcppolarlegenditem_calculateautomargin_isbase = false;
            return QCPPolarLegendItem::calculateAutoMargin(side);
        } else if (qcppolarlegenditem_calculateautomargin_callback != nullptr) {
            int cbval1 = static_cast<int>(side);

            int callback_ret = qcppolarlegenditem_calculateautomargin_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPPolarLegendItem::calculateAutoMargin(side);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void layoutChanged() override {
        if (qcppolarlegenditem_layoutchanged_isbase) {
            qcppolarlegenditem_layoutchanged_isbase = false;
            QCPPolarLegendItem::layoutChanged();
        } else if (qcppolarlegenditem_layoutchanged_callback != nullptr) {
            qcppolarlegenditem_layoutchanged_callback();
        } else {
            QCPPolarLegendItem::layoutChanged();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcppolarlegenditem_parentplotinitialized_isbase) {
            qcppolarlegenditem_parentplotinitialized_isbase = false;
            QCPPolarLegendItem::parentPlotInitialized(parentPlot);
        } else if (qcppolarlegenditem_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcppolarlegenditem_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPPolarLegendItem::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcppolarlegenditem_mousepressevent_isbase) {
            qcppolarlegenditem_mousepressevent_isbase = false;
            QCPPolarLegendItem::mousePressEvent(event, details);
        } else if (qcppolarlegenditem_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcppolarlegenditem_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPPolarLegendItem::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcppolarlegenditem_mousemoveevent_isbase) {
            qcppolarlegenditem_mousemoveevent_isbase = false;
            QCPPolarLegendItem::mouseMoveEvent(event, startPos);
        } else if (qcppolarlegenditem_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcppolarlegenditem_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPPolarLegendItem::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcppolarlegenditem_mousereleaseevent_isbase) {
            qcppolarlegenditem_mousereleaseevent_isbase = false;
            QCPPolarLegendItem::mouseReleaseEvent(event, startPos);
        } else if (qcppolarlegenditem_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcppolarlegenditem_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPPolarLegendItem::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcppolarlegenditem_mousedoubleclickevent_isbase) {
            qcppolarlegenditem_mousedoubleclickevent_isbase = false;
            QCPPolarLegendItem::mouseDoubleClickEvent(event, details);
        } else if (qcppolarlegenditem_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcppolarlegenditem_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPPolarLegendItem::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcppolarlegenditem_wheelevent_isbase) {
            qcppolarlegenditem_wheelevent_isbase = false;
            QCPPolarLegendItem::wheelEvent(event);
        } else if (qcppolarlegenditem_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcppolarlegenditem_wheelevent_callback(this, cbval1);
        } else {
            QCPPolarLegendItem::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcppolarlegenditem_event_isbase) {
            qcppolarlegenditem_event_isbase = false;
            return QCPPolarLegendItem::event(event);
        } else if (qcppolarlegenditem_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcppolarlegenditem_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPPolarLegendItem::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcppolarlegenditem_eventfilter_isbase) {
            qcppolarlegenditem_eventfilter_isbase = false;
            return QCPPolarLegendItem::eventFilter(watched, event);
        } else if (qcppolarlegenditem_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcppolarlegenditem_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPPolarLegendItem::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcppolarlegenditem_timerevent_isbase) {
            qcppolarlegenditem_timerevent_isbase = false;
            QCPPolarLegendItem::timerEvent(event);
        } else if (qcppolarlegenditem_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcppolarlegenditem_timerevent_callback(this, cbval1);
        } else {
            QCPPolarLegendItem::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcppolarlegenditem_childevent_isbase) {
            qcppolarlegenditem_childevent_isbase = false;
            QCPPolarLegendItem::childEvent(event);
        } else if (qcppolarlegenditem_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcppolarlegenditem_childevent_callback(this, cbval1);
        } else {
            QCPPolarLegendItem::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcppolarlegenditem_customevent_isbase) {
            qcppolarlegenditem_customevent_isbase = false;
            QCPPolarLegendItem::customEvent(event);
        } else if (qcppolarlegenditem_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcppolarlegenditem_customevent_callback(this, cbval1);
        } else {
            QCPPolarLegendItem::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcppolarlegenditem_connectnotify_isbase) {
            qcppolarlegenditem_connectnotify_isbase = false;
            QCPPolarLegendItem::connectNotify(signal);
        } else if (qcppolarlegenditem_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcppolarlegenditem_connectnotify_callback(this, cbval1);
        } else {
            QCPPolarLegendItem::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcppolarlegenditem_disconnectnotify_isbase) {
            qcppolarlegenditem_disconnectnotify_isbase = false;
            QCPPolarLegendItem::disconnectNotify(signal);
        } else if (qcppolarlegenditem_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcppolarlegenditem_disconnectnotify_callback(this, cbval1);
        } else {
            QCPPolarLegendItem::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    QPen getIconBorderPen() const {
        if (qcppolarlegenditem_geticonborderpen_isbase) {
            qcppolarlegenditem_geticonborderpen_isbase = false;
            return QCPPolarLegendItem::getIconBorderPen();
        } else if (qcppolarlegenditem_geticonborderpen_callback != nullptr) {
            QPen* callback_ret = qcppolarlegenditem_geticonborderpen_callback();
            return *callback_ret;
        } else {
            return QCPPolarLegendItem::getIconBorderPen();
        }
    }

    // Virtual method for C ABI access and custom callback
    QColor getTextColor() const {
        if (qcppolarlegenditem_gettextcolor_isbase) {
            qcppolarlegenditem_gettextcolor_isbase = false;
            return QCPPolarLegendItem::getTextColor();
        } else if (qcppolarlegenditem_gettextcolor_callback != nullptr) {
            QColor* callback_ret = qcppolarlegenditem_gettextcolor_callback();
            return *callback_ret;
        } else {
            return QCPPolarLegendItem::getTextColor();
        }
    }

    // Virtual method for C ABI access and custom callback
    QFont getFont() const {
        if (qcppolarlegenditem_getfont_isbase) {
            qcppolarlegenditem_getfont_isbase = false;
            return QCPPolarLegendItem::getFont();
        } else if (qcppolarlegenditem_getfont_callback != nullptr) {
            QFont* callback_ret = qcppolarlegenditem_getfont_callback();
            return *callback_ret;
        } else {
            return QCPPolarLegendItem::getFont();
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcppolarlegenditem_initializeparentplot_isbase) {
            qcppolarlegenditem_initializeparentplot_isbase = false;
            QCPPolarLegendItem::initializeParentPlot(parentPlot);
        } else if (qcppolarlegenditem_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcppolarlegenditem_initializeparentplot_callback(this, cbval1);
        } else {
            QCPPolarLegendItem::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcppolarlegenditem_setparentlayerable_isbase) {
            qcppolarlegenditem_setparentlayerable_isbase = false;
            QCPPolarLegendItem::setParentLayerable(parentLayerable);
        } else if (qcppolarlegenditem_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcppolarlegenditem_setparentlayerable_callback(this, cbval1);
        } else {
            QCPPolarLegendItem::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcppolarlegenditem_movetolayer_isbase) {
            qcppolarlegenditem_movetolayer_isbase = false;
            return QCPPolarLegendItem::moveToLayer(layer, prepend);
        } else if (qcppolarlegenditem_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcppolarlegenditem_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPPolarLegendItem::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcppolarlegenditem_applyantialiasinghint_isbase) {
            qcppolarlegenditem_applyantialiasinghint_isbase = false;
            QCPPolarLegendItem::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcppolarlegenditem_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcppolarlegenditem_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPPolarLegendItem::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcppolarlegenditem_sender_isbase) {
            qcppolarlegenditem_sender_isbase = false;
            return QCPPolarLegendItem::sender();
        } else if (qcppolarlegenditem_sender_callback != nullptr) {
            QObject* callback_ret = qcppolarlegenditem_sender_callback();
            return callback_ret;
        } else {
            return QCPPolarLegendItem::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcppolarlegenditem_sendersignalindex_isbase) {
            qcppolarlegenditem_sendersignalindex_isbase = false;
            return QCPPolarLegendItem::senderSignalIndex();
        } else if (qcppolarlegenditem_sendersignalindex_callback != nullptr) {
            int callback_ret = qcppolarlegenditem_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPPolarLegendItem::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcppolarlegenditem_receivers_isbase) {
            qcppolarlegenditem_receivers_isbase = false;
            return QCPPolarLegendItem::receivers(signal);
        } else if (qcppolarlegenditem_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcppolarlegenditem_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPPolarLegendItem::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcppolarlegenditem_issignalconnected_isbase) {
            qcppolarlegenditem_issignalconnected_isbase = false;
            return QCPPolarLegendItem::isSignalConnected(signal);
        } else if (qcppolarlegenditem_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcppolarlegenditem_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPPolarLegendItem::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend void QCPPolarLegendItem_Draw(QCPPolarLegendItem* self, QCPPainter* painter);
    friend void QCPPolarLegendItem_QBaseDraw(QCPPolarLegendItem* self, QCPPainter* painter);
    friend QSize* QCPPolarLegendItem_MinimumOuterSizeHint(const QCPPolarLegendItem* self);
    friend QSize* QCPPolarLegendItem_QBaseMinimumOuterSizeHint(const QCPPolarLegendItem* self);
    friend int QCPPolarLegendItem_SelectionCategory(const QCPPolarLegendItem* self);
    friend int QCPPolarLegendItem_QBaseSelectionCategory(const QCPPolarLegendItem* self);
    friend void QCPPolarLegendItem_ApplyDefaultAntialiasingHint(const QCPPolarLegendItem* self, QCPPainter* painter);
    friend void QCPPolarLegendItem_QBaseApplyDefaultAntialiasingHint(const QCPPolarLegendItem* self, QCPPainter* painter);
    friend QRect* QCPPolarLegendItem_ClipRect(const QCPPolarLegendItem* self);
    friend QRect* QCPPolarLegendItem_QBaseClipRect(const QCPPolarLegendItem* self);
    friend void QCPPolarLegendItem_SelectEvent(QCPPolarLegendItem* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPPolarLegendItem_QBaseSelectEvent(QCPPolarLegendItem* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPPolarLegendItem_DeselectEvent(QCPPolarLegendItem* self, bool* selectionStateChanged);
    friend void QCPPolarLegendItem_QBaseDeselectEvent(QCPPolarLegendItem* self, bool* selectionStateChanged);
    friend int QCPPolarLegendItem_CalculateAutoMargin(QCPPolarLegendItem* self, int side);
    friend int QCPPolarLegendItem_QBaseCalculateAutoMargin(QCPPolarLegendItem* self, int side);
    friend void QCPPolarLegendItem_LayoutChanged(QCPPolarLegendItem* self);
    friend void QCPPolarLegendItem_QBaseLayoutChanged(QCPPolarLegendItem* self);
    friend void QCPPolarLegendItem_ParentPlotInitialized(QCPPolarLegendItem* self, QCustomPlot* parentPlot);
    friend void QCPPolarLegendItem_QBaseParentPlotInitialized(QCPPolarLegendItem* self, QCustomPlot* parentPlot);
    friend void QCPPolarLegendItem_MousePressEvent(QCPPolarLegendItem* self, QMouseEvent* event, const QVariant* details);
    friend void QCPPolarLegendItem_QBaseMousePressEvent(QCPPolarLegendItem* self, QMouseEvent* event, const QVariant* details);
    friend void QCPPolarLegendItem_MouseMoveEvent(QCPPolarLegendItem* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPPolarLegendItem_QBaseMouseMoveEvent(QCPPolarLegendItem* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPPolarLegendItem_MouseReleaseEvent(QCPPolarLegendItem* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPPolarLegendItem_QBaseMouseReleaseEvent(QCPPolarLegendItem* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPPolarLegendItem_MouseDoubleClickEvent(QCPPolarLegendItem* self, QMouseEvent* event, const QVariant* details);
    friend void QCPPolarLegendItem_QBaseMouseDoubleClickEvent(QCPPolarLegendItem* self, QMouseEvent* event, const QVariant* details);
    friend void QCPPolarLegendItem_WheelEvent(QCPPolarLegendItem* self, QWheelEvent* event);
    friend void QCPPolarLegendItem_QBaseWheelEvent(QCPPolarLegendItem* self, QWheelEvent* event);
    friend void QCPPolarLegendItem_TimerEvent(QCPPolarLegendItem* self, QTimerEvent* event);
    friend void QCPPolarLegendItem_QBaseTimerEvent(QCPPolarLegendItem* self, QTimerEvent* event);
    friend void QCPPolarLegendItem_ChildEvent(QCPPolarLegendItem* self, QChildEvent* event);
    friend void QCPPolarLegendItem_QBaseChildEvent(QCPPolarLegendItem* self, QChildEvent* event);
    friend void QCPPolarLegendItem_CustomEvent(QCPPolarLegendItem* self, QEvent* event);
    friend void QCPPolarLegendItem_QBaseCustomEvent(QCPPolarLegendItem* self, QEvent* event);
    friend void QCPPolarLegendItem_ConnectNotify(QCPPolarLegendItem* self, const QMetaMethod* signal);
    friend void QCPPolarLegendItem_QBaseConnectNotify(QCPPolarLegendItem* self, const QMetaMethod* signal);
    friend void QCPPolarLegendItem_DisconnectNotify(QCPPolarLegendItem* self, const QMetaMethod* signal);
    friend void QCPPolarLegendItem_QBaseDisconnectNotify(QCPPolarLegendItem* self, const QMetaMethod* signal);
    friend QPen* QCPPolarLegendItem_GetIconBorderPen(const QCPPolarLegendItem* self);
    friend QPen* QCPPolarLegendItem_QBaseGetIconBorderPen(const QCPPolarLegendItem* self);
    friend QColor* QCPPolarLegendItem_GetTextColor(const QCPPolarLegendItem* self);
    friend QColor* QCPPolarLegendItem_QBaseGetTextColor(const QCPPolarLegendItem* self);
    friend QFont* QCPPolarLegendItem_GetFont(const QCPPolarLegendItem* self);
    friend QFont* QCPPolarLegendItem_QBaseGetFont(const QCPPolarLegendItem* self);
    friend void QCPPolarLegendItem_InitializeParentPlot(QCPPolarLegendItem* self, QCustomPlot* parentPlot);
    friend void QCPPolarLegendItem_QBaseInitializeParentPlot(QCPPolarLegendItem* self, QCustomPlot* parentPlot);
    friend void QCPPolarLegendItem_SetParentLayerable(QCPPolarLegendItem* self, QCPLayerable* parentLayerable);
    friend void QCPPolarLegendItem_QBaseSetParentLayerable(QCPPolarLegendItem* self, QCPLayerable* parentLayerable);
    friend bool QCPPolarLegendItem_MoveToLayer(QCPPolarLegendItem* self, QCPLayer* layer, bool prepend);
    friend bool QCPPolarLegendItem_QBaseMoveToLayer(QCPPolarLegendItem* self, QCPLayer* layer, bool prepend);
    friend void QCPPolarLegendItem_ApplyAntialiasingHint(const QCPPolarLegendItem* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPPolarLegendItem_QBaseApplyAntialiasingHint(const QCPPolarLegendItem* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPPolarLegendItem_Sender(const QCPPolarLegendItem* self);
    friend QObject* QCPPolarLegendItem_QBaseSender(const QCPPolarLegendItem* self);
    friend int QCPPolarLegendItem_SenderSignalIndex(const QCPPolarLegendItem* self);
    friend int QCPPolarLegendItem_QBaseSenderSignalIndex(const QCPPolarLegendItem* self);
    friend int QCPPolarLegendItem_Receivers(const QCPPolarLegendItem* self, const char* signal);
    friend int QCPPolarLegendItem_QBaseReceivers(const QCPPolarLegendItem* self, const char* signal);
    friend bool QCPPolarLegendItem_IsSignalConnected(const QCPPolarLegendItem* self, const QMetaMethod* signal);
    friend bool QCPPolarLegendItem_QBaseIsSignalConnected(const QCPPolarLegendItem* self, const QMetaMethod* signal);
};

// This class is a subclass of QCPPolarGraph so that we can call protected methods
class VirtualQCPPolarGraph final : public QCPPolarGraph {

  public:
    // Virtual class boolean flag
    bool isVirtualQCPPolarGraph = true;

    // Virtual class public types (including callbacks)
    using QCPPolarGraph_Metacall_Callback = int (*)(QCPPolarGraph*, int, int, void**);
    using QCPPolarGraph_SelectTest_Callback = double (*)(const QCPPolarGraph*, QPointF*, bool, QVariant*);
    using QCPPolarGraph_Interface1D_Callback = QCPPlottableInterface1D* (*)();
    using QCPPolarGraph_GetKeyRange_Callback = QCPRange* (*)(const QCPPolarGraph*, bool*, int);
    using QCPPolarGraph_GetValueRange_Callback = QCPRange* (*)(const QCPPolarGraph*, bool*, int, QCPRange*);
    using QCPPolarGraph_ClipRect_Callback = QRect* (*)();
    using QCPPolarGraph_Draw_Callback = void (*)(QCPPolarGraph*, QCPPainter*);
    using QCPPolarGraph_SelectionCategory_Callback = int (*)();
    using QCPPolarGraph_SelectEvent_Callback = void (*)(QCPPolarGraph*, QMouseEvent*, bool, QVariant*, bool*);
    using QCPPolarGraph_DeselectEvent_Callback = void (*)(QCPPolarGraph*, bool*);
    using QCPPolarGraph_DrawLinePlot_Callback = void (*)(const QCPPolarGraph*, QCPPainter*, libqt_list /* of QPointF* */);
    using QCPPolarGraph_DrawFill_Callback = void (*)(const QCPPolarGraph*, QCPPainter*, libqt_list /* of QPointF* */);
    using QCPPolarGraph_DrawScatterPlot_Callback = void (*)(const QCPPolarGraph*, QCPPainter*, libqt_list /* of QPointF* */, QCPScatterStyle*);
    using QCPPolarGraph_DrawLegendIcon_Callback = void (*)(const QCPPolarGraph*, QCPPainter*, QRectF*);
    using QCPPolarGraph_DataCount_Callback = int (*)();
    using QCPPolarGraph_ParentPlotInitialized_Callback = void (*)(QCPPolarGraph*, QCustomPlot*);
    using QCPPolarGraph_ApplyDefaultAntialiasingHint_Callback = void (*)(const QCPPolarGraph*, QCPPainter*);
    using QCPPolarGraph_MousePressEvent_Callback = void (*)(QCPPolarGraph*, QMouseEvent*, QVariant*);
    using QCPPolarGraph_MouseMoveEvent_Callback = void (*)(QCPPolarGraph*, QMouseEvent*, QPointF*);
    using QCPPolarGraph_MouseReleaseEvent_Callback = void (*)(QCPPolarGraph*, QMouseEvent*, QPointF*);
    using QCPPolarGraph_MouseDoubleClickEvent_Callback = void (*)(QCPPolarGraph*, QMouseEvent*, QVariant*);
    using QCPPolarGraph_WheelEvent_Callback = void (*)(QCPPolarGraph*, QWheelEvent*);
    using QCPPolarGraph_Event_Callback = bool (*)(QCPPolarGraph*, QEvent*);
    using QCPPolarGraph_EventFilter_Callback = bool (*)(QCPPolarGraph*, QObject*, QEvent*);
    using QCPPolarGraph_TimerEvent_Callback = void (*)(QCPPolarGraph*, QTimerEvent*);
    using QCPPolarGraph_ChildEvent_Callback = void (*)(QCPPolarGraph*, QChildEvent*);
    using QCPPolarGraph_CustomEvent_Callback = void (*)(QCPPolarGraph*, QEvent*);
    using QCPPolarGraph_ConnectNotify_Callback = void (*)(QCPPolarGraph*, QMetaMethod*);
    using QCPPolarGraph_DisconnectNotify_Callback = void (*)(QCPPolarGraph*, QMetaMethod*);
    using QCPPolarGraph_ApplyFillAntialiasingHint_Callback = void (*)(const QCPPolarGraph*, QCPPainter*);
    using QCPPolarGraph_ApplyScattersAntialiasingHint_Callback = void (*)(const QCPPolarGraph*, QCPPainter*);
    using QCPPolarGraph_GetDataSegments_Callback = void (*)(const QCPPolarGraph*, libqt_list /* of QCPDataRange* */, libqt_list /* of QCPDataRange* */);
    using QCPPolarGraph_DrawPolyline_Callback = void (*)(const QCPPolarGraph*, QCPPainter*, libqt_list /* of QPointF* */);
    using QCPPolarGraph_GetLines_Callback = void (*)(const QCPPolarGraph*, libqt_list /* of QPointF* */, QCPDataRange*);
    using QCPPolarGraph_GetScatters_Callback = void (*)(const QCPPolarGraph*, libqt_list /* of QPointF* */, QCPDataRange*);
    using QCPPolarGraph_DataToLines_Callback = QPointF** (*)(const QCPPolarGraph*, libqt_list /* of QCPGraphData* */);
    using QCPPolarGraph_InitializeParentPlot_Callback = void (*)(QCPPolarGraph*, QCustomPlot*);
    using QCPPolarGraph_SetParentLayerable_Callback = void (*)(QCPPolarGraph*, QCPLayerable*);
    using QCPPolarGraph_MoveToLayer_Callback = bool (*)(QCPPolarGraph*, QCPLayer*, bool);
    using QCPPolarGraph_ApplyAntialiasingHint_Callback = void (*)(const QCPPolarGraph*, QCPPainter*, bool, int);
    using QCPPolarGraph_Sender_Callback = QObject* (*)();
    using QCPPolarGraph_SenderSignalIndex_Callback = int (*)();
    using QCPPolarGraph_Receivers_Callback = int (*)(const QCPPolarGraph*, const char*);
    using QCPPolarGraph_IsSignalConnected_Callback = bool (*)(const QCPPolarGraph*, QMetaMethod*);

  protected:
    // Instance callback storage
    QCPPolarGraph_Metacall_Callback qcppolargraph_metacall_callback = nullptr;
    QCPPolarGraph_SelectTest_Callback qcppolargraph_selecttest_callback = nullptr;
    QCPPolarGraph_Interface1D_Callback qcppolargraph_interface1d_callback = nullptr;
    QCPPolarGraph_GetKeyRange_Callback qcppolargraph_getkeyrange_callback = nullptr;
    QCPPolarGraph_GetValueRange_Callback qcppolargraph_getvaluerange_callback = nullptr;
    QCPPolarGraph_ClipRect_Callback qcppolargraph_cliprect_callback = nullptr;
    QCPPolarGraph_Draw_Callback qcppolargraph_draw_callback = nullptr;
    QCPPolarGraph_SelectionCategory_Callback qcppolargraph_selectioncategory_callback = nullptr;
    QCPPolarGraph_SelectEvent_Callback qcppolargraph_selectevent_callback = nullptr;
    QCPPolarGraph_DeselectEvent_Callback qcppolargraph_deselectevent_callback = nullptr;
    QCPPolarGraph_DrawLinePlot_Callback qcppolargraph_drawlineplot_callback = nullptr;
    QCPPolarGraph_DrawFill_Callback qcppolargraph_drawfill_callback = nullptr;
    QCPPolarGraph_DrawScatterPlot_Callback qcppolargraph_drawscatterplot_callback = nullptr;
    QCPPolarGraph_DrawLegendIcon_Callback qcppolargraph_drawlegendicon_callback = nullptr;
    QCPPolarGraph_DataCount_Callback qcppolargraph_datacount_callback = nullptr;
    QCPPolarGraph_ParentPlotInitialized_Callback qcppolargraph_parentplotinitialized_callback = nullptr;
    QCPPolarGraph_ApplyDefaultAntialiasingHint_Callback qcppolargraph_applydefaultantialiasinghint_callback = nullptr;
    QCPPolarGraph_MousePressEvent_Callback qcppolargraph_mousepressevent_callback = nullptr;
    QCPPolarGraph_MouseMoveEvent_Callback qcppolargraph_mousemoveevent_callback = nullptr;
    QCPPolarGraph_MouseReleaseEvent_Callback qcppolargraph_mousereleaseevent_callback = nullptr;
    QCPPolarGraph_MouseDoubleClickEvent_Callback qcppolargraph_mousedoubleclickevent_callback = nullptr;
    QCPPolarGraph_WheelEvent_Callback qcppolargraph_wheelevent_callback = nullptr;
    QCPPolarGraph_Event_Callback qcppolargraph_event_callback = nullptr;
    QCPPolarGraph_EventFilter_Callback qcppolargraph_eventfilter_callback = nullptr;
    QCPPolarGraph_TimerEvent_Callback qcppolargraph_timerevent_callback = nullptr;
    QCPPolarGraph_ChildEvent_Callback qcppolargraph_childevent_callback = nullptr;
    QCPPolarGraph_CustomEvent_Callback qcppolargraph_customevent_callback = nullptr;
    QCPPolarGraph_ConnectNotify_Callback qcppolargraph_connectnotify_callback = nullptr;
    QCPPolarGraph_DisconnectNotify_Callback qcppolargraph_disconnectnotify_callback = nullptr;
    QCPPolarGraph_ApplyFillAntialiasingHint_Callback qcppolargraph_applyfillantialiasinghint_callback = nullptr;
    QCPPolarGraph_ApplyScattersAntialiasingHint_Callback qcppolargraph_applyscattersantialiasinghint_callback = nullptr;
    QCPPolarGraph_GetDataSegments_Callback qcppolargraph_getdatasegments_callback = nullptr;
    QCPPolarGraph_DrawPolyline_Callback qcppolargraph_drawpolyline_callback = nullptr;
    QCPPolarGraph_GetLines_Callback qcppolargraph_getlines_callback = nullptr;
    QCPPolarGraph_GetScatters_Callback qcppolargraph_getscatters_callback = nullptr;
    QCPPolarGraph_DataToLines_Callback qcppolargraph_datatolines_callback = nullptr;
    QCPPolarGraph_InitializeParentPlot_Callback qcppolargraph_initializeparentplot_callback = nullptr;
    QCPPolarGraph_SetParentLayerable_Callback qcppolargraph_setparentlayerable_callback = nullptr;
    QCPPolarGraph_MoveToLayer_Callback qcppolargraph_movetolayer_callback = nullptr;
    QCPPolarGraph_ApplyAntialiasingHint_Callback qcppolargraph_applyantialiasinghint_callback = nullptr;
    QCPPolarGraph_Sender_Callback qcppolargraph_sender_callback = nullptr;
    QCPPolarGraph_SenderSignalIndex_Callback qcppolargraph_sendersignalindex_callback = nullptr;
    QCPPolarGraph_Receivers_Callback qcppolargraph_receivers_callback = nullptr;
    QCPPolarGraph_IsSignalConnected_Callback qcppolargraph_issignalconnected_callback = nullptr;

    // Instance base flags
    mutable bool qcppolargraph_metacall_isbase = false;
    mutable bool qcppolargraph_selecttest_isbase = false;
    mutable bool qcppolargraph_interface1d_isbase = false;
    mutable bool qcppolargraph_getkeyrange_isbase = false;
    mutable bool qcppolargraph_getvaluerange_isbase = false;
    mutable bool qcppolargraph_cliprect_isbase = false;
    mutable bool qcppolargraph_draw_isbase = false;
    mutable bool qcppolargraph_selectioncategory_isbase = false;
    mutable bool qcppolargraph_selectevent_isbase = false;
    mutable bool qcppolargraph_deselectevent_isbase = false;
    mutable bool qcppolargraph_drawlineplot_isbase = false;
    mutable bool qcppolargraph_drawfill_isbase = false;
    mutable bool qcppolargraph_drawscatterplot_isbase = false;
    mutable bool qcppolargraph_drawlegendicon_isbase = false;
    mutable bool qcppolargraph_datacount_isbase = false;
    mutable bool qcppolargraph_parentplotinitialized_isbase = false;
    mutable bool qcppolargraph_applydefaultantialiasinghint_isbase = false;
    mutable bool qcppolargraph_mousepressevent_isbase = false;
    mutable bool qcppolargraph_mousemoveevent_isbase = false;
    mutable bool qcppolargraph_mousereleaseevent_isbase = false;
    mutable bool qcppolargraph_mousedoubleclickevent_isbase = false;
    mutable bool qcppolargraph_wheelevent_isbase = false;
    mutable bool qcppolargraph_event_isbase = false;
    mutable bool qcppolargraph_eventfilter_isbase = false;
    mutable bool qcppolargraph_timerevent_isbase = false;
    mutable bool qcppolargraph_childevent_isbase = false;
    mutable bool qcppolargraph_customevent_isbase = false;
    mutable bool qcppolargraph_connectnotify_isbase = false;
    mutable bool qcppolargraph_disconnectnotify_isbase = false;
    mutable bool qcppolargraph_applyfillantialiasinghint_isbase = false;
    mutable bool qcppolargraph_applyscattersantialiasinghint_isbase = false;
    mutable bool qcppolargraph_getdatasegments_isbase = false;
    mutable bool qcppolargraph_drawpolyline_isbase = false;
    mutable bool qcppolargraph_getlines_isbase = false;
    mutable bool qcppolargraph_getscatters_isbase = false;
    mutable bool qcppolargraph_datatolines_isbase = false;
    mutable bool qcppolargraph_initializeparentplot_isbase = false;
    mutable bool qcppolargraph_setparentlayerable_isbase = false;
    mutable bool qcppolargraph_movetolayer_isbase = false;
    mutable bool qcppolargraph_applyantialiasinghint_isbase = false;
    mutable bool qcppolargraph_sender_isbase = false;
    mutable bool qcppolargraph_sendersignalindex_isbase = false;
    mutable bool qcppolargraph_receivers_isbase = false;
    mutable bool qcppolargraph_issignalconnected_isbase = false;

  public:
    VirtualQCPPolarGraph(QCPPolarAxisAngular* keyAxis, QCPPolarAxisRadial* valueAxis) : QCPPolarGraph(keyAxis, valueAxis) {};

    ~VirtualQCPPolarGraph() {
        qcppolargraph_metacall_callback = nullptr;
        qcppolargraph_selecttest_callback = nullptr;
        qcppolargraph_interface1d_callback = nullptr;
        qcppolargraph_getkeyrange_callback = nullptr;
        qcppolargraph_getvaluerange_callback = nullptr;
        qcppolargraph_cliprect_callback = nullptr;
        qcppolargraph_draw_callback = nullptr;
        qcppolargraph_selectioncategory_callback = nullptr;
        qcppolargraph_selectevent_callback = nullptr;
        qcppolargraph_deselectevent_callback = nullptr;
        qcppolargraph_drawlineplot_callback = nullptr;
        qcppolargraph_drawfill_callback = nullptr;
        qcppolargraph_drawscatterplot_callback = nullptr;
        qcppolargraph_drawlegendicon_callback = nullptr;
        qcppolargraph_datacount_callback = nullptr;
        qcppolargraph_parentplotinitialized_callback = nullptr;
        qcppolargraph_applydefaultantialiasinghint_callback = nullptr;
        qcppolargraph_mousepressevent_callback = nullptr;
        qcppolargraph_mousemoveevent_callback = nullptr;
        qcppolargraph_mousereleaseevent_callback = nullptr;
        qcppolargraph_mousedoubleclickevent_callback = nullptr;
        qcppolargraph_wheelevent_callback = nullptr;
        qcppolargraph_event_callback = nullptr;
        qcppolargraph_eventfilter_callback = nullptr;
        qcppolargraph_timerevent_callback = nullptr;
        qcppolargraph_childevent_callback = nullptr;
        qcppolargraph_customevent_callback = nullptr;
        qcppolargraph_connectnotify_callback = nullptr;
        qcppolargraph_disconnectnotify_callback = nullptr;
        qcppolargraph_applyfillantialiasinghint_callback = nullptr;
        qcppolargraph_applyscattersantialiasinghint_callback = nullptr;
        qcppolargraph_getdatasegments_callback = nullptr;
        qcppolargraph_drawpolyline_callback = nullptr;
        qcppolargraph_getlines_callback = nullptr;
        qcppolargraph_getscatters_callback = nullptr;
        qcppolargraph_datatolines_callback = nullptr;
        qcppolargraph_initializeparentplot_callback = nullptr;
        qcppolargraph_setparentlayerable_callback = nullptr;
        qcppolargraph_movetolayer_callback = nullptr;
        qcppolargraph_applyantialiasinghint_callback = nullptr;
        qcppolargraph_sender_callback = nullptr;
        qcppolargraph_sendersignalindex_callback = nullptr;
        qcppolargraph_receivers_callback = nullptr;
        qcppolargraph_issignalconnected_callback = nullptr;
    }

    // Callback setters
    inline void setQCPPolarGraph_Metacall_Callback(QCPPolarGraph_Metacall_Callback cb) { qcppolargraph_metacall_callback = cb; }
    inline void setQCPPolarGraph_SelectTest_Callback(QCPPolarGraph_SelectTest_Callback cb) { qcppolargraph_selecttest_callback = cb; }
    inline void setQCPPolarGraph_Interface1D_Callback(QCPPolarGraph_Interface1D_Callback cb) { qcppolargraph_interface1d_callback = cb; }
    inline void setQCPPolarGraph_GetKeyRange_Callback(QCPPolarGraph_GetKeyRange_Callback cb) { qcppolargraph_getkeyrange_callback = cb; }
    inline void setQCPPolarGraph_GetValueRange_Callback(QCPPolarGraph_GetValueRange_Callback cb) { qcppolargraph_getvaluerange_callback = cb; }
    inline void setQCPPolarGraph_ClipRect_Callback(QCPPolarGraph_ClipRect_Callback cb) { qcppolargraph_cliprect_callback = cb; }
    inline void setQCPPolarGraph_Draw_Callback(QCPPolarGraph_Draw_Callback cb) { qcppolargraph_draw_callback = cb; }
    inline void setQCPPolarGraph_SelectionCategory_Callback(QCPPolarGraph_SelectionCategory_Callback cb) { qcppolargraph_selectioncategory_callback = cb; }
    inline void setQCPPolarGraph_SelectEvent_Callback(QCPPolarGraph_SelectEvent_Callback cb) { qcppolargraph_selectevent_callback = cb; }
    inline void setQCPPolarGraph_DeselectEvent_Callback(QCPPolarGraph_DeselectEvent_Callback cb) { qcppolargraph_deselectevent_callback = cb; }
    inline void setQCPPolarGraph_DrawLinePlot_Callback(QCPPolarGraph_DrawLinePlot_Callback cb) { qcppolargraph_drawlineplot_callback = cb; }
    inline void setQCPPolarGraph_DrawFill_Callback(QCPPolarGraph_DrawFill_Callback cb) { qcppolargraph_drawfill_callback = cb; }
    inline void setQCPPolarGraph_DrawScatterPlot_Callback(QCPPolarGraph_DrawScatterPlot_Callback cb) { qcppolargraph_drawscatterplot_callback = cb; }
    inline void setQCPPolarGraph_DrawLegendIcon_Callback(QCPPolarGraph_DrawLegendIcon_Callback cb) { qcppolargraph_drawlegendicon_callback = cb; }
    inline void setQCPPolarGraph_DataCount_Callback(QCPPolarGraph_DataCount_Callback cb) { qcppolargraph_datacount_callback = cb; }
    inline void setQCPPolarGraph_ParentPlotInitialized_Callback(QCPPolarGraph_ParentPlotInitialized_Callback cb) { qcppolargraph_parentplotinitialized_callback = cb; }
    inline void setQCPPolarGraph_ApplyDefaultAntialiasingHint_Callback(QCPPolarGraph_ApplyDefaultAntialiasingHint_Callback cb) { qcppolargraph_applydefaultantialiasinghint_callback = cb; }
    inline void setQCPPolarGraph_MousePressEvent_Callback(QCPPolarGraph_MousePressEvent_Callback cb) { qcppolargraph_mousepressevent_callback = cb; }
    inline void setQCPPolarGraph_MouseMoveEvent_Callback(QCPPolarGraph_MouseMoveEvent_Callback cb) { qcppolargraph_mousemoveevent_callback = cb; }
    inline void setQCPPolarGraph_MouseReleaseEvent_Callback(QCPPolarGraph_MouseReleaseEvent_Callback cb) { qcppolargraph_mousereleaseevent_callback = cb; }
    inline void setQCPPolarGraph_MouseDoubleClickEvent_Callback(QCPPolarGraph_MouseDoubleClickEvent_Callback cb) { qcppolargraph_mousedoubleclickevent_callback = cb; }
    inline void setQCPPolarGraph_WheelEvent_Callback(QCPPolarGraph_WheelEvent_Callback cb) { qcppolargraph_wheelevent_callback = cb; }
    inline void setQCPPolarGraph_Event_Callback(QCPPolarGraph_Event_Callback cb) { qcppolargraph_event_callback = cb; }
    inline void setQCPPolarGraph_EventFilter_Callback(QCPPolarGraph_EventFilter_Callback cb) { qcppolargraph_eventfilter_callback = cb; }
    inline void setQCPPolarGraph_TimerEvent_Callback(QCPPolarGraph_TimerEvent_Callback cb) { qcppolargraph_timerevent_callback = cb; }
    inline void setQCPPolarGraph_ChildEvent_Callback(QCPPolarGraph_ChildEvent_Callback cb) { qcppolargraph_childevent_callback = cb; }
    inline void setQCPPolarGraph_CustomEvent_Callback(QCPPolarGraph_CustomEvent_Callback cb) { qcppolargraph_customevent_callback = cb; }
    inline void setQCPPolarGraph_ConnectNotify_Callback(QCPPolarGraph_ConnectNotify_Callback cb) { qcppolargraph_connectnotify_callback = cb; }
    inline void setQCPPolarGraph_DisconnectNotify_Callback(QCPPolarGraph_DisconnectNotify_Callback cb) { qcppolargraph_disconnectnotify_callback = cb; }
    inline void setQCPPolarGraph_ApplyFillAntialiasingHint_Callback(QCPPolarGraph_ApplyFillAntialiasingHint_Callback cb) { qcppolargraph_applyfillantialiasinghint_callback = cb; }
    inline void setQCPPolarGraph_ApplyScattersAntialiasingHint_Callback(QCPPolarGraph_ApplyScattersAntialiasingHint_Callback cb) { qcppolargraph_applyscattersantialiasinghint_callback = cb; }
    inline void setQCPPolarGraph_GetDataSegments_Callback(QCPPolarGraph_GetDataSegments_Callback cb) { qcppolargraph_getdatasegments_callback = cb; }
    inline void setQCPPolarGraph_DrawPolyline_Callback(QCPPolarGraph_DrawPolyline_Callback cb) { qcppolargraph_drawpolyline_callback = cb; }
    inline void setQCPPolarGraph_GetLines_Callback(QCPPolarGraph_GetLines_Callback cb) { qcppolargraph_getlines_callback = cb; }
    inline void setQCPPolarGraph_GetScatters_Callback(QCPPolarGraph_GetScatters_Callback cb) { qcppolargraph_getscatters_callback = cb; }
    inline void setQCPPolarGraph_DataToLines_Callback(QCPPolarGraph_DataToLines_Callback cb) { qcppolargraph_datatolines_callback = cb; }
    inline void setQCPPolarGraph_InitializeParentPlot_Callback(QCPPolarGraph_InitializeParentPlot_Callback cb) { qcppolargraph_initializeparentplot_callback = cb; }
    inline void setQCPPolarGraph_SetParentLayerable_Callback(QCPPolarGraph_SetParentLayerable_Callback cb) { qcppolargraph_setparentlayerable_callback = cb; }
    inline void setQCPPolarGraph_MoveToLayer_Callback(QCPPolarGraph_MoveToLayer_Callback cb) { qcppolargraph_movetolayer_callback = cb; }
    inline void setQCPPolarGraph_ApplyAntialiasingHint_Callback(QCPPolarGraph_ApplyAntialiasingHint_Callback cb) { qcppolargraph_applyantialiasinghint_callback = cb; }
    inline void setQCPPolarGraph_Sender_Callback(QCPPolarGraph_Sender_Callback cb) { qcppolargraph_sender_callback = cb; }
    inline void setQCPPolarGraph_SenderSignalIndex_Callback(QCPPolarGraph_SenderSignalIndex_Callback cb) { qcppolargraph_sendersignalindex_callback = cb; }
    inline void setQCPPolarGraph_Receivers_Callback(QCPPolarGraph_Receivers_Callback cb) { qcppolargraph_receivers_callback = cb; }
    inline void setQCPPolarGraph_IsSignalConnected_Callback(QCPPolarGraph_IsSignalConnected_Callback cb) { qcppolargraph_issignalconnected_callback = cb; }

    // Base flag setters
    inline void setQCPPolarGraph_Metacall_IsBase(bool value) const { qcppolargraph_metacall_isbase = value; }
    inline void setQCPPolarGraph_SelectTest_IsBase(bool value) const { qcppolargraph_selecttest_isbase = value; }
    inline void setQCPPolarGraph_Interface1D_IsBase(bool value) const { qcppolargraph_interface1d_isbase = value; }
    inline void setQCPPolarGraph_GetKeyRange_IsBase(bool value) const { qcppolargraph_getkeyrange_isbase = value; }
    inline void setQCPPolarGraph_GetValueRange_IsBase(bool value) const { qcppolargraph_getvaluerange_isbase = value; }
    inline void setQCPPolarGraph_ClipRect_IsBase(bool value) const { qcppolargraph_cliprect_isbase = value; }
    inline void setQCPPolarGraph_Draw_IsBase(bool value) const { qcppolargraph_draw_isbase = value; }
    inline void setQCPPolarGraph_SelectionCategory_IsBase(bool value) const { qcppolargraph_selectioncategory_isbase = value; }
    inline void setQCPPolarGraph_SelectEvent_IsBase(bool value) const { qcppolargraph_selectevent_isbase = value; }
    inline void setQCPPolarGraph_DeselectEvent_IsBase(bool value) const { qcppolargraph_deselectevent_isbase = value; }
    inline void setQCPPolarGraph_DrawLinePlot_IsBase(bool value) const { qcppolargraph_drawlineplot_isbase = value; }
    inline void setQCPPolarGraph_DrawFill_IsBase(bool value) const { qcppolargraph_drawfill_isbase = value; }
    inline void setQCPPolarGraph_DrawScatterPlot_IsBase(bool value) const { qcppolargraph_drawscatterplot_isbase = value; }
    inline void setQCPPolarGraph_DrawLegendIcon_IsBase(bool value) const { qcppolargraph_drawlegendicon_isbase = value; }
    inline void setQCPPolarGraph_DataCount_IsBase(bool value) const { qcppolargraph_datacount_isbase = value; }
    inline void setQCPPolarGraph_ParentPlotInitialized_IsBase(bool value) const { qcppolargraph_parentplotinitialized_isbase = value; }
    inline void setQCPPolarGraph_ApplyDefaultAntialiasingHint_IsBase(bool value) const { qcppolargraph_applydefaultantialiasinghint_isbase = value; }
    inline void setQCPPolarGraph_MousePressEvent_IsBase(bool value) const { qcppolargraph_mousepressevent_isbase = value; }
    inline void setQCPPolarGraph_MouseMoveEvent_IsBase(bool value) const { qcppolargraph_mousemoveevent_isbase = value; }
    inline void setQCPPolarGraph_MouseReleaseEvent_IsBase(bool value) const { qcppolargraph_mousereleaseevent_isbase = value; }
    inline void setQCPPolarGraph_MouseDoubleClickEvent_IsBase(bool value) const { qcppolargraph_mousedoubleclickevent_isbase = value; }
    inline void setQCPPolarGraph_WheelEvent_IsBase(bool value) const { qcppolargraph_wheelevent_isbase = value; }
    inline void setQCPPolarGraph_Event_IsBase(bool value) const { qcppolargraph_event_isbase = value; }
    inline void setQCPPolarGraph_EventFilter_IsBase(bool value) const { qcppolargraph_eventfilter_isbase = value; }
    inline void setQCPPolarGraph_TimerEvent_IsBase(bool value) const { qcppolargraph_timerevent_isbase = value; }
    inline void setQCPPolarGraph_ChildEvent_IsBase(bool value) const { qcppolargraph_childevent_isbase = value; }
    inline void setQCPPolarGraph_CustomEvent_IsBase(bool value) const { qcppolargraph_customevent_isbase = value; }
    inline void setQCPPolarGraph_ConnectNotify_IsBase(bool value) const { qcppolargraph_connectnotify_isbase = value; }
    inline void setQCPPolarGraph_DisconnectNotify_IsBase(bool value) const { qcppolargraph_disconnectnotify_isbase = value; }
    inline void setQCPPolarGraph_ApplyFillAntialiasingHint_IsBase(bool value) const { qcppolargraph_applyfillantialiasinghint_isbase = value; }
    inline void setQCPPolarGraph_ApplyScattersAntialiasingHint_IsBase(bool value) const { qcppolargraph_applyscattersantialiasinghint_isbase = value; }
    inline void setQCPPolarGraph_GetDataSegments_IsBase(bool value) const { qcppolargraph_getdatasegments_isbase = value; }
    inline void setQCPPolarGraph_DrawPolyline_IsBase(bool value) const { qcppolargraph_drawpolyline_isbase = value; }
    inline void setQCPPolarGraph_GetLines_IsBase(bool value) const { qcppolargraph_getlines_isbase = value; }
    inline void setQCPPolarGraph_GetScatters_IsBase(bool value) const { qcppolargraph_getscatters_isbase = value; }
    inline void setQCPPolarGraph_DataToLines_IsBase(bool value) const { qcppolargraph_datatolines_isbase = value; }
    inline void setQCPPolarGraph_InitializeParentPlot_IsBase(bool value) const { qcppolargraph_initializeparentplot_isbase = value; }
    inline void setQCPPolarGraph_SetParentLayerable_IsBase(bool value) const { qcppolargraph_setparentlayerable_isbase = value; }
    inline void setQCPPolarGraph_MoveToLayer_IsBase(bool value) const { qcppolargraph_movetolayer_isbase = value; }
    inline void setQCPPolarGraph_ApplyAntialiasingHint_IsBase(bool value) const { qcppolargraph_applyantialiasinghint_isbase = value; }
    inline void setQCPPolarGraph_Sender_IsBase(bool value) const { qcppolargraph_sender_isbase = value; }
    inline void setQCPPolarGraph_SenderSignalIndex_IsBase(bool value) const { qcppolargraph_sendersignalindex_isbase = value; }
    inline void setQCPPolarGraph_Receivers_IsBase(bool value) const { qcppolargraph_receivers_isbase = value; }
    inline void setQCPPolarGraph_IsSignalConnected_IsBase(bool value) const { qcppolargraph_issignalconnected_isbase = value; }

    // Virtual method for C ABI access and custom callback
    virtual int qt_metacall(QMetaObject::Call param1, int param2, void** param3) override {
        if (qcppolargraph_metacall_isbase) {
            qcppolargraph_metacall_isbase = false;
            return QCPPolarGraph::qt_metacall(param1, param2, param3);
        } else if (qcppolargraph_metacall_callback != nullptr) {
            int cbval1 = static_cast<int>(param1);
            int cbval2 = param2;
            void** cbval3 = param3;

            int callback_ret = qcppolargraph_metacall_callback(this, cbval1, cbval2, cbval3);
            return static_cast<int>(callback_ret);
        } else {
            return QCPPolarGraph::qt_metacall(param1, param2, param3);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual double selectTest(const QPointF& pos, bool onlySelectable, QVariant* details) const override {
        if (qcppolargraph_selecttest_isbase) {
            qcppolargraph_selecttest_isbase = false;
            return QCPPolarGraph::selectTest(pos, onlySelectable, details);
        } else if (qcppolargraph_selecttest_callback != nullptr) {
            const QPointF& pos_ret = pos;
            // Cast returned reference into pointer
            QPointF* cbval1 = const_cast<QPointF*>(&pos_ret);
            bool cbval2 = onlySelectable;
            QVariant* cbval3 = details;

            double callback_ret = qcppolargraph_selecttest_callback(this, cbval1, cbval2, cbval3);
            return static_cast<double>(callback_ret);
        } else {
            return QCPPolarGraph::selectTest(pos, onlySelectable, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPPlottableInterface1D* interface1D() override {
        if (qcppolargraph_interface1d_isbase) {
            qcppolargraph_interface1d_isbase = false;
            return QCPPolarGraph::interface1D();
        } else if (qcppolargraph_interface1d_callback != nullptr) {
            QCPPlottableInterface1D* callback_ret = qcppolargraph_interface1d_callback();
            return callback_ret;
        } else {
            return QCPPolarGraph::interface1D();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPRange getKeyRange(bool& foundRange, QCP::SignDomain inSignDomain) const override {
        if (qcppolargraph_getkeyrange_isbase) {
            qcppolargraph_getkeyrange_isbase = false;
            return QCPPolarGraph::getKeyRange(foundRange, inSignDomain);
        } else if (qcppolargraph_getkeyrange_callback != nullptr) {
            bool* cbval1 = &foundRange;
            int cbval2 = static_cast<int>(inSignDomain);

            QCPRange* callback_ret = qcppolargraph_getkeyrange_callback(this, cbval1, cbval2);
            return *callback_ret;
        } else {
            return QCPPolarGraph::getKeyRange(foundRange, inSignDomain);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCPRange getValueRange(bool& foundRange, QCP::SignDomain inSignDomain, const QCPRange& inKeyRange) const override {
        if (qcppolargraph_getvaluerange_isbase) {
            qcppolargraph_getvaluerange_isbase = false;
            return QCPPolarGraph::getValueRange(foundRange, inSignDomain, inKeyRange);
        } else if (qcppolargraph_getvaluerange_callback != nullptr) {
            bool* cbval1 = &foundRange;
            int cbval2 = static_cast<int>(inSignDomain);
            const QCPRange& inKeyRange_ret = inKeyRange;
            // Cast returned reference into pointer
            QCPRange* cbval3 = const_cast<QCPRange*>(&inKeyRange_ret);

            QCPRange* callback_ret = qcppolargraph_getvaluerange_callback(this, cbval1, cbval2, cbval3);
            return *callback_ret;
        } else {
            return QCPPolarGraph::getValueRange(foundRange, inSignDomain, inKeyRange);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QRect clipRect() const override {
        if (qcppolargraph_cliprect_isbase) {
            qcppolargraph_cliprect_isbase = false;
            return QCPPolarGraph::clipRect();
        } else if (qcppolargraph_cliprect_callback != nullptr) {
            QRect* callback_ret = qcppolargraph_cliprect_callback();
            return *callback_ret;
        } else {
            return QCPPolarGraph::clipRect();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void draw(QCPPainter* painter) override {
        if (qcppolargraph_draw_isbase) {
            qcppolargraph_draw_isbase = false;
            QCPPolarGraph::draw(painter);
        } else if (qcppolargraph_draw_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcppolargraph_draw_callback(this, cbval1);
        } else {
            QCPPolarGraph::draw(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual QCP::Interaction selectionCategory() const override {
        if (qcppolargraph_selectioncategory_isbase) {
            qcppolargraph_selectioncategory_isbase = false;
            return QCPPolarGraph::selectionCategory();
        } else if (qcppolargraph_selectioncategory_callback != nullptr) {
            int callback_ret = qcppolargraph_selectioncategory_callback();
            return static_cast<QCP::Interaction>(callback_ret);
        } else {
            return QCPPolarGraph::selectionCategory();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void selectEvent(QMouseEvent* event, bool additive, const QVariant& details, bool* selectionStateChanged) override {
        if (qcppolargraph_selectevent_isbase) {
            qcppolargraph_selectevent_isbase = false;
            QCPPolarGraph::selectEvent(event, additive, details, selectionStateChanged);
        } else if (qcppolargraph_selectevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            bool cbval2 = additive;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval3 = const_cast<QVariant*>(&details_ret);
            bool* cbval4 = selectionStateChanged;

            qcppolargraph_selectevent_callback(this, cbval1, cbval2, cbval3, cbval4);
        } else {
            QCPPolarGraph::selectEvent(event, additive, details, selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void deselectEvent(bool* selectionStateChanged) override {
        if (qcppolargraph_deselectevent_isbase) {
            qcppolargraph_deselectevent_isbase = false;
            QCPPolarGraph::deselectEvent(selectionStateChanged);
        } else if (qcppolargraph_deselectevent_callback != nullptr) {
            bool* cbval1 = selectionStateChanged;

            qcppolargraph_deselectevent_callback(this, cbval1);
        } else {
            QCPPolarGraph::deselectEvent(selectionStateChanged);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void drawLinePlot(QCPPainter* painter, const QVector<QPointF>& lines) const override {
        if (qcppolargraph_drawlineplot_isbase) {
            qcppolargraph_drawlineplot_isbase = false;
            QCPPolarGraph::drawLinePlot(painter, lines);
        } else if (qcppolargraph_drawlineplot_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            const QVector<QPointF>& lines_ret = lines;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** lines_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (lines_ret.size() + 1)));
            for (qsizetype i = 0; i < lines_ret.size(); ++i) {
                lines_arr[i] = new QPointF(lines_ret[i]);
            }
            libqt_list lines_out;
            lines_out.len = lines_ret.size();
            lines_out.data = static_cast<void*>(lines_arr);
            libqt_list /* of QPointF* */ cbval2 = lines_out;

            qcppolargraph_drawlineplot_callback(this, cbval1, cbval2);
        } else {
            QCPPolarGraph::drawLinePlot(painter, lines);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void drawFill(QCPPainter* painter, QVector<QPointF>* lines) const override {
        if (qcppolargraph_drawfill_isbase) {
            qcppolargraph_drawfill_isbase = false;
            QCPPolarGraph::drawFill(painter, lines);
        } else if (qcppolargraph_drawfill_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            QVector<QPointF>* lines_ret = lines;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** lines_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (lines_ret->size() + 1)));
            for (qsizetype i = 0; i < lines_ret->size(); ++i) {
                lines_arr[i] = new QPointF((*lines_ret)[i]);
            }
            libqt_list lines_out;
            lines_out.len = lines_ret->size();
            lines_out.data = static_cast<void*>(lines_arr);
            libqt_list /* of QPointF* */ cbval2 = lines_out;

            qcppolargraph_drawfill_callback(this, cbval1, cbval2);
        } else {
            QCPPolarGraph::drawFill(painter, lines);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void drawScatterPlot(QCPPainter* painter, const QVector<QPointF>& scatters, const QCPScatterStyle& style) const override {
        if (qcppolargraph_drawscatterplot_isbase) {
            qcppolargraph_drawscatterplot_isbase = false;
            QCPPolarGraph::drawScatterPlot(painter, scatters, style);
        } else if (qcppolargraph_drawscatterplot_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            const QVector<QPointF>& scatters_ret = scatters;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** scatters_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (scatters_ret.size() + 1)));
            for (qsizetype i = 0; i < scatters_ret.size(); ++i) {
                scatters_arr[i] = new QPointF(scatters_ret[i]);
            }
            libqt_list scatters_out;
            scatters_out.len = scatters_ret.size();
            scatters_out.data = static_cast<void*>(scatters_arr);
            libqt_list /* of QPointF* */ cbval2 = scatters_out;
            const QCPScatterStyle& style_ret = style;
            // Cast returned reference into pointer
            QCPScatterStyle* cbval3 = const_cast<QCPScatterStyle*>(&style_ret);

            qcppolargraph_drawscatterplot_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPPolarGraph::drawScatterPlot(painter, scatters, style);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void drawLegendIcon(QCPPainter* painter, const QRectF& rect) const override {
        if (qcppolargraph_drawlegendicon_isbase) {
            qcppolargraph_drawlegendicon_isbase = false;
            QCPPolarGraph::drawLegendIcon(painter, rect);
        } else if (qcppolargraph_drawlegendicon_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            const QRectF& rect_ret = rect;
            // Cast returned reference into pointer
            QRectF* cbval2 = const_cast<QRectF*>(&rect_ret);

            qcppolargraph_drawlegendicon_callback(this, cbval1, cbval2);
        } else {
            QCPPolarGraph::drawLegendIcon(painter, rect);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual int dataCount() const override {
        if (qcppolargraph_datacount_isbase) {
            qcppolargraph_datacount_isbase = false;
            return QCPPolarGraph::dataCount();
        } else if (qcppolargraph_datacount_callback != nullptr) {
            int callback_ret = qcppolargraph_datacount_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPPolarGraph::dataCount();
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void parentPlotInitialized(QCustomPlot* parentPlot) override {
        if (qcppolargraph_parentplotinitialized_isbase) {
            qcppolargraph_parentplotinitialized_isbase = false;
            QCPPolarGraph::parentPlotInitialized(parentPlot);
        } else if (qcppolargraph_parentplotinitialized_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcppolargraph_parentplotinitialized_callback(this, cbval1);
        } else {
            QCPPolarGraph::parentPlotInitialized(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void applyDefaultAntialiasingHint(QCPPainter* painter) const override {
        if (qcppolargraph_applydefaultantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcppolargraph_applydefaultantialiasinghint_callback(this, cbval1);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mousePressEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcppolargraph_mousepressevent_isbase) {
            qcppolargraph_mousepressevent_isbase = false;
            QCPPolarGraph::mousePressEvent(event, details);
        } else if (qcppolargraph_mousepressevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcppolargraph_mousepressevent_callback(this, cbval1, cbval2);
        } else {
            QCPPolarGraph::mousePressEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseMoveEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcppolargraph_mousemoveevent_isbase) {
            qcppolargraph_mousemoveevent_isbase = false;
            QCPPolarGraph::mouseMoveEvent(event, startPos);
        } else if (qcppolargraph_mousemoveevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcppolargraph_mousemoveevent_callback(this, cbval1, cbval2);
        } else {
            QCPPolarGraph::mouseMoveEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseReleaseEvent(QMouseEvent* event, const QPointF& startPos) override {
        if (qcppolargraph_mousereleaseevent_isbase) {
            qcppolargraph_mousereleaseevent_isbase = false;
            QCPPolarGraph::mouseReleaseEvent(event, startPos);
        } else if (qcppolargraph_mousereleaseevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QPointF& startPos_ret = startPos;
            // Cast returned reference into pointer
            QPointF* cbval2 = const_cast<QPointF*>(&startPos_ret);

            qcppolargraph_mousereleaseevent_callback(this, cbval1, cbval2);
        } else {
            QCPPolarGraph::mouseReleaseEvent(event, startPos);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void mouseDoubleClickEvent(QMouseEvent* event, const QVariant& details) override {
        if (qcppolargraph_mousedoubleclickevent_isbase) {
            qcppolargraph_mousedoubleclickevent_isbase = false;
            QCPPolarGraph::mouseDoubleClickEvent(event, details);
        } else if (qcppolargraph_mousedoubleclickevent_callback != nullptr) {
            QMouseEvent* cbval1 = event;
            const QVariant& details_ret = details;
            // Cast returned reference into pointer
            QVariant* cbval2 = const_cast<QVariant*>(&details_ret);

            qcppolargraph_mousedoubleclickevent_callback(this, cbval1, cbval2);
        } else {
            QCPPolarGraph::mouseDoubleClickEvent(event, details);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void wheelEvent(QWheelEvent* event) override {
        if (qcppolargraph_wheelevent_isbase) {
            qcppolargraph_wheelevent_isbase = false;
            QCPPolarGraph::wheelEvent(event);
        } else if (qcppolargraph_wheelevent_callback != nullptr) {
            QWheelEvent* cbval1 = event;

            qcppolargraph_wheelevent_callback(this, cbval1);
        } else {
            QCPPolarGraph::wheelEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool event(QEvent* event) override {
        if (qcppolargraph_event_isbase) {
            qcppolargraph_event_isbase = false;
            return QCPPolarGraph::event(event);
        } else if (qcppolargraph_event_callback != nullptr) {
            QEvent* cbval1 = event;

            bool callback_ret = qcppolargraph_event_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPPolarGraph::event(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual bool eventFilter(QObject* watched, QEvent* event) override {
        if (qcppolargraph_eventfilter_isbase) {
            qcppolargraph_eventfilter_isbase = false;
            return QCPPolarGraph::eventFilter(watched, event);
        } else if (qcppolargraph_eventfilter_callback != nullptr) {
            QObject* cbval1 = watched;
            QEvent* cbval2 = event;

            bool callback_ret = qcppolargraph_eventfilter_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPPolarGraph::eventFilter(watched, event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void timerEvent(QTimerEvent* event) override {
        if (qcppolargraph_timerevent_isbase) {
            qcppolargraph_timerevent_isbase = false;
            QCPPolarGraph::timerEvent(event);
        } else if (qcppolargraph_timerevent_callback != nullptr) {
            QTimerEvent* cbval1 = event;

            qcppolargraph_timerevent_callback(this, cbval1);
        } else {
            QCPPolarGraph::timerEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void childEvent(QChildEvent* event) override {
        if (qcppolargraph_childevent_isbase) {
            qcppolargraph_childevent_isbase = false;
            QCPPolarGraph::childEvent(event);
        } else if (qcppolargraph_childevent_callback != nullptr) {
            QChildEvent* cbval1 = event;

            qcppolargraph_childevent_callback(this, cbval1);
        } else {
            QCPPolarGraph::childEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void customEvent(QEvent* event) override {
        if (qcppolargraph_customevent_isbase) {
            qcppolargraph_customevent_isbase = false;
            QCPPolarGraph::customEvent(event);
        } else if (qcppolargraph_customevent_callback != nullptr) {
            QEvent* cbval1 = event;

            qcppolargraph_customevent_callback(this, cbval1);
        } else {
            QCPPolarGraph::customEvent(event);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void connectNotify(const QMetaMethod& signal) override {
        if (qcppolargraph_connectnotify_isbase) {
            qcppolargraph_connectnotify_isbase = false;
            QCPPolarGraph::connectNotify(signal);
        } else if (qcppolargraph_connectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcppolargraph_connectnotify_callback(this, cbval1);
        } else {
            QCPPolarGraph::connectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    virtual void disconnectNotify(const QMetaMethod& signal) override {
        if (qcppolargraph_disconnectnotify_isbase) {
            qcppolargraph_disconnectnotify_isbase = false;
            QCPPolarGraph::disconnectNotify(signal);
        } else if (qcppolargraph_disconnectnotify_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            qcppolargraph_disconnectnotify_callback(this, cbval1);
        } else {
            QCPPolarGraph::disconnectNotify(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyFillAntialiasingHint(QCPPainter* painter) const {
        if (qcppolargraph_applyfillantialiasinghint_isbase) {
            qcppolargraph_applyfillantialiasinghint_isbase = false;
            QCPPolarGraph::applyFillAntialiasingHint(painter);
        } else if (qcppolargraph_applyfillantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcppolargraph_applyfillantialiasinghint_callback(this, cbval1);
        } else {
            QCPPolarGraph::applyFillAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyScattersAntialiasingHint(QCPPainter* painter) const {
        if (qcppolargraph_applyscattersantialiasinghint_isbase) {
            qcppolargraph_applyscattersantialiasinghint_isbase = false;
            QCPPolarGraph::applyScattersAntialiasingHint(painter);
        } else if (qcppolargraph_applyscattersantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;

            qcppolargraph_applyscattersantialiasinghint_callback(this, cbval1);
        } else {
            QCPPolarGraph::applyScattersAntialiasingHint(painter);
        }
    }

    // Virtual method for C ABI access and custom callback
    void getDataSegments(QList<QCPDataRange>& selectedSegments, QList<QCPDataRange>& unselectedSegments) const {
        if (qcppolargraph_getdatasegments_isbase) {
            qcppolargraph_getdatasegments_isbase = false;
            QCPPolarGraph::getDataSegments(selectedSegments, unselectedSegments);
        } else if (qcppolargraph_getdatasegments_callback != nullptr) {
            QList<QCPDataRange>& selectedSegments_ret = selectedSegments;
            // Convert QList<> from C++ memory to manually-managed C memory
            QCPDataRange** selectedSegments_arr = static_cast<QCPDataRange**>(malloc(sizeof(QCPDataRange*) * (selectedSegments_ret.size() + 1)));
            for (qsizetype i = 0; i < selectedSegments_ret.size(); ++i) {
                selectedSegments_arr[i] = new QCPDataRange(selectedSegments_ret[i]);
            }
            libqt_list selectedSegments_out;
            selectedSegments_out.len = selectedSegments_ret.size();
            selectedSegments_out.data = static_cast<void*>(selectedSegments_arr);
            libqt_list /* of QCPDataRange* */ cbval1 = selectedSegments_out;
            QList<QCPDataRange>& unselectedSegments_ret = unselectedSegments;
            // Convert QList<> from C++ memory to manually-managed C memory
            QCPDataRange** unselectedSegments_arr = static_cast<QCPDataRange**>(malloc(sizeof(QCPDataRange*) * (unselectedSegments_ret.size() + 1)));
            for (qsizetype i = 0; i < unselectedSegments_ret.size(); ++i) {
                unselectedSegments_arr[i] = new QCPDataRange(unselectedSegments_ret[i]);
            }
            libqt_list unselectedSegments_out;
            unselectedSegments_out.len = unselectedSegments_ret.size();
            unselectedSegments_out.data = static_cast<void*>(unselectedSegments_arr);
            libqt_list /* of QCPDataRange* */ cbval2 = unselectedSegments_out;

            qcppolargraph_getdatasegments_callback(this, cbval1, cbval2);
        } else {
            QCPPolarGraph::getDataSegments(selectedSegments, unselectedSegments);
        }
    }

    // Virtual method for C ABI access and custom callback
    void drawPolyline(QCPPainter* painter, const QVector<QPointF>& lineData) const {
        if (qcppolargraph_drawpolyline_isbase) {
            qcppolargraph_drawpolyline_isbase = false;
            QCPPolarGraph::drawPolyline(painter, lineData);
        } else if (qcppolargraph_drawpolyline_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            const QVector<QPointF>& lineData_ret = lineData;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** lineData_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (lineData_ret.size() + 1)));
            for (qsizetype i = 0; i < lineData_ret.size(); ++i) {
                lineData_arr[i] = new QPointF(lineData_ret[i]);
            }
            libqt_list lineData_out;
            lineData_out.len = lineData_ret.size();
            lineData_out.data = static_cast<void*>(lineData_arr);
            libqt_list /* of QPointF* */ cbval2 = lineData_out;

            qcppolargraph_drawpolyline_callback(this, cbval1, cbval2);
        } else {
            QCPPolarGraph::drawPolyline(painter, lineData);
        }
    }

    // Virtual method for C ABI access and custom callback
    void getLines(QVector<QPointF>* lines, const QCPDataRange& dataRange) const {
        if (qcppolargraph_getlines_isbase) {
            qcppolargraph_getlines_isbase = false;
            QCPPolarGraph::getLines(lines, dataRange);
        } else if (qcppolargraph_getlines_callback != nullptr) {
            QVector<QPointF>* lines_ret = lines;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** lines_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (lines_ret->size() + 1)));
            for (qsizetype i = 0; i < lines_ret->size(); ++i) {
                lines_arr[i] = new QPointF((*lines_ret)[i]);
            }
            libqt_list lines_out;
            lines_out.len = lines_ret->size();
            lines_out.data = static_cast<void*>(lines_arr);
            libqt_list /* of QPointF* */ cbval1 = lines_out;
            const QCPDataRange& dataRange_ret = dataRange;
            // Cast returned reference into pointer
            QCPDataRange* cbval2 = const_cast<QCPDataRange*>(&dataRange_ret);

            qcppolargraph_getlines_callback(this, cbval1, cbval2);
        } else {
            QCPPolarGraph::getLines(lines, dataRange);
        }
    }

    // Virtual method for C ABI access and custom callback
    void getScatters(QVector<QPointF>* scatters, const QCPDataRange& dataRange) const {
        if (qcppolargraph_getscatters_isbase) {
            qcppolargraph_getscatters_isbase = false;
            QCPPolarGraph::getScatters(scatters, dataRange);
        } else if (qcppolargraph_getscatters_callback != nullptr) {
            QVector<QPointF>* scatters_ret = scatters;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QPointF** scatters_arr = static_cast<QPointF**>(malloc(sizeof(QPointF*) * (scatters_ret->size() + 1)));
            for (qsizetype i = 0; i < scatters_ret->size(); ++i) {
                scatters_arr[i] = new QPointF((*scatters_ret)[i]);
            }
            libqt_list scatters_out;
            scatters_out.len = scatters_ret->size();
            scatters_out.data = static_cast<void*>(scatters_arr);
            libqt_list /* of QPointF* */ cbval1 = scatters_out;
            const QCPDataRange& dataRange_ret = dataRange;
            // Cast returned reference into pointer
            QCPDataRange* cbval2 = const_cast<QCPDataRange*>(&dataRange_ret);

            qcppolargraph_getscatters_callback(this, cbval1, cbval2);
        } else {
            QCPPolarGraph::getScatters(scatters, dataRange);
        }
    }

    // Virtual method for C ABI access and custom callback
    QVector<QPointF> dataToLines(const QVector<QCPGraphData>& data) const {
        if (qcppolargraph_datatolines_isbase) {
            qcppolargraph_datatolines_isbase = false;
            return QCPPolarGraph::dataToLines(data);
        } else if (qcppolargraph_datatolines_callback != nullptr) {
            const QVector<QCPGraphData>& data_ret = data;
            // Convert QVector<> from C++ memory to manually-managed C memory
            QCPGraphData** data_arr = static_cast<QCPGraphData**>(malloc(sizeof(QCPGraphData*) * (data_ret.size() + 1)));
            for (qsizetype i = 0; i < data_ret.size(); ++i) {
                data_arr[i] = new QCPGraphData(data_ret[i]);
            }
            libqt_list data_out;
            data_out.len = data_ret.size();
            data_out.data = static_cast<void*>(data_arr);
            libqt_list /* of QCPGraphData* */ cbval1 = data_out;

            QPointF** callback_ret = qcppolargraph_datatolines_callback(this, cbval1);
            QVector<QPointF> callback_ret_QVector;
            // Iterate until null pointer sentinel
            for (QPointF** ptridx = callback_ret; *ptridx != nullptr; ptridx++) {
                callback_ret_QVector.push_back(**ptridx);
            }
            free(callback_ret);
            return callback_ret_QVector;
        } else {
            return QCPPolarGraph::dataToLines(data);
        }
    }

    // Virtual method for C ABI access and custom callback
    void initializeParentPlot(QCustomPlot* parentPlot) {
        if (qcppolargraph_initializeparentplot_isbase) {
            qcppolargraph_initializeparentplot_isbase = false;
            QCPPolarGraph::initializeParentPlot(parentPlot);
        } else if (qcppolargraph_initializeparentplot_callback != nullptr) {
            QCustomPlot* cbval1 = parentPlot;

            qcppolargraph_initializeparentplot_callback(this, cbval1);
        } else {
            QCPPolarGraph::initializeParentPlot(parentPlot);
        }
    }

    // Virtual method for C ABI access and custom callback
    void setParentLayerable(QCPLayerable* parentLayerable) {
        if (qcppolargraph_setparentlayerable_isbase) {
            qcppolargraph_setparentlayerable_isbase = false;
            QCPPolarGraph::setParentLayerable(parentLayerable);
        } else if (qcppolargraph_setparentlayerable_callback != nullptr) {
            QCPLayerable* cbval1 = parentLayerable;

            qcppolargraph_setparentlayerable_callback(this, cbval1);
        } else {
            QCPPolarGraph::setParentLayerable(parentLayerable);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool moveToLayer(QCPLayer* layer, bool prepend) {
        if (qcppolargraph_movetolayer_isbase) {
            qcppolargraph_movetolayer_isbase = false;
            return QCPPolarGraph::moveToLayer(layer, prepend);
        } else if (qcppolargraph_movetolayer_callback != nullptr) {
            QCPLayer* cbval1 = layer;
            bool cbval2 = prepend;

            bool callback_ret = qcppolargraph_movetolayer_callback(this, cbval1, cbval2);
            return callback_ret;
        } else {
            return QCPPolarGraph::moveToLayer(layer, prepend);
        }
    }

    // Virtual method for C ABI access and custom callback
    void applyAntialiasingHint(QCPPainter* painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const {
        if (qcppolargraph_applyantialiasinghint_isbase) {
            qcppolargraph_applyantialiasinghint_isbase = false;
            QCPPolarGraph::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        } else if (qcppolargraph_applyantialiasinghint_callback != nullptr) {
            QCPPainter* cbval1 = painter;
            bool cbval2 = localAntialiased;
            int cbval3 = static_cast<int>(overrideElement);

            qcppolargraph_applyantialiasinghint_callback(this, cbval1, cbval2, cbval3);
        } else {
            QCPPolarGraph::applyAntialiasingHint(painter, localAntialiased, overrideElement);
        }
    }

    // Virtual method for C ABI access and custom callback
    QObject* sender() const {
        if (qcppolargraph_sender_isbase) {
            qcppolargraph_sender_isbase = false;
            return QCPPolarGraph::sender();
        } else if (qcppolargraph_sender_callback != nullptr) {
            QObject* callback_ret = qcppolargraph_sender_callback();
            return callback_ret;
        } else {
            return QCPPolarGraph::sender();
        }
    }

    // Virtual method for C ABI access and custom callback
    int senderSignalIndex() const {
        if (qcppolargraph_sendersignalindex_isbase) {
            qcppolargraph_sendersignalindex_isbase = false;
            return QCPPolarGraph::senderSignalIndex();
        } else if (qcppolargraph_sendersignalindex_callback != nullptr) {
            int callback_ret = qcppolargraph_sendersignalindex_callback();
            return static_cast<int>(callback_ret);
        } else {
            return QCPPolarGraph::senderSignalIndex();
        }
    }

    // Virtual method for C ABI access and custom callback
    int receivers(const char* signal) const {
        if (qcppolargraph_receivers_isbase) {
            qcppolargraph_receivers_isbase = false;
            return QCPPolarGraph::receivers(signal);
        } else if (qcppolargraph_receivers_callback != nullptr) {
            const char* cbval1 = (const char*)signal;

            int callback_ret = qcppolargraph_receivers_callback(this, cbval1);
            return static_cast<int>(callback_ret);
        } else {
            return QCPPolarGraph::receivers(signal);
        }
    }

    // Virtual method for C ABI access and custom callback
    bool isSignalConnected(const QMetaMethod& signal) const {
        if (qcppolargraph_issignalconnected_isbase) {
            qcppolargraph_issignalconnected_isbase = false;
            return QCPPolarGraph::isSignalConnected(signal);
        } else if (qcppolargraph_issignalconnected_callback != nullptr) {
            const QMetaMethod& signal_ret = signal;
            // Cast returned reference into pointer
            QMetaMethod* cbval1 = const_cast<QMetaMethod*>(&signal_ret);

            bool callback_ret = qcppolargraph_issignalconnected_callback(this, cbval1);
            return callback_ret;
        } else {
            return QCPPolarGraph::isSignalConnected(signal);
        }
    }

    // Friend functions
    friend QRect* QCPPolarGraph_ClipRect(const QCPPolarGraph* self);
    friend QRect* QCPPolarGraph_QBaseClipRect(const QCPPolarGraph* self);
    friend void QCPPolarGraph_Draw(QCPPolarGraph* self, QCPPainter* painter);
    friend void QCPPolarGraph_QBaseDraw(QCPPolarGraph* self, QCPPainter* painter);
    friend int QCPPolarGraph_SelectionCategory(const QCPPolarGraph* self);
    friend int QCPPolarGraph_QBaseSelectionCategory(const QCPPolarGraph* self);
    friend void QCPPolarGraph_SelectEvent(QCPPolarGraph* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPPolarGraph_QBaseSelectEvent(QCPPolarGraph* self, QMouseEvent* event, bool additive, const QVariant* details, bool* selectionStateChanged);
    friend void QCPPolarGraph_DeselectEvent(QCPPolarGraph* self, bool* selectionStateChanged);
    friend void QCPPolarGraph_QBaseDeselectEvent(QCPPolarGraph* self, bool* selectionStateChanged);
    friend void QCPPolarGraph_DrawLinePlot(const QCPPolarGraph* self, QCPPainter* painter, const libqt_list /* of QPointF* */ lines);
    friend void QCPPolarGraph_QBaseDrawLinePlot(const QCPPolarGraph* self, QCPPainter* painter, const libqt_list /* of QPointF* */ lines);
    friend void QCPPolarGraph_DrawFill(const QCPPolarGraph* self, QCPPainter* painter, libqt_list /* of QPointF* */ lines);
    friend void QCPPolarGraph_QBaseDrawFill(const QCPPolarGraph* self, QCPPainter* painter, libqt_list /* of QPointF* */ lines);
    friend void QCPPolarGraph_DrawScatterPlot(const QCPPolarGraph* self, QCPPainter* painter, const libqt_list /* of QPointF* */ scatters, const QCPScatterStyle* style);
    friend void QCPPolarGraph_QBaseDrawScatterPlot(const QCPPolarGraph* self, QCPPainter* painter, const libqt_list /* of QPointF* */ scatters, const QCPScatterStyle* style);
    friend void QCPPolarGraph_DrawLegendIcon(const QCPPolarGraph* self, QCPPainter* painter, const QRectF* rect);
    friend void QCPPolarGraph_QBaseDrawLegendIcon(const QCPPolarGraph* self, QCPPainter* painter, const QRectF* rect);
    friend int QCPPolarGraph_DataCount(const QCPPolarGraph* self);
    friend int QCPPolarGraph_QBaseDataCount(const QCPPolarGraph* self);
    friend void QCPPolarGraph_ParentPlotInitialized(QCPPolarGraph* self, QCustomPlot* parentPlot);
    friend void QCPPolarGraph_QBaseParentPlotInitialized(QCPPolarGraph* self, QCustomPlot* parentPlot);
    friend void QCPPolarGraph_ApplyDefaultAntialiasingHint(const QCPPolarGraph* self, QCPPainter* painter);
    friend void QCPPolarGraph_QBaseApplyDefaultAntialiasingHint(const QCPPolarGraph* self, QCPPainter* painter);
    friend void QCPPolarGraph_MousePressEvent(QCPPolarGraph* self, QMouseEvent* event, const QVariant* details);
    friend void QCPPolarGraph_QBaseMousePressEvent(QCPPolarGraph* self, QMouseEvent* event, const QVariant* details);
    friend void QCPPolarGraph_MouseMoveEvent(QCPPolarGraph* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPPolarGraph_QBaseMouseMoveEvent(QCPPolarGraph* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPPolarGraph_MouseReleaseEvent(QCPPolarGraph* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPPolarGraph_QBaseMouseReleaseEvent(QCPPolarGraph* self, QMouseEvent* event, const QPointF* startPos);
    friend void QCPPolarGraph_MouseDoubleClickEvent(QCPPolarGraph* self, QMouseEvent* event, const QVariant* details);
    friend void QCPPolarGraph_QBaseMouseDoubleClickEvent(QCPPolarGraph* self, QMouseEvent* event, const QVariant* details);
    friend void QCPPolarGraph_WheelEvent(QCPPolarGraph* self, QWheelEvent* event);
    friend void QCPPolarGraph_QBaseWheelEvent(QCPPolarGraph* self, QWheelEvent* event);
    friend void QCPPolarGraph_TimerEvent(QCPPolarGraph* self, QTimerEvent* event);
    friend void QCPPolarGraph_QBaseTimerEvent(QCPPolarGraph* self, QTimerEvent* event);
    friend void QCPPolarGraph_ChildEvent(QCPPolarGraph* self, QChildEvent* event);
    friend void QCPPolarGraph_QBaseChildEvent(QCPPolarGraph* self, QChildEvent* event);
    friend void QCPPolarGraph_CustomEvent(QCPPolarGraph* self, QEvent* event);
    friend void QCPPolarGraph_QBaseCustomEvent(QCPPolarGraph* self, QEvent* event);
    friend void QCPPolarGraph_ConnectNotify(QCPPolarGraph* self, const QMetaMethod* signal);
    friend void QCPPolarGraph_QBaseConnectNotify(QCPPolarGraph* self, const QMetaMethod* signal);
    friend void QCPPolarGraph_DisconnectNotify(QCPPolarGraph* self, const QMetaMethod* signal);
    friend void QCPPolarGraph_QBaseDisconnectNotify(QCPPolarGraph* self, const QMetaMethod* signal);
    friend void QCPPolarGraph_ApplyFillAntialiasingHint(const QCPPolarGraph* self, QCPPainter* painter);
    friend void QCPPolarGraph_QBaseApplyFillAntialiasingHint(const QCPPolarGraph* self, QCPPainter* painter);
    friend void QCPPolarGraph_ApplyScattersAntialiasingHint(const QCPPolarGraph* self, QCPPainter* painter);
    friend void QCPPolarGraph_QBaseApplyScattersAntialiasingHint(const QCPPolarGraph* self, QCPPainter* painter);
    friend void QCPPolarGraph_GetDataSegments(const QCPPolarGraph* self, libqt_list /* of QCPDataRange* */ selectedSegments, libqt_list /* of QCPDataRange* */ unselectedSegments);
    friend void QCPPolarGraph_QBaseGetDataSegments(const QCPPolarGraph* self, libqt_list /* of QCPDataRange* */ selectedSegments, libqt_list /* of QCPDataRange* */ unselectedSegments);
    friend void QCPPolarGraph_DrawPolyline(const QCPPolarGraph* self, QCPPainter* painter, const libqt_list /* of QPointF* */ lineData);
    friend void QCPPolarGraph_QBaseDrawPolyline(const QCPPolarGraph* self, QCPPainter* painter, const libqt_list /* of QPointF* */ lineData);
    friend void QCPPolarGraph_GetLines(const QCPPolarGraph* self, libqt_list /* of QPointF* */ lines, const QCPDataRange* dataRange);
    friend void QCPPolarGraph_QBaseGetLines(const QCPPolarGraph* self, libqt_list /* of QPointF* */ lines, const QCPDataRange* dataRange);
    friend void QCPPolarGraph_GetScatters(const QCPPolarGraph* self, libqt_list /* of QPointF* */ scatters, const QCPDataRange* dataRange);
    friend void QCPPolarGraph_QBaseGetScatters(const QCPPolarGraph* self, libqt_list /* of QPointF* */ scatters, const QCPDataRange* dataRange);
    friend libqt_list /* of QPointF* */ QCPPolarGraph_DataToLines(const QCPPolarGraph* self, const libqt_list /* of QCPGraphData* */ data);
    friend libqt_list /* of QPointF* */ QCPPolarGraph_QBaseDataToLines(const QCPPolarGraph* self, const libqt_list /* of QCPGraphData* */ data);
    friend void QCPPolarGraph_InitializeParentPlot(QCPPolarGraph* self, QCustomPlot* parentPlot);
    friend void QCPPolarGraph_QBaseInitializeParentPlot(QCPPolarGraph* self, QCustomPlot* parentPlot);
    friend void QCPPolarGraph_SetParentLayerable(QCPPolarGraph* self, QCPLayerable* parentLayerable);
    friend void QCPPolarGraph_QBaseSetParentLayerable(QCPPolarGraph* self, QCPLayerable* parentLayerable);
    friend bool QCPPolarGraph_MoveToLayer(QCPPolarGraph* self, QCPLayer* layer, bool prepend);
    friend bool QCPPolarGraph_QBaseMoveToLayer(QCPPolarGraph* self, QCPLayer* layer, bool prepend);
    friend void QCPPolarGraph_ApplyAntialiasingHint(const QCPPolarGraph* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend void QCPPolarGraph_QBaseApplyAntialiasingHint(const QCPPolarGraph* self, QCPPainter* painter, bool localAntialiased, int overrideElement);
    friend QObject* QCPPolarGraph_Sender(const QCPPolarGraph* self);
    friend QObject* QCPPolarGraph_QBaseSender(const QCPPolarGraph* self);
    friend int QCPPolarGraph_SenderSignalIndex(const QCPPolarGraph* self);
    friend int QCPPolarGraph_QBaseSenderSignalIndex(const QCPPolarGraph* self);
    friend int QCPPolarGraph_Receivers(const QCPPolarGraph* self, const char* signal);
    friend int QCPPolarGraph_QBaseReceivers(const QCPPolarGraph* self, const char* signal);
    friend bool QCPPolarGraph_IsSignalConnected(const QCPPolarGraph* self, const QMetaMethod* signal);
    friend bool QCPPolarGraph_QBaseIsSignalConnected(const QCPPolarGraph* self, const QMetaMethod* signal);
};

#endif
